; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\Users\am\Desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor
PUBLIC	?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor
PUBLIC	??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>
PUBLIC	??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings
PUBLIC	??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo
PUBLIC	??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
PUBLIC	??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty
PUBLIC	?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::move<google_object * &>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
PUBLIC	?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted
PUBLIC	?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted
PUBLIC	?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
PUBLIC	?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
PUBLIC	??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
PUBLIC	??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
PUBLIC	??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >
PUBLIC	??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >
PUBLIC	??0?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>
PUBLIC	??0?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >
PUBLIC	??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >
PUBLIC	??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
PUBLIC	??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor'
PUBLIC	?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
PUBLIC	?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear
PUBLIC	??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
PUBLIC	??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
PUBLIC	??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
PUBLIC	??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor'
PUBLIC	?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive
PUBLIC	?clear@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear
PUBLIC	??1?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::~btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>
PUBLIC	??1?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@XZ ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::~btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >
PUBLIC	??_G?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEPAXI@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::`scalar deleting destructor'
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear
PUBLIC	?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy
PUBLIC	??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy
PUBLIC	??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
PUBLIC	??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
PUBLIC	??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
PUBLIC	??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
PUBLIC	??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==
PUBLIC	?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
PUBLIC	??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->
PUBLIC	??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
PUBLIC	??0?$pair@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
PUBLIC	?key@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::key
PUBLIC	?data@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABQAUstx_object@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::data
PUBLIC	??Cconst_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPBU?$pair@IPAUstx_object@@@std@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator->
PUBLIC	??8const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator==
PUBLIC	??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*
PUBLIC	??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*
PUBLIC	??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->
PUBLIC	??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=
PUBLIC	??0const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABViterator@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::const_iterator
PUBLIC	??9const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator!=
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=
PUBLIC	?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted
PUBLIC	?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size
PUBLIC	?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size
PUBLIC	?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
PUBLIC	??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
PUBLIC	??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>
PUBLIC	??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
PUBLIC	?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize
PUBLIC	??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator()
PUBLIC	??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
PUBLIC	??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[]
PUBLIC	??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value
PUBLIC	?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node
PUBLIC	??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
PUBLIC	??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>
PUBLIC	?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
PUBLIC	?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value
PUBLIC	?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
PUBLIC	?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node
PUBLIC	?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal
PUBLIC	?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root
PUBLIC	?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf
PUBLIC	?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node
PUBLIC	?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split
PUBLIC	?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
PUBLIC	??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>
PUBLIC	??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>
PUBLIC	??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z ; std::make_pair<unsigned int,google_object *>
PUBLIC	??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::forward<google_object *>
PUBLIC	??$forward@I@std@@YA$$QAIAAI@Z			; std::forward<unsigned int>
PUBLIC	??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>
PUBLIC	??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>
PUBLIC	??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*
PUBLIC	??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
PUBLIC	??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
PUBLIC	??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
PUBLIC	??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[]
PUBLIC	?isfull@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfull
PUBLIC	?isfull@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfull
PUBLIC	?initialize@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::initialize
PUBLIC	??$_Allocate@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
PUBLIC	?allocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocate
PUBLIC	?allocate_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUleaf_node@12@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_leaf
PUBLIC	?split_leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUleaf_node@12@PAIPAPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_leaf_node
PUBLIC	?initialize@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::initialize
PUBLIC	?initialize@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::initialize
PUBLIC	??$_Allocate@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
PUBLIC	?allocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocate
PUBLIC	?allocate_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUinner_node@12@G@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_inner
PUBLIC	?split_inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUinner_node@12@PAIPAPAUnode@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_inner_node
PUBLIC	??0?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
PUBLIC	??$move@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YA$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z ; std::move<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>
PUBLIC	??0?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
PUBLIC	?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_descend
PUBLIC	??$forward@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAAAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z ; std::forward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>
PUBLIC	??$forward@AA_N@std@@YAAA_NAA_N@Z		; std::forward<bool &>
PUBLIC	??$?0AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@Z ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &,bool &>
PUBLIC	??$?0Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAU01@@Z ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
PUBLIC	?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
PUBLIC	?insert2@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert2
PUBLIC	?insert@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABU?$pair@IPAUstx_object@@@4@@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::insert
PUBLIC	??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
PUBLIC	??0?$pair@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
PUBLIC	??A?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEAAPAUstx_object@@ABI@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::operator[]
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode
PUBLIC	??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
PUBLIC	??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
PUBLIC	??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>
PUBLIC	?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front
PUBLIC	?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
PUBLIC	?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket
PUBLIC	?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size
PUBLIC	?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor
PUBLIC	?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin
PUBLIC	?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate
PUBLIC	??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate
PUBLIC	?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size
PUBLIC	?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity
PUBLIC	?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to
PUBLIC	??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
PUBLIC	??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
PUBLIC	??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill
PUBLIC	?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen
PUBLIC	?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range
PUBLIC	??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >
PUBLIC	??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
PUBLIC	?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
PUBLIC	?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter
PUBLIC	??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy
PUBLIC	??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
PUBLIC	?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=
PUBLIC	??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
PUBLIC	??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
PUBLIC	??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
PUBLIC	?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase
PUBLIC	?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n
PUBLIC	?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
PUBLIC	?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size
PUBLIC	?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size
PUBLIC	?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
PUBLIC	??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
PUBLIC	??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
PUBLIC	?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
PUBLIC	?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size
PUBLIC	?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size
PUBLIC	?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate
PUBLIC	??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ; std::move<cpp_object * &>
PUBLIC	??$move@ABI@std@@YA$$QBIABI@Z			; std::move<unsigned int const &>
PUBLIC	??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
PUBLIC	??$forward@$$CBI@std@@YA$$QBIABI@Z		; std::forward<unsigned int const >
PUBLIC	??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ; std::forward<cpp_object *>
PUBLIC	??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>
PUBLIC	?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct
PUBLIC	??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ; std::forward<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
PUBLIC	?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?max@?$numeric_limits@I@std@@SAIXZ		; std::numeric_limits<unsigned int>::max
PUBLIC	?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor
PUBLIC	?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold
PUBLIC	?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
PUBLIC	?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin
PUBLIC	??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate
PUBLIC	??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >
PUBLIC	??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ; std::forward<std::pair<unsigned int const ,google_object *> const &>
PUBLIC	??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>
PUBLIC	??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z ; std::_Destroy<std::pair<unsigned int const ,google_object *> >
PUBLIC	??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
PUBLIC	??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
PUBLIC	?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty
PUBLIC	?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate
PUBLIC	?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die
PUBLIC	?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table
PUBLIC	?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size
PUBLIC	?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
PUBLIC	??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++
PUBLIC	??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=
PUBLIC	?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
PUBLIC	?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty
PUBLIC	??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
PUBLIC	??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate
PUBLIC	?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets
PUBLIC	??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
PUBLIC	??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo
PUBLIC	??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value
PUBLIC	?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold
PUBLIC	?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold
PUBLIC	?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size
PUBLIC	?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds
PUBLIC	??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>
PUBLIC	??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>
PUBLIC	??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>
PUBLIC	??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>
PUBLIC	??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z ; std::_Move<std::pair<unsigned int const ,google_object *> * &>
PUBLIC	??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ; std::swap<std::pair<unsigned int const ,google_object *> *>
PUBLIC	?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
PUBLIC	?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold
PUBLIC	?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@PBD@Z			; std::length_error::length_error
PUBLIC	?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor
PUBLIC	?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
PUBLIC	?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink
PUBLIC	?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
PUBLIC	?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
PUBLIC	?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash
PUBLIC	?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash
PUBLIC	??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>
PUBLIC	??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>
PUBLIC	??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>
PUBLIC	??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>
PUBLIC	?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
PUBLIC	?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
PUBLIC	?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
PUBLIC	?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
PUBLIC	?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
PUBLIC	??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
PUBLIC	?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
PUBLIC	?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals
PUBLIC	?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals
PUBLIC	?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key
PUBLIC	??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator()
PUBLIC	?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key
PUBLIC	?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key
PUBLIC	?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
PUBLIC	??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator()
PUBLIC	?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key
PUBLIC	?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key
PUBLIC	?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted
PUBLIC	?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink
PUBLIC	?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
PUBLIC	?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
PUBLIC	??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==
PUBLIC	?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
PUBLIC	??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->
PUBLIC	?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end
PUBLIC	?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
PUBLIC	?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key
PUBLIC	?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys
PUBLIC	?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp
PUBLIC	??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
PUBLIC	?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key
PUBLIC	?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key
PUBLIC	?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare
PUBLIC	??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
PUBLIC	?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound
PUBLIC	??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
PUBLIC	??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
PUBLIC	??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
PUBLIC	?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique
PUBLIC	?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find
PUBLIC	?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
PUBLIC	?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment
PUBLIC	??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++
PUBLIC	?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root
PUBLIC	??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
PUBLIC	?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
PUBLIC	?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement
PUBLIC	??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
PUBLIC	??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
PUBLIC	??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
PUBLIC	?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
PUBLIC	?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty
PUBLIC	?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
PUBLIC	?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
PUBLIC	?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
PUBLIC	?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right
PUBLIC	?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position
PUBLIC	?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child
PUBLIC	?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position
PUBLIC	?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count
PUBLIC	?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
PUBLIC	?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
PUBLIC	?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
PUBLIC	?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
PUBLIC	?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
PUBLIC	?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
PUBLIC	?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
PUBLIC	?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance
PUBLIC	?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent
PUBLIC	?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root
PUBLIC	??$_Move@AAI@std@@YA$$QAIAAI@Z			; std::_Move<unsigned int &>
PUBLIC	??$swap@I@std@@YAXAAI0@Z			; std::swap<unsigned int>
PUBLIC	??$btree_swap_helper@I@btree@@YAXAAI0@Z		; btree::btree_swap_helper<unsigned int>
PUBLIC	??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ; std::_Move<google_object * &>
PUBLIC	??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z ; std::swap<google_object *>
PUBLIC	??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z ; btree::btree_swap_helper<google_object *>
PUBLIC	?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap
PUBLIC	?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value
PUBLIC	?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap
PUBLIC	?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
PUBLIC	??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ	; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>
PUBLIC	?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>
PUBLIC	??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
PUBLIC	??$_Move@AAE@std@@YA$$QAEAAE@Z			; std::_Move<unsigned char &>
PUBLIC	??$swap@E@std@@YAXAAE0@Z			; std::swap<unsigned char>
PUBLIC	??$btree_swap_helper@E@btree@@YAXAAE0@Z		; btree::btree_swap_helper<unsigned char>
PUBLIC	?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap
PUBLIC	?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root
PUBLIC	?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node
PUBLIC	?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
PUBLIC	?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy
PUBLIC	?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy
PUBLIC	?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator
PUBLIC	?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node
PUBLIC	?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink
PUBLIC	?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
PUBLIC	?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase
PUBLIC	?end@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::end
PUBLIC	?key_equal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABI0@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_equal
PUBLIC	?end@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::end
PUBLIC	??0?$_Pair_base@IPAUstx_object@@@std@@QAE@XZ	; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
PUBLIC	??0?$pair@IPAUstx_object@@@std@@QAE@XZ		; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
PUBLIC	??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@PAUleaf_node@12@G@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator
PUBLIC	??$find_lower@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUleaf_node@01@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
PUBLIC	?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find
PUBLIC	?find@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@ABI@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::find
PUBLIC	?isfew@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfew
PUBLIC	?isunderflow@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isunderflow
PUBLIC	?isfew@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfew
PUBLIC	?isunderflow@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isunderflow
PUBLIC	??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node><std::pair<unsigned int,stx_object *> >
PUBLIC	?leaf_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node_allocator
PUBLIC	??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node><std::pair<unsigned int,stx_object *> >
PUBLIC	?inner_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node_allocator
PUBLIC	?deallocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::deallocate
PUBLIC	??$_Destroy@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
PUBLIC	?destroy@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::destroy
PUBLIC	?deallocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::deallocate
PUBLIC	??$_Destroy@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
PUBLIC	?destroy@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::destroy
PUBLIC	?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::free_node
PUBLIC	?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves
PUBLIC	?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_inner
PUBLIC	?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_leaf
PUBLIC	?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_inner
PUBLIC	??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<stx_object * *,stx_object * *>
PUBLIC	??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ; std::_Copy_backward<stx_object * *,stx_object * *>
PUBLIC	??$copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ; std::copy_backward<stx_object * *,stx_object * *>
PUBLIC	??$data_copy_backward@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy_backward<stx_object * *,stx_object * *>
PUBLIC	?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf
PUBLIC	??$_Copy_backward@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<unsigned int *,unsigned int *>
PUBLIC	??$_Copy_backward@PAIPAI@std@@YAPAIPAI00@Z	; std::_Copy_backward<unsigned int *,unsigned int *>
PUBLIC	??$copy_backward@PAIPAI@std@@YAPAIPAI00@Z	; std::copy_backward<unsigned int *,unsigned int *>
PUBLIC	??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ; std::copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner
PUBLIC	?key_less@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_less
PUBLIC	?key_lessequal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_lessequal
PUBLIC	??$find_lower@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUinner_node@01@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
PUBLIC	??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t
PUBLIC	??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t
PUBLIC	??_5result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEAAU012@ABU012@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::operator|=
PUBLIC	??$_Unchecked@PAI@std@@YAPAIPAI@Z		; std::_Unchecked<unsigned int *>
PUBLIC	??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ; std::_Ptr_cat<unsigned int,unsigned int>
PUBLIC	??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<unsigned int *,unsigned int *>
PUBLIC	??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z		; std::_Copy_impl<unsigned int *,unsigned int *>
PUBLIC	??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z	; std::_Rechecked<unsigned int *,unsigned int *>
PUBLIC	??$copy@PAIPAI@std@@YAPAIPAI00@Z		; std::copy<unsigned int *,unsigned int *>
PUBLIC	??$_Unchecked@PAPAUstx_object@@@std@@YAPAPAUstx_object@@PAPAU1@@Z ; std::_Unchecked<stx_object * *>
PUBLIC	??$_Ptr_cat@PAUstx_object@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUstx_object@@0@Z ; std::_Ptr_cat<stx_object *,stx_object *>
PUBLIC	??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<stx_object * *,stx_object * *>
PUBLIC	??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ; std::_Copy_impl<stx_object * *,stx_object * *>
PUBLIC	??$_Rechecked@PAPAUstx_object@@PAPAU1@@std@@YAAAPAPAUstx_object@@AAPAPAU1@PAPAU1@@Z ; std::_Rechecked<stx_object * *,stx_object * *>
PUBLIC	??$copy@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ; std::copy<stx_object * *,stx_object * *>
PUBLIC	??$data_copy@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy<stx_object * *,stx_object * *>
PUBLIC	??$_Unchecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@Z ; std::_Unchecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$_Ptr_cat@PAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAU123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@0@Z ; std::_Ptr_cat<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *>
PUBLIC	??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$_Rechecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAAAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAPAPAU123@PAPAU123@@Z ; std::_Rechecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	??$copy@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ; std::copy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
PUBLIC	?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
PUBLIC	??0tree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::tree_stats::tree_stats
PUBLIC	?isleafnode@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::isleafnode
PUBLIC	?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_node
PUBLIC	?verify_leaflinks@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_leaflinks
PUBLIC	?verify@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEXXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify
PUBLIC	?has@result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NW4result_flags_t@23@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::has
PUBLIC	?erase@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXViterator@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase
PUBLIC	?erase@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEXViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@@Z ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::erase
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ; std::addressof<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >
PUBLIC	?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil
PUBLIC	??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy
PUBLIC	??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
PUBLIC	?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase
PUBLIC	?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode
PUBLIC	??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
PUBLIC	??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
PUBLIC	??R?$equal_to@I@std@@QBE_NABI0@Z		; std::equal_to<unsigned int>::operator()
PUBLIC	??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
PUBLIC	?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
PUBLIC	?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo
PUBLIC	??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[]
PUBLIC	?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi
PUBLIC	?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End
PUBLIC	??Rcpp_tommy_inthash_u32@@QBEII@Z		; cpp_tommy_inthash_u32::operator()
PUBLIC	??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=
PUBLIC	?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
PUBLIC	??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
PUBLIC	?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
PUBLIC	??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
PUBLIC	??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
PUBLIC	??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
PUBLIC	??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>
PUBLIC	??$move@AAPAUstx_object@@@std@@YA$$QAPAUstx_object@@AAPAU1@@Z ; std::move<stx_object * &>
PUBLIC	??$move@AAI@std@@YA$$QAIAAI@Z			; std::move<unsigned int &>
PUBLIC	??4?$pair@IPAUstx_object@@@std@@QAEAAU01@$$QAU01@@Z ; std::pair<unsigned int,stx_object *>::operator=
PUBLIC	?key@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::key
PUBLIC	?data@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEAAPAUstx_object@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::data
PUBLIC	??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABU01@@Z ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
PUBLIC	??0?$pair@IPAUstx_object@@@std@@QAE@ABU01@@Z	; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
PUBLIC	??R?$btree_pair_to_value@U?$pair@IPAUstx_object@@@std@@U12@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE?AU?$pair@IPAUstx_object@@@std@@ABU34@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree_pair_to_value<std::pair<unsigned int,stx_object *>,std::pair<unsigned int,stx_object *> >::operator()
PUBLIC	??$forward@ABI@std@@YAABIABI@Z			; std::forward<unsigned int const &>
PUBLIC	??$?0ABIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int const &,stx_object * &>
PUBLIC	??$?0ABIAAPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int const &,stx_object * &>
PUBLIC	??Citerator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPAU?$pair@IPAUstx_object@@@std@@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator->
PUBLIC	??8iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator==
PUBLIC	??$forward@AAPAUstx_object@@@std@@YAAAPAUstx_object@@AAPAU1@@Z ; std::forward<stx_object * &>
PUBLIC	??$forward@AAI@std@@YAAAIAAI@Z			; std::forward<unsigned int &>
PUBLIC	??$?0AAIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@AAIAAPAUstx_object@@@Z ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int &,stx_object * &>
PUBLIC	??$?0IPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@AAU01@@Z ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int,stx_object *>
PUBLIC	??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV012@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==
PUBLIC	?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->
PUBLIC	??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
PUBLIC	??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
PUBLIC	?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
PUBLIC	?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
PUBLIC	?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count
PUBLIC	?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
PUBLIC	?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf
PUBLIC	?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count
PUBLIC	?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child
PUBLIC	??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats
PUBLIC	??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=
PUBLIC	?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
PUBLIC	?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used
PUBLIC	?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used
PUBLIC	?get_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABUtree_stats@12@XZ ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::get_stats
PUBLIC	?get_stats@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QBEABUtree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::get_stats
PUBLIC	?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
PUBLIC	?TRIE_INPLACE@@3PAUtrie_inplace_object@@A	; TRIE_INPLACE
PUBLIC	?RBTREE@@3PAUrbt_object@@A			; RBTREE
PUBLIC	?HASHLIN@@3PAUhashtable_object@@A		; HASHLIN
PUBLIC	?RAND1@@3PAIA					; RAND1
PUBLIC	?JUDY@@3PAUjudy_object@@A			; JUDY
PUBLIC	?nedtrie@@3Unedtrie_t@@A			; nedtrie
PUBLIC	?HASHDYN@@3PAUhashtable_object@@A		; HASHDYN
PUBLIC	?JUDYARRAY@@3PAUjudyarray_object@@A		; JUDYARRAY
PUBLIC	?HASHTABLE@@3PAUhashtable_object@@A		; HASHTABLE
PUBLIC	?the_order@@3IA					; the_order
PUBLIC	?the_time@@3_KA					; the_time
PUBLIC	?STX@@3PAUstx_object@@A				; STX
PUBLIC	?hashdyn@@3Utommy_hashdyn_struct@@A		; hashdyn
PUBLIC	?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
PUBLIC	?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
PUBLIC	?trie_inplace@@3Utommy_trie_inplace_struct@@A	; trie_inplace
PUBLIC	?the_retry@@3IA					; the_retry
PUBLIC	?KHASH@@3PAUkhash_object@@A			; KHASH
PUBLIC	?trie@@3Utommy_trie_struct@@A			; trie
PUBLIC	?GOOGLE@@3PAUgoogle_object@@A			; GOOGLE
PUBLIC	?RAND0@@3PAIA					; RAND0
PUBLIC	?khash@@3PAUkh_word_t@@A			; khash
PUBLIC	?NEDTRIE@@3PAUnedtrie_object@@A			; NEDTRIE
PUBLIC	?trie_allocator@@3Utommy_allocator_struct@@A	; trie_allocator
PUBLIC	?CPP@@3PAUcpp_object@@A				; CPP
PUBLIC	?tree@@3Urbtree_t@@A				; tree
PUBLIC	?hashtable@@3Utommy_hashtable_struct@@A		; hashtable
PUBLIC	?the_operation@@3IA				; the_operation
PUBLIC	?TRIE@@3PAUtrie_object@@A			; TRIE
PUBLIC	?UTHASH@@3PAUuthash_object@@A			; UTHASH
PUBLIC	?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
PUBLIC	?the_log@@3HA					; the_log
PUBLIC	?the_max@@3IA					; the_max
PUBLIC	?LOG@@3PAY2BA@15IA				; LOG
PUBLIC	?LAST@@3PAY01IA					; LAST
PUBLIC	?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
PUBLIC	?FORWARD@@3PAIA					; FORWARD
PUBLIC	?the_start_data@@3IA				; the_start_data
PUBLIC	?hashlin@@3Utommy_hashlin_struct@@A		; hashlin
PUBLIC	?CACHE@@3PAEA					; CACHE
PUBLIC	?the_data@@3IA					; the_data
PUBLIC	?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B ; std::_Num_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_base@std@@2_NB		; std::_Num_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_base@std@@2_NB		; std::_Num_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_base@std@@2_NB		; std::_Num_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_base@std@@2_NB			; std::_Num_base::is_bounded
PUBLIC	?is_exact@_Num_base@std@@2_NB			; std::_Num_base::is_exact
PUBLIC	?is_iec559@_Num_base@std@@2_NB			; std::_Num_base::is_iec559
PUBLIC	?is_integer@_Num_base@std@@2_NB			; std::_Num_base::is_integer
PUBLIC	?is_modulo@_Num_base@std@@2_NB			; std::_Num_base::is_modulo
PUBLIC	?is_signed@_Num_base@std@@2_NB			; std::_Num_base::is_signed
PUBLIC	?is_specialized@_Num_base@std@@2_NB		; std::_Num_base::is_specialized
PUBLIC	?tinyness_before@_Num_base@std@@2_NB		; std::_Num_base::tinyness_before
PUBLIC	?traps@_Num_base@std@@2_NB			; std::_Num_base::traps
PUBLIC	?round_style@_Num_base@std@@2W4float_round_style@2@B ; std::_Num_base::round_style
PUBLIC	?digits@_Num_base@std@@2HB			; std::_Num_base::digits
PUBLIC	?digits10@_Num_base@std@@2HB			; std::_Num_base::digits10
PUBLIC	?max_digits10@_Num_base@std@@2HB		; std::_Num_base::max_digits10
PUBLIC	?max_exponent@_Num_base@std@@2HB		; std::_Num_base::max_exponent
PUBLIC	?max_exponent10@_Num_base@std@@2HB		; std::_Num_base::max_exponent10
PUBLIC	?min_exponent@_Num_base@std@@2HB		; std::_Num_base::min_exponent
PUBLIC	?min_exponent10@_Num_base@std@@2HB		; std::_Num_base::min_exponent10
PUBLIC	?radix@_Num_base@std@@2HB			; std::_Num_base::radix
PUBLIC	?is_bounded@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_bounded
PUBLIC	?is_exact@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_exact
PUBLIC	?is_integer@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_integer
PUBLIC	?is_modulo@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_modulo
PUBLIC	?is_specialized@_Num_int_base@std@@2_NB		; std::_Num_int_base::is_specialized
PUBLIC	?radix@_Num_int_base@std@@2HB			; std::_Num_int_base::radix
PUBLIC	?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B ; std::_Num_float_base::has_denorm
PUBLIC	?has_denorm_loss@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_denorm_loss
PUBLIC	?has_infinity@_Num_float_base@std@@2_NB		; std::_Num_float_base::has_infinity
PUBLIC	?has_quiet_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_quiet_NaN
PUBLIC	?has_signaling_NaN@_Num_float_base@std@@2_NB	; std::_Num_float_base::has_signaling_NaN
PUBLIC	?is_bounded@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_bounded
PUBLIC	?is_exact@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_exact
PUBLIC	?is_iec559@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_iec559
PUBLIC	?is_integer@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_integer
PUBLIC	?is_modulo@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_modulo
PUBLIC	?is_signed@_Num_float_base@std@@2_NB		; std::_Num_float_base::is_signed
PUBLIC	?is_specialized@_Num_float_base@std@@2_NB	; std::_Num_float_base::is_specialized
PUBLIC	?tinyness_before@_Num_float_base@std@@2_NB	; std::_Num_float_base::tinyness_before
PUBLIC	?traps@_Num_float_base@std@@2_NB		; std::_Num_float_base::traps
PUBLIC	?round_style@_Num_float_base@std@@2W4float_round_style@2@B ; std::_Num_float_base::round_style
PUBLIC	?radix@_Num_float_base@std@@2HB			; std::_Num_float_base::radix
PUBLIC	?is_signed@?$numeric_limits@D@std@@2_NB		; std::numeric_limits<char>::is_signed
PUBLIC	?digits@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits
PUBLIC	?digits10@?$numeric_limits@D@std@@2HB		; std::numeric_limits<char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@D@std@@2HB	; std::numeric_limits<char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_W@std@@2_NB	; std::numeric_limits<wchar_t>::is_signed
PUBLIC	?digits@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits
PUBLIC	?digits10@?$numeric_limits@_W@std@@2HB		; std::numeric_limits<wchar_t>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_W@std@@2HB	; std::numeric_limits<wchar_t>::max_digits10
PUBLIC	?is_modulo@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_modulo
PUBLIC	?is_signed@?$numeric_limits@_N@std@@2_NB	; std::numeric_limits<bool>::is_signed
PUBLIC	?digits@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits
PUBLIC	?digits10@?$numeric_limits@_N@std@@2HB		; std::numeric_limits<bool>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_N@std@@2HB	; std::numeric_limits<bool>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@C@std@@2_NB		; std::numeric_limits<signed char>::is_signed
PUBLIC	?digits@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits
PUBLIC	?digits10@?$numeric_limits@C@std@@2HB		; std::numeric_limits<signed char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@C@std@@2HB	; std::numeric_limits<signed char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@E@std@@2_NB		; std::numeric_limits<unsigned char>::is_signed
PUBLIC	?digits@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits
PUBLIC	?digits10@?$numeric_limits@E@std@@2HB		; std::numeric_limits<unsigned char>::digits10
PUBLIC	?max_digits10@?$numeric_limits@E@std@@2HB	; std::numeric_limits<unsigned char>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@F@std@@2_NB		; std::numeric_limits<short>::is_signed
PUBLIC	?digits@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits
PUBLIC	?digits10@?$numeric_limits@F@std@@2HB		; std::numeric_limits<short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@F@std@@2HB	; std::numeric_limits<short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@G@std@@2_NB		; std::numeric_limits<unsigned short>::is_signed
PUBLIC	?digits@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits
PUBLIC	?digits10@?$numeric_limits@G@std@@2HB		; std::numeric_limits<unsigned short>::digits10
PUBLIC	?max_digits10@?$numeric_limits@G@std@@2HB	; std::numeric_limits<unsigned short>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@H@std@@2_NB		; std::numeric_limits<int>::is_signed
PUBLIC	?digits@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits
PUBLIC	?digits10@?$numeric_limits@H@std@@2HB		; std::numeric_limits<int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@H@std@@2HB	; std::numeric_limits<int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@I@std@@2_NB		; std::numeric_limits<unsigned int>::is_signed
PUBLIC	?digits@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits
PUBLIC	?digits10@?$numeric_limits@I@std@@2HB		; std::numeric_limits<unsigned int>::digits10
PUBLIC	?max_digits10@?$numeric_limits@I@std@@2HB	; std::numeric_limits<unsigned int>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@J@std@@2_NB		; std::numeric_limits<long>::is_signed
PUBLIC	?digits@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits
PUBLIC	?digits10@?$numeric_limits@J@std@@2HB		; std::numeric_limits<long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@J@std@@2HB	; std::numeric_limits<long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@K@std@@2_NB		; std::numeric_limits<unsigned long>::is_signed
PUBLIC	?digits@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits
PUBLIC	?digits10@?$numeric_limits@K@std@@2HB		; std::numeric_limits<unsigned long>::digits10
PUBLIC	?max_digits10@?$numeric_limits@K@std@@2HB	; std::numeric_limits<unsigned long>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_J@std@@2_NB	; std::numeric_limits<__int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits
PUBLIC	?digits10@?$numeric_limits@_J@std@@2HB		; std::numeric_limits<__int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_J@std@@2HB	; std::numeric_limits<__int64>::max_digits10
PUBLIC	?is_signed@?$numeric_limits@_K@std@@2_NB	; std::numeric_limits<unsigned __int64>::is_signed
PUBLIC	?digits@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits
PUBLIC	?digits10@?$numeric_limits@_K@std@@2HB		; std::numeric_limits<unsigned __int64>::digits10
PUBLIC	?max_digits10@?$numeric_limits@_K@std@@2HB	; std::numeric_limits<unsigned __int64>::max_digits10
PUBLIC	?digits@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits
PUBLIC	?digits10@?$numeric_limits@M@std@@2HB		; std::numeric_limits<float>::digits10
PUBLIC	?max_digits10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@M@std@@2HB	; std::numeric_limits<float>::min_exponent10
PUBLIC	?digits@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits
PUBLIC	?digits10@?$numeric_limits@N@std@@2HB		; std::numeric_limits<double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@N@std@@2HB	; std::numeric_limits<double>::min_exponent10
PUBLIC	?digits@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits
PUBLIC	?digits10@?$numeric_limits@O@std@@2HB		; std::numeric_limits<long double>::digits10
PUBLIC	?max_digits10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_digits10
PUBLIC	?max_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent
PUBLIC	?max_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::max_exponent10
PUBLIC	?min_exponent@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent
PUBLIC	?min_exponent10@?$numeric_limits@O@std@@2HB	; std::numeric_limits<long double>::min_exponent10
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?JudySize@@3PAHA				; JudySize
PUBLIC	?JudyMask@@3PAIA				; JudyMask
PUBLIC	?uthash@@3PAUuthash_object@@A			; uthash
PUBLIC	?judy@@3PAXA					; judy
PUBLIC	?judyarray@@3PAUJudy@@A				; judyarray
PUBLIC	?SEED@@3_KA					; SEED
PUBLIC	?OPERATION_NAME@@3PAPBDA			; OPERATION_NAME
PUBLIC	?ORDER_NAME@@3PAPBDA				; ORDER_NAME
PUBLIC	?DATA_NAME@@3PAPBDA				; DATA_NAME
PUBLIC	?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ILLEGAL_BUCKET
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@	; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_OCCUPANCY_PCT
PUBLIC	?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_EMPTY_PCT
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_C@_0BA@CGMABIOM@insert?5overflow?$AA@	; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
EXTRN	_strncmp:PROC
EXTRN	_fopen:PROC
EXTRN	_sprintf:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	_calloc:PROC
EXTRN	_JudyLIns:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	_abort:PROC
EXTRN	_JudyLGet:PROC
EXTRN	_JudyLDel:PROC
EXTRN	___iob_func:PROC
EXTRN	_realloc:PROC
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_memmove:PROC
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_JudyLMemUsed:PROC
EXTRN	_fclose:PROC
EXTRN	_fprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
EXTRN	_exit:PROC
EXTRN	_atoi:PROC
EXTRN	_printf:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A DD 01H DUP (?) ; cppmap
?TRIE_INPLACE@@3PAUtrie_inplace_object@@A DD 01H DUP (?) ; TRIE_INPLACE
?RBTREE@@3PAUrbt_object@@A DD 01H DUP (?)		; RBTREE
?HASHLIN@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHLIN
?RAND1@@3PAIA DD 01H DUP (?)				; RAND1
?JUDY@@3PAUjudy_object@@A DD 01H DUP (?)		; JUDY
?nedtrie@@3Unedtrie_t@@A DB 088H DUP (?)		; nedtrie
?HASHDYN@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHDYN
?JUDYARRAY@@3PAUjudyarray_object@@A DD 01H DUP (?)	; JUDYARRAY
?HASHTABLE@@3PAUhashtable_object@@A DD 01H DUP (?)	; HASHTABLE
?the_order@@3IA DD 01H DUP (?)				; the_order
?the_time@@3_KA DQ 01H DUP (?)				; the_time
?STX@@3PAUstx_object@@A DD 01H DUP (?)			; STX
?hashdyn@@3Utommy_hashdyn_struct@@A DB 014H DUP (?)	; hashdyn
?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A DD 01H DUP (?) ; stxbtree
?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A DD 01H DUP (?) ; cppunorderedmap
?trie_inplace@@3Utommy_trie_inplace_struct@@A DB 0104H DUP (?) ; trie_inplace
?the_retry@@3IA DD 01H DUP (?)				; the_retry
?KHASH@@3PAUkhash_object@@A DD 01H DUP (?)		; KHASH
?trie@@3Utommy_trie_struct@@A DB 04cH DUP (?)		; trie
?GOOGLE@@3PAUgoogle_object@@A DD 01H DUP (?)		; GOOGLE
?RAND0@@3PAIA DD 01H DUP (?)				; RAND0
?khash@@3PAUkh_word_t@@A DD 01H DUP (?)			; khash
?NEDTRIE@@3PAUnedtrie_object@@A DD 01H DUP (?)		; NEDTRIE
?trie_allocator@@3Utommy_allocator_struct@@A DB 014H DUP (?) ; trie_allocator
?CPP@@3PAUcpp_object@@A DD 01H DUP (?)			; CPP
?tree@@3Urbtree_t@@A DB 020H DUP (?)			; tree
?hashtable@@3Utommy_hashtable_struct@@A DB 010H DUP (?)	; hashtable
?the_operation@@3IA DD 01H DUP (?)			; the_operation
?TRIE@@3PAUtrie_object@@A DD 01H DUP (?)		; TRIE
?UTHASH@@3PAUuthash_object@@A DD 01H DUP (?)		; UTHASH
?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A DD 01H DUP (?) ; googledensehash
?the_log@@3HA DD 01H DUP (?)				; the_log
?the_max@@3IA DD 01H DUP (?)				; the_max
?LOG@@3PAY2BA@15IA DD 0540H DUP (?)			; LOG
?LAST@@3PAY01IA DD 020H DUP (?)				; LAST
?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A DD 01H DUP (?) ; googlebtree
?FORWARD@@3PAIA DD 01H DUP (?)				; FORWARD
?the_start_data@@3IA DD 01H DUP (?)			; the_start_data
?hashlin@@3Utommy_hashlin_struct@@A DB 0a4H DUP (?)	; hashlin
?CACHE@@3PAEA DB 0800000H DUP (?)			; CACHE
?the_data@@3IA DD 01H DUP (?)				; the_data
?uthash@@3PAUuthash_object@@A DD 01H DUP (?)		; uthash
?judy@@3PAXA DD	01H DUP (?)				; judy
?judyarray@@3PAUJudy@@A DD 01H DUP (?)			; judyarray
?SEED@@3_KA DQ	01H DUP (?)				; SEED
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
CONST	SEGMENT
??_C@_0BA@CGMABIOM@insert?5overflow?$AA@ DB 'insert overflow', 00H ; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB
CONST	SEGMENT
?HT_EMPTY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB DD 014H ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_EMPTY_PCT
CONST	ENDS
;	COMDAT ?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB
CONST	SEGMENT
?HT_OCCUPANCY_PCT@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@2HB DD 032H ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::HT_OCCUPANCY_PCT
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
CONST	SEGMENT
??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@ DB 'sparsehash'
	DB	': FATAL ERROR: failed to reallocate %lu elements for ptr %p', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
CONST	SEGMENT
??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@ DB 'resize overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT ?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB
CONST	SEGMENT
?ILLEGAL_BUCKET@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0IB DD 0ffffffffH ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ILLEGAL_BUCKET
?JudySize@@3PAHA DD 040H				; JudySize
	DD	08H
	DD	010H
	DD	020H
	DD	040H
	DD	080H
	DD	0100H
	DD	020H
?JudyMask@@3PAIA DD 00H					; JudyMask
	DD	0ffH
	DD	0ffffH
	DD	0ffffffH
	DD	0ffffffffH
	ORG $+16
?OPERATION_NAME@@3PAPBDA DD FLAT:$SG-77			; OPERATION_NAME
	DD	FLAT:$SG-78
	DD	FLAT:$SG-79
	DD	FLAT:$SG-80
	DD	FLAT:$SG-81
	DD	FLAT:$SG-82
?ORDER_NAME@@3PAPBDA DD FLAT:$SG-83			; ORDER_NAME
	DD	FLAT:$SG-84
	ORG $+4
?DATA_NAME@@3PAPBDA DD FLAT:$SG-85			; DATA_NAME
	DD	FLAT:$SG-86
	DD	FLAT:$SG-87
	DD	FLAT:$SG-88
	DD	FLAT:$SG-89
	DD	FLAT:$SG-90
	DD	FLAT:$SG-91
	DD	FLAT:$SG-92
	DD	FLAT:$SG-93
	DD	FLAT:$SG-94
	DD	FLAT:$SG-95
	DD	FLAT:$SG-96
	DD	FLAT:$SG-97
	DD	FLAT:$SG-98
	DD	FLAT:$SG-99
	DD	FLAT:$SG-100
___ac_prime_list DD 00H
	DD	03H
	DD	0bH
	DD	017H
	DD	035H
	DD	061H
	DD	0c1H
	DD	0185H
	DD	0301H
	DD	0607H
	DD	0c07H
	DD	01807H
	DD	03001H
	DD	06011H
	DD	0c005H
	DD	01800dH
	DD	030005H
	DD	060019H
	DD	0c0001H
	DD	0180005H
	DD	030000bH
	DD	060000dH
	DD	0c00005H
	DD	01800013H
	DD	03000005H
	DD	06000017H
	DD	0c000013H
	DD	018000005H
	DD	030000059H
	DD	060000005H
	DD	0c0000001H
	DD	0fffffffbH
___ac_HASH_UPPER DQ 03fe8a3d70a3d70a4r		; 0.77
$SG-77	DB	'insert', 00H
	ORG $+1
$SG-78	DB	'hit', 00H
$SG-79	DB	'miss', 00H
	ORG $+3
$SG-80	DB	'size', 00H
	ORG $+3
$SG-81	DB	'change', 00H
	ORG $+1
$SG-82	DB	'remove', 00H
	ORG $+1
$SG-83	DB	'forward', 00H
$SG-84	DB	'random', 00H
	ORG $+1
$SG-85	DB	'tommy-hashtable', 00H
$SG-86	DB	'tommy-hashdyn', 00H
	ORG $+2
$SG-87	DB	'tommy-hashlin', 00H
	ORG $+2
$SG-88	DB	'tommy-trie', 00H
	ORG $+1
$SG-89	DB	'tommy-trie-inplace', 00H
	ORG $+1
$SG-90	DB	'rbtree', 00H
	ORG $+1
$SG-91	DB	'nedtrie', 00H
$SG-92	DB	'khash', 00H
	ORG $+2
$SG-93	DB	'uthash', 00H
	ORG $+1
$SG-94	DB	'judy', 00H
	ORG $+3
$SG-95	DB	'judyarray', 00H
	ORG $+2
$SG-96	DB	'googledensehash', 00H
$SG-97	DB	'googlebtree', 00H
$SG-98	DB	'stxbtree', 00H
	ORG $+3
$SG-99	DB	'c++unorderedmap', 00H
$SG-100	DB	'c++map', 00H
	ORG $+1
$SG-101	DB	'%10s, %10s, %12s, ', 00H
	ORG $+1
$SG-102	DB	'%4u [ns]', 0aH, 00H
	ORG $+2
$SG-103	DB	'%10s, %10s, %12s, ', 00H
	ORG $+1
$SG-104	DB	'%4u [byte]', 0aH, 00H
$SG-105	DB	'dat_%s_%s.lst', 00H
	ORG $+2
$SG-106	DB	'JudyLIns', 00H
	ORG $+3
$SG-107	DB	'benchmark.cc', 00H
	ORG $+3
$SG-108	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-109	DB	'JudyLDel', 00H
	ORG $+3
$SG-110	DB	'benchmark.cc', 00H
	ORG $+3
$SG-111	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-112	DB	'JudyLIns', 00H
	ORG $+3
$SG-113	DB	'benchmark.cc', 00H
	ORG $+3
$SG-114	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-115	DB	'JudyLDel', 00H
	ORG $+3
$SG-116	DB	'benchmark.cc', 00H
	ORG $+3
$SG-117	DB	'File ''%s'', line %d: %s(), JU_ERRNO_* == %d, ID == %d', 0aH
	DB	00H
	ORG $+2
$SG-118	DB	'wt', 00H
	ORG $+1
$SG-119	DB	'0', 09H, 00H
	ORG $+1
$SG-120	DB	'%s', 09H, 00H
$SG-121	DB	0aH, 00H
	ORG $+2
$SG-122	DB	'%d %s %s', 00H
	ORG $+3
$SG-123	DB	' (skipped, too slow)', 0aH, 00H
	ORG $+2
$SG-124	DB	0aH, 00H
	ORG $+2
$SG-125	DB	'at', 00H
	ORG $+1
$SG-126	DB	'%u', 09H, 00H
$SG-127	DB	'%u', 09H, 00H
$SG-128	DB	0aH, 00H
	ORG $+2
$SG-129	DB	'Cache miss %d [ns]', 0aH, 00H
$SG-130	DB	'Tommy benchmark program.', 0aH, 00H
	ORG $+2
$SG-131	DB	'-l', 00H
	ORG $+1
$SG-132	DB	'-s', 00H
	ORG $+1
$SG-133	DB	'-m', 00H
	ORG $+1
$SG-134	DB	'-n', 00H
	ORG $+1
$SG-135	DB	'-N', 00H
	ORG $+1
$SG-136	DB	'Missing data in %s', 0aH, 00H
$SG-137	DB	'-d', 00H
	ORG $+1
$SG-138	DB	'Missing data in %s', 0aH, 00H
$SG-139	DB	'Unknown data %s', 0aH, 00H
	ORG $+3
$SG-140	DB	'Unknown option %s', 0aH, 00H
	ORG $+1
$SG-141	DB	'OK', 0aH, 00H
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@O@std@@2HB DD 0fffffecdH ; std::numeric_limits<long double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@O@std@@2HB DD 0fffffc03H	; std::numeric_limits<long double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@O@std@@2HB DD 0134H	; std::numeric_limits<long double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@O@std@@2HB DD 0400H	; std::numeric_limits<long double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@O@std@@2HB DD 011H	; std::numeric_limits<long double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@O@std@@2HB DD 0fH		; std::numeric_limits<long double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@O@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@O@std@@2HB DD 035H		; std::numeric_limits<long double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@N@std@@2HB DD 0fffffecdH ; std::numeric_limits<double>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@N@std@@2HB DD 0fffffc03H	; std::numeric_limits<double>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@N@std@@2HB DD 0134H	; std::numeric_limits<double>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@N@std@@2HB DD 0400H	; std::numeric_limits<double>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@N@std@@2HB DD 011H	; std::numeric_limits<double>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@N@std@@2HB DD 0fH		; std::numeric_limits<double>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@N@std@@2HB DD 035H		; std::numeric_limits<double>::digits
CONST	ENDS
;	COMDAT ?min_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent10@?$numeric_limits@M@std@@2HB DD 0ffffffdbH ; std::numeric_limits<float>::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?min_exponent@?$numeric_limits@M@std@@2HB DD 0ffffff83H	; std::numeric_limits<float>::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent10@?$numeric_limits@M@std@@2HB DD 026H	; std::numeric_limits<float>::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_exponent@?$numeric_limits@M@std@@2HB DD 080H	; std::numeric_limits<float>::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@M@std@@2HB DD 08H	; std::numeric_limits<float>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@M@std@@2HB DD 06H		; std::numeric_limits<float>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@M@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@M@std@@2HB DD 018H		; std::numeric_limits<float>::digits
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_K@std@@2HB DD 015H	; std::numeric_limits<unsigned __int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_K@std@@2HB DD 013H		; std::numeric_limits<unsigned __int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_K@std@@2HB DD 040H		; std::numeric_limits<unsigned __int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_K@std@@2_NB DB 00H		; std::numeric_limits<unsigned __int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_J@std@@2HB DD 014H	; std::numeric_limits<__int64>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_J@std@@2HB DD 012H		; std::numeric_limits<__int64>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_J@std@@2HB DD 03fH		; std::numeric_limits<__int64>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_J@std@@2_NB DB 01H		; std::numeric_limits<__int64>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@K@std@@2HB DD 0bH	; std::numeric_limits<unsigned long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@K@std@@2HB DD 09H		; std::numeric_limits<unsigned long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@K@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@K@std@@2HB DD 020H		; std::numeric_limits<unsigned long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@K@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@K@std@@2_NB DB 00H		; std::numeric_limits<unsigned long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@J@std@@2HB DD 0bH	; std::numeric_limits<long>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@J@std@@2HB DD 09H		; std::numeric_limits<long>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@J@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@J@std@@2HB DD 01fH		; std::numeric_limits<long>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@J@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@J@std@@2_NB DB 01H		; std::numeric_limits<long>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@I@std@@2HB DD 0bH	; std::numeric_limits<unsigned int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@I@std@@2HB DD 09H		; std::numeric_limits<unsigned int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@I@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@I@std@@2HB DD 020H		; std::numeric_limits<unsigned int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@I@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@I@std@@2_NB DB 00H		; std::numeric_limits<unsigned int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@H@std@@2HB DD 0bH	; std::numeric_limits<int>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@H@std@@2HB DD 09H		; std::numeric_limits<int>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@H@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@H@std@@2HB DD 01fH		; std::numeric_limits<int>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@H@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@H@std@@2_NB DB 01H		; std::numeric_limits<int>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@G@std@@2HB DD 06H	; std::numeric_limits<unsigned short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@G@std@@2HB DD 04H		; std::numeric_limits<unsigned short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@G@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@G@std@@2HB DD 010H		; std::numeric_limits<unsigned short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@G@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@G@std@@2_NB DB 00H		; std::numeric_limits<unsigned short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@F@std@@2HB DD 06H	; std::numeric_limits<short>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@F@std@@2HB DD 04H		; std::numeric_limits<short>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@F@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@F@std@@2HB DD 0fH		; std::numeric_limits<short>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@F@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@F@std@@2_NB DB 01H		; std::numeric_limits<short>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@E@std@@2HB DD 04H	; std::numeric_limits<unsigned char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@E@std@@2HB DD 02H		; std::numeric_limits<unsigned char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@E@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@E@std@@2HB DD 08H		; std::numeric_limits<unsigned char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@E@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@E@std@@2_NB DB 00H		; std::numeric_limits<unsigned char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@C@std@@2HB DD 04H	; std::numeric_limits<signed char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@C@std@@2HB DD 02H		; std::numeric_limits<signed char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@C@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@C@std@@2HB DD 07H		; std::numeric_limits<signed char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@C@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@C@std@@2_NB DB 01H		; std::numeric_limits<signed char>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_N@std@@2HB DD 00H	; std::numeric_limits<bool>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_N@std@@2HB DD 00H		; std::numeric_limits<bool>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_N@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_N@std@@2HB DD 01H		; std::numeric_limits<bool>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@?$numeric_limits@_N@std@@2_NB
CONST	SEGMENT
?is_modulo@?$numeric_limits@_N@std@@2_NB DB 00H		; std::numeric_limits<bool>::is_modulo
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@_W@std@@2HB DD 06H	; std::numeric_limits<wchar_t>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@_W@std@@2HB DD 04H		; std::numeric_limits<wchar_t>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@_W@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@_W@std@@2HB DD 010H		; std::numeric_limits<wchar_t>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@_W@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@_W@std@@2_NB DB 00H		; std::numeric_limits<wchar_t>::is_signed
CONST	ENDS
;	COMDAT ?max_digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?max_digits10@?$numeric_limits@D@std@@2HB DD 04H	; std::numeric_limits<char>::max_digits10
CONST	ENDS
;	COMDAT ?digits10@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits10@?$numeric_limits@D@std@@2HB DD 02H		; std::numeric_limits<char>::digits10
CONST	ENDS
;	COMDAT ?digits@?$numeric_limits@D@std@@2HB
CONST	SEGMENT
?digits@?$numeric_limits@D@std@@2HB DD 07H		; std::numeric_limits<char>::digits
CONST	ENDS
;	COMDAT ?is_signed@?$numeric_limits@D@std@@2_NB
CONST	SEGMENT
?is_signed@?$numeric_limits@D@std@@2_NB DB 01H		; std::numeric_limits<char>::is_signed
CONST	ENDS
;	COMDAT ?radix@_Num_float_base@std@@2HB
CONST	SEGMENT
?radix@_Num_float_base@std@@2HB DD 02H			; std::_Num_float_base::radix
CONST	ENDS
;	COMDAT ?round_style@_Num_float_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_float_base@std@@2W4float_round_style@2@B DD 01H ; std::_Num_float_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_float_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_float_base@std@@2_NB DB 01H			; std::_Num_float_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_float_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_float_base@std@@2_NB DB 00H		; std::_Num_float_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_float_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_float_base@std@@2_NB DB 01H		; std::_Num_float_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_float_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_float_base@std@@2_NB DB 01H	; std::_Num_float_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_float_base@std@@2W4float_denorm_style@2@B DD 01H ; std::_Num_float_base::has_denorm
CONST	ENDS
;	COMDAT ?radix@_Num_int_base@std@@2HB
CONST	SEGMENT
?radix@_Num_int_base@std@@2HB DD 02H			; std::_Num_int_base::radix
CONST	ENDS
;	COMDAT ?is_specialized@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_specialized
CONST	ENDS
;	COMDAT ?is_modulo@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_integer
CONST	ENDS
;	COMDAT ?is_exact@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_int_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_int_base@std@@2_NB DB 01H		; std::_Num_int_base::is_bounded
CONST	ENDS
;	COMDAT ?radix@_Num_base@std@@2HB
CONST	SEGMENT
?radix@_Num_base@std@@2HB DD 00H			; std::_Num_base::radix
CONST	ENDS
;	COMDAT ?min_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::min_exponent10
CONST	ENDS
;	COMDAT ?min_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?min_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::min_exponent
CONST	ENDS
;	COMDAT ?max_exponent10@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent10@_Num_base@std@@2HB DD 00H		; std::_Num_base::max_exponent10
CONST	ENDS
;	COMDAT ?max_exponent@_Num_base@std@@2HB
CONST	SEGMENT
?max_exponent@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_exponent
CONST	ENDS
;	COMDAT ?max_digits10@_Num_base@std@@2HB
CONST	SEGMENT
?max_digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::max_digits10
CONST	ENDS
;	COMDAT ?digits10@_Num_base@std@@2HB
CONST	SEGMENT
?digits10@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits10
CONST	ENDS
;	COMDAT ?digits@_Num_base@std@@2HB
CONST	SEGMENT
?digits@_Num_base@std@@2HB DD 00H			; std::_Num_base::digits
CONST	ENDS
;	COMDAT ?round_style@_Num_base@std@@2W4float_round_style@2@B
CONST	SEGMENT
?round_style@_Num_base@std@@2W4float_round_style@2@B DD 00H ; std::_Num_base::round_style
CONST	ENDS
;	COMDAT ?traps@_Num_base@std@@2_NB
CONST	SEGMENT
?traps@_Num_base@std@@2_NB DB 00H			; std::_Num_base::traps
CONST	ENDS
;	COMDAT ?tinyness_before@_Num_base@std@@2_NB
CONST	SEGMENT
?tinyness_before@_Num_base@std@@2_NB DB 00H		; std::_Num_base::tinyness_before
CONST	ENDS
;	COMDAT ?is_specialized@_Num_base@std@@2_NB
CONST	SEGMENT
?is_specialized@_Num_base@std@@2_NB DB 00H		; std::_Num_base::is_specialized
CONST	ENDS
;	COMDAT ?is_signed@_Num_base@std@@2_NB
CONST	SEGMENT
?is_signed@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_signed
CONST	ENDS
;	COMDAT ?is_modulo@_Num_base@std@@2_NB
CONST	SEGMENT
?is_modulo@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_modulo
CONST	ENDS
;	COMDAT ?is_integer@_Num_base@std@@2_NB
CONST	SEGMENT
?is_integer@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_integer
CONST	ENDS
;	COMDAT ?is_iec559@_Num_base@std@@2_NB
CONST	SEGMENT
?is_iec559@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_iec559
CONST	ENDS
;	COMDAT ?is_exact@_Num_base@std@@2_NB
CONST	SEGMENT
?is_exact@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_exact
CONST	ENDS
;	COMDAT ?is_bounded@_Num_base@std@@2_NB
CONST	SEGMENT
?is_bounded@_Num_base@std@@2_NB DB 00H			; std::_Num_base::is_bounded
CONST	ENDS
;	COMDAT ?has_signaling_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_signaling_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_signaling_NaN
CONST	ENDS
;	COMDAT ?has_quiet_NaN@_Num_base@std@@2_NB
CONST	SEGMENT
?has_quiet_NaN@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_quiet_NaN
CONST	ENDS
;	COMDAT ?has_infinity@_Num_base@std@@2_NB
CONST	SEGMENT
?has_infinity@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_infinity
CONST	ENDS
;	COMDAT ?has_denorm_loss@_Num_base@std@@2_NB
CONST	SEGMENT
?has_denorm_loss@_Num_base@std@@2_NB DB 00H		; std::_Num_base::has_denorm_loss
CONST	ENDS
;	COMDAT ?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B
CONST	SEGMENT
?has_denorm@_Num_base@std@@2W4float_denorm_style@2@B DD 00H ; std::_Num_base::has_denorm
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	ENDS
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAE@std@@YA$$QAEAAE@Z
_TEXT	SEGMENT
??$_Move@AAE@std@@YA$$QAEAAE@Z PROC			; std::_Move<unsigned char &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAE@std@@YA$$QAEAAE@Z ENDP			; std::_Move<unsigned char &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z
_TEXT	SEGMENT
??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z PROC ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YA$$QAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAPAV12@@Z ENDP ; std::_Move<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@ABI@std@@YA$$QBIABI@Z
_TEXT	SEGMENT
??$move@ABI@std@@YA$$QBIABI@Z PROC			; std::move<unsigned int const &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@ABI@std@@YA$$QBIABI@Z ENDP			; std::move<unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z PROC ; std::forward<cpp_object *>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@PAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ENDP ; std::forward<cpp_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@$$CBI@std@@YA$$QBIABI@Z
_TEXT	SEGMENT
??$forward@$$CBI@std@@YA$$QBIABI@Z PROC			; std::forward<unsigned int const >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@$$CBI@std@@YA$$QBIABI@Z ENDP			; std::forward<unsigned int const >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@E@std@@YAXAAE0@Z
_TEXT	SEGMENT
??$swap@E@std@@YAXAAE0@Z PROC				; std::swap<unsigned char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx

; 103  : 	_Left = _Move(_Right);

  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl

; 104  : 	_Right = _Move(_Tmp);

  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@E@std@@YAXAAE0@Z ENDP				; std::swap<unsigned char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z
_TEXT	SEGMENT
??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z PROC ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@std@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@0@Z ENDP ; std::swap<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 136  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 137  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@ABIABQAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z PROC ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z
_TEXT	SEGMENT
??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z PROC ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 202  : 		{	// construct from compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 203  : 		}

  0000a	c3		 ret	 0
??$?0$$CBIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@ABU?$pair@$$CBIPAUgoogle_object@@@1@@Z ENDP ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int const ,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::_Move<google_object * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::_Move<google_object * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2448 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2449 : 	ptrdiff_t _Count = _Last - _First;

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi

; 2450 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2451 : 		_Count * sizeof (*_First));

  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2452 : 	return (_Dest - _Count);

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2453 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2153 : 	ptrdiff_t _Count = _Last - _First;

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2

; 2154 : 	_CSTD memmove(&*_Dest, &*_First,
; 2155 : 		_Count * sizeof (*_First));

  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2156 : 	return (_Dest + _Count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2157 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUstx_object@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUstx_object@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAUstx_object@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUstx_object@@0@Z PROC ; std::_Ptr_cat<stx_object *,stx_object *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUstx_object@@PAU1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUstx_object@@0@Z ENDP ; std::_Ptr_cat<stx_object *,stx_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z
_TEXT	SEGMENT
??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z PROC ; std::forward<std::pair<unsigned int const ,google_object *> const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAABU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ENDP ; std::forward<std::pair<unsigned int const ,google_object *> const &>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@E@btree@@YAXAAE0@Z
_TEXT	SEGMENT
??$btree_swap_helper@E@btree@@YAXAAE0@Z PROC		; btree::btree_swap_helper<unsigned char>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx
  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl
  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@E@btree@@YAXAAE0@Z ENDP		; btree::btree_swap_helper<unsigned char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z
_TEXT	SEGMENT
??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z PROC ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@btree@@YAXAAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@0@0@Z ENDP ; btree::btree_swap_helper<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 2080 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	7c 02		 jl	 SHORT $LN4@max
  00006	8b c1		 mov	 eax, ecx
$LN4@max:

; 2081 : 	}

  00008	c3		 ret	 0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>, COMDAT
; _this$ = eax

; 126  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : 		}

  0000d	c3		 ret	 0
??0?$_Pair_base@IPAUgoogle_object@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ PROC		; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>, COMDAT
; _this$ = eax

; 183  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 184  : 		}

  0000d	c3		 ret	 0
??0?$pair@IPAUgoogle_object@@@std@@QAE@XZ ENDP		; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ
_TEXT	SEGMENT
?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost, COMDAT
; _this$ = eax

; 546  :   btree_node** mutable_rightmost() { return &fields_.rightmost; }

  00000	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00005	c3		 ret	 0
?mutable_rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::move<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z
_TEXT	SEGMENT
??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z PROC ; std::swap<google_object *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAUgoogle_object@@@std@@YAXAAPAUgoogle_object@@0@Z ENDP ; std::swap<google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@I@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$forward@I@std@@YA$$QAIAAI@Z PROC			; std::forward<unsigned int>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@I@std@@YA$$QAIAAI@Z ENDP			; std::forward<unsigned int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::forward<google_object *>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@PAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::forward<google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2448 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2449 : 	ptrdiff_t _Count = _Last - _First;

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi

; 2450 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2451 : 		_Count * sizeof (*_First));

  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2452 : 	return (_Dest - _Count);

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2453 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z PROC ; std::_Copy_backward<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2462 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ENDP ; std::_Copy_backward<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2448 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2449 : 	ptrdiff_t _Count = _Last - _First;

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi

; 2450 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2451 : 		_Count * sizeof (*_First));

  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2452 : 	return (_Dest - _Count);

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2453 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AA_N@std@@YAAA_NAA_N@Z
_TEXT	SEGMENT
??$forward@AA_N@std@@YAAA_NAA_N@Z PROC			; std::forward<bool &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AA_N@std@@YAAA_NAA_N@Z ENDP			; std::forward<bool &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAAAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z
_TEXT	SEGMENT
??$forward@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAAAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z PROC ; std::forward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAAAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z ENDP ; std::forward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2153 : 	ptrdiff_t _Count = _Last - _First;

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2

; 2154 : 	_CSTD memmove(&*_Dest, &*_First,
; 2155 : 		_Count * sizeof (*_First));

  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2156 : 	return (_Dest + _Count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2157 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAU123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAU123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@0@Z PROC ; std::_Ptr_cat<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAU123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@0@Z ENDP ; std::_Ptr_cat<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Rechecked@PAPAUstx_object@@PAPAU1@@std@@YAAAPAPAUstx_object@@AAPAPAU1@PAPAU1@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAUstx_object@@PAPAU1@@std@@YAAAPAPAUstx_object@@AAPAPAU1@PAPAU1@@Z PROC ; std::_Rechecked<stx_object * *,stx_object * *>, COMDAT
; __Dest$ = eax
; __Src$ = ecx

; 275  : 	_Dest = _Src;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 276  : 	return (_Dest);
; 277  : 	}

  00002	c3		 ret	 0
??$_Rechecked@PAPAUstx_object@@PAPAU1@@std@@YAAAPAPAUstx_object@@AAPAPAU1@PAPAU1@@Z ENDP ; std::_Rechecked<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z
_TEXT	SEGMENT
??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z PROC ; std::_Copy_impl<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2164 : 	return (_Copy_impl(_First, _Last,
; 2165 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2166 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ENDP ; std::_Copy_impl<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAPAUstx_object@@@std@@YAPAPAUstx_object@@PAPAU1@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAUstx_object@@@std@@YAPAPAUstx_object@@PAPAU1@@Z PROC ; std::_Unchecked<stx_object * *>, COMDAT
; __Src$ = eax

; 267  : 	return (_Src);
; 268  : 	}

  00000	c3		 ret	 0
??$_Unchecked@PAPAUstx_object@@@std@@YAPAPAUstx_object@@PAPAU1@@Z ENDP ; std::_Unchecked<stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2153 : 	ptrdiff_t _Count = _Last - _First;

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2

; 2154 : 	_CSTD memmove(&*_Dest, &*_First,
; 2155 : 		_Count * sizeof (*_First));

  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2156 : 	return (_Dest + _Count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2157 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAIPAI@std@@YAPAIPAI00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z PROC ; std::_Ptr_cat<unsigned int,unsigned int>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAI0@Z ENDP ; std::_Ptr_cat<unsigned int,unsigned int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned int const ,google_object *> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YAAAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z
_TEXT	SEGMENT
??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z PROC ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@std@@YA$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@AAU12@@Z ENDP ; std::forward<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 2095 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00004	7c 02		 jl	 SHORT $LN4@min
  00006	8b c1		 mov	 eax, ecx
$LN4@min:

; 2096 : 	}

  00008	c3		 ret	 0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z
_TEXT	SEGMENT
?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy, COMDAT

; 726  :     fields_.values[i].~mutable_value_type();
; 727  :   }

  00000	c3		 ret	 0
?value_destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z
_TEXT	SEGMENT
?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child, COMDAT
; _this$ = eax
; _i$ = ecx

; 573  :   btree_node** mutable_child(int i) { return &fields_.children[i]; }

  00000	8d 84 88 00 01
	00 00		 lea	 eax, DWORD PTR [eax+ecx*4+256]
  00007	c3		 ret	 0
?mutable_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count, COMDAT
; _this$ = eax

; 530  :   void set_count(int v) { fields_.count = v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 4d 08	 mov	 cl, BYTE PTR _v$[ebp]
  00006	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?set_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position, COMDAT
; _this$ = eax

; 526  :   void set_position(int v) { fields_.position = v; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8a 4d 08	 mov	 cl, BYTE PTR _v$[ebp]
  00006	88 48 01	 mov	 BYTE PTR [eax+1], cl
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?set_position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_position
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position, COMDAT
; _this$ = eax

; 525  :   int position() const { return fields_.position; }

  00000	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  00004	c3		 ret	 0
?position@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::position
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z
_TEXT	SEGMENT
??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z PROC ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU12@@Z ENDP ; std::move<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > > &>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z
_TEXT	SEGMENT
??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z PROC ; btree::btree_swap_helper<google_object *>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@PAUgoogle_object@@@btree@@YAXAAPAUgoogle_object@@0@Z ENDP ; btree::btree_swap_helper<google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z PROC ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ENDP ; std::_Destroy<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z PROC ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAXPAU?$pair@$$CBIPAUcpp_object@@@0@@Z ENDP ; std::_Destroy<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z PROC ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ENDP ; std::_Val_type<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Last$ = ecx
; __Dest$ = eax

; 2438 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]

; 2439 : 	while (_First != _Last)

  00006	3b d1		 cmp	 edx, ecx
  00008	74 16		 je	 SHORT $LN1@Copy_backw
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL2@Copy_backw:

; 2440 : 		*--_Dest = *--_Last;

  00010	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00013	83 e9 04	 sub	 ecx, 4
  00016	83 e8 04	 sub	 eax, 4
  00019	89 30		 mov	 DWORD PTR [eax], esi
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f1		 jne	 SHORT $LL2@Copy_backw
  0001f	5e		 pop	 esi
$LN1@Copy_backw:

; 2441 : 	return (_Dest);
; 2442 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z PROC ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 2690 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2691 : 	for (; _First != _Last; ++_First)

  00006	3b c1		 cmp	 eax, ecx
  00008	74 12		 je	 SHORT $LN1@Fill
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@Fill:

; 2692 : 		*_First = _Val;

  00010	8b 32		 mov	 esi, DWORD PTR [edx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c0 04	 add	 eax, 4
  00017	3b c1		 cmp	 eax, ecx
  00019	75 f5		 jne	 SHORT $LL3@Fill
  0001b	5e		 pop	 esi
$LN1@Fill:

; 2693 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ENDP ; std::_Fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z PROC ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Src$ = eax

; 267  : 	return (_Src);
; 268  : 	}

  00000	c3		 ret	 0
??$_Unchecked@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@@Z ENDP ; std::_Unchecked<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00006	3b ca		 cmp	 ecx, edx
  00008	74 15		 je	 SHORT $LN1@Move
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00010	8b 31		 mov	 esi, DWORD PTR [ecx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c1 04	 add	 ecx, 4
  00017	83 c0 04	 add	 eax, 4
  0001a	3b ca		 cmp	 ecx, edx
  0001c	75 f2		 jne	 SHORT $LL3@Move
  0001e	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z PROC ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2462 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ENDP ; std::_Copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z PROC ; std::copy_backward<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2469 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2470 : 	return (_Rechecked(_Dest,
; 2471 : 		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2472 : 			_Unchecked(_Dest))));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2473 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$copy_backward@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ENDP ; std::copy_backward<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::_Copy_backward<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2462 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::_Copy_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z
_TEXT	SEGMENT
??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z PROC ; std::_Move<std::pair<unsigned int const ,google_object *> * &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAPAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YA$$QAPAU?$pair@$$CBIPAUgoogle_object@@@0@AAPAU10@@Z ENDP ; std::_Move<std::pair<unsigned int const ,google_object *> * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$_Move@AAI@std@@YA$$QAIAAI@Z PROC			; std::_Move<unsigned int &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::_Move<unsigned int &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z
_TEXT	SEGMENT
??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z PROC ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAV123@@Z ENDP ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z
_TEXT	SEGMENT
??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z PROC ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YA$$QAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAU123@@Z ENDP ; std::_Move<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Rechecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAAAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAPAPAU123@PAPAU123@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAAAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAPAPAU123@PAPAU123@@Z PROC ; std::_Rechecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __Dest$ = eax
; __Src$ = ecx

; 275  : 	_Dest = _Src;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 276  : 	return (_Dest);
; 277  : 	}

  00002	c3		 ret	 0
??$_Rechecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAAAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAPAPAU123@PAPAU123@@Z ENDP ; std::_Rechecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z
_TEXT	SEGMENT
??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z PROC ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2164 : 	return (_Copy_impl(_First, _Last,
; 2165 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2166 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ENDP ; std::_Copy_impl<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@Z PROC ; std::_Unchecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __Src$ = eax

; 267  : 	return (_Src);
; 268  : 	}

  00000	c3		 ret	 0
??$_Unchecked@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@Z ENDP ; std::_Unchecked<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$copy@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z
_TEXT	SEGMENT
??$copy@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z PROC ; std::copy<stx_object * *,stx_object * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2174 : 	return (_Rechecked(_Dest,
; 2175 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2176 : 			_Unchecked(_Dest))));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2177 : 	}

  0001c	c3		 ret	 0
??$copy@PAPAUstx_object@@PAPAU1@@std@@YAPAPAUstx_object@@PAPAU1@00@Z ENDP ; std::copy<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z
_TEXT	SEGMENT
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z PROC	; std::_Rechecked<unsigned int *,unsigned int *>, COMDAT
; __Dest$ = eax
; __Src$ = ecx

; 275  : 	_Dest = _Src;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 276  : 	return (_Dest);
; 277  : 	}

  00002	c3		 ret	 0
??$_Rechecked@PAIPAI@std@@YAAAPAIAAPAIPAI@Z ENDP	; std::_Rechecked<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::_Copy_impl<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2164 : 	return (_Copy_impl(_First, _Last,
; 2165 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2166 : 	}

  0001c	c3		 ret	 0
??$_Copy_impl@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::_Copy_impl<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked@PAI@std@@YAPAIPAI@Z
_TEXT	SEGMENT
??$_Unchecked@PAI@std@@YAPAIPAI@Z PROC			; std::_Unchecked<unsigned int *>, COMDAT
; __Src$ = eax

; 267  : 	return (_Src);
; 268  : 	}

  00000	c3		 ret	 0
??$_Unchecked@PAI@std@@YAPAIPAI@Z ENDP			; std::_Unchecked<unsigned int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AAPAUstx_object@@@std@@YAAAPAUstx_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$forward@AAPAUstx_object@@@std@@YAAAPAUstx_object@@AAPAU1@@Z PROC ; std::forward<stx_object * &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@AAPAUstx_object@@@std@@YAAAPAUstx_object@@AAPAU1@@Z ENDP ; std::forward<stx_object * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT
; __Arg$ = eax

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 96   : 	}

  00000	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z PROC ; std::forward<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Arg$ = eax

; 79   : 	return ((_Ty&&)_Arg);
; 80   : 	}

  00000	c3		 ret	 0
??$forward@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YA$$QAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ENDP ; std::forward<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@AAIAAPAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@AAIAAPAUstx_object@@@Z PROC ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int &,stx_object * &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@AAIAAPAUstx_object@@@Z ENDP ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int &,stx_object * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUgoogle_object@@@std@@@?$allocator@D@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; std::allocator<char>::allocator<char><std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size, COMDAT
; _this$ = eax

; 877  : 		return (this->_Mysize);

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 878  : 		}

  00003	c3		 ret	 0
?size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size, COMDAT
; _this$ = eax

; 389  : 		return (_List.size());

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 390  : 		}

  00003	c3		 ret	 0
?size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = eax

; 38   : 		{	// construct with null node pointer

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00006	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor, COMDAT
; _this$ = eax

; 485  : 		return (_Max_bucket_size);

  00000	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]

; 486  : 		}

  00005	c3		 ret	 0
?max_load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_load_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count, COMDAT
; _this$ = eax

; 423  : 		return (_Maxidx);

  00000	8b 40 24	 mov	 eax, DWORD PTR [eax+36]

; 424  : 		}

  00003	c3		 ret	 0
?bucket_count@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::bucket_count
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size, COMDAT

; 874  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z PROC ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key, COMDAT
; _x$ = eax

; 324  :   static const Key& key(const mutable_value_type &x) { return x.first; }

  00000	c3		 ret	 0
?key@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAABIABU?$pair@IPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size, COMDAT

; 74   :     return static_cast<size_type>(-1) / sizeof(value_type);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 75   :   }

  00005	c3		 ret	 0
?max_size@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QBEIXZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax

; 208  : 		{	// construct with null node pointer

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00006	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size, COMDAT
; _this$ = eax

; 869  : 		return (this->_Mysize);

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 870  : 		}

  00003	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_max_count$ = 12					; size = 4
?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf, COMDAT
; _f$ = eax

; 686  :       leaf_fields *f, btree_node *parent, int max_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 687  :     btree_node *n = reinterpret_cast<btree_node*>(f);
; 688  :     f->leaf = 1;
; 689  :     f->position = 0;
; 690  :     f->max_count = max_count;

  00003	8a 55 0c	 mov	 dl, BYTE PTR _max_count$[ebp]
  00006	32 c9		 xor	 cl, cl

; 691  :     f->count = 0;

  00008	88 48 03	 mov	 BYTE PTR [eax+3], cl

; 692  :     f->parent = parent;

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0000e	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00013	88 50 02	 mov	 BYTE PTR [eax+2], dl
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 693  :     if (!NDEBUG) {
; 694  :       memset(&f->values, 0, max_count * sizeof(value_type));
; 695  :     }
; 696  :     return n;
; 697  :   }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?init_leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUleaf_fields@12@PAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_leaf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value, COMDAT
; _this$ = eax
; _i$ = ecx

; 563  :     return &fields_.values[i];

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 564  :   }

  00004	c3		 ret	 0
?mutable_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAU?$pair@IPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z
_TEXT	SEGMENT
?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key, COMDAT
; _this$ = eax
; _i$ = ecx

; 554  :     return params_type::key(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 555  :   }

  00004	c3		 ret	 0
?key@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABIH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ
_TEXT	SEGMENT
?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size, COMDAT
; _this$ = eax

; 550  :   size_type* mutable_size() { return &fields_.size; }

  00000	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00005	c3		 ret	 0
?mutable_size@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEPAIXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ
_TEXT	SEGMENT
?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator, COMDAT
; _this$ = eax

; 1235 :     return static_cast<internal_allocator_type*>(&root_);
; 1236 :   }

  00000	c3		 ret	 0
?mutable_internal_allocator@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$allocator@D@std@@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_internal_allocator
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ
_TEXT	SEGMENT
?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp, COMDAT
; _this$ = eax

; 1117 :     return *this;
; 1118 :   }

  00000	c3		 ret	 0
?key_comp@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::key_comp
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size, COMDAT

; 506  :   size_type max_size() const  { return val_info.max_size(); }

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00005	c3		 ret	 0
?max_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::destroy
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ
_TEXT	SEGMENT
?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key, COMDAT
; _this$ = eax

; 803  :     return node->key(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 804  :   }

  00009	c3		 ret	 0
?key@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEABIXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ
_TEXT	SEGMENT
?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent, COMDAT
; _this$ = eax

; 534  :   btree_node* parent() const { return fields_.parent; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
?parent@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::parent
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z PROC ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >, COMDAT
; _this$ = eax

; 198  :       : Compare(c) {
; 199  :   }

  00000	c3		 ret	 0
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@ABU01@@Z ENDP ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root, COMDAT
; _this$ = eax

; 1215 :   node_type** mutable_root() { return &root_.data; }

  00000	c3		 ret	 0
?mutable_root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z PROC ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = edx
; __Last$ = ecx

; 2459 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2460 : 	return (_Copy_backward(_First, _Last,
; 2461 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	3b d1		 cmp	 edx, ecx
  00008	74 16		 je	 SHORT $LN5@Copy_backw@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Copy_backw@2:
  00010	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
  00013	83 e9 04	 sub	 ecx, 4
  00016	83 e8 04	 sub	 eax, 4
  00019	89 30		 mov	 DWORD PTR [eax], esi
  0001b	3b ca		 cmp	 ecx, edx
  0001d	75 f1		 jne	 SHORT $LL6@Copy_backw@2
  0001f	5e		 pop	 esi
$LN5@Copy_backw@2:

; 2462 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_backward@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ENDP ; std::_Copy_backward<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z PROC ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 2713 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2714 : 	_DEBUG_RANGE(_First, _Last);
; 2715 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

  00006	3b c1		 cmp	 eax, ecx
  00008	74 12		 je	 SHORT $LN7@fill
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@fill:
  00010	8b 32		 mov	 esi, DWORD PTR [edx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c0 04	 add	 eax, 4
  00017	3b c1		 cmp	 eax, ecx
  00019	75 f5		 jne	 SHORT $LL9@fill
  0001b	5e		 pop	 esi
$LN7@fill:

; 2716 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$fill@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0ABV10@@Z ENDP ; std::fill<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@$$CBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPBV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YA$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z
_TEXT	SEGMENT
??$move@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YA$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z PROC ; std::move<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YA$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAV123@@Z ENDP ; std::move<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z PROC ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	3b ca		 cmp	 ecx, edx
  00008	74 15		 je	 SHORT $LN5@Move@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL7@Move@2:
  00010	8b 31		 mov	 esi, DWORD PTR [ecx]
  00012	89 30		 mov	 DWORD PTR [eax], esi
  00014	83 c1 04	 add	 ecx, 4
  00017	83 c0 04	 add	 eax, 4
  0001a	3b ca		 cmp	 ecx, edx
  0001c	75 f2		 jne	 SHORT $LL7@Move@2
  0001e	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00@Z ENDP ; std::_Move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z
_TEXT	SEGMENT
??$_Destroy@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z PROC ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ENDP ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z
_TEXT	SEGMENT
??$_Destroy@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z PROC ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ENDP ; std::_Destroy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node><std::pair<unsigned int,stx_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node><std::pair<unsigned int,stx_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node><std::pair<unsigned int,stx_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@IPAUstx_object@@@std@@@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@1@@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node><std::pair<unsigned int,stx_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@0AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z PROC ; std::copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2469 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2470 : 	return (_Rechecked(_Dest,
; 2471 : 		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2472 : 			_Unchecked(_Dest))));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2473 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$copy_backward@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ENDP ; std::copy_backward<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??$data_copy_backward@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
??$data_copy_backward@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy_backward<stx_object * *,stx_object * *>, COMDAT
; _first$ = ecx
; _last$ = eax

; 1516 :     static OutputIterator data_copy_backward (InputIterator first, InputIterator last,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1517 :                                               OutputIterator result)
; 1518 :     {
; 1519 :         if (used_as_set) return result; // no operation
; 1520 :         else return std::copy_backward(first, last, result);

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _result$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 1521 :     }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$data_copy_backward@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy_backward<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$copy_backward@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::copy_backward<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2469 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2470 : 	return (_Rechecked(_Dest,
; 2471 : 		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
; 2472 : 			_Unchecked(_Dest))));

  00003	2b c1		 sub	 eax, ecx
  00005	c1 f8 02	 sar	 eax, 2
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000c	03 c0		 add	 eax, eax
  0000e	03 c0		 add	 eax, eax
  00010	50		 push	 eax
  00011	2b f0		 sub	 esi, eax
  00013	51		 push	 ecx
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 2473 : 	}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$copy_backward@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::copy_backward<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z
_TEXT	SEGMENT
??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z PROC ; std::swap<std::pair<unsigned int const ,google_object *> *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@PAU?$pair@$$CBIPAUgoogle_object@@@std@@@std@@YAXAAPAU?$pair@$$CBIPAUgoogle_object@@@0@0@Z ENDP ; std::swap<std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@I@std@@YAXAAI0@Z
_TEXT	SEGMENT
??$swap@I@std@@YAXAAI0@Z PROC				; std::swap<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi

; 104  : 	_Right = _Move(_Tmp);

  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@I@std@@YAXAAI0@Z ENDP				; std::swap<unsigned int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z
_TEXT	SEGMENT
??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z PROC ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	57		 push	 edi

; 103  : 	_Left = _Move(_Right);

  00007	8b 38		 mov	 edi, DWORD PTR [eax]
  00009	89 39		 mov	 DWORD PTR [ecx], edi
  0000b	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000e	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 104  : 	_Right = _Move(_Tmp);
; 105  : 	}

  00011	5f		 pop	 edi
  00012	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00015	89 10		 mov	 DWORD PTR [eax], edx
  00017	5e		 pop	 esi
  00018	c3		 ret	 0
??$swap@VKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAVKeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ENDP ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z
_TEXT	SEGMENT
??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z PROC ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);
; 103  : 	_Left = _Move(_Right);

  00000	f3 0f 7e 18	 movq	 xmm3, QWORD PTR [eax]
  00004	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00008	f3 0f 7e 49 08	 movq	 xmm1, QWORD PTR [ecx+8]
  0000d	f3 0f 7e 51 10	 movq	 xmm2, QWORD PTR [ecx+16]
  00012	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
  00016	f3 0f 7e 58 08	 movq	 xmm3, QWORD PTR [eax+8]
  0001b	66 0f d6 59 08	 movq	 QWORD PTR [ecx+8], xmm3
  00020	f3 0f 7e 58 10	 movq	 xmm3, QWORD PTR [eax+16]
  00025	66 0f d6 59 10	 movq	 QWORD PTR [ecx+16], xmm3

; 104  : 	_Right = _Move(_Tmp);

  0002a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0002e	66 0f d6 48 08	 movq	 QWORD PTR [eax+8], xmm1
  00033	66 0f d6 50 10	 movq	 QWORD PTR [eax+16], xmm2

; 105  : 	}

  00038	c3		 ret	 0
??$swap@USettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@@std@@YAXAAUSettings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@0@Z ENDP ; std::swap<google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z
_TEXT	SEGMENT
??$copy@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z PROC ; std::copy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2174 : 	return (_Rechecked(_Dest,
; 2175 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2176 : 			_Unchecked(_Dest))));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2177 : 	}

  0001c	c3		 ret	 0
??$copy@PAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@@std@@YAPAPAUnode@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@PAPAU123@00@Z ENDP ; std::copy<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *,stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node * *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??$data_copy@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z
_TEXT	SEGMENT
??$data_copy@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy<stx_object * *,stx_object * *>, COMDAT
; _first$ = ecx
; _last$ = eax
; _result$ = edi

; 1507 :                                      OutputIterator result)
; 1508 :     {
; 1509 :         if (used_as_set) return result; // no operation
; 1510 :         else return std::copy(first, last, result);

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 1511 :     }

  0001c	c3		 ret	 0
??$data_copy@PAPAUstx_object@@PAPAU1@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAPAPAUstx_object@@PAPAU2@00@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::data_copy<stx_object * *,stx_object * *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
??$copy@PAIPAI@std@@YAPAIPAI00@Z PROC			; std::copy<unsigned int *,unsigned int *>, COMDAT
; __First$ = ecx
; __Last$ = eax
; __Dest$ = edi

; 2174 : 	return (_Rechecked(_Dest,
; 2175 : 		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
; 2176 : 			_Unchecked(_Dest))));

  00000	2b c1		 sub	 eax, ecx
  00002	56		 push	 esi
  00003	c1 f8 02	 sar	 eax, 2
  00006	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	57		 push	 edi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5e		 pop	 esi

; 2177 : 	}

  0001c	c3		 ret	 0
??$copy@PAIPAI@std@@YAPAIPAI00@Z ENDP			; std::copy<unsigned int *,unsigned int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z PROC ; std::move<cpp_object * &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAPAUcpp_object@@@std@@YA$$QAPAUcpp_object@@AAPAU1@@Z ENDP ; std::move<cpp_object * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$move@AAPAUstx_object@@@std@@YA$$QAPAUstx_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUstx_object@@@std@@YA$$QAPAUstx_object@@AAPAU1@@Z PROC ; std::move<stx_object * &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAPAUstx_object@@@std@@YA$$QAPAUstx_object@@AAPAU1@@Z ENDP ; std::move<stx_object * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z PROC ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@std@@YAXAAV?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>,std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00000	c3		 ret	 0
??$?0U?$pair@$$CBIPAUcpp_object@@@std@@@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > ><std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>, COMDAT
; __Val$ = eax

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);
; 69   : 		}

  00000	c3		 ret	 0
??$_Kfn@$$CBIPAUcpp_object@@@?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z
_TEXT	SEGMENT
??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z PROC ; std::move<google_object * &>, COMDAT
; __Arg$ = eax

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);
; 88   : 	}

  00000	c3		 ret	 0
??$move@AAPAUgoogle_object@@@std@@YA$$QAPAUgoogle_object@@AAPAU1@@Z ENDP ; std::move<google_object * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z
_TEXT	SEGMENT
??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z PROC ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>, COMDAT
; __Val$ = eax

; 69   : 		{	// extract key from element value
; 70   : 		return (_Val.first);
; 71   : 		}

  00000	c3		 ret	 0
??$_Kfn@$$CBIPAUcpp_object@@@?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@SAABIABU?$pair@$$CBIPAUcpp_object@@@2@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Kfn<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z PROC ; std::addressof<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = eax

; 111  : 	return ((_Ty *) &(char&)_Val);
; 112  : 	}

  00000	c3		 ret	 0
??$addressof@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@YAPAU?$pair@$$CBIPAUcpp_object@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 102  : 	_Ty _Tmp = _Move(_Left);

  00000	8a 11		 mov	 dl, BYTE PTR [ecx]
  00002	53		 push	 ebx

; 103  : 	_Left = _Move(_Right);

  00003	8a 18		 mov	 bl, BYTE PTR [eax]
  00005	88 19		 mov	 BYTE PTR [ecx], bl

; 104  : 	_Right = _Move(_Tmp);

  00007	88 10		 mov	 BYTE PTR [eax], dl
  00009	5b		 pop	 ebx

; 105  : 	}

  0000a	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0IPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
??$?0IPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@AAU01@@Z PROC ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 196  : 		}

  0000a	c3		 ret	 0
??$?0IPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@AAU01@@Z ENDP ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int,stx_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat, COMDAT

; 253  : 		}

  00000	c3		 ret	 0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Compat
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size, COMDAT

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::max_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z
_TEXT	SEGMENT
?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate, COMDAT
; _p$ = edx
; _n$ = eax

; 70   :     return static_cast<pointer>(realloc(p, n * sizeof(value_type)));

  00000	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00007	51		 push	 ecx
  00008	52		 push	 edx
  00009	e8 00 00 00 00	 call	 _realloc
  0000e	83 c4 08	 add	 esp, 8

; 71   :   }

  00011	c3		 ret	 0
?reallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@I@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::reallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 204  : 		}

  00009	c3		 ret	 0
??8?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range, COMDAT

; 1454 : 		}

  00000	c3		 ret	 0
?_Orphan_range@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Orphan_range
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen, COMDAT

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Xlen
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::max_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 880  : 		}

  00008	c3		 ret	 0
?size@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 778  : 		}

  00008	c3		 ret	 0
?capacity@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::capacity
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z
_TEXT	SEGMENT
?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die, COMDAT
; _ptr$ = edi
; _n$ = esi

; 1142 :       pointer retval = this->reallocate(ptr, n);

  00000	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  00007	50		 push	 eax
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 _realloc
  0000e	83 c4 08	 add	 esp, 8

; 1143 :       if (retval == NULL) {

  00011	85 c0		 test	 eax, eax
  00013	75 1f		 jne	 SHORT $LN2@realloc_or

; 1144 :         // We really should use PRIuS here, but I don't want to have to add
; 1145 :         // a whole new configure option, with concomitant macro namespace
; 1146 :         // pollution, just to print this (unlikely) error message.  So I cast.
; 1147 :         fprintf(stderr, "sparsehash: FATAL ERROR: failed to reallocate "
; 1148 :                 "%lu elements for ptr %p",
; 1149 :                 static_cast<unsigned long>(n), ptr);

  00015	57		 push	 edi
  00016	56		 push	 esi
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  0001c	e8 00 00 00 00	 call	 ___iob_func
  00021	83 c0 40	 add	 eax, 64			; 00000040H
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _fprintf
  0002a	83 c4 10	 add	 esp, 16			; 00000010H

; 1150 :         exit(1);

  0002d	6a 01		 push	 1
  0002f	e8 00 00 00 00	 call	 _exit
$LN7@realloc_or:
$LN2@realloc_or:

; 1151 :       }
; 1152 :       return retval;
; 1153 :     }

  00034	c3		 ret	 0
$LN6@realloc_or:
?realloc_or_die@?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU45@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::realloc_or_die
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 208  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 209  : 		}

  00009	c3		 ret	 0
??9?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::operator!=
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?initialize@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z
_TEXT	SEGMENT
?initialize@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::initialize, COMDAT
; _this$ = eax
; _l$ = ecx

; 267  :             level = l;
; 268  :             slotuse = 0;

  00000	33 d2		 xor	 edx, edx
  00002	66 89 08	 mov	 WORD PTR [eax], cx
  00005	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 269  :         }

  00009	c3		 ret	 0
?initialize@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::initialize
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 1
?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table, COMDAT
; _new_size$ = edi

; 604  :                     true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	56		 push	 esi

; 605  :     table = val_info.realloc_or_die(table, new_size);

  00008	8b 73 34	 mov	 esi, DWORD PTR [ebx+52]
  0000b	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00012	50		 push	 eax
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 _realloc
  00019	83 c4 08	 add	 esp, 8
  0001c	85 c0		 test	 eax, eax
  0001e	75 1f		 jne	 SHORT $LN3@resize_tab
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  00027	e8 00 00 00 00	 call	 ___iob_func
  0002c	83 c0 40	 add	 eax, 64			; 00000040H
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _fprintf
  00035	83 c4 10	 add	 esp, 16			; 00000010H
  00038	6a 01		 push	 1
  0003a	e8 00 00 00 00	 call	 _exit
$LN10@resize_tab:
$LN3@resize_tab:
  0003f	5e		 pop	 esi
  00040	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  00043	5b		 pop	 ebx

; 606  :   }

  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
$LN9@resize_tab:
?resize_table@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXIIU?$integral_constant@_N$00@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_table
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?isfull@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isfull@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfull, COMDAT
; _this$ = ecx

; 300  :             return (node::slotuse == innerslotmax);

  00000	33 c0		 xor	 eax, eax
  00002	66 83 79 02 20	 cmp	 WORD PTR [ecx+2], 32	; 00000020H
  00007	0f 94 c0	 sete	 al

; 301  :         }

  0000a	c3		 ret	 0
?isfull@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfull
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?initialize@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z
_TEXT	SEGMENT
?initialize@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::initialize, COMDAT
; _this$ = eax
; _l$ = ecx

; 294  :             node::initialize(l);

  00000	33 d2		 xor	 edx, edx
  00002	66 89 08	 mov	 WORD PTR [eax], cx
  00005	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 295  :         }

  00009	c3		 ret	 0
?initialize@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXG@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::initialize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isfull@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isfull@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfull, COMDAT
; _this$ = ecx

; 346  :             return (node::slotuse == leafslotmax);

  00000	33 c0		 xor	 eax, eax
  00002	66 83 79 02 20	 cmp	 WORD PTR [ecx+2], 32	; 00000020H
  00007	0f 94 c0	 sete	 al

; 347  :         }

  0000a	c3		 ret	 0
?isfull@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfull
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?initialize@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ
_TEXT	SEGMENT
?initialize@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::initialize, COMDAT
; _this$ = eax

; 339  :             node::initialize(0);

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx

; 340  :             prevleaf = nextleaf = NULL;

  00004	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 341  :         }

  0000a	c3		 ret	 0
?initialize@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::initialize
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator(), COMDAT
; _value$ = eax
; _new_key$ = ecx

; 129  :       *const_cast<Key*>(&value->first) = new_key;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 130  :       // It would be nice to clear the rest of value here as well, in
; 131  :       // case it's taking up a lot of memory.  We do this by clearing
; 132  :       // the value.  This assumes T has a zero-arg constructor!
; 133  :       value->second = T();

  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 134  :     }

  0000b	c3		 ret	 0
??RSetKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator(), COMDAT
; _p$ = eax

; 124  :       return p.first;
; 125  :     }

  00000	c3		 ret	 0
??RSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEABIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ
_TEXT	SEGMENT
?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies, COMDAT
; _this$ = eax

; 126  :     ++num_ht_copies_;

  00000	ff 40 14	 inc	 DWORD PTR [eax+20]

; 127  :   }

  00003	c3		 ret	 0
?inc_num_ht_copies@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::inc_num_ht_copies
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::destroy, COMDAT

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c3		 ret	 0
?destroy@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEXPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z PROC ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>, COMDAT
; _this$ = eax

; 41   : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@QAE@U?$less@I@1@@Z ENDP ; std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?inner_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ
_TEXT	SEGMENT
?inner_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 1462 :         return typename inner_node::alloc_type(m_allocator);
; 1463 :     }

  00000	c3		 ret	 0
?inner_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node_allocator
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?leaf_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ
_TEXT	SEGMENT
?leaf_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 1456 :         return typename leaf_node::alloc_type(m_allocator);
; 1457 :     }

  00000	c3		 ret	 0
?leaf_node_allocator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AV?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node_allocator
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key, COMDAT
; _v$ = eax
; _k$ = ecx

; 1196 :       SetKey::operator()(v, k);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1197 :     }

  0000b	c3		 ret	 0
?set_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::set_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key, COMDAT
; _v$ = eax

; 1193 :       return ExtractKey::operator()(v);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1194 :     }

  00002	c3		 ret	 0
?get_key@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::get_key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ
_TEXT	SEGMENT
?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty, COMDAT
; _this$ = eax

; 109  :     return use_empty_;

  00000	8a 40 11	 mov	 al, BYTE PTR [eax+17]

; 110  :   }

  00003	c3		 ret	 0
?use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::use_empty
_TEXT	ENDS
PUBLIC	__real@3e4ccccd
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z
_TEXT	SEGMENT
?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor, COMDAT
; _this$ = eax

; 78   :     shrink_factor_ = f;

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00008	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 79   :   }

  0000d	c3		 ret	 0
?set_shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_factor
_TEXT	ENDS
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z
_TEXT	SEGMENT
?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor, COMDAT
; _this$ = eax

; 72   :     enlarge_factor_ = f;

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 73   :   }

  0000d	c3		 ret	 0
?set_enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_factor
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@ABI@Z
_TEXT	SEGMENT
??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@ABI@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t, COMDAT
; _this$ = eax
; _k$ = ecx

; 2570 :         { }

  00000	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000b	c3		 ret	 0
??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@ABI@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@@Z
_TEXT	SEGMENT
??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t, COMDAT
; _this$ = eax
; _f$ = ecx

; 2565 :         { }

  00000	89 08		 mov	 DWORD PTR [eax], ecx
  00002	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00009	c3		 ret	 0
??0result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@W4result_flags_t@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::result_t
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=, COMDAT
; _this$ = eax
; _x$ = ecx

; 900  :       leaf_nodes += x.leaf_nodes;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	01 10		 add	 DWORD PTR [eax], edx

; 901  :       internal_nodes += x.internal_nodes;

  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	01 48 04	 add	 DWORD PTR [eax+4], ecx

; 902  :       return *this;
; 903  :     }

  0000a	c3		 ret	 0
??Ynode_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEAAU012@ABU012@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::operator+=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats, COMDAT
; _this$ = eax
; _l$ = ecx

; 896  :           internal_nodes(i) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 897  :     }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??0node_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@II@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::node_stats::node_stats
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = eax

; 427  : 		_Myfirst = 0;

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000a	c2 04 00	 ret	 4
??0?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c3		 ret	 0
?_Destroy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z
_TEXT	SEGMENT
??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[], COMDAT
; _this$ = eax
; __Pos$ = edx

; 929  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 930  : 		if (size() <= _Pos)
; 931  : 			{	// report error
; 932  : 			_DEBUG_ERROR("vector subscript out of range");
; 933  : 			_SCL_SECURE_OUT_OF_RANGE;
; 934  : 			}
; 935  : 
; 936  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 937  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 938  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 939  : 
; 940  : 		return (*(this->_Myfirst + _Pos));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 941  : 		}

  00005	c3		 ret	 0
??A?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@I@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::operator[]
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?isunderflow@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isunderflow@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isunderflow, COMDAT
; _this$ = eax

; 312  :             return (node::slotuse < mininnerslots);

  00000	66 83 78 02 10	 cmp	 WORD PTR [eax+2], 16	; 00000010H
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax

; 313  :         }

  00009	c3		 ret	 0
?isunderflow@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isunderflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isfew@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isfew@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfew, COMDAT
; _this$ = ecx

; 306  :             return (node::slotuse <= mininnerslots);

  00000	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00005	66 3b 41 02	 cmp	 ax, WORD PTR [ecx+2]
  00009	1b c0		 sbb	 eax, eax
  0000b	40		 inc	 eax

; 307  :         }

  0000c	c3		 ret	 0
?isfew@inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node::isfew
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isunderflow@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isunderflow@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isunderflow, COMDAT
; _this$ = eax

; 358  :             return (node::slotuse < minleafslots);

  00000	66 83 78 02 10	 cmp	 WORD PTR [eax+2], 16	; 00000010H
  00005	1b c0		 sbb	 eax, eax
  00007	f7 d8		 neg	 eax

; 359  :         }

  00009	c3		 ret	 0
?isunderflow@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isunderflow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?isfew@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isfew@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfew, COMDAT
; _this$ = ecx

; 352  :             return (node::slotuse <= minleafslots);

  00000	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00005	66 3b 41 02	 cmp	 ax, WORD PTR [ecx+2]
  00009	1b c0		 sbb	 eax, eax
  0000b	40		 inc	 eax

; 353  :         }

  0000c	c3		 ret	 0
?isfew@leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node::isfew
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?verify_leaflinks@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXXZ
_TEXT	SEGMENT
?verify_leaflinks@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_leaflinks, COMDAT
; _this$ = eax

; 3737 :         const leaf_node *n = m_headleaf;

  00000	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 3738 : 
; 3739 :         assert(n->level == 0);
; 3740 :         assert(!n || n->prevleaf == NULL);
; 3741 : 
; 3742 :         unsigned int testcount = 0;
; 3743 : 
; 3744 :         while(n)

  00003	85 d2		 test	 edx, edx
  00005	74 1c		 je	 SHORT $LN6@verify_lea
  00007	56		 push	 esi
$LL7@verify_lea:

; 3745 :         {
; 3746 :             assert(n->level == 0);
; 3747 :             assert(n->slotuse > 0);
; 3748 : 
; 3749 :             for(unsigned short slot = 0; slot < n->slotuse - 1; ++slot)

  00008	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0000c	48		 dec	 eax
  0000d	33 c9		 xor	 ecx, ecx
  0000f	85 c0		 test	 eax, eax
  00011	7e 08		 jle	 SHORT $LN3@verify_lea
$LL5@verify_lea:
  00013	41		 inc	 ecx
  00014	0f b7 f1	 movzx	 esi, cx
  00017	3b f0		 cmp	 esi, eax
  00019	7c f8		 jl	 SHORT $LL5@verify_lea
$LN3@verify_lea:

; 3750 :             {
; 3751 :                 assert(key_lessequal(n->slotkey[slot], n->slotkey[slot + 1]));
; 3752 :             }
; 3753 : 
; 3754 :             testcount += n->slotuse;
; 3755 : 
; 3756 :             if (n->nextleaf)
; 3757 :             {
; 3758 :                 assert(key_lessequal(n->slotkey[n->slotuse-1], n->nextleaf->slotkey[0]));
; 3759 : 
; 3760 :                 assert(n == n->nextleaf->prevleaf);
; 3761 :             }
; 3762 :             else
; 3763 :             {
; 3764 :                 assert(m_tailleaf == n);
; 3765 :             }
; 3766 : 
; 3767 :             n = n->nextleaf;

  0001b	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0001e	85 d2		 test	 edx, edx
  00020	75 e6		 jne	 SHORT $LL7@verify_lea
  00022	5e		 pop	 esi
$LN6@verify_lea:

; 3768 :         }
; 3769 : 
; 3770 :         assert(testcount == size());
; 3771 :     }

  00023	c3		 ret	 0
?verify_leaflinks@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_leaflinks
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z
_TEXT	SEGMENT
tv470 = -4						; size = 4
tv458 = 8						; size = 4
_left$ = 8						; size = 4
_parent$ = 12						; size = 4
_parentslot$ = 16					; size = 4
?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner, COMDAT
; _right$ = edi

; 3498 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3499 :         BTREE_ASSERT(left->level == right->level);
; 3500 :         BTREE_ASSERT(parent->level == left->level + 1);
; 3501 : 
; 3502 :         BTREE_ASSERT(left->slotuse > right->slotuse);
; 3503 :         BTREE_ASSERT(parent->childid[parentslot] == left);
; 3504 : 
; 3505 :         unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

  00004	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00008	53		 push	 ebx
  00009	8b 5d 08	 mov	 ebx, DWORD PTR _left$[ebp]

; 3506 : 
; 3507 :         BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");
; 3508 : 
; 3509 :         if (selfverify)
; 3510 :         {
; 3511 :             // find the left node's slot in the parent's children
; 3512 :             unsigned int leftslot = 0;
; 3513 :             while(leftslot <= parent->slotuse && parent->childid[leftslot] != left)
; 3514 :                 ++leftslot;
; 3515 : 
; 3516 :             BTREE_ASSERT(leftslot < parent->slotuse);
; 3517 :             BTREE_ASSERT(parent->childid[leftslot] == left);
; 3518 :             BTREE_ASSERT(parent->childid[leftslot+1] == right);
; 3519 : 
; 3520 :             BTREE_ASSERT(leftslot == parentslot);
; 3521 :         }
; 3522 : 
; 3523 :         // shift all slots in the right node
; 3524 : 
; 3525 :         BTREE_ASSERT(right->slotuse + shiftnum < innerslotmax);
; 3526 : 
; 3527 :         std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
; 3528 :                            right->slotkey + right->slotuse + shiftnum);

  0000c	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00013	56		 push	 esi
  00014	0f b7 73 02	 movzx	 esi, WORD PTR [ebx+2]
  00018	8d 57 04	 lea	 edx, DWORD PTR [edi+4]
  0001b	2b ca		 sub	 ecx, edx
  0001d	2b f0		 sub	 esi, eax
  0001f	03 cf		 add	 ecx, edi
  00021	c1 f9 02	 sar	 ecx, 2
  00024	89 55 08	 mov	 DWORD PTR tv458[ebp], edx
  00027	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0002e	52		 push	 edx
  0002f	8b 55 08	 mov	 edx, DWORD PTR tv458[ebp]
  00032	2b c1		 sub	 eax, ecx
  00034	d1 fe		 sar	 esi, 1
  00036	03 c6		 add	 eax, esi
  00038	52		 push	 edx
  00039	8d 44 87 04	 lea	 eax, DWORD PTR [edi+eax*4+4]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _memmove

; 3529 :         std::copy_backward(right->childid, right->childid + right->slotuse+1,
; 3530 :                            right->childid + right->slotuse+1 + shiftnum);

  00043	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00047	8d 04 8d 88 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+136]
  0004e	8d 97 84 00 00
	00		 lea	 edx, DWORD PTR [edi+132]
  00054	2b c2		 sub	 eax, edx
  00056	03 c7		 add	 eax, edi
  00058	c1 f8 02	 sar	 eax, 2
  0005b	89 55 fc	 mov	 DWORD PTR tv470[ebp], edx
  0005e	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00065	52		 push	 edx
  00066	8b 55 fc	 mov	 edx, DWORD PTR tv470[ebp]
  00069	2b c8		 sub	 ecx, eax
  0006b	03 ce		 add	 ecx, esi
  0006d	52		 push	 edx
  0006e	8d 84 8f 88 00
	00 00		 lea	 eax, DWORD PTR [edi+ecx*4+136]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _memmove

; 3531 : 
; 3532 :         right->slotuse += shiftnum;

  0007b	66 01 77 02	 add	 WORD PTR [edi+2], si

; 3533 : 
; 3534 :         // copy the parent's decision slotkey and childid to the last new key on the right
; 3535 :         right->slotkey[shiftnum - 1] = parent->slotkey[parentslot];

  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _parent$[ebp]
  00082	8b 55 10	 mov	 edx, DWORD PTR _parentslot$[ebp]
  00085	8b 44 91 04	 mov	 eax, DWORD PTR [ecx+edx*4+4]
  00089	89 04 b7	 mov	 DWORD PTR [edi+esi*4], eax

; 3536 : 
; 3537 :         // copy the remaining last items from the left node to the first slot in the right node.
; 3538 :         std::copy(left->slotkey + left->slotuse - shiftnum+1, left->slotkey + left->slotuse,
; 3539 :                   right->slotkey);

  0008c	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  00090	8b c8		 mov	 ecx, eax
  00092	2b ce		 sub	 ecx, esi
  00094	8d 4c 8b 08	 lea	 ecx, DWORD PTR [ebx+ecx*4+8]
  00098	8d 14 85 04 00
	00 00		 lea	 edx, DWORD PTR [eax*4+4]
  0009f	8b 45 08	 mov	 eax, DWORD PTR tv458[ebp]
  000a2	2b d1		 sub	 edx, ecx
  000a4	03 d3		 add	 edx, ebx
  000a6	c1 fa 02	 sar	 edx, 2
  000a9	03 d2		 add	 edx, edx
  000ab	03 d2		 add	 edx, edx
  000ad	52		 push	 edx
  000ae	51		 push	 ecx
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _memmove

; 3540 :         std::copy(left->childid + left->slotuse - shiftnum+1, left->childid + left->slotuse+1,
; 3541 :                   right->childid);

  000b5	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  000b9	8b c8		 mov	 ecx, eax
  000bb	2b ce		 sub	 ecx, esi
  000bd	8d 8c 8b 88 00
	00 00		 lea	 ecx, DWORD PTR [ebx+ecx*4+136]
  000c4	8d 14 85 88 00
	00 00		 lea	 edx, DWORD PTR [eax*4+136]
  000cb	8b 45 fc	 mov	 eax, DWORD PTR tv470[ebp]
  000ce	2b d1		 sub	 edx, ecx
  000d0	03 d3		 add	 edx, ebx
  000d2	c1 fa 02	 sar	 edx, 2
  000d5	03 d2		 add	 edx, edx
  000d7	03 d2		 add	 edx, edx
  000d9	52		 push	 edx
  000da	51		 push	 ecx
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 _memmove

; 3542 : 
; 3543 :         // copy the first to-be-removed key from the left node to the parent's decision slot
; 3544 :         parent->slotkey[parentslot] = left->slotkey[left->slotuse - shiftnum];

  000e1	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  000e5	8b 45 0c	 mov	 eax, DWORD PTR _parent$[ebp]
  000e8	2b ce		 sub	 ecx, esi
  000ea	8b 54 8b 04	 mov	 edx, DWORD PTR [ebx+ecx*4+4]
  000ee	8b 4d 10	 mov	 ecx, DWORD PTR _parentslot$[ebp]
  000f1	83 c4 30	 add	 esp, 48			; 00000030H
  000f4	89 54 88 04	 mov	 DWORD PTR [eax+ecx*4+4], edx

; 3545 : 
; 3546 :         left->slotuse -= shiftnum;

  000f8	66 29 73 02	 sub	 WORD PTR [ebx+2], si
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx

; 3547 :     }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z
_TEXT	SEGMENT
tv470 = -8						; size = 4
tv458 = -4						; size = 4
_parent$ = 8						; size = 4
_parentslot$ = 12					; size = 4
?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf, COMDAT
; _left$ = esi
; _right$ = edi

; 3444 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3445 :         BTREE_ASSERT(left->isleafnode() && right->isleafnode());
; 3446 :         BTREE_ASSERT(parent->level == 1);
; 3447 : 
; 3448 :         BTREE_ASSERT(left->nextleaf == right);
; 3449 :         BTREE_ASSERT(left == right->prevleaf);
; 3450 :         BTREE_ASSERT(parent->childid[parentslot] == left);
; 3451 : 
; 3452 :         BTREE_ASSERT(left->slotuse > right->slotuse);
; 3453 : 
; 3454 :         unsigned int shiftnum = (left->slotuse - right->slotuse) >> 1;

  00006	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]

; 3455 : 
; 3456 :         BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to right " << right << " from left " << left << " with common parent " << parent << ".");
; 3457 : 
; 3458 :         if (selfverify)
; 3459 :         {
; 3460 :             // find the left node's slot in the parent's children
; 3461 :             unsigned int leftslot = 0;
; 3462 :             while(leftslot <= parent->slotuse && parent->childid[leftslot] != left)
; 3463 :                 ++leftslot;
; 3464 : 
; 3465 :             BTREE_ASSERT(leftslot < parent->slotuse);
; 3466 :             BTREE_ASSERT(parent->childid[leftslot] == left);
; 3467 :             BTREE_ASSERT(parent->childid[leftslot+1] == right);
; 3468 : 
; 3469 :             BTREE_ASSERT(leftslot == parentslot);
; 3470 :         }
; 3471 : 
; 3472 :         // shift all slots in the right node
; 3473 : 
; 3474 :         BTREE_ASSERT(right->slotuse + shiftnum < leafslotmax);
; 3475 : 
; 3476 :         std::copy_backward(right->slotkey, right->slotkey + right->slotuse,
; 3477 :                            right->slotkey + right->slotuse + shiftnum);

  0000a	8d 0c 85 0c 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+12]
  00011	53		 push	 ebx
  00012	0f b7 5e 02	 movzx	 ebx, WORD PTR [esi+2]
  00016	8d 57 0c	 lea	 edx, DWORD PTR [edi+12]
  00019	2b ca		 sub	 ecx, edx
  0001b	2b d8		 sub	 ebx, eax
  0001d	03 cf		 add	 ecx, edi
  0001f	c1 f9 02	 sar	 ecx, 2
  00022	89 55 fc	 mov	 DWORD PTR tv458[ebp], edx
  00025	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0002c	52		 push	 edx
  0002d	8b 55 fc	 mov	 edx, DWORD PTR tv458[ebp]
  00030	2b c1		 sub	 eax, ecx
  00032	d1 fb		 sar	 ebx, 1
  00034	03 c3		 add	 eax, ebx
  00036	52		 push	 edx
  00037	8d 44 87 0c	 lea	 eax, DWORD PTR [edi+eax*4+12]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _memmove

; 3478 :         data_copy_backward(right->slotdata, right->slotdata + right->slotuse,
; 3479 :                            right->slotdata + right->slotuse + shiftnum);

  00041	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00045	8d 04 8d 8c 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+140]
  0004c	8d 97 8c 00 00
	00		 lea	 edx, DWORD PTR [edi+140]
  00052	2b c2		 sub	 eax, edx
  00054	03 c7		 add	 eax, edi
  00056	c1 f8 02	 sar	 eax, 2
  00059	89 55 f8	 mov	 DWORD PTR tv470[ebp], edx
  0005c	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00063	52		 push	 edx
  00064	8b 55 f8	 mov	 edx, DWORD PTR tv470[ebp]
  00067	2b c8		 sub	 ecx, eax
  00069	03 cb		 add	 ecx, ebx
  0006b	52		 push	 edx
  0006c	8d 84 8f 8c 00
	00 00		 lea	 eax, DWORD PTR [edi+ecx*4+140]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _memmove

; 3480 : 
; 3481 :         right->slotuse += shiftnum;

  00079	66 01 5f 02	 add	 WORD PTR [edi+2], bx

; 3482 : 
; 3483 :         // copy the last items from the left node to the first slot in the right node.
; 3484 :         std::copy(left->slotkey + left->slotuse - shiftnum, left->slotkey + left->slotuse,
; 3485 :                   right->slotkey);

  0007d	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00081	8b c8		 mov	 ecx, eax
  00083	2b cb		 sub	 ecx, ebx
  00085	8d 4c 8e 0c	 lea	 ecx, DWORD PTR [esi+ecx*4+12]
  00089	8d 14 85 0c 00
	00 00		 lea	 edx, DWORD PTR [eax*4+12]
  00090	8b 45 fc	 mov	 eax, DWORD PTR tv458[ebp]
  00093	2b d1		 sub	 edx, ecx
  00095	03 d6		 add	 edx, esi
  00097	c1 fa 02	 sar	 edx, 2
  0009a	03 d2		 add	 edx, edx
  0009c	03 d2		 add	 edx, edx
  0009e	52		 push	 edx
  0009f	51		 push	 ecx
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 _memmove

; 3486 :         data_copy(left->slotdata + left->slotuse - shiftnum, left->slotdata + left->slotuse,
; 3487 :                   right->slotdata);

  000a6	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  000aa	8b c8		 mov	 ecx, eax
  000ac	2b cb		 sub	 ecx, ebx
  000ae	8d 8c 8e 8c 00
	00 00		 lea	 ecx, DWORD PTR [esi+ecx*4+140]
  000b5	8d 14 85 8c 00
	00 00		 lea	 edx, DWORD PTR [eax*4+140]
  000bc	8b 45 f8	 mov	 eax, DWORD PTR tv470[ebp]
  000bf	2b d1		 sub	 edx, ecx
  000c1	03 d6		 add	 edx, esi
  000c3	c1 fa 02	 sar	 edx, 2
  000c6	03 d2		 add	 edx, edx
  000c8	03 d2		 add	 edx, edx
  000ca	52		 push	 edx
  000cb	51		 push	 ecx
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memmove

; 3488 : 
; 3489 :         left->slotuse -= shiftnum;
; 3490 : 
; 3491 :         parent->slotkey[parentslot] = left->slotkey[left->slotuse-1];

  000d2	8b 45 0c	 mov	 eax, DWORD PTR _parentslot$[ebp]
  000d5	83 c4 30	 add	 esp, 48			; 00000030H
  000d8	66 29 5e 02	 sub	 WORD PTR [esi+2], bx
  000dc	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  000e0	8b 54 8e 08	 mov	 edx, DWORD PTR [esi+ecx*4+8]
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  000e7	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx
  000eb	5b		 pop	 ebx

; 3492 :     }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z
_TEXT	SEGMENT
tv444 = -8						; size = 4
tv437 = -4						; size = 4
_parent$ = 8						; size = 4
_parentslot$ = 12					; size = 4
?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_inner, COMDAT
; _left$ = eax
; _right$ = esi

; 3386 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 3387 :         BTREE_ASSERT(left->level == right->level);
; 3388 :         BTREE_ASSERT(parent->level == left->level + 1);
; 3389 : 
; 3390 :         BTREE_ASSERT(left->slotuse < right->slotuse);
; 3391 :         BTREE_ASSERT(parent->childid[parentslot] == left);
; 3392 : 
; 3393 :         unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;
; 3394 : 
; 3395 :         BTREE_PRINT("Shifting (inner) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");
; 3396 : 
; 3397 :         BTREE_ASSERT(left->slotuse + shiftnum < innerslotmax);
; 3398 : 
; 3399 :         if (selfverify)
; 3400 :         {
; 3401 :             // find the left node's slot in the parent's children and compare to parentslot
; 3402 : 
; 3403 :             unsigned int leftslot = 0;
; 3404 :             while(leftslot <= parent->slotuse && parent->childid[leftslot] != left)
; 3405 :                 ++leftslot;
; 3406 : 
; 3407 :             BTREE_ASSERT(leftslot < parent->slotuse);
; 3408 :             BTREE_ASSERT(parent->childid[leftslot] == left);
; 3409 :             BTREE_ASSERT(parent->childid[leftslot+1] == right);
; 3410 : 
; 3411 :             BTREE_ASSERT(leftslot == parentslot);
; 3412 :         }
; 3413 : 
; 3414 :         // copy the parent's decision slotkey and childid to the first new key on the left
; 3415 :         left->slotkey[left->slotuse] = parent->slotkey[parentslot];

  00006	8b 55 0c	 mov	 edx, DWORD PTR _parentslot$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0000c	8b 4c 91 04	 mov	 ecx, DWORD PTR [ecx+edx*4+4]
  00010	53		 push	 ebx
  00011	0f b7 5e 02	 movzx	 ebx, WORD PTR [esi+2]
  00015	57		 push	 edi
  00016	8b f8		 mov	 edi, eax
  00018	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  0001c	89 4c 87 04	 mov	 DWORD PTR [edi+eax*4+4], ecx

; 3416 :         left->slotuse++;

  00020	66 ff 47 02	 inc	 WORD PTR [edi+2]

; 3417 : 
; 3418 :         // copy the other items from the right node to the last slots in the left node.
; 3419 : 
; 3420 :         std::copy(right->slotkey, right->slotkey + shiftnum-1,
; 3421 :                   left->slotkey + left->slotuse);

  00024	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  00028	2b d8		 sub	 ebx, eax
  0002a	d1 fb		 sar	 ebx, 1
  0002c	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0002f	8d 0c 9d 00 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4]
  00036	89 4d fc	 mov	 DWORD PTR tv437[ebp], ecx
  00039	2b c8		 sub	 ecx, eax
  0003b	03 ce		 add	 ecx, esi
  0003d	c1 f9 02	 sar	 ecx, 2
  00040	03 c9		 add	 ecx, ecx
  00042	03 c9		 add	 ecx, ecx
  00044	51		 push	 ecx
  00045	50		 push	 eax
  00046	8d 44 97 04	 lea	 eax, DWORD PTR [edi+edx*4+4]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _memmove

; 3422 :         std::copy(right->childid, right->childid + shiftnum,
; 3423 :                   left->childid + left->slotuse);

  00050	8d 86 84 00 00
	00		 lea	 eax, DWORD PTR [esi+132]
  00056	8d 0c 9d 84 00
	00 00		 lea	 ecx, DWORD PTR [ebx*4+132]
  0005d	89 4d f8	 mov	 DWORD PTR tv444[ebp], ecx
  00060	2b c8		 sub	 ecx, eax
  00062	03 ce		 add	 ecx, esi
  00064	c1 f9 02	 sar	 ecx, 2
  00067	03 c9		 add	 ecx, ecx
  00069	03 c9		 add	 ecx, ecx
  0006b	51		 push	 ecx
  0006c	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00070	50		 push	 eax
  00071	8d 94 8f 84 00
	00 00		 lea	 edx, DWORD PTR [edi+ecx*4+132]
  00078	52		 push	 edx
  00079	e8 00 00 00 00	 call	 _memmove

; 3424 : 
; 3425 :         left->slotuse += shiftnum - 1;
; 3426 : 
; 3427 :         // fixup parent
; 3428 :         parent->slotkey[parentslot] = right->slotkey[shiftnum - 1];

  0007e	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  00081	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  00084	66 01 47 02	 add	 WORD PTR [edi+2], ax
  00088	8b 45 fc	 mov	 eax, DWORD PTR tv437[ebp]
  0008b	8b 0c 30	 mov	 ecx, DWORD PTR [eax+esi]
  0008e	8b 7d 0c	 mov	 edi, DWORD PTR _parentslot$[ebp]
  00091	89 4c ba 04	 mov	 DWORD PTR [edx+edi*4+4], ecx

; 3429 : 
; 3430 :         // shift all slots in the right node
; 3431 : 
; 3432 :         std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
; 3433 :                   right->slotkey);

  00095	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00099	8d 44 30 04	 lea	 eax, DWORD PTR [eax+esi+4]
  0009d	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  000a4	2b d0		 sub	 edx, eax
  000a6	03 d6		 add	 edx, esi
  000a8	c1 fa 02	 sar	 edx, 2
  000ab	03 d2		 add	 edx, edx
  000ad	03 d2		 add	 edx, edx
  000af	52		 push	 edx
  000b0	50		 push	 eax
  000b1	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _memmove

; 3434 :         std::copy(right->childid + shiftnum, right->childid + right->slotuse+1,
; 3435 :                   right->childid);

  000ba	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  000be	8b 45 f8	 mov	 eax, DWORD PTR tv444[ebp]
  000c1	03 c6		 add	 eax, esi
  000c3	8d 14 8d 88 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+136]
  000ca	2b d0		 sub	 edx, eax
  000cc	03 d6		 add	 edx, esi
  000ce	c1 fa 02	 sar	 edx, 2
  000d1	03 d2		 add	 edx, edx
  000d3	03 d2		 add	 edx, edx
  000d5	52		 push	 edx
  000d6	50		 push	 eax
  000d7	8d 86 84 00 00
	00		 lea	 eax, DWORD PTR [esi+132]
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 _memmove
  000e3	83 c4 30	 add	 esp, 48			; 00000030H

; 3436 : 
; 3437 :         right->slotuse -= shiftnum;

  000e6	66 29 5e 02	 sub	 WORD PTR [esi+2], bx
  000ea	5f		 pop	 edi
  000eb	5b		 pop	 ebx

; 3438 :     }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_inner
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z
_TEXT	SEGMENT
tv406 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
tv396 = 12						; size = 4
_left$ = 12						; size = 4
_parent$ = 16						; size = 4
_parentslot$ = 20					; size = 4
?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_leaf, COMDAT
; _right$ = esi

; 3338 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _left$[ebp]

; 3339 :         BTREE_ASSERT(left->isleafnode() && right->isleafnode());
; 3340 :         BTREE_ASSERT(parent->level == 1);
; 3341 : 
; 3342 :         BTREE_ASSERT(left->nextleaf == right);
; 3343 :         BTREE_ASSERT(left == right->prevleaf);
; 3344 : 
; 3345 :         BTREE_ASSERT(left->slotuse < right->slotuse);
; 3346 :         BTREE_ASSERT(parent->childid[parentslot] == left);
; 3347 : 
; 3348 :         unsigned int shiftnum = (right->slotuse - left->slotuse) >> 1;

  00008	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  0000c	57		 push	 edi
  0000d	0f b7 7e 02	 movzx	 edi, WORD PTR [esi+2]
  00011	2b f9		 sub	 edi, ecx
  00013	d1 ff		 sar	 edi, 1

; 3349 : 
; 3350 :         BTREE_PRINT("Shifting (leaf) " << shiftnum << " entries to left " << left << " from right " << right << " with common parent " << parent << ".");
; 3351 : 
; 3352 :         BTREE_ASSERT(left->slotuse + shiftnum < leafslotmax);
; 3353 : 
; 3354 :         // copy the first items from the right node to the last slot in the left node.
; 3355 : 
; 3356 :         std::copy(right->slotkey, right->slotkey + shiftnum,
; 3357 :                   left->slotkey + left->slotuse);

  00015	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00018	8d 14 bd 0c 00
	00 00		 lea	 edx, DWORD PTR [edi*4+12]
  0001f	89 55 0c	 mov	 DWORD PTR tv396[ebp], edx
  00022	2b d0		 sub	 edx, eax
  00024	03 d6		 add	 edx, esi
  00026	c1 fa 02	 sar	 edx, 2
  00029	03 d2		 add	 edx, edx
  0002b	03 d2		 add	 edx, edx
  0002d	52		 push	 edx
  0002e	50		 push	 eax
  0002f	8d 44 8b 0c	 lea	 eax, DWORD PTR [ebx+ecx*4+12]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _memmove

; 3358 :         data_copy(right->slotdata, right->slotdata + shiftnum,
; 3359 :                   left->slotdata + left->slotuse);

  00039	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  0003f	8d 0c bd 8c 00
	00 00		 lea	 ecx, DWORD PTR [edi*4+140]
  00046	89 4d fc	 mov	 DWORD PTR tv406[ebp], ecx
  00049	2b c8		 sub	 ecx, eax
  0004b	03 ce		 add	 ecx, esi
  0004d	c1 f9 02	 sar	 ecx, 2
  00050	03 c9		 add	 ecx, ecx
  00052	03 c9		 add	 ecx, ecx
  00054	51		 push	 ecx
  00055	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  00059	50		 push	 eax
  0005a	8d 94 8b 8c 00
	00 00		 lea	 edx, DWORD PTR [ebx+ecx*4+140]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 _memmove

; 3360 : 
; 3361 :         left->slotuse += shiftnum;

  00067	66 01 7b 02	 add	 WORD PTR [ebx+2], di

; 3362 : 
; 3363 :         // shift all slots in the right node to the left
; 3364 : 
; 3365 :         std::copy(right->slotkey + shiftnum, right->slotkey + right->slotuse,
; 3366 :                   right->slotkey);

  0006b	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  0006f	8b 45 0c	 mov	 eax, DWORD PTR tv396[ebp]
  00072	03 c6		 add	 eax, esi
  00074	8d 14 8d 0c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+12]
  0007b	2b d0		 sub	 edx, eax
  0007d	03 d6		 add	 edx, esi
  0007f	c1 fa 02	 sar	 edx, 2
  00082	03 d2		 add	 edx, edx
  00084	03 d2		 add	 edx, edx
  00086	52		 push	 edx
  00087	50		 push	 eax
  00088	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memmove

; 3367 :         data_copy(right->slotdata + shiftnum, right->slotdata + right->slotuse,
; 3368 :                   right->slotdata);

  00091	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00095	8b 45 fc	 mov	 eax, DWORD PTR tv406[ebp]
  00098	03 c6		 add	 eax, esi
  0009a	8d 14 8d 8c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+140]
  000a1	2b d0		 sub	 edx, eax
  000a3	03 d6		 add	 edx, esi
  000a5	c1 fa 02	 sar	 edx, 2
  000a8	03 d2		 add	 edx, edx
  000aa	03 d2		 add	 edx, edx
  000ac	52		 push	 edx
  000ad	50		 push	 eax
  000ae	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 _memmove

; 3369 : 
; 3370 :         right->slotuse -= shiftnum;

  000ba	66 29 7e 02	 sub	 WORD PTR [esi+2], di

; 3371 : 
; 3372 :         // fixup parent
; 3373 :         if (parentslot < parent->slotuse) {

  000be	8b 4d 10	 mov	 ecx, DWORD PTR _parent$[ebp]
  000c1	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  000c5	8b 45 14	 mov	 eax, DWORD PTR _parentslot$[ebp]
  000c8	83 c4 30	 add	 esp, 48			; 00000030H
  000cb	3b c2		 cmp	 eax, edx
  000cd	73 22		 jae	 SHORT $LN2@shift_left

; 3374 :             parent->slotkey[parentslot] = left->slotkey[left->slotuse - 1];

  000cf	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  000d3	8b 54 93 08	 mov	 edx, DWORD PTR [ebx+edx*4+8]
  000d7	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 3375 :             return btree_ok;

  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000de	5f		 pop	 edi
  000df	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000e5	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000ec	5b		 pop	 ebx

; 3379 :         }
; 3380 :     }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
$LN2@shift_left:

; 3376 :         }
; 3377 :         else { // the update is further up the tree
; 3378 :             return result_t(btree_update_lastkey, left->slotkey[left->slotuse - 1]);

  000f1	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  000f5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f8	8b 54 8b 08	 mov	 edx, DWORD PTR [ebx+ecx*4+8]
  000fc	5f		 pop	 edi
  000fd	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00103	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00106	5b		 pop	 ebx

; 3379 :         }
; 3380 :     }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c3		 ret	 0
?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_leaf
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_inner, COMDAT
; _left$ = esi
; _right$ = edi
; _parent$ = ecx
; _parentslot$ = edx

; 3294 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3295 :         BTREE_PRINT("Merge inner nodes " << left << " and " << right << " with common parent " << parent << ".");
; 3296 : 
; 3297 :         BTREE_ASSERT(left->level == right->level);
; 3298 :         BTREE_ASSERT(parent->level == left->level + 1);
; 3299 : 
; 3300 :         BTREE_ASSERT(parent->childid[parentslot] == left);
; 3301 : 
; 3302 :         BTREE_ASSERT(left->slotuse + right->slotuse < innerslotmax);
; 3303 : 
; 3304 :         if (selfverify)
; 3305 :         {
; 3306 :             // find the left node's slot in the parent's children
; 3307 :             unsigned int leftslot = 0;
; 3308 :             while(leftslot <= parent->slotuse && parent->childid[leftslot] != left)
; 3309 :                 ++leftslot;
; 3310 : 
; 3311 :             BTREE_ASSERT(leftslot < parent->slotuse);
; 3312 :             BTREE_ASSERT(parent->childid[leftslot] == left);
; 3313 :             BTREE_ASSERT(parent->childid[leftslot+1] == right);
; 3314 : 
; 3315 :             BTREE_ASSERT(parentslot == leftslot);
; 3316 :         }
; 3317 : 
; 3318 :         // retrieve the decision key from parent
; 3319 :         left->slotkey[left->slotuse] = parent->slotkey[parentslot];

  00003	8b 4c 91 04	 mov	 ecx, DWORD PTR [ecx+edx*4+4]
  00007	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0000b	89 4c 86 04	 mov	 DWORD PTR [esi+eax*4+4], ecx

; 3320 :         left->slotuse++;

  0000f	66 ff 46 02	 inc	 WORD PTR [esi+2]

; 3321 : 
; 3322 :         // copy over keys and children from right
; 3323 :         std::copy(right->slotkey, right->slotkey + right->slotuse,
; 3324 :                   left->slotkey + left->slotuse);

  00013	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  00017	8d 14 95 04 00
	00 00		 lea	 edx, DWORD PTR [edx*4+4]
  0001e	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00021	2b d0		 sub	 edx, eax
  00023	03 d7		 add	 edx, edi
  00025	c1 fa 02	 sar	 edx, 2
  00028	53		 push	 ebx
  00029	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	03 d2		 add	 edx, edx
  0002e	03 d2		 add	 edx, edx
  00030	52		 push	 edx
  00031	50		 push	 eax
  00032	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00036	8d 4c 86 04	 lea	 ecx, DWORD PTR [esi+eax*4+4]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _memmove

; 3325 :         std::copy(right->childid, right->childid + right->slotuse+1,
; 3326 :                   left->childid + left->slotuse);

  00040	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  00044	8d 87 84 00 00
	00		 lea	 eax, DWORD PTR [edi+132]
  0004a	8d 0c 95 88 00
	00 00		 lea	 ecx, DWORD PTR [edx*4+136]
  00051	0f b7 56 02	 movzx	 edx, WORD PTR [esi+2]
  00055	2b c8		 sub	 ecx, eax
  00057	03 cf		 add	 ecx, edi
  00059	c1 f9 02	 sar	 ecx, 2
  0005c	03 c9		 add	 ecx, ecx
  0005e	03 c9		 add	 ecx, ecx
  00060	51		 push	 ecx
  00061	50		 push	 eax
  00062	8d 84 96 84 00
	00 00		 lea	 eax, DWORD PTR [esi+edx*4+132]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 _memmove

; 3327 : 
; 3328 :         left->slotuse += right->slotuse;

  0006f	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00073	66 01 4e 02	 add	 WORD PTR [esi+2], cx
  00077	83 c4 18	 add	 esp, 24			; 00000018H

; 3329 :         right->slotuse = 0;

  0007a	33 d2		 xor	 edx, edx

; 3330 : 
; 3331 :         return btree_fixmerge;

  0007c	c7 03 04 00 00
	00		 mov	 DWORD PTR [ebx], 4
  00082	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  00085	8b c3		 mov	 eax, ebx
  00087	66 89 57 02	 mov	 WORD PTR [edi+2], dx
  0008b	5b		 pop	 ebx

; 3332 :     }

  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_inner
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves, COMDAT
; _left$ = edi
; _right$ = esi

; 3263 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3264 :         BTREE_PRINT("Merge leaf nodes " << left << " and " << right << " with common parent " << parent << ".");
; 3265 :         (void)parent;
; 3266 : 
; 3267 :         BTREE_ASSERT(left->isleafnode() && right->isleafnode());
; 3268 :         BTREE_ASSERT(parent->level == 1);
; 3269 : 
; 3270 :         BTREE_ASSERT(left->slotuse + right->slotuse < leafslotmax);
; 3271 : 
; 3272 :         std::copy(right->slotkey, right->slotkey + right->slotuse,
; 3273 :                   left->slotkey + left->slotuse);

  00003	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00007	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0000a	8d 14 8d 0c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+12]
  00011	2b d0		 sub	 edx, eax
  00013	03 d6		 add	 edx, esi
  00015	c1 fa 02	 sar	 edx, 2
  00018	53		 push	 ebx
  00019	8b 5d 0c	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	03 d2		 add	 edx, edx
  0001e	03 d2		 add	 edx, edx
  00020	52		 push	 edx
  00021	50		 push	 eax
  00022	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00026	8d 4c 87 0c	 lea	 ecx, DWORD PTR [edi+eax*4+12]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 _memmove

; 3274 :         data_copy(right->slotdata, right->slotdata + right->slotuse,
; 3275 :                   left->slotdata + left->slotuse);

  00030	0f b7 56 02	 movzx	 edx, WORD PTR [esi+2]
  00034	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  0003a	8d 0c 95 8c 00
	00 00		 lea	 ecx, DWORD PTR [edx*4+140]
  00041	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  00045	2b c8		 sub	 ecx, eax
  00047	03 ce		 add	 ecx, esi
  00049	c1 f9 02	 sar	 ecx, 2
  0004c	03 c9		 add	 ecx, ecx
  0004e	03 c9		 add	 ecx, ecx
  00050	51		 push	 ecx
  00051	50		 push	 eax
  00052	8d 84 97 8c 00
	00 00		 lea	 eax, DWORD PTR [edi+edx*4+140]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _memmove

; 3276 : 
; 3277 :         left->slotuse += right->slotuse;

  0005f	66 8b 4e 02	 mov	 cx, WORD PTR [esi+2]
  00063	66 01 4f 02	 add	 WORD PTR [edi+2], cx

; 3278 : 
; 3279 :         left->nextleaf = right->nextleaf;

  00067	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0006a	83 c4 18	 add	 esp, 24			; 00000018H
  0006d	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 3280 :         if (left->nextleaf)

  00070	85 c0		 test	 eax, eax
  00072	74 05		 je	 SHORT $LN2@merge_leav

; 3281 :             left->nextleaf->prevleaf = left;

  00074	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 3282 :         else

  00077	eb 06		 jmp	 SHORT $LN1@merge_leav
$LN2@merge_leav:

; 3283 :             m_tailleaf = left;

  00079	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN1@merge_leav:

; 3284 : 
; 3285 :         right->slotuse = 0;

  0007f	33 c0		 xor	 eax, eax

; 3286 : 
; 3287 :         return btree_fixmerge;

  00081	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00084	66 89 46 02	 mov	 WORD PTR [esi+2], ax
  00088	c7 03 04 00 00
	00		 mov	 DWORD PTR [ebx], 4
  0008e	8b c3		 mov	 eax, ebx
  00090	5b		 pop	 ebx

; 3288 :     }

  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z
_TEXT	SEGMENT
?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child, COMDAT
; _this$ = eax
; _i$ = ecx

; 572  :   btree_node* child(int i) const { return fields_.children[i]; }

  00000	8b 84 88 00 01
	00 00		 mov	 eax, DWORD PTR [eax+ecx*4+256]
  00007	c3		 ret	 0
?child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ
_TEXT	SEGMENT
?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost, COMDAT
; _this$ = eax

; 545  :   btree_node* rightmost() const { return fields_.rightmost; }

  00000	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
  00006	c3		 ret	 0
?rightmost@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEPAV12@XZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ
_TEXT	SEGMENT
?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf, COMDAT
; _this$ = eax

; 522  :   bool leaf() const { return fields_.leaf; }

  00000	8a 00		 mov	 al, BYTE PTR [eax]
  00002	c3		 ret	 0
?leaf@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::leaf
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 131  : 		{	// construct by copying _Pair_base

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 132  : 		}

  0000a	c3		 ret	 0
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$equal_to@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$equal_to@I@std@@QBE_NABI0@Z PROC			; std::equal_to<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 92   : 		return (_Left == _Right);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 93   : 		}

  00009	c3		 ret	 0
??R?$equal_to@I@std@@QBE_NABI0@Z ENDP			; std::equal_to<unsigned int>::operator()
_TEXT	ENDS
PUBLIC	__real@4f800000
;	COMDAT __real@4f800000
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z
_TEXT	SEGMENT
tv71 = -12						; size = 8
tv131 = -8						; size = 4
tv68 = -8						; size = 4
tv129 = -2						; size = 2
?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size, COMDAT
; _this$ = ecx
; _x$ = eax

; 97   :   size_type shrink_size(size_type x) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 98   :     return static_cast<size_type>(x * shrink_factor_);

  00006	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv131[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@shrink_siz
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN3@shrink_siz:
  00016	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00019	d9 7d fe	 fnstcw	 WORD PTR tv129[ebp]
  0001c	0f b7 45 fe	 movzx	 eax, WORD PTR tv129[ebp]
  00020	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00025	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00028	d9 6d f8	 fldcw	 WORD PTR tv68[ebp]
  0002b	df 7d f4	 fistp	 QWORD PTR tv71[ebp]
  0002e	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00031	d9 6d fe	 fldcw	 WORD PTR tv129[ebp]

; 99   :   }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z
_TEXT	SEGMENT
tv71 = -12						; size = 8
tv131 = -8						; size = 4
tv68 = -8						; size = 4
tv129 = -2						; size = 2
?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size, COMDAT
; _this$ = ecx
; _x$ = eax

; 94   :   size_type enlarge_size(size_type x) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 95   :     return static_cast<size_type>(x * enlarge_factor_);

  00006	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv131[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@enlarge_si
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN3@enlarge_si:
  00016	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00019	d9 7d fe	 fnstcw	 WORD PTR tv129[ebp]
  0001c	0f b7 45 fe	 movzx	 eax, WORD PTR tv129[ebp]
  00020	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00025	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00028	d9 6d f8	 fldcw	 WORD PTR tv68[ebp]
  0002b	df 7d f4	 fistp	 QWORD PTR tv71[ebp]
  0002e	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00031	d9 6d fe	 fldcw	 WORD PTR tv129[ebp]

; 96   :   }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?enlarge_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold, COMDAT
; _this$ = eax
; _t$ = ecx

; 91   :     shrink_threshold_ = t;

  00000	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 92   :   }

  00003	c3		 ret	 0
?set_shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_shrink_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ
_TEXT	SEGMENT
?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold, COMDAT
; _this$ = eax

; 88   :     return shrink_threshold_;

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 89   :   }

  00003	c3		 ret	 0
?shrink_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold, COMDAT
; _this$ = eax
; _t$ = ecx

; 85   :     enlarge_threshold_ = t;

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 86   :   }

  00002	c3		 ret	 0
?set_enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_enlarge_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ
_TEXT	SEGMENT
?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold, COMDAT
; _this$ = eax

; 82   :     return enlarge_threshold_;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   :   }

  00002	c3		 ret	 0
?enlarge_threshold@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_threshold
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ
_TEXT	SEGMENT
?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor, COMDAT
; _this$ = eax

; 75   :     return shrink_factor_;

  00000	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]

; 76   :   }

  00005	c3		 ret	 0
?shrink_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ
_TEXT	SEGMENT
?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor, COMDAT
; _this$ = eax

; 69   :     return enlarge_factor_;

  00000	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]

; 70   :   }

  00005	c3		 ret	 0
?enlarge_factor@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEMXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::enlarge_factor
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z
_TEXT	SEGMENT
??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>, COMDAT
; _this$ = eax

; 60   :     set_enlarge_factor(ht_occupancy_flt);

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	33 c9		 xor	 ecx, ecx
  0000a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 61   :     set_shrink_factor(ht_empty_flt);

  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001c	66 89 48 10	 mov	 WORD PTR [eax+16], cx
  00020	88 48 12	 mov	 BYTE PTR [eax+18], cl
  00023	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00026	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 62   :   }

  0002b	c3		 ret	 0
??0?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAE@ABVcpp_tommy_inthash_u32@@MM@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 57   :   libc_allocator_with_realloc(const libc_allocator_with_realloc&) {}

  00000	c3		 ret	 0
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@ABV01@@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key, COMDAT
; _v$ = eax
; _k$ = ecx

; 1218 :     key_info.set_key(v, k);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1219 :   }

  0000b	c3		 ret	 0
?set_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key, COMDAT
; _v$ = eax

; 1215 :     return key_info.get_key(v);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 1216 :   }

  00002	c3		 ret	 0
?get_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?BIABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::get_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	c3		 ret	 0
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABU01@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?has@result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NW4result_flags_t@23@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?has@result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NW4result_flags_t@23@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::has, COMDAT
; _this$ = eax

; 2574 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2575 :             return (flags & f) != 0;

  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	23 45 08	 and	 eax, DWORD PTR _f$[ebp]
  00008	f7 d8		 neg	 eax
  0000a	1b c0		 sbb	 eax, eax
  0000c	f7 d8		 neg	 eax

; 2576 :         }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?has@result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NW4result_flags_t@23@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::has
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = eax

; 93   : 		return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 94   : 		}

  00002	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z PROC ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 151  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z PROC ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 151  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z ENDP ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z PROC ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 136  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 137  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z ENDP ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABU01@@Z PROC	; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 131  : 		{	// construct by copying _Pair_base

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 132  : 		}

  0000a	c3		 ret	 0
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@ABU01@@Z ENDP	; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@IPAUstx_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@XZ PROC	; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>, COMDAT
; _this$ = eax

; 126  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : 		}

  0000d	c3		 ret	 0
??0?$_Pair_base@IPAUstx_object@@@std@@QAE@XZ ENDP	; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = eax

; 512  : 		{	// construct empty vector with allocator

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 513  : 		}

  0000a	c3		 ret	 0
??0?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@ABV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@1@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEXPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::deallocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval, COMDAT
; __Pnode$ = eax

; 571  : 		return ((reference)(*_Pnode)._Myval);

  00000	83 c0 08	 add	 eax, 8

; 572  : 		}

  00003	c3		 ret	 0
?_Myval@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Myval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode, COMDAT
; __Pnode$ = eax

; 566  : 		return ((_Nodepref)(*_Pnode)._Prev);

  00000	83 c0 04	 add	 eax, 4

; 567  : 		}

  00003	c3		 ret	 0
?_Prevnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Prevnode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z
_TEXT	SEGMENT
?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode, COMDAT
; __Pnode$ = eax

; 561  : 		return ((_Nodepref)(*_Pnode)._Next);
; 562  : 		}

  00000	c3		 ret	 0
?_Nextnode@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@SAAAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@PAU342@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Nextnode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = eax

; 502  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 503  : 		}

  00009	c3		 ret	 0
??1?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval1$ = eax
; __Keyval2$ = edx

; 159  : 		return (!_Keyeqobj(_Keyval1, _Keyval2));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 160  : 		}

  00009	c3		 ret	 0
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBE_NABI0@Z ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z
_TEXT	SEGMENT
??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z PROC ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>, COMDAT
; _this$ = eax
; __Traits$ = ecx

; 42   : 		{	// construct with specified comparator

  00000	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00003	66 89 10	 mov	 WORD PTR [eax], dx

; 43   : 		}

  00006	c3		 ret	 0
??0?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@2@@Z ENDP ; std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi, COMDAT
; _this$ = eax
; __Bucket$ = edx

; 708  : 		return (_Vec[2 * _Bucket + 1]);

  00000	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00003	8d 44 d1 04	 lea	 eax, DWORD PTR [ecx+edx*8+4]

; 709  : 		}

  00007	c3		 ret	 0
?_Vec_hi@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_hi
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo, COMDAT
; _this$ = eax
; __Bucket$ = edx

; 698  : 		return (_Vec[2 * _Bucket]);

  00000	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00003	8d 04 d1	 lea	 eax, DWORD PTR [ecx+edx*8]

; 699  : 		}

  00006	c3		 ret	 0
?_Vec_lo@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEAAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Vec_lo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?isleafnode@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ
_TEXT	SEGMENT
?isleafnode@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::isleafnode, COMDAT
; _this$ = ecx

; 274  :             return (level == 0);

  00000	33 c0		 xor	 eax, eax
  00002	66 39 01	 cmp	 WORD PTR [ecx], ax
  00005	0f 94 c0	 sete	 al

; 275  :         }

  00008	c3		 ret	 0
?isleafnode@node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::node::isleafnode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??0tree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ
_TEXT	SEGMENT
??0tree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::tree_stats::tree_stats, COMDAT
; _this$ = eax

; 1270 :         {

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1271 :         }

  0000a	c3		 ret	 0
??0tree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::tree_stats::tree_stats
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>, COMDAT
; _this$ = eax
; _n$ = ecx

; 769  :         position(p) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 770  :   }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@1@H@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count, COMDAT
; _this$ = eax

; 531  :   int max_count() const { return fields_.max_count; }

  00000	0f b6 40 02	 movzx	 eax, BYTE PTR [eax+2]
  00004	c3		 ret	 0
?max_count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::max_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ
_TEXT	SEGMENT
?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count, COMDAT
; _this$ = eax

; 529  :   int count() const { return fields_.count; }

  00000	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  00004	c3		 ret	 0
?count@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
$T171854 = -16						; size = 8
_this$ = -8						; size = 4
tv230 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_node$ = 12						; size = 4
?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats, COMDAT
; _this$ = ecx

; 1364 :   node_stats internal_stats(const node_type *node) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1365 :     if (!node) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR _node$[ebp]
  00009	53		 push	 ebx
  0000a	33 db		 xor	 ebx, ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00011	3b c3		 cmp	 eax, ebx
  00013	75 11		 jne	 SHORT $LN5@internal_s

; 1366 :       return node_stats(0, 0);

  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	89 18		 mov	 DWORD PTR [eax], ebx
  0001a	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 1376 :   }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
$LN5@internal_s:

; 1367 :     }
; 1368 :     if (node->leaf()) {

  00026	38 18		 cmp	 BYTE PTR [eax], bl
  00028	74 15		 je	 SHORT $LN4@internal_s

; 1369 :       return node_stats(1, 0);

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00033	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 1376 :   }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN4@internal_s:

; 1370 :     }
; 1371 :     node_stats res(0, 1);

  0003f	33 f6		 xor	 esi, esi
  00041	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 1372 :     for (int i = 0; i <= node->count(); ++i) {

  00044	38 58 03	 cmp	 BYTE PTR [eax+3], bl
  00047	72 2f		 jb	 SHORT $LN1@internal_s

; 1370 :     }
; 1371 :     node_stats res(0, 1);

  00049	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0004e	89 45 fc	 mov	 DWORD PTR tv230[ebp], eax
$LN3@internal_s:

; 1373 :       res += internal_stats(node->child(i));

  00051	8b 45 fc	 mov	 eax, DWORD PTR tv230[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	50		 push	 eax
  00057	8d 4d f0	 lea	 ecx, DWORD PTR $T171854[ebp]
  0005a	51		 push	 ecx
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00063	03 30		 add	 esi, DWORD PTR [eax]
  00065	03 78 04	 add	 edi, DWORD PTR [eax+4]
  00068	8b 55 0c	 mov	 edx, DWORD PTR _node$[ebp]
  0006b	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  0006f	83 45 fc 04	 add	 DWORD PTR tv230[ebp], 4
  00073	43		 inc	 ebx
  00074	3b d8		 cmp	 ebx, eax
  00076	7e d9		 jle	 SHORT $LN3@internal_s
$LN1@internal_s:

; 1374 :     }
; 1375 :     return res;

  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007b	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1376 :   }

  0007e	5f		 pop	 edi
  0007f	89 30		 mov	 DWORD PTR [eax], esi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root, COMDAT
; _this$ = eax

; 1214 :   const node_type* root() const { return root_.data; }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABEPBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root, COMDAT
; _this$ = eax

; 1213 :   node_type* root() { return root_.data; }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	c3		 ret	 0
?root@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::root
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 150  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 151  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z
_TEXT	SEGMENT
??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo, COMDAT
; _this$ = eax

; 1191 :     }

  00000	c3		 ret	 0
??0KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@2@ABUSetKey@42@ABU?$equal_to@I@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::KeyInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted, COMDAT
; _this$ = eax

; 119  :     use_deleted_ = t;

  00000	c6 40 12 01	 mov	 BYTE PTR [eax+18], 1

; 120  :   }

  00004	c3		 ret	 0
?set_use_deleted@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty, COMDAT
; _this$ = eax

; 112  :     use_empty_ = t;

  00000	c6 40 11 01	 mov	 BYTE PTR [eax+17], 1

; 113  :   }

  00004	c3		 ret	 0
?set_use_empty@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_use_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z
_TEXT	SEGMENT
?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink, COMDAT
; _this$ = eax
; _t$ = ecx

; 105  :     consider_shrink_ = t;

  00000	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 106  :   }

  00003	c3		 ret	 0
?set_consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEX_N@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::set_consider_shrink
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ
_TEXT	SEGMENT
?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink, COMDAT
; _this$ = eax

; 102  :     return consider_shrink_;

  00000	8a 40 10	 mov	 al, BYTE PTR [eax+16]

; 103  :   }

  00003	c3		 ret	 0
?consider_shrink@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBE_NXZ ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::consider_shrink
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z
_TEXT	SEGMENT
??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings, COMDAT
; _this$ = eax

; 1181 :             hf, HT_OCCUPANCY_PCT / 100.0f, HT_EMPTY_PCT / 100.0f) {}

  00000	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00008	33 c9		 xor	 ecx, ecx
  0000a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00017	89 08		 mov	 DWORD PTR [eax], ecx
  00019	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001c	66 89 48 10	 mov	 WORD PTR [eax+16], cx
  00020	88 48 12	 mov	 BYTE PTR [eax+18], cl
  00023	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00026	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0002b	c3		 ret	 0
??0Settings@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABVcpp_tommy_inthash_u32@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::Settings::Settings
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z
_TEXT	SEGMENT
?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate, COMDAT
; _n$ = eax

; 64   :     return static_cast<pointer>(malloc(n * sizeof(value_type)));

  00000	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00007	51		 push	 ecx
  00008	e8 00 00 00 00	 call	 _malloc
  0000d	83 c4 04	 add	 esp, 4

; 65   :   }

  00010	c3		 ret	 0
?allocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEPAU?$pair@$$CBIPAUgoogle_object@@@std@@IPBU34@@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::allocate
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size, COMDAT
; _this$ = ecx

; 505  :   size_type size() const      { return num_elements - num_deleted; }

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	2b 41 20	 sub	 eax, DWORD PTR [ecx+32]
  00006	c3		 ret	 0
?size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUstx_object@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$pair@IPAUstx_object@@@std@@QAE@ABU01@@Z PROC	; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	c3		 ret	 0
??0?$pair@IPAUstx_object@@@std@@QAE@ABU01@@Z ENDP	; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??R?$btree_pair_to_value@U?$pair@IPAUstx_object@@@std@@U12@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE?AU?$pair@IPAUstx_object@@@std@@ABU34@@Z
_TEXT	SEGMENT
??R?$btree_pair_to_value@U?$pair@IPAUstx_object@@@std@@U12@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE?AU?$pair@IPAUstx_object@@@std@@ABU34@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree_pair_to_value<std::pair<unsigned int,stx_object *>,std::pair<unsigned int,stx_object *> >::operator(), COMDAT
; ___$ReturnUdt$ = eax
; _p$ = ecx

; 409  :             return p;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 410  :         }

  0000a	c3		 ret	 0
??R?$btree_pair_to_value@U?$pair@IPAUstx_object@@@std@@U12@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE?AU?$pair@IPAUstx_object@@@std@@ABU34@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree_pair_to_value<std::pair<unsigned int,stx_object *>,std::pair<unsigned int,stx_object *> >::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z
_TEXT	SEGMENT
??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value, COMDAT
; _this$ = eax
; _k$ = ecx

; 238  :     generate_value(const key_type &k)

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 239  :         : key(k) {
; 240  :     }

  00002	c3		 ret	 0
??0generate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABI@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::generate_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = eax

; 47   : 		return (_Mylist::_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 48   : 		}

  00005	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*, COMDAT
; _this$ = eax

; 202  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 203  : 		if (this->_Getcont() == 0
; 204  : 			|| this->_Ptr == 0
; 205  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 206  : 			{	// report error
; 207  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 208  : 			_SCL_SECURE_OUT_OF_RANGE;
; 209  : 			}
; 210  : 
; 211  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 212  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 213  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 214  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 215  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 216  : 
; 217  : 		return (_Mylist::_Myval(this->_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 218  : 		}

  00005	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z PROC ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 234  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@$$CBIPAUcpp_object@@@std@@QAE@ABI$$QAPAUcpp_object@@@Z ENDP ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = eax

; 122  : 		return (_Ptr);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?data@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEAAPAUstx_object@@XZ
_TEXT	SEGMENT
?data@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEAAPAUstx_object@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::data, COMDAT
; _this$ = eax

; 538  :             return currnode->slotdata[used_as_set ? 0 : currslot];

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8d 84 8a 8c 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+140]

; 539  :         }

  0000d	c3		 ret	 0
?data@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEAAPAUstx_object@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::data
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ
_TEXT	SEGMENT
?key@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::key, COMDAT
; _this$ = eax

; 532  :             return currnode->slotkey[currslot];

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8d 44 8a 0c	 lea	 eax, DWORD PTR [edx+ecx*4+12]

; 533  :         }

  0000a	c3		 ret	 0
?key@iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::key
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??4?$pair@IPAUstx_object@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
??4?$pair@IPAUstx_object@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::pair<unsigned int,stx_object *>::operator=, COMDAT
; _this$ = eax
; __Right$ = ecx

; 260  : 		this->first = _STD move(_Right.first);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 261  : 		this->second = _STD move(_Right.second);

  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 262  : 		return (*this);
; 263  : 		}

  0000a	c3		 ret	 0
??4?$pair@IPAUstx_object@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::pair<unsigned int,stx_object *>::operator=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z PROC ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 234  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@IPAUstx_object@@@std@@QAE@ABI$$QAPAUstx_object@@@Z ENDP ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z PROC ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 188  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 189  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@IPAUstx_object@@@std@@QAE@ABIABQAUstx_object@@@Z ENDP ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@IPAUstx_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@IPAUstx_object@@@std@@QAE@XZ PROC		; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>, COMDAT
; _this$ = eax

; 183  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 184  : 		}

  0000d	c3		 ret	 0
??0?$pair@IPAUstx_object@@@std@@QAE@XZ ENDP		; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?data@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABQAUstx_object@@XZ
_TEXT	SEGMENT
?data@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABQAUstx_object@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::data, COMDAT
; _this$ = eax

; 741  :             return currnode->slotdata[used_as_set ? 0 : currslot];

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8d 84 8a 8c 00
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+140]

; 742  :         }

  0000d	c3		 ret	 0
?data@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABQAUstx_object@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::data
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ
_TEXT	SEGMENT
?key@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::key, COMDAT
; _this$ = eax

; 735  :             return currnode->slotkey[currslot];

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	8d 44 8a 0c	 lea	 eax, DWORD PTR [edx+ecx*4+12]

; 736  :         }

  0000a	c3		 ret	 0
?key@const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABIXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*, COMDAT
; _this$ = eax

; 172  :   reference operator*() const { return *pos; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??D?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEAAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*, COMDAT
; _this$ = eax

; 230  :   reference operator*() const { return *pos; }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??D?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >, COMDAT
; _this$ = eax

; 139  : 		{	// construct with default hasher and equality comparator
; 140  : 		}

  00000	c3		 ret	 0
??0?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QAE@XZ ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 182  : 		::operator delete(_Ptr);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 183  : 		}

  00007	c3		 ret	 0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::allocator<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00003	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBIPAUcpp_object@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Myval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00000	83 c0 08	 add	 eax, 8

; 633  : 		}

  00003	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Right
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00000	83 c0 04	 add	 eax, 4

; 628  : 		}

  00003	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Parent
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);
; 623  : 		}

  00000	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Left
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00003	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAAIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00000	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  00003	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Isnil
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 607  : 		return ((char&)(*_Pnode)._Color);

  00000	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  00003	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Color
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = eax

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root, COMDAT
; _this$ = eax

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rmost
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00006	8b 10		 mov	 edx, DWORD PTR [eax]
  00008	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000b	8b 10		 mov	 edx, DWORD PTR [eax]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00013	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  0001c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00022	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00025	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00027	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00038	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003a	89 02		 mov	 DWORD PTR [edx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003c	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00045	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  00048	89 08		 mov	 DWORD PTR [eax], ecx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1780 : 		}

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?get_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABUtree_stats@12@XZ
_TEXT	SEGMENT
?get_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABUtree_stats@12@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::get_stats, COMDAT
; _this$ = eax

; 1749 :         return m_stats;

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1750 :     }

  00003	c3		 ret	 0
?get_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEABUtree_stats@12@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::get_stats
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>, COMDAT
; _this$ = eax

; 1315 :     {

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00010	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1316 :     }

  00013	c3		 ret	 0
??0?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z
_TEXT	SEGMENT
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>, COMDAT
; _this$ = eax
; _x$ = ecx

; 773  :         position(x.position) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 774  :   }

  0000a	c3		 ret	 0
??0?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE@ABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value, COMDAT
; _this$ = eax
; _i$ = ecx

; 560  :     return reinterpret_cast<const_reference>(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 561  :   }

  00004	c3		 ret	 0
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEABU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z
_TEXT	SEGMENT
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value, COMDAT
; _this$ = eax
; _i$ = ecx

; 557  :     return reinterpret_cast<reference>(fields_.values[i]);

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]

; 558  :   }

  00004	c3		 ret	 0
?value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
_TEXT	ENDS
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; __Left$ = eax
; __Right$ = edx

; 125  : 		return (_Left < _Right);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 126  : 		}

  00008	c3		 ret	 0
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ
_TEXT	SEGMENT
_stats$ = -8						; size = 8
?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used, COMDAT
; _this$ = ecx

; 1173 :   size_type bytes_used() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1174 :     node_stats stats = internal_stats(root());

  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _stats$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats

; 1175 :     if (stats.leaf_nodes == 1 && stats.internal_nodes == 0) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _stats$[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _stats$[ebp+4]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 14		 jne	 SHORT $LN2@bytes_used
  0001e	85 c9		 test	 ecx, ecx
  00020	75 10		 jne	 SHORT $LN2@bytes_used

; 1176 :       return sizeof(*this) +
; 1177 :           sizeof(base_fields) + root()->max_count() * sizeof(value_type);

  00022	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00026	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]

; 1183 :     }
; 1184 :   }

  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN2@bytes_used:

; 1178 :     } else {
; 1179 :       return sizeof(*this) +
; 1180 :           sizeof(root_fields) - sizeof(internal_fields) +
; 1181 :           stats.leaf_nodes * sizeof(leaf_fields) +
; 1182 :           stats.internal_nodes * sizeof(internal_fields);

  00032	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00035	c1 e1 07	 shl	 ecx, 7
  00038	c1 e0 08	 shl	 eax, 8
  0003b	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1183 :     }
; 1184 :   }

  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?bytes_used@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBEIXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::bytes_used
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>, COMDAT
; _this$ = eax

; 126  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 127  : 		}

  0000d	c3		 ret	 0
??0?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@XZ ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 233  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 234  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z
_TEXT	SEGMENT
?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate, COMDAT
; _p$ = eax

; 67   :     free(p);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 _free
  00006	59		 pop	 ecx

; 68   :   }

  00007	c3		 ret	 0
?deallocate@?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::deallocate
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count, COMDAT
; _this$ = eax

; 508  :   size_type bucket_count() const      { return num_buckets; }

  00000	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00003	c3		 ret	 0
?bucket_count@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEIXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z
_TEXT	SEGMENT
?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets, COMDAT

; 358  :     for ( ; first != last; ++first)
; 359  :       table[first].~value_type();
; 360  :   }

  00000	c3		 ret	 0
?destroy_buckets@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXII@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::destroy_buckets
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = eax

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00000	c3		 ret	 0
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->, COMDAT
; _this$ = eax

; 52   : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 53   : 		}

  00005	c3		 ret	 0
??C?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 282  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 283  : 		if (this->_Getcont() == 0
; 284  : 			|| this->_Getcont() != _Right._Getcont())
; 285  : 			{	// report error
; 286  : 			_DEBUG_ERROR("list iterators incompatible");
; 287  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 288  : 			}
; 289  : 
; 290  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 291  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 292  : 			&& this->_Getcont() == _Right._Getcont());
; 293  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 294  : 
; 295  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 296  : 		}

  00009	c3		 ret	 0
??8?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==, COMDAT
; _this$ = eax
; __Right$ = edx

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 331  : 		}

  00009	c3		 ret	 0
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??8iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 620  :             return (x.currnode == currnode) && (x.currslot == currslot);

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00004	75 10		 jne	 SHORT $LN3@operator
  00006	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  0000a	66 3b 41 04	 cmp	 ax, WORD PTR [ecx+4]
  0000e	75 06		 jne	 SHORT $LN3@operator
  00010	b8 01 00 00 00	 mov	 eax, 1

; 621  :         }

  00015	c3		 ret	 0
$LN3@operator:

; 620  :             return (x.currnode == currnode) && (x.currslot == currslot);

  00016	33 c0		 xor	 eax, eax

; 621  :         }

  00018	c3		 ret	 0
??8iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator!=, COMDAT
; _this$ = ecx
; _x$ = eax

; 829  :             return (x.currnode != currnode) || (x.currslot != currslot);

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00004	75 0d		 jne	 SHORT $LN3@operator@2
  00006	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  0000a	66 3b 41 04	 cmp	 ax, WORD PTR [ecx+4]
  0000e	75 03		 jne	 SHORT $LN3@operator@2
  00010	33 c0		 xor	 eax, eax

; 830  :         }

  00012	c3		 ret	 0
$LN3@operator@2:

; 829  :             return (x.currnode != currnode) || (x.currslot != currslot);

  00013	b8 01 00 00 00	 mov	 eax, 1

; 830  :         }

  00018	c3		 ret	 0
??9const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 823  :             return (x.currnode == currnode) && (x.currslot == currslot);

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00004	75 10		 jne	 SHORT $LN3@operator@3
  00006	66 8b 40 04	 mov	 ax, WORD PTR [eax+4]
  0000a	66 3b 41 04	 cmp	 ax, WORD PTR [ecx+4]
  0000e	75 06		 jne	 SHORT $LN3@operator@3
  00010	b8 01 00 00 00	 mov	 eax, 1

; 824  :         }

  00015	c3		 ret	 0
$LN3@operator@3:

; 823  :             return (x.currnode == currnode) && (x.currslot == currslot);

  00016	33 c0		 xor	 eax, eax

; 824  :         }

  00018	c3		 ret	 0
??8const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBE_NABV012@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??Cconst_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPBU?$pair@IPAUstx_object@@@std@@XZ
_TEXT	SEGMENT
??Cconst_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPBU?$pair@IPAUstx_object@@@std@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator->, COMDAT
; _this$ = eax

; 728  :             temp_value = pair_to_value_type()( pair_type(key(),data()) );

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	8b 74 8a 0c	 mov	 esi, DWORD PTR [edx+ecx*4+12]
  0000b	8b 8c 8a 8c 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*4+140]
  00012	83 c0 08	 add	 eax, 8
  00015	89 30		 mov	 DWORD PTR [eax], esi
  00017	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 729  :             return &temp_value;
; 730  :         }

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??Cconst_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPBU?$pair@IPAUstx_object@@@std@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABViterator@12@@Z
_TEXT	SEGMENT
??0const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABViterator@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::const_iterator, COMDAT
; _this$ = eax
; _it$ = ecx

; 702  :         { }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  00008	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  0000c	33 c9		 xor	 ecx, ecx
  0000e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00011	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00014	c3		 ret	 0
??0const_iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABViterator@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::const_iterator::const_iterator
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->, COMDAT
; _this$ = eax

; 809  :     return &node->value(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 810  :   }

  00009	c3		 ret	 0
??C?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z
_TEXT	SEGMENT
??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=, COMDAT
; _this$ = ecx
; _x$ = eax

; 798  :     return node != x.node || position != x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0b		 jne	 SHORT $LN3@operator@4
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 03		 jne	 SHORT $LN3@operator@4
  0000e	33 c0		 xor	 eax, eax

; 799  :   }

  00010	c3		 ret	 0
$LN3@operator@4:

; 798  :     return node != x.node || position != x.position;

  00011	b8 01 00 00 00	 mov	 eax, 1

; 799  :   }

  00016	c3		 ret	 0
??9?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 795  :     return node == x.node && position == x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0e		 jne	 SHORT $LN3@operator@5
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 06		 jne	 SHORT $LN3@operator@5
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 796  :   }

  00013	c3		 ret	 0
$LN3@operator@5:

; 795  :     return node == x.node && position == x.position;

  00014	33 c0		 xor	 eax, eax

; 796  :   }

  00016	c3		 ret	 0
??8?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QBE_NABU01@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>, COMDAT
; _this$ = eax
; _x$ = ecx

; 773  :         position(x.position) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 774  :   }

  0000a	c3		 ret	 0
??0?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@btree@@QAE@ABU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > const ,std::pair<unsigned int const ,google_object *> const &,std::pair<unsigned int const ,google_object *> const *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==, COMDAT
; _this$ = eax
; _it$ = edx

; 187  :   bool operator==(const iterator& it) const { return pos == it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 94 c0	 sete	 al
  0000b	c3		 ret	 0
??8?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->, COMDAT
; _this$ = eax

; 173  :   pointer operator->() const { return &(operator*()); }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??C?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=, COMDAT
; _this$ = eax
; _it$ = edx

; 246  :   bool operator!=(const const_iterator& it) const { return pos != it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 95 c0	 setne	 al
  0000b	c3		 ret	 0
??9?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator!=
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z
_TEXT	SEGMENT
??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==, COMDAT
; _this$ = eax
; _it$ = edx

; 245  :   bool operator==(const const_iterator& it) const { return pos == it.pos; }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	33 c0		 xor	 eax, eax
  00005	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00008	0f 94 c0	 sete	 al
  0000b	c3		 ret	 0
??8?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU01@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->, COMDAT
; _this$ = eax

; 231  :   pointer operator->() const { return &(operator*()); }

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	c3		 ret	 0
??C?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBEPBU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z
_TEXT	SEGMENT
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
; _it$ = ecx

; 225  :     : ht(it.ht), pos(it.pos), end(it.end) { }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	c3		 ret	 0
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int,stx_object *> >::allocator<std::pair<unsigned int,stx_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree_map.h
_TEXT	ENDS
;	COMDAT ?get_stats@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QBEABUtree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ
_TEXT	SEGMENT
?get_stats@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QBEABUtree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::get_stats, COMDAT
; _this$ = eax

; 329  : 	return tree.get_stats();

  00000	83 c0 0c	 add	 eax, 12			; 0000000cH

; 330  :     }

  00003	c3		 ret	 0
?get_stats@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QBEABUtree_stats@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::get_stats
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00000	c3		 ret	 0
??0?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,google_object *> >::allocator<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->, COMDAT
; _this$ = eax

; 809  :     return &node->value(position);

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 10		 mov	 edx, DWORD PTR [eax]
  00005	8d 44 ca 08	 lea	 eax, DWORD PTR [edx+ecx*8+8]

; 810  :   }

  00009	c3		 ret	 0
??C?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBEPAU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z
_TEXT	SEGMENT
??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==, COMDAT
; _this$ = ecx
; _x$ = eax

; 795  :     return node == x.node && position == x.position;

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	3b 10		 cmp	 edx, DWORD PTR [eax]
  00004	75 0e		 jne	 SHORT $LN3@operator@6
  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00009	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0000c	75 06		 jne	 SHORT $LN3@operator@6
  0000e	b8 01 00 00 00	 mov	 eax, 1

; 796  :   }

  00013	c3		 ret	 0
$LN3@operator@6:

; 795  :     return node == x.node && position == x.position;

  00014	33 c0		 xor	 eax, eax

; 796  :   }

  00016	c3		 ret	 0
??8?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QBE_NABU?$btree_iterator@$$CBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@ABU?$pair@$$CBIPAUgoogle_object@@@std@@PBU34@@1@@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator==
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ
_TEXT	SEGMENT
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ PROC ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >, COMDAT
; _this$ = eax

; 195  :   btree_key_compare_to_adapter() { }

  00000	c3		 ret	 0
??0?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@QAE@XZ ENDP ; btree::btree_key_compare_to_adapter<std::less<unsigned int> >::btree_key_compare_to_adapter<std::less<unsigned int> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ
_TEXT	SEGMENT
_stats$172430 = -8					; size = 8
?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used, COMDAT
; _this$ = ecx

; 111  :   size_type bytes_used() const { return tree_.bytes_used(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b 31		 mov	 esi, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _stats$172430[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00013	8b 45 f8	 mov	 eax, DWORD PTR _stats$172430[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _stats$172430[ebp+4]
  00019	83 f8 01	 cmp	 eax, 1
  0001c	75 14		 jne	 SHORT $LN4@bytes_used@2
  0001e	85 c9		 test	 ecx, ecx
  00020	75 10		 jne	 SHORT $LN4@bytes_used@2
  00022	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00026	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]
  0002d	5e		 pop	 esi
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN4@bytes_used@2:
  00032	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00035	c1 e1 07	 shl	 ecx, 7
  00038	c1 e0 08	 shl	 eax, 8
  0003b	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?bytes_used@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBEIXZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::bytes_used
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ PROC	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>, COMDAT
; _this$ = eax

; 183  : 		{	// construct from defaults

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 184  : 		}

  0000d	c3		 ret	 0
??0?$pair@$$CBIPAUgoogle_object@@@std@@QAE@XZ ENDP	; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\libc_allocator_with_realloc.h
_TEXT	ENDS
;	COMDAT ??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT

; 58   :   ~libc_allocator_with_realloc() {}

  00000	c3		 ret	 0
??1?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::~libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ
_TEXT	SEGMENT
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ PROC ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >, COMDAT
; _this$ = eax

; 56   :   libc_allocator_with_realloc() {}

  00000	c3		 ret	 0
??0?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@QAE@XZ ENDP ; google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count, COMDAT
; _this$ = eax

; 223  :   size_type bucket_count() const      { return rep.bucket_count(); }

  00000	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00003	c3		 ret	 0
?bucket_count@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QBEIXZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::bucket_count
_TEXT	ENDS
PUBLIC	?rbt_size@@YAIPAUrbtree_t@@I@Z			; rbt_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
;	COMDAT ?rbt_size@@YAIPAUrbtree_t@@I@Z
_TEXT	SEGMENT
?rbt_size@@YAIPAUrbtree_t@@I@Z PROC			; rbt_size, COMDAT

; 2106 : 	struct rbt_object element;
; 2107 : 	(void)tree;
; 2108 : 	return count * sizeof(element.link);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00005	03 c0		 add	 eax, eax
  00007	03 c0		 add	 eax, eax
  00009	03 c0		 add	 eax, eax

; 2109 : }

  0000b	c3		 ret	 0
?rbt_size@@YAIPAUrbtree_t@@I@Z ENDP			; rbt_size
_TEXT	ENDS
PUBLIC	?stxbtree_size@@YAIPAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@@Z ; stxbtree_size
; Function compile flags: /Ogtp
;	COMDAT ?stxbtree_size@@YAIPAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@@Z
_TEXT	SEGMENT
?stxbtree_size@@YAIPAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@@Z PROC ; stxbtree_size, COMDAT

; 2097 : {

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree

; 2098 : 	return stxbtree->get_stats().leaves * sizeof(struct stxbtree_t::btree_impl::leaf_node)
; 2099 : 		+ stxbtree->get_stats().innernodes * sizeof(struct stxbtree_t::btree_impl::inner_node);

  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00009	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000c	69 c0 0c 01 00
	00		 imul	 eax, 268		; 0000010cH
  00012	69 c9 08 01 00
	00		 imul	 ecx, 264		; 00000108H
  00018	03 c1		 add	 eax, ecx

; 2100 : 	return 0;
; 2101 : }

  0001a	c3		 ret	 0
?stxbtree_size@@YAIPAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@@Z ENDP ; stxbtree_size
_TEXT	ENDS
PUBLIC	?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z ; googlebtree_size
; Function compile flags: /Ogtp
;	COMDAT ?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z
_TEXT	SEGMENT
_stats$172511 = -8					; size = 8
?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z PROC ; googlebtree_size, COMDAT

; 2090 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0000c	56		 push	 esi

; 2091 : 	return googlebtree->bytes_used();

  0000d	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000f	56		 push	 esi
  00010	8d 45 f8	 lea	 eax, DWORD PTR _stats$172511[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00019	8b 45 f8	 mov	 eax, DWORD PTR _stats$172511[ebp]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _stats$172511[ebp+4]
  0001f	83 f8 01	 cmp	 eax, 1
  00022	75 14		 jne	 SHORT $LN6@googlebtre
  00024	85 c9		 test	 ecx, ecx
  00026	75 10		 jne	 SHORT $LN6@googlebtre
  00028	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  0002c	8d 04 c5 0c 00
	00 00		 lea	 eax, DWORD PTR [eax*8+12]

; 2092 : }

  00033	5e		 pop	 esi
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0

; 2091 : 	return googlebtree->bytes_used();

$LN6@googlebtre:
  00038	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0003b	c1 e1 07	 shl	 ecx, 7
  0003e	c1 e0 08	 shl	 eax, 8
  00041	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 2092 : }

  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?googlebtree_size@@YAIPAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@Z ENDP ; googlebtree_size
_TEXT	ENDS
PUBLIC	?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z ; googledensehash_size
; Function compile flags: /Ogtp
;	COMDAT ?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z
_TEXT	SEGMENT
?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z PROC ; googledensehash_size, COMDAT

; 2083 : 	googledensehash_t::value_type element;
; 2084 : 	return googledensehash->bucket_count() * sizeof(element);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00005	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00008	03 c0		 add	 eax, eax
  0000a	03 c0		 add	 eax, eax
  0000c	03 c0		 add	 eax, eax

; 2085 : }

  0000e	c3		 ret	 0
?googledensehash_size@@YAIPAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@Z ENDP ; googledensehash_size
_TEXT	ENDS
PUBLIC	?khash_size@@YAIPAUkh_word_t@@@Z		; khash_size
; Function compile flags: /Ogtp
;	COMDAT ?khash_size@@YAIPAUkh_word_t@@@Z
_TEXT	SEGMENT
?khash_size@@YAIPAUkh_word_t@@@Z PROC			; khash_size, COMDAT

; 2074 : {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash

; 2075 : 	return khash->n_buckets * sizeof(void*) /* val */
; 2076 : 		+ khash->n_buckets * sizeof(uint32_t) /* key */
; 2077 : 		+ (khash->n_buckets >> 4) * sizeof(uint32_t); /* flags */

  00005	8b 00		 mov	 eax, DWORD PTR [eax]
  00007	8b c8		 mov	 ecx, eax
  00009	c1 e9 04	 shr	 ecx, 4
  0000c	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0000f	03 c0		 add	 eax, eax
  00011	03 c0		 add	 eax, eax

; 2078 : }

  00013	c3		 ret	 0
?khash_size@@YAIPAUkh_word_t@@@Z ENDP			; khash_size
_TEXT	ENDS
PUBLIC	?nedtrie_size@@YAIPAUnedtrie_t@@@Z		; nedtrie_size
; Function compile flags: /Ogtp
;	COMDAT ?nedtrie_size@@YAIPAUnedtrie_t@@@Z
_TEXT	SEGMENT
?nedtrie_size@@YAIPAUnedtrie_t@@@Z PROC			; nedtrie_size, COMDAT

; 2069 : 	struct nedtrie_object element;
; 2070 : 	return nedtrie->count * sizeof(element.link);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  00005	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00008	03 c0		 add	 eax, eax
  0000a	03 c0		 add	 eax, eax

; 2071 : }

  0000c	c3		 ret	 0
?nedtrie_size@@YAIPAUnedtrie_t@@@Z ENDP			; nedtrie_size
_TEXT	ENDS
PUBLIC	?uthash_size@@YAIPAUuthash_object@@@Z		; uthash_size
; Function compile flags: /Ogtp
;	COMDAT ?uthash_size@@YAIPAUuthash_object@@@Z
_TEXT	SEGMENT
?uthash_size@@YAIPAUuthash_object@@@Z PROC		; uthash_size, COMDAT

; 2056 : {

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash

; 2057 : 	UT_hash_table* table;
; 2058 : 	if (!obj)

  00005	85 c0		 test	 eax, eax
  00007	75 03		 jne	 SHORT $LN2@uthash_siz
$LN5@uthash_siz:

; 2059 : 		return 0;

  00009	33 c0		 xor	 eax, eax

; 2065 : }

  0000b	c3		 ret	 0
$LN2@uthash_siz:

; 2060 : 	table = obj->hh.tbl;

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]

; 2061 : 	if (!table)

  0000e	85 c0		 test	 eax, eax

; 2062 : 		return 0;

  00010	74 f7		 je	 SHORT $LN5@uthash_siz

; 2063 : 	return table->num_buckets * (tommy_size_t)sizeof(table->buckets[0])
; 2064 : 		+ table->num_items * (tommy_size_t)sizeof(UT_hash_handle);

  00012	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	c1 e1 05	 shl	 ecx, 5
  0001b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0001e	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 2065 : }

  00021	c3		 ret	 0
?uthash_size@@YAIPAUuthash_object@@@Z ENDP		; uthash_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV012@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator, COMDAT
; _this$ = eax
; ___that$ = ecx
  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00008	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00012	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00015	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00018	c3		 ret	 0
??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@ABV012@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator
_TEXT	ENDS
PUBLIC	?order_done@@YAXXZ				; order_done
; Function compile flags: /Ogtp
;	COMDAT ?order_done@@YAXXZ
_TEXT	SEGMENT
?order_done@@YAXXZ PROC					; order_done, COMDAT

; 725  : 	free(FORWARD);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free

; 726  : 	free(RAND0);

  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND0@@3PAIA ; RAND0
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 _free

; 727  : 	free(RAND1); 

  00017	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 _free
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 728  : }

  00026	c3		 ret	 0
?order_done@@YAXXZ ENDP					; order_done
_TEXT	ENDS
PUBLIC	?cache_clear@@YAXXZ				; cache_clear
; Function compile flags: /Ogtp
;	COMDAT ?cache_clear@@YAXXZ
_TEXT	SEGMENT
?cache_clear@@YAXXZ PROC				; cache_clear, COMDAT

; 667  : 	unsigned i;
; 668  : 
; 669  : 	/* read & write */
; 670  : 	for(i=0;i<sizeof(CACHE);i += 32)

  00000	33 c0		 xor	 eax, eax
  00002	b1 01		 mov	 cl, 1
  00004	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL3@cache_clea:

; 671  : 		CACHE[i] += 1;

  00010	00 88 00 00 00
	00		 add	 BYTE PTR ?CACHE@@3PAEA[eax], cl
  00016	83 c0 20	 add	 eax, 32			; 00000020H
  00019	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0001e	72 f0		 jb	 SHORT $LL3@cache_clea

; 672  : 
; 673  : #ifdef WIN32
; 674  : 	Sleep(0);

  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 675  : #endif
; 676  : }

  00028	c3		 ret	 0
?cache_clear@@YAXXZ ENDP				; cache_clear
_TEXT	ENDS
PUBLIC	?open@@YAPAU_iobuf@@PBD@Z			; open
; Function compile flags: /Ogtp
;	COMDAT ?open@@YAPAU_iobuf@@PBD@Z
_TEXT	SEGMENT
_buf$ = -128						; size = 128
_mode$ = 8						; size = 4
?open@@YAPAU_iobuf@@PBD@Z PROC				; open, COMDAT

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 	char buf[128];
; 650  : 	sprintf(buf, "dat_%s_%s.lst", ORDER_NAME[the_order], OPERATION_NAME[the_operation]);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00008	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0000f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00015	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0001c	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8d 4d 80	 lea	 ecx, DWORD PTR _buf$[ebp]
  00027	68 00 00 00 00	 push	 OFFSET $SG-105
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _sprintf

; 651  : 	return fopen(buf, mode);

  00032	8b 55 08	 mov	 edx, DWORD PTR _mode$[ebp]
  00035	52		 push	 edx
  00036	8d 45 80	 lea	 eax, DWORD PTR _buf$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _fopen
  0003f	83 c4 18	 add	 esp, 24			; 00000018H

; 652  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?open@@YAPAU_iobuf@@PBD@Z ENDP				; open
_TEXT	ENDS
PUBLIC	?mem@@YAXII@Z					; mem
; Function compile flags: /Ogtp
;	COMDAT ?mem@@YAXII@Z
_TEXT	SEGMENT
?mem@@YAXII@Z PROC					; mem, COMDAT
; _data$ = eax
; _v$ = esi

; 631  : 	if (!the_log) {

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00007	75 3e		 jne	 SHORT $LN1@mem

; 632  : 		printf("%10s, %10s, %12s, ", ORDER_NAME[the_order], OPERATION_NAME[the_operation], DATA_NAME[data]);

  00009	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  00010	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA+12
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0001b	51		 push	 ecx
  0001c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00023	52		 push	 edx
  00024	51		 push	 ecx
  00025	68 00 00 00 00	 push	 OFFSET $SG-103
  0002a	e8 00 00 00 00	 call	 _printf

; 633  : 		printf("%4u [byte]\n", (unsigned)(v / the_max));

  0002f	33 d2		 xor	 edx, edx
  00031	8b c6		 mov	 eax, esi
  00033	f7 35 00 00 00
	00		 div	 DWORD PTR ?the_max@@3IA	; the_max
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET $SG-104
  0003f	e8 00 00 00 00	 call	 _printf
  00044	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@mem:

; 634  : 	} 
; 635  : 
; 636  : 	LOG[the_retry][the_data][the_order][the_operation] = (unsigned)(v / the_max);

  00047	33 d2		 xor	 edx, edx
  00049	8b c6		 mov	 eax, esi
  0004b	f7 35 00 00 00
	00		 div	 DWORD PTR ?the_max@@3IA	; the_max
  00051	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  0005d	c1 e2 04	 shl	 edx, 4
  00060	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?the_data@@3IA ; the_data
  00066	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00069	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00072	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00075	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax

; 637  : }

  0007c	c3		 ret	 0
?mem@@YAXII@Z ENDP					; mem
_TEXT	ENDS
PUBLIC	?is_select@@YAHI@Z				; is_select
; Function compile flags: /Ogtp
;	COMDAT ?is_select@@YAHI@Z
_TEXT	SEGMENT
_data$ = 8						; size = 4
?is_select@@YAHI@Z PROC					; is_select, COMDAT

; 597  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 598  : 	return the_data == data;

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  00009	33 c0		 xor	 eax, eax
  0000b	3b 4d 08	 cmp	 ecx, DWORD PTR _data$[ebp]
  0000e	0f 94 c0	 sete	 al

; 599  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?is_select@@YAHI@Z ENDP					; is_select
_TEXT	ENDS
PUBLIC	?is_listed@@YAHI@Z				; is_listed
; Function compile flags: /Ogtp
;	COMDAT ?is_listed@@YAHI@Z
_TEXT	SEGMENT
?is_listed@@YAHI@Z PROC					; is_listed, COMDAT

; 587  : 	(void)data;
; 588  : 
; 589  : 	/* always have all the columns, we exclude them in the graphs */
; 590  : 	return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 591  : }

  00005	c3		 ret	 0
?is_listed@@YAHI@Z ENDP					; is_listed
_TEXT	ENDS
PUBLIC	?rnd@@YAII@Z					; rnd
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Ogtp
;	COMDAT ?rnd@@YAII@Z
_TEXT	SEGMENT
tv131 = -8						; size = 8
_max$ = 8						; size = 4
?rnd@@YAII@Z PROC					; rnd, COMDAT

; 434  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _max$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 449  : 
; 450  : 	/* it may happen as the divider is approximated down */
; 451  : 	if (r >= max)

  0000c	6a 00		 push	 0
  0000e	53		 push	 ebx
  0000f	6a ff		 push	 -1
  00011	6a ff		 push	 -1
  00013	e8 00 00 00 00	 call	 __aulldiv
  00018	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?SEED@@3_KA+4
  0001e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?SEED@@3_KA
  00024	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00027	89 55 fc	 mov	 DWORD PTR tv131[ebp+4], edx
  0002a	8d 9b 00 00 00
	00		 npad	 6
$loop$145824:

; 435  : 	unsigned r;
; 436  : 	tommy_uint64_t divider;
; 437  :     
; 438  : loop:    
; 439  : 	/* linear congruential generator from MMIX by Donald Knuth, http://en.wikipedia.org/wiki/Linear_congruential_generator */
; 440  : #ifdef _MSC_VER
; 441  : 	divider = 0xFFFFFFFFFFFFFFFF / max;
; 442  : 	SEED = SEED * 6364136223846793005 + 1442695040888963407;

  00030	68 2d f4 51 58	 push	 1481765933		; 5851f42dH
  00035	68 2d 7f 95 4c	 push	 1284865837		; 4c957f2dH
  0003a	57		 push	 edi
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 __allmul

; 443  : #else
; 444  : 	divider = 0xFFFFFFFFFFFFFFFFULL / max;
; 445  : 	SEED = SEED * 6364136223846793005LL + 1442695040888963407LL;
; 446  : #endif
; 447  :  
; 448  : 	r = (unsigned)(SEED / divider);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR tv131[ebp]
  00044	05 4f 81 67 f7	 add	 eax, -144211633		; f767814fH
  00049	8b f0		 mov	 esi, eax
  0004b	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp+4]
  0004e	50		 push	 eax
  0004f	81 d2 7e 7b 05
	14		 adc	 edx, 335903614		; 14057b7eH
  00055	51		 push	 ecx
  00056	8b fa		 mov	 edi, edx
  00058	57		 push	 edi
  00059	56		 push	 esi
  0005a	e8 00 00 00 00	 call	 __aulldiv

; 449  : 
; 450  : 	/* it may happen as the divider is approximated down */
; 451  : 	if (r >= max)

  0005f	3b c3		 cmp	 eax, ebx
  00061	73 cd		 jae	 SHORT $loop$145824

; 452  : 		goto loop;
; 453  : 
; 454  : 	return r;
; 455  : }

  00063	89 3d 04 00 00
	00		 mov	 DWORD PTR ?SEED@@3_KA+4, edi
  00069	5f		 pop	 edi
  0006a	89 35 00 00 00
	00		 mov	 DWORD PTR ?SEED@@3_KA, esi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?rnd@@YAII@Z ENDP					; rnd
_TEXT	ENDS
EXTRN	__alldiv:PROC
EXTRN	__alldvrm:PROC
_win_frequency DQ 01H DUP (?)
; Function compile flags: /Ogtp
;	COMDAT ?nano@@YA_KXZ
_TEXT	SEGMENT
tv70 = -8						; size = 8
_t$ = -8						; size = 8
?nano@@YA_KXZ PROC					; nano, COMDAT

; 372  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 373  : 	tommy_uint64_t ret;
; 374  : #if defined(_WIN32)   
; 375  : 	LARGE_INTEGER t;
; 376  : 
; 377  : 	if (!QueryPerformanceCounter(&t))

  00009	8d 45 f8	 lea	 eax, DWORD PTR _t$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00013	85 c0		 test	 eax, eax
  00015	75 09		 jne	 SHORT $LN1@nano

; 378  : 		return 0;

  00017	33 d2		 xor	 edx, edx

; 383  : #elif defined(__MACH__)
; 384  : 	mach_timebase_info_data_t info;
; 385  : 	kern_return_t r;
; 386  : 	tommy_uint64_t t;
; 387  : 
; 388  : 	t = mach_absolute_time();
; 389  : 
; 390  : 	r = mach_timebase_info(&info);
; 391  : 	if (r != 0) {
; 392  : 		abort();
; 393  : 	}
; 394  : 
; 395  : 	ret = (t / info.denom) * info.numer;
; 396  : 	
; 397  : 	ret += (t % info.denom) * info.numer / info.denom;
; 398  : #elif defined(__linux)
; 399  : 	struct timespec ts;
; 400  : 	int r;
; 401  : 
; 402  : 	r = clock_gettime(CLOCK_MONOTONIC, &ts);
; 403  : 	if (r != 0) {
; 404  : 		abort();
; 405  : 	}
; 406  : 
; 407  : 	ret = ts.tv_sec * (tommy_uint64_t)1000000000 + ts.tv_nsec;
; 408  : #else
; 409  : 	struct timeval tv;
; 410  : 	int r;
; 411  : 
; 412  : 	r = gettimeofday(&tv, 0);
; 413  : 	if (r != 0) {
; 414  : 		abort();
; 415  : 	}
; 416  : 
; 417  : 	ret = tv.tv_sec * (tommy_uint64_t)1000000000 + tv.tv_usec * 1000;
; 418  : #endif
; 419  : 	return ret;
; 420  : }

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
$LN1@nano:

; 379  : 
; 380  : 	ret = (t.QuadPart / win_frequency.QuadPart) * 1000000000;
; 381  : 
; 382  : 	ret += (t.QuadPart % win_frequency.QuadPart) * 1000000000 / win_frequency.QuadPart;

  00020	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00026	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _t$[ebp+4]
  0002f	8b 55 f8	 mov	 edx, DWORD PTR _t$[ebp]
  00032	56		 push	 esi
  00033	57		 push	 edi
  00034	51		 push	 ecx
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 __alldvrm
  0003b	6a 00		 push	 0
  0003d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00042	53		 push	 ebx
  00043	51		 push	 ecx
  00044	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00047	89 55 fc	 mov	 DWORD PTR tv70[ebp+4], edx
  0004a	e8 00 00 00 00	 call	 __allmul
  0004f	56		 push	 esi
  00050	57		 push	 edi
  00051	52		 push	 edx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __alldiv
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  0005b	6a 00		 push	 0
  0005d	8b f0		 mov	 esi, eax
  0005f	8b 45 fc	 mov	 eax, DWORD PTR tv70[ebp+4]
  00062	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	8b fa		 mov	 edi, edx
  0006b	e8 00 00 00 00	 call	 __allmul
  00070	03 c6		 add	 eax, esi
  00072	13 d7		 adc	 edx, edi

; 383  : #elif defined(__MACH__)
; 384  : 	mach_timebase_info_data_t info;
; 385  : 	kern_return_t r;
; 386  : 	tommy_uint64_t t;
; 387  : 
; 388  : 	t = mach_absolute_time();
; 389  : 
; 390  : 	r = mach_timebase_info(&info);
; 391  : 	if (r != 0) {
; 392  : 		abort();
; 393  : 	}
; 394  : 
; 395  : 	ret = (t / info.denom) * info.numer;
; 396  : 	
; 397  : 	ret += (t % info.denom) * info.numer / info.denom;
; 398  : #elif defined(__linux)
; 399  : 	struct timespec ts;
; 400  : 	int r;
; 401  : 
; 402  : 	r = clock_gettime(CLOCK_MONOTONIC, &ts);
; 403  : 	if (r != 0) {
; 404  : 		abort();
; 405  : 	}
; 406  : 
; 407  : 	ret = ts.tv_sec * (tommy_uint64_t)1000000000 + ts.tv_nsec;
; 408  : #else
; 409  : 	struct timeval tv;
; 410  : 	int r;
; 411  : 
; 412  : 	r = gettimeofday(&tv, 0);
; 413  : 	if (r != 0) {
; 414  : 		abort();
; 415  : 	}
; 416  : 
; 417  : 	ret = tv.tv_sec * (tommy_uint64_t)1000000000 + tv.tv_usec * 1000;
; 418  : #endif
; 419  : 	return ret;
; 420  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
?nano@@YA_KXZ ENDP					; nano
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nano_init@@YAXXZ
_TEXT	SEGMENT
?nano_init@@YAXXZ PROC					; nano_init, COMDAT

; 364  : #if defined(_WIN32)
; 365  : 	if (!QueryPerformanceFrequency(&win_frequency)) {

  00000	68 00 00 00 00	 push	 OFFSET _win_frequency
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  0000b	85 c0		 test	 eax, eax
  0000d	75 0c		 jne	 SHORT $LN1@nano_init

; 366  : 		win_frequency.QuadPart = 0;

  0000f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00013	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _win_frequency, xmm0
$LN1@nano_init:

; 367  : 	}
; 368  : #endif
; 369  : }

  0001b	c3		 ret	 0
?nano_init@@YAXXZ ENDP					; nano_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_del_word@@YAXPAUkh_word_t@@I@Z
_TEXT	SEGMENT
?kh_del_word@@YAXPAUkh_word_t@@I@Z PROC			; kh_del_word, COMDAT
; _x$ = eax

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00007	3b 06		 cmp	 eax, DWORD PTR [esi]
  00009	74 2a		 je	 SHORT $LN1@kh_del_wor
  0000b	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000e	8b c8		 mov	 ecx, eax
  00010	83 e0 0f	 and	 eax, 15			; 0000000fH
  00013	c1 e9 04	 shr	 ecx, 4
  00016	57		 push	 edi
  00017	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]
  0001a	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0001d	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00020	8b cf		 mov	 ecx, edi
  00022	d3 e8		 shr	 eax, cl
  00024	a8 03		 test	 al, 3
  00026	75 0c		 jne	 SHORT $LN4@kh_del_wor
  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	d3 e0		 shl	 eax, cl
  0002f	09 02		 or	 DWORD PTR [edx], eax
  00031	ff 4e 04	 dec	 DWORD PTR [esi+4]
$LN4@kh_del_wor:
  00034	5f		 pop	 edi
$LN1@kh_del_wor:
  00035	5e		 pop	 esi
  00036	c3		 ret	 0
?kh_del_word@@YAXPAUkh_word_t@@I@Z ENDP			; kh_del_word
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@41f0000000000000
EXTRN	_memset:PROC
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?kh_resize_word@@YAXPAUkh_word_t@@I@Z
_TEXT	SEGMENT
tv552 = -28						; size = 8
tv558 = -24						; size = 4
tv397 = -24						; size = 4
_tmp$145634 = -20					; size = 4
_tmp$145632 = -20					; size = 4
tv554 = -16						; size = 4
_j$ = -16						; size = 4
_new_flags$ = -12					; size = 4
_val$145617 = -8					; size = 4
_key$145616 = -4					; size = 4
tv557 = -2						; size = 2
_new_n_buckets$ = 8					; size = 4
?kh_resize_word@@YAXPAUkh_word_t@@I@Z PROC		; kh_resize_word, COMDAT
; _h$ = edi

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	b8 1f 00 00 00	 mov	 eax, 31			; 0000001fH
  0000e	83 f9 fb	 cmp	 ecx, -5			; fffffffbH
  00011	73 0a		 jae	 SHORT $LN23@kh_resize_
$LL24@kh_resize_:
  00013	48		 dec	 eax
  00014	39 0c 85 00 00
	00 00		 cmp	 DWORD PTR ___ac_prime_list[eax*4], ecx
  0001b	77 f6		 ja	 SHORT $LL24@kh_resize_
$LN23@kh_resize_:
  0001d	56		 push	 esi
  0001e	8b 34 85 04 00
	00 00		 mov	 esi, DWORD PTR ___ac_prime_list[eax*4+4]
  00025	8b c6		 mov	 eax, esi
  00027	89 45 e8	 mov	 DWORD PTR tv558[ebp], eax
  0002a	db 45 e8	 fild	 DWORD PTR tv558[ebp]
  0002d	89 75 08	 mov	 DWORD PTR _new_n_buckets$[ebp], esi
  00030	85 c0		 test	 eax, eax
  00032	79 06		 jns	 SHORT $LN36@kh_resize_
  00034	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN36@kh_resize_:
  0003a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR ___ac_HASH_UPPER
  00040	d9 7d fe	 fnstcw	 WORD PTR tv557[ebp]
  00043	0f b7 45 fe	 movzx	 eax, WORD PTR tv557[ebp]
  00047	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  0004d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00052	89 45 f0	 mov	 DWORD PTR tv554[ebp], eax
  00055	d9 6d f0	 fldcw	 WORD PTR tv554[ebp]
  00058	df 7d e4	 fistp	 QWORD PTR tv552[ebp]
  0005b	8b 45 e4	 mov	 eax, DWORD PTR tv552[ebp]
  0005e	89 45 e8	 mov	 DWORD PTR tv397[ebp], eax
  00061	d9 6d fe	 fldcw	 WORD PTR tv557[ebp]
  00064	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  00067	0f 83 c6 01 00
	00		 jae	 $LN18@kh_resize_
  0006d	8b ce		 mov	 ecx, esi
  0006f	c1 e9 04	 shr	 ecx, 4
  00072	53		 push	 ebx
  00073	8d 1c 8d 04 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4+4]
  0007a	53		 push	 ebx
  0007b	e8 00 00 00 00	 call	 _malloc
  00080	53		 push	 ebx
  00081	68 aa 00 00 00	 push	 170			; 000000aaH
  00086	50		 push	 eax
  00087	89 45 f4	 mov	 DWORD PTR _new_flags$[ebp], eax
  0008a	e8 00 00 00 00	 call	 _memset
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	39 37		 cmp	 DWORD PTR [edi], esi
  00094	73 24		 jae	 SHORT $LN33@kh_resize_
  00096	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00099	8d 1c b5 00 00
	00 00		 lea	 ebx, DWORD PTR [esi*4]
  000a0	53		 push	 ebx
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 _realloc
  000a7	89 47 14	 mov	 DWORD PTR [edi+20], eax
  000aa	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000ad	53		 push	 ebx
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _realloc
  000b4	83 c4 10	 add	 esp, 16			; 00000010H
  000b7	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN33@kh_resize_:
  000ba	33 c0		 xor	 eax, eax
  000bc	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax
  000bf	39 07		 cmp	 DWORD PTR [edi], eax
  000c1	0f 84 23 01 00
	00		 je	 $LN15@kh_resize_
$LL17@kh_resize_:
  000c7	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  000ca	8b c8		 mov	 ecx, eax
  000cc	c1 e9 04	 shr	 ecx, 4
  000cf	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  000d2	8b 16		 mov	 edx, DWORD PTR [esi]
  000d4	8b c8		 mov	 ecx, eax
  000d6	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000d9	03 c9		 add	 ecx, ecx
  000db	d3 ea		 shr	 edx, cl
  000dd	f6 c2 03	 test	 dl, 3
  000e0	0f 85 f5 00 00
	00		 jne	 $LN35@kh_resize_
  000e6	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  000e9	8b 1c 82	 mov	 ebx, DWORD PTR [edx+eax*4]
  000ec	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  000ef	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  000f2	ba 01 00 00 00	 mov	 edx, 1
  000f7	d3 e2		 shl	 edx, cl
  000f9	89 45 f8	 mov	 DWORD PTR _val$145617[ebp], eax
  000fc	09 16		 or	 DWORD PTR [esi], edx
$LN37@kh_resize_:
  000fe	33 d2		 xor	 edx, edx
  00100	8b c3		 mov	 eax, ebx
  00102	f7 75 08	 div	 DWORD PTR _new_n_buckets$[ebp]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00108	49		 dec	 ecx
  00109	8b c3		 mov	 eax, ebx
  0010b	89 5d fc	 mov	 DWORD PTR _key$145616[ebp], ebx
  0010e	8b 5d f4	 mov	 ebx, DWORD PTR _new_flags$[ebp]
  00111	8b f2		 mov	 esi, edx
  00113	33 d2		 xor	 edx, edx
  00115	f7 f1		 div	 ecx
  00117	8b c6		 mov	 eax, esi
  00119	c1 e8 04	 shr	 eax, 4
  0011c	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0011f	8b ce		 mov	 ecx, esi
  00121	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00124	03 c9		 add	 ecx, ecx
  00126	d3 e8		 shr	 eax, cl
  00128	a8 02		 test	 al, 2
  0012a	75 2f		 jne	 SHORT $LN9@kh_resize_
  0012c	8d 64 24 00	 npad	 4
$LL10@kh_resize_:
  00130	8b 4d 08	 mov	 ecx, DWORD PTR _new_n_buckets$[ebp]
  00133	8d 44 32 01	 lea	 eax, DWORD PTR [edx+esi+1]
  00137	3b c1		 cmp	 eax, ecx
  00139	72 09		 jb	 SHORT $LN8@kh_resize_
  0013b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0013e	2b c1		 sub	 eax, ecx
  00140	03 f0		 add	 esi, eax
  00142	eb 02		 jmp	 SHORT $LN7@kh_resize_
$LN8@kh_resize_:
  00144	8b f0		 mov	 esi, eax
$LN7@kh_resize_:
  00146	8b c6		 mov	 eax, esi
  00148	c1 e8 04	 shr	 eax, 4
  0014b	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0014e	8b ce		 mov	 ecx, esi
  00150	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00153	03 c9		 add	 ecx, ecx
  00155	d3 e8		 shr	 eax, cl
  00157	a8 02		 test	 al, 2
  00159	74 d5		 je	 SHORT $LL10@kh_resize_
$LN9@kh_resize_:
  0015b	8b 55 f4	 mov	 edx, DWORD PTR _new_flags$[ebp]
  0015e	8b ce		 mov	 ecx, esi
  00160	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00163	03 c9		 add	 ecx, ecx
  00165	bb 02 00 00 00	 mov	 ebx, 2
  0016a	8b c6		 mov	 eax, esi
  0016c	c1 e8 04	 shr	 eax, 4
  0016f	d3 e3		 shl	 ebx, cl
  00171	03 c0		 add	 eax, eax
  00173	03 c0		 add	 eax, eax
  00175	f7 d3		 not	 ebx
  00177	21 1c 10	 and	 DWORD PTR [eax+edx], ebx
  0017a	3b 37		 cmp	 esi, DWORD PTR [edi]
  0017c	73 48		 jae	 SHORT $LN34@kh_resize_
  0017e	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00181	8b 14 10	 mov	 edx, DWORD PTR [eax+edx]
  00184	d3 ea		 shr	 edx, cl
  00186	f6 c2 03	 test	 dl, 3
  00189	75 3b		 jne	 SHORT $LN34@kh_resize_
  0018b	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0018e	8b 1c b2	 mov	 ebx, DWORD PTR [edx+esi*4]
  00191	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  00194	89 5d ec	 mov	 DWORD PTR _tmp$145632[ebp], ebx
  00197	8b 5d fc	 mov	 ebx, DWORD PTR _key$145616[ebp]
  0019a	89 1a		 mov	 DWORD PTR [edx], ebx
  0019c	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  0019f	8b 5d ec	 mov	 ebx, DWORD PTR _tmp$145632[ebp]
  001a2	8d 14 b2	 lea	 edx, DWORD PTR [edx+esi*4]
  001a5	8b 32		 mov	 esi, DWORD PTR [edx]
  001a7	89 75 ec	 mov	 DWORD PTR _tmp$145634[ebp], esi
  001aa	8b 75 f8	 mov	 esi, DWORD PTR _val$145617[ebp]
  001ad	89 32		 mov	 DWORD PTR [edx], esi
  001af	8b 55 ec	 mov	 edx, DWORD PTR _tmp$145634[ebp]
  001b2	03 47 10	 add	 eax, DWORD PTR [edi+16]
  001b5	89 55 f8	 mov	 DWORD PTR _val$145617[ebp], edx
  001b8	ba 01 00 00 00	 mov	 edx, 1
  001bd	d3 e2		 shl	 edx, cl
  001bf	09 10		 or	 DWORD PTR [eax], edx
  001c1	e9 38 ff ff ff	 jmp	 $LN37@kh_resize_
$LN34@kh_resize_:
  001c6	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  001c9	8b 4d fc	 mov	 ecx, DWORD PTR _key$145616[ebp]
  001cc	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _val$145617[ebp]
  001d2	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  001d5	89 04 b2	 mov	 DWORD PTR [edx+esi*4], eax
  001d8	8b 45 f0	 mov	 eax, DWORD PTR _j$[ebp]
$LN35@kh_resize_:
  001db	8b 75 08	 mov	 esi, DWORD PTR _new_n_buckets$[ebp]
  001de	40		 inc	 eax
  001df	89 45 f0	 mov	 DWORD PTR _j$[ebp], eax
  001e2	3b 07		 cmp	 eax, DWORD PTR [edi]
  001e4	0f 85 dd fe ff
	ff		 jne	 $LL17@kh_resize_
$LN15@kh_resize_:
  001ea	39 37		 cmp	 DWORD PTR [edi], esi
  001ec	76 24		 jbe	 SHORT $LN1@kh_resize_
  001ee	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  001f1	8d 1c b5 00 00
	00 00		 lea	 ebx, DWORD PTR [esi*4]
  001f8	53		 push	 ebx
  001f9	51		 push	 ecx
  001fa	e8 00 00 00 00	 call	 _realloc
  001ff	8b 57 18	 mov	 edx, DWORD PTR [edi+24]
  00202	53		 push	 ebx
  00203	52		 push	 edx
  00204	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00207	e8 00 00 00 00	 call	 _realloc
  0020c	83 c4 10	 add	 esp, 16			; 00000010H
  0020f	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN1@kh_resize_:
  00212	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00215	50		 push	 eax
  00216	e8 00 00 00 00	 call	 _free
  0021b	8b 4d f4	 mov	 ecx, DWORD PTR _new_flags$[ebp]
  0021e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00221	8b 45 e8	 mov	 eax, DWORD PTR tv397[ebp]
  00224	83 c4 04	 add	 esp, 4
  00227	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  0022a	89 37		 mov	 DWORD PTR [edi], esi
  0022c	89 57 08	 mov	 DWORD PTR [edi+8], edx
  0022f	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00232	5b		 pop	 ebx
$LN18@kh_resize_:
  00233	5e		 pop	 esi
  00234	8b e5		 mov	 esp, ebp
  00236	5d		 pop	 ebp
  00237	c3		 ret	 0
?kh_resize_word@@YAXPAUkh_word_t@@I@Z ENDP		; kh_resize_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_get_word@@YAIPAUkh_word_t@@I@Z
_TEXT	SEGMENT
tv225 = -4						; size = 4
_last$145579 = -4					; size = 4
_key$ = 8						; size = 4
?kh_get_word@@YAIPAUkh_word_t@@I@Z PROC			; kh_get_word, COMDAT

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 4d 08	 mov	 ecx, DWORD PTR _key$[ebp]
  00007	53		 push	 ebx
  00008	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0000e	57		 push	 edi
  0000f	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00011	85 ff		 test	 edi, edi
  00013	0f 84 a1 00 00
	00		 je	 $LN8@kh_get_wor
  00019	8b c1		 mov	 eax, ecx
  0001b	33 d2		 xor	 edx, edx
  0001d	f7 f7		 div	 edi
  0001f	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  00022	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00025	89 45 fc	 mov	 DWORD PTR tv225[ebp], eax
  00028	8b c1		 mov	 eax, ecx
  0002a	56		 push	 esi
  0002b	8b f2		 mov	 esi, edx
  0002d	33 d2		 xor	 edx, edx
  0002f	f7 75 fc	 div	 DWORD PTR tv225[ebp]
  00032	8b c6		 mov	 eax, esi
  00034	c1 e8 04	 shr	 eax, 4
  00037	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0003a	8b ce		 mov	 ecx, esi
  0003c	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0003f	03 c9		 add	 ecx, ecx
  00041	d3 e8		 shr	 eax, cl
  00043	89 75 fc	 mov	 DWORD PTR _last$145579[ebp], esi
  00046	a8 02		 test	 al, 2
  00048	75 47		 jne	 SHORT $LN6@kh_get_wor
  0004a	8d 9b 00 00 00
	00		 npad	 6
$LL7@kh_get_wor:
  00050	a8 01		 test	 al, 1
  00052	75 10		 jne	 SHORT $LN5@kh_get_wor
  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005c	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0005f	39 04 b1	 cmp	 DWORD PTR [ecx+esi*4], eax
  00062	74 2d		 je	 SHORT $LN6@kh_get_wor
$LN5@kh_get_wor:
  00064	8d 44 32 01	 lea	 eax, DWORD PTR [edx+esi+1]
  00068	3b c7		 cmp	 eax, edi
  0006a	72 09		 jb	 SHORT $LN4@kh_get_wor
  0006c	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0006f	2b cf		 sub	 ecx, edi
  00071	03 f1		 add	 esi, ecx
  00073	eb 02		 jmp	 SHORT $LN3@kh_get_wor
$LN4@kh_get_wor:
  00075	8b f0		 mov	 esi, eax
$LN3@kh_get_wor:
  00077	3b 75 fc	 cmp	 esi, DWORD PTR _last$145579[ebp]
  0007a	74 35		 je	 SHORT $LN14@kh_get_wor
  0007c	8b c6		 mov	 eax, esi
  0007e	c1 e8 04	 shr	 eax, 4
  00081	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  00084	8b ce		 mov	 ecx, esi
  00086	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00089	03 c9		 add	 ecx, ecx
  0008b	d3 e8		 shr	 eax, cl
  0008d	a8 02		 test	 al, 2
  0008f	74 bf		 je	 SHORT $LL7@kh_get_wor
$LN6@kh_get_wor:
  00091	8b d6		 mov	 edx, esi
  00093	8b ce		 mov	 ecx, esi
  00095	c1 ea 04	 shr	 edx, 4
  00098	8b 04 93	 mov	 eax, DWORD PTR [ebx+edx*4]
  0009b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0009e	03 c9		 add	 ecx, ecx
  000a0	d3 e8		 shr	 eax, cl
  000a2	a8 03		 test	 al, 3
  000a4	8b c7		 mov	 eax, edi
  000a6	75 02		 jne	 SHORT $LN15@kh_get_wor
  000a8	8b c6		 mov	 eax, esi
$LN15@kh_get_wor:
  000aa	5e		 pop	 esi
  000ab	5f		 pop	 edi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
$LN14@kh_get_wor:
  000b1	5e		 pop	 esi
  000b2	8b c7		 mov	 eax, edi
  000b4	5f		 pop	 edi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN8@kh_get_wor:
  000ba	5f		 pop	 edi
  000bb	33 c0		 xor	 eax, eax
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?kh_get_word@@YAIPAUkh_word_t@@I@Z ENDP			; kh_get_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_destroy_word@@YAXPAUkh_word_t@@@Z
_TEXT	SEGMENT
?kh_destroy_word@@YAXPAUkh_word_t@@@Z PROC		; kh_destroy_word, COMDAT

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00007	85 f6		 test	 esi, esi
  00009	74 24		 je	 SHORT $LN1@kh_destroy
  0000b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _free
  00014	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _free
  0001d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _free
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 _free
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@kh_destroy:
  0002f	5e		 pop	 esi
  00030	c3		 ret	 0
?kh_destroy_word@@YAXPAUkh_word_t@@@Z ENDP		; kh_destroy_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_init_word@@YAPAUkh_word_t@@XZ
_TEXT	SEGMENT
?kh_init_word@@YAPAUkh_word_t@@XZ PROC			; kh_init_word, COMDAT

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	6a 1c		 push	 28			; 0000001cH
  00002	6a 01		 push	 1
  00004	e8 00 00 00 00	 call	 _calloc
  00009	83 c4 08	 add	 esp, 8
  0000c	c3		 ret	 0
?kh_init_word@@YAPAUkh_word_t@@XZ ENDP			; kh_init_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z
_TEXT	SEGMENT
?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z PROC	; nedtrie_t_nobblezeros, COMDAT

; 304  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?nedtrie_t_nobblezeros@@YAHPAUnedtrie_t@@@Z ENDP	; nedtrie_t_nobblezeros
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_func@@YAIPBUnedtrie_object@@@Z
_TEXT	SEGMENT
?nedtrie_func@@YAIPBUnedtrie_object@@@Z PROC		; nedtrie_func, COMDAT
; _r$ = eax

; 301  : 	return r->value;

  00000	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 302  : }

  00003	c3		 ret	 0
?nedtrie_func@@YAIPBUnedtrie_object@@@Z ENDP		; nedtrie_func
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_new@@YAXPAUrbtree_t@@@Z
_TEXT	SEGMENT
?rbt_new@@YAXPAUrbtree_t@@@Z PROC			; rbt_new, COMDAT

; 295  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A+8
  00005	b9 04 00 00 00	 mov	 ecx, OFFSET ?tree@@3Urbtree_t@@A+4
  0000a	83 e0 01	 and	 eax, 1
  0000d	0b c1		 or	 eax, ecx
  0000f	83 c8 01	 or	 eax, 1
  00012	83 e0 fe	 and	 eax, -2			; fffffffeH
  00015	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
  0001b	89 0d 04 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+4, ecx
  00021	a3 08 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+8, eax
  00026	c3		 ret	 0
?rbt_new@@YAXPAUrbtree_t@@@Z ENDP			; rbt_new
_TEXT	ENDS
PUBLIC	?tommy_hashtable_compare@@YAHPBX0@Z		; tommy_hashtable_compare
; Function compile flags: /Ogtp
;	COMDAT ?tommy_hashtable_compare@@YAHPBX0@Z
_TEXT	SEGMENT
_void_arg$ = 8						; size = 4
_void_obj$ = 12						; size = 4
?tommy_hashtable_compare@@YAHPBX0@Z PROC		; tommy_hashtable_compare, COMDAT

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  : 	const unsigned* arg = (const unsigned*)void_arg;
; 285  : 	const struct hashtable_object* obj = (const struct hashtable_object*)void_obj;
; 286  : 
; 287  : 	if (*arg == obj->value)

  00003	8b 45 08	 mov	 eax, DWORD PTR _void_arg$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR _void_obj$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 4a 10	 cmp	 ecx, DWORD PTR [edx+16]
  00010	0f 95 c0	 setne	 al

; 288  : 		return 0;
; 289  : 
; 290  : 	return 1;
; 291  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?tommy_hashtable_compare@@YAHPBX0@Z ENDP		; tommy_hashtable_compare
_TEXT	ENDS
PUBLIC	?rbt_compare@@YAHPBX0@Z				; rbt_compare
; Function compile flags: /Ogtp
;	COMDAT ?rbt_compare@@YAHPBX0@Z
_TEXT	SEGMENT
?rbt_compare@@YAHPBX0@Z PROC				; rbt_compare, COMDAT
; _void_a$ = eax
; _void_b$ = ecx

; 269  : 	const struct rbt_object* a = (const struct rbt_object*)void_a;
; 270  : 	const struct rbt_object* b = (const struct rbt_object*)void_b;
; 271  : 
; 272  : 	int va = a->value;

  00000	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 273  : 	int vb = b->value;

  00003	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 274  : 
; 275  : 	if (va < vb)

  00006	3b c1		 cmp	 eax, ecx
  00008	7d 04		 jge	 SHORT $LN2@rbt_compar

; 276  : 		return -1;

  0000a	83 c8 ff	 or	 eax, -1

; 278  : 		return 1;
; 279  : 	return 0;
; 280  : }

  0000d	c3		 ret	 0
$LN2@rbt_compar:

; 277  : 	if (va > vb)

  0000e	33 d2		 xor	 edx, edx
  00010	3b c1		 cmp	 eax, ecx
  00012	0f 9f c2	 setg	 dl
  00015	8b c2		 mov	 eax, edx

; 278  : 		return 1;
; 279  : 	return 0;
; 280  : }

  00017	c3		 ret	 0
?rbt_compare@@YAHPBX0@Z ENDP				; rbt_compare
_TEXT	ENDS
PUBLIC	?judy_last@@YAPAIPAUJudy@@III@Z			; judy_last
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_last@@YAPAIPAUJudy@@III@Z
_TEXT	SEGMENT
_node$ = -4						; size = 4
_off$ = 8						; size = 4
_depth$ = 12						; size = 4
?judy_last@@YAPAIPAUJudy@@III@Z PROC			; judy_last, COMDAT
; _judy$ = ecx
; _next$ = eax

; 904  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR _off$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f8		 mov	 edi, eax

; 905  : JudySlot *table, *inner;
; 906  : uint keysize, size;
; 907  : JudySlot *node;
; 908  : int slot, cnt;
; 909  : uchar *base;
; 910  : 
; 911  : 	while( next ) {

  0000c	85 ff		 test	 edi, edi
  0000e	0f 84 22 01 00
	00		 je	 $LN22@judy_last
$LL23@judy_last:

; 912  : 		if( judy->level < judy->max )

  00014	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00017	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  0001a	73 04		 jae	 SHORT $LN21@judy_last

; 913  : 			judy->level++;

  0001c	40		 inc	 eax
  0001d	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$LN21@judy_last:

; 914  : 
; 915  : 		judy->stack[judy->level].next = next;

  00020	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00023	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00026	89 7c 81 34	 mov	 DWORD PTR [ecx+eax*4+52], edi

; 916  : 		judy->stack[judy->level].off = off;

  0002a	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0002d	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00030	89 5c 91 38	 mov	 DWORD PTR [ecx+edx*4+56], ebx

; 917  : 		size = JudySize[next & 0x07];

  00034	8b d7		 mov	 edx, edi
  00036	83 e2 07	 and	 edx, 7
  00039	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edx*4]

; 918  : 		switch( next & 0x07 ) {

  00040	83 fa 07	 cmp	 edx, 7
  00043	0f 87 e5 00 00
	00		 ja	 $LN37@judy_last
  00049	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN43@judy_last[edx*4]
$LN18@judy_last:

; 919  : 		case JUDY_1:
; 920  : 		case JUDY_2:
; 921  : 		case JUDY_4:
; 922  : 		case JUDY_8:
; 923  : 		case JUDY_16:
; 924  : 		case JUDY_32:
; 925  : #ifdef ASKITIS
; 926  : 		case JUDY_64:
; 927  : #endif
; 928  : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  00050	83 e3 03	 and	 ebx, 3

; 929  : 			slot = size / (sizeof(JudySlot) + keysize);
; 930  : 			base = (uchar *)(next & JUDY_mask);
; 931  : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00053	83 e7 f8	 and	 edi, -8			; fffffff8H
  00056	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00059	89 55 fc	 mov	 DWORD PTR _node$[ebp], edx
  0005c	be 04 00 00 00	 mov	 esi, 4
  00061	33 d2		 xor	 edx, edx
  00063	2b f3		 sub	 esi, ebx
  00065	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
  00068	f7 f3		 div	 ebx

; 932  : 			judy->stack[judy->level].slot = --slot;

  0006a	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0006d	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  00071	48		 dec	 eax
  00072	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 933  : 
; 934  : #if BYTE_ORDER != BIG_ENDIAN
; 935  : 			if( !judy->depth && !base[slot * keysize] || judy->depth && ++depth == judy->depth )

  00075	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00078	85 d2		 test	 edx, edx
  0007a	75 12		 jne	 SHORT $LN39@judy_last
  0007c	8b d8		 mov	 ebx, eax
  0007e	0f af de	 imul	 ebx, esi
  00081	38 14 3b	 cmp	 BYTE PTR [ebx+edi], dl
  00084	0f 84 b5 00 00
	00		 je	 $LN16@judy_last
  0008a	85 d2		 test	 edx, edx
  0008c	74 0f		 je	 SHORT $LN34@judy_last
$LN39@judy_last:
  0008e	8b 7d 0c	 mov	 edi, DWORD PTR _depth$[ebp]
  00091	47		 inc	 edi
  00092	89 7d 0c	 mov	 DWORD PTR _depth$[ebp], edi
  00095	3b fa		 cmp	 edi, edx
  00097	0f 84 a2 00 00
	00		 je	 $LN16@judy_last
$LN34@judy_last:

; 940  : 
; 941  : 			next = node[-slot-1];
; 942  : 			off += keysize;

  0009d	8b 5d 08	 mov	 ebx, DWORD PTR _off$[ebp]
  000a0	8d 14 85 04 00
	00 00		 lea	 edx, DWORD PTR [eax*4+4]
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  000aa	2b c2		 sub	 eax, edx
  000ac	8b 38		 mov	 edi, DWORD PTR [eax]
  000ae	03 de		 add	 ebx, esi

; 943  : 			continue;

  000b0	eb 79		 jmp	 SHORT $LN40@judy_last
$LN14@judy_last:

; 944  : 
; 945  : 		case JUDY_radix:
; 946  : 			table = (JudySlot *)(next & JUDY_mask);

  000b2	8b f7		 mov	 esi, edi

; 947  : 			off++;

  000b4	43		 inc	 ebx
  000b5	83 e6 f8	 and	 esi, -8			; fffffff8H

; 948  : 
; 949  : 			if( judy->depth )

  000b8	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  000bc	89 5d 08	 mov	 DWORD PTR _off$[ebp], ebx
  000bf	74 08		 je	 SHORT $LN12@judy_last

; 950  : 			  if( !(off & JUDY_key_mask) )

  000c1	f6 c3 03	 test	 bl, 3
  000c4	75 03		 jne	 SHORT $LN12@judy_last

; 951  : 				depth++;

  000c6	ff 45 0c	 inc	 DWORD PTR _depth$[ebp]
$LN12@judy_last:

; 952  : 
; 953  : 			for( slot = 256; slot--; ) {

  000c9	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000ce	8b ff		 npad	 2
$LL11@judy_last:

; 954  : 			  judy->stack[judy->level].slot = slot;

  000d0	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  000d3	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000d7	4a		 dec	 edx
  000d8	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 955  : 			  if( (inner = (JudySlot *)(table[slot >> 4] & JUDY_mask)) ) {

  000db	8b c2		 mov	 eax, edx
  000dd	c1 f8 04	 sar	 eax, 4
  000e0	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000e3	83 e0 f8	 and	 eax, -8			; fffffff8H
  000e6	74 22		 je	 SHORT $LN9@judy_last

; 956  : 				if( (next = inner[slot & 0x0F]) )

  000e8	8b fa		 mov	 edi, edx
  000ea	83 e7 0f	 and	 edi, 15			; 0000000fH
  000ed	8b 3c b8	 mov	 edi, DWORD PTR [eax+edi*4]
  000f0	85 ff		 test	 edi, edi
  000f2	74 1c		 je	 SHORT $LN3@judy_last

; 957  : 				  if( !judy->depth && !slot || judy->depth && depth == judy->depth )

  000f4	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  000f7	85 f6		 test	 esi, esi
  000f9	75 08		 jne	 SHORT $LN42@judy_last
  000fb	85 d2		 test	 edx, edx
  000fd	74 39		 je	 SHORT $LN24@judy_last
  000ff	85 f6		 test	 esi, esi
  00101	74 2b		 je	 SHORT $LN37@judy_last
$LN42@judy_last:
  00103	39 75 0c	 cmp	 DWORD PTR _depth$[ebp], esi
  00106	74 30		 je	 SHORT $LN24@judy_last

; 963  : 			}
; 964  : 			continue;

  00108	eb 24		 jmp	 SHORT $LN37@judy_last
$LN9@judy_last:

; 958  : 					return &inner[0];
; 959  : 				  else
; 960  : 					break;
; 961  : 			  } else
; 962  : 				slot &= 0xF0;

  0010a	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
$LN3@judy_last:

; 952  : 
; 953  : 			for( slot = 256; slot--; ) {

  00110	85 d2		 test	 edx, edx
  00112	75 bc		 jne	 SHORT $LL11@judy_last

; 969  : 			base = (uchar *)(next & JUDY_mask);
; 970  : 			cnt = JUDY_span_bytes;
; 971  : 			if( !base[cnt - 1] )	// leaf node?

  00114	eb 18		 jmp	 SHORT $LN37@judy_last
$LN2@judy_last:

; 965  : 
; 966  : #ifndef ASKITIS
; 967  : 		case JUDY_span:
; 968  : 			node = (JudySlot *)((next & JUDY_mask) + JudySize[JUDY_span]);

  00116	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  0011b	83 e7 f8	 and	 edi, -8			; fffffff8H

; 969  : 			base = (uchar *)(next & JUDY_mask);
; 970  : 			cnt = JUDY_span_bytes;
; 971  : 			if( !base[cnt - 1] )	// leaf node?

  0011e	80 7f 1b 00	 cmp	 BYTE PTR [edi+27], 0
  00122	74 2e		 je	 SHORT $LN32@judy_last

; 973  : 			next = node[-1];

  00124	8b 7c 07 fc	 mov	 edi, DWORD PTR [edi+eax-4]

; 974  : 			off += cnt;

  00128	83 c3 1c	 add	 ebx, 28			; 0000001cH
$LN40@judy_last:
  0012b	89 5d 08	 mov	 DWORD PTR _off$[ebp], ebx
$LN37@judy_last:

; 905  : JudySlot *table, *inner;
; 906  : uint keysize, size;
; 907  : JudySlot *node;
; 908  : int slot, cnt;
; 909  : uchar *base;
; 910  : 
; 911  : 	while( next ) {

  0012e	85 ff		 test	 edi, edi
  00130	0f 85 de fe ff
	ff		 jne	 $LL23@judy_last
$LN22@judy_last:

; 975  : 			continue;
; 976  : #endif
; 977  : 		}
; 978  : 	}
; 979  : 	return NULL;

  00136	33 c0		 xor	 eax, eax
$LN24@judy_last:
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 980  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c3		 ret	 0
$LN16@judy_last:
  0013f	5f		 pop	 edi

; 936  : #else
; 937  : 			if( !judy->depth && !base[slot * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
; 938  : #endif
; 939  : 				return &node[-slot-1];

  00140	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00147	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0014a	5e		 pop	 esi
  0014b	2b c1		 sub	 eax, ecx
  0014d	5b		 pop	 ebx

; 980  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
$LN32@judy_last:

; 972  : 				return &node[-1];

  00152	8d 44 07 fc	 lea	 eax, DWORD PTR [edi+eax-4]
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	5b		 pop	 ebx

; 980  : }

  00159	8b e5		 mov	 esp, ebp
  0015b	5d		 pop	 ebp
  0015c	c3		 ret	 0
  0015d	8d 49 00	 npad	 3
$LN43@judy_last:
  00160	00 00 00 00	 DD	 $LN14@judy_last
  00164	00 00 00 00	 DD	 $LN18@judy_last
  00168	00 00 00 00	 DD	 $LN18@judy_last
  0016c	00 00 00 00	 DD	 $LN18@judy_last
  00170	00 00 00 00	 DD	 $LN18@judy_last
  00174	00 00 00 00	 DD	 $LN18@judy_last
  00178	00 00 00 00	 DD	 $LN18@judy_last
  0017c	00 00 00 00	 DD	 $LN2@judy_last
?judy_last@@YAPAIPAUJudy@@III@Z ENDP			; judy_last
_TEXT	ENDS
PUBLIC	?judy_slot@@YAPAIPAUJudy@@PAEI@Z		; judy_slot
; Function compile flags: /Ogtp
;	COMDAT ?judy_slot@@YAPAIPAUJudy@@PAEI@Z
_TEXT	SEGMENT
tv395 = -24						; size = 4
tv592 = -20						; size = 4
_test$ = -16						; size = 4
tv375 = -12						; size = 4
_tst$ = -12						; size = 4
_node$ = -8						; size = 4
_depth$ = -4						; size = 4
_buff$ = 8						; size = 4
?judy_slot@@YAPAIPAUJudy@@PAEI@Z PROC			; judy_slot, COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray

; 525  : judyvalue *src = (judyvalue *)buff;
; 526  : int slot, size, keysize, tst, cnt;
; 527  : JudySlot next = *judy->root;

  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	57		 push	 edi

; 528  : judyvalue value, test = 0;

  00011	33 ff		 xor	 edi, edi

; 529  : JudySlot *table;
; 530  : JudySlot *node;
; 531  : uint depth = 0;
; 532  : uint off = 0;

  00013	33 db		 xor	 ebx, ebx
  00015	89 7d f0	 mov	 DWORD PTR _test$[ebp], edi
  00018	89 7d fc	 mov	 DWORD PTR _depth$[ebp], edi

; 533  : uchar *base;
; 534  : 
; 535  : #ifndef ASKITIS
; 536  : 	judy->level = 0;

  0001b	89 7e 28	 mov	 DWORD PTR [esi+40], edi

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  0001e	3b cf		 cmp	 ecx, edi
  00020	75 11		 jne	 SHORT $LN37@judy_slot
$LN36@judy_slot:
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi

; 653  : 				continue;
; 654  : 			}
; 655  : 			return NULL;
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	5b		 pop	 ebx

; 661  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
  0002b	eb 03 8d 49 00	 npad	 5
$LL62@judy_slot:

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  00030	8b 7d fc	 mov	 edi, DWORD PTR _depth$[ebp]
$LN37@judy_slot:

; 540  : #ifndef ASKITIS
; 541  : 		if( judy->level < judy->max )

  00033	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00036	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00039	73 04		 jae	 SHORT $LN35@judy_slot

; 542  : 			judy->level++;

  0003b	40		 inc	 eax
  0003c	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN35@judy_slot:

; 543  : 
; 544  : 		judy->stack[judy->level].next = next;

  0003f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00042	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00045	89 4c 86 34	 mov	 DWORD PTR [esi+eax*4+52], ecx

; 545  : 		judy->stack[judy->level].off = off;

  00049	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0004c	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0004f	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx

; 546  : #endif
; 547  : 		size = JudySize[next & 0x07];

  00053	8b d1		 mov	 edx, ecx
  00055	83 e2 07	 and	 edx, 7
  00058	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edx*4]

; 548  : 
; 549  : 		switch( next & 0x07 ) {

  0005f	83 fa 07	 cmp	 edx, 7
  00062	0f 87 a0 01 00
	00		 ja	 $LN33@judy_slot
  00068	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN73@judy_slot[edx*4]
$LN32@judy_slot:

; 550  : 
; 551  : 		case JUDY_1:
; 552  : 		case JUDY_2:
; 553  : 		case JUDY_4:
; 554  : 		case JUDY_8:
; 555  : 		case JUDY_16:
; 556  : 		case JUDY_32:
; 557  : #ifdef ASKITIS
; 558  : 		case JUDY_64:
; 559  : #endif
; 560  : 			base = (uchar *)(next & JUDY_mask);

  0006f	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00072	89 4d f4	 mov	 DWORD PTR tv375[ebp], ecx

; 561  : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00075	03 c8		 add	 ecx, eax
  00077	89 4d f8	 mov	 DWORD PTR _node$[ebp], ecx

; 562  : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  0007a	8b d3		 mov	 edx, ebx
  0007c	83 e2 03	 and	 edx, 3
  0007f	b9 04 00 00 00	 mov	 ecx, 4
  00084	2b ca		 sub	 ecx, edx

; 563  : 			cnt = size / (sizeof(JudySlot) + keysize);

  00086	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00089	33 d2		 xor	 edx, edx
  0008b	f7 f7		 div	 edi

; 564  : 			slot = cnt;

  0008d	8b f8		 mov	 edi, eax

; 565  : 			value = 0;

  0008f	33 c0		 xor	 eax, eax

; 566  : 
; 567  : 			if( judy->depth ) {

  00091	39 46 30	 cmp	 DWORD PTR [esi+48], eax
  00094	74 1a		 je	 SHORT $LL29@judy_slot

; 568  : 				value = src[depth++];

  00096	8b 55 fc	 mov	 edx, DWORD PTR _depth$[ebp]
  00099	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  0009c	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 569  : 				off |= JUDY_key_mask;

  0009f	83 cb 03	 or	 ebx, 3
  000a2	42		 inc	 edx

; 570  : 				off++;

  000a3	43		 inc	 ebx

; 571  : 				value &= JudyMask[keysize];

  000a4	23 04 8d 00 00
	00 00		 and	 eax, DWORD PTR ?JudyMask@@3PAIA[ecx*4]
  000ab	89 55 fc	 mov	 DWORD PTR _depth$[ebp], edx

; 572  : 			} else

  000ae	eb 09		 jmp	 SHORT $LN27@judy_slot
$LL29@judy_slot:

; 573  : 			  do {
; 574  : 				value <<= 8;
; 575  : 				if( off < max )
; 576  : 					value |= buff[off];
; 577  : 			  } while( ++off & JUDY_key_mask );

  000b0	43		 inc	 ebx
  000b1	c1 e0 08	 shl	 eax, 8
  000b4	f6 c3 03	 test	 bl, 3
  000b7	75 f7		 jne	 SHORT $LL29@judy_slot
$LN27@judy_slot:

; 578  : 
; 579  : 			//  find slot > key
; 580  : 
; 581  : 			while( slot-- ) {

  000b9	85 ff		 test	 edi, edi
  000bb	74 2f		 je	 SHORT $LN58@judy_slot
  000bd	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?JudyMask@@3PAIA[ecx*4]
  000c4	89 55 e8	 mov	 DWORD PTR tv395[ebp], edx
  000c7	8b d1		 mov	 edx, ecx
  000c9	f7 da		 neg	 edx
  000cb	89 55 ec	 mov	 DWORD PTR tv592[ebp], edx
  000ce	8b d7		 mov	 edx, edi
  000d0	0f af d1	 imul	 edx, ecx
  000d3	03 55 f4	 add	 edx, DWORD PTR tv375[ebp]
$LL25@judy_slot:
  000d6	03 55 ec	 add	 edx, DWORD PTR tv592[ebp]

; 582  : 				test = *(judyvalue *)(base + slot * keysize);
; 583  : #if BYTE_ORDER == BIG_ENDIAN
; 584  : 				test >>= 8 * (JUDY_key_size - keysize); 
; 585  : #else
; 586  : 				test &= JudyMask[keysize];

  000d9	8b 4d e8	 mov	 ecx, DWORD PTR tv395[ebp]
  000dc	23 0a		 and	 ecx, DWORD PTR [edx]
  000de	4f		 dec	 edi
  000df	89 4d f0	 mov	 DWORD PTR _test$[ebp], ecx

; 587  : #endif
; 588  : 				if( test <= value )

  000e2	3b c8		 cmp	 ecx, eax
  000e4	76 0a		 jbe	 SHORT $LN24@judy_slot

; 578  : 
; 579  : 			//  find slot > key
; 580  : 
; 581  : 			while( slot-- ) {

  000e6	85 ff		 test	 edi, edi
  000e8	75 ec		 jne	 SHORT $LL25@judy_slot
  000ea	eb 03		 jmp	 SHORT $LN60@judy_slot
$LN58@judy_slot:
  000ec	8b 4d f0	 mov	 ecx, DWORD PTR _test$[ebp]
$LN60@judy_slot:
  000ef	4f		 dec	 edi
$LN24@judy_slot:

; 589  : 					break;
; 590  : 			}
; 591  : #ifndef ASKITIS
; 592  : 			judy->stack[judy->level].slot = slot;

  000f0	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000f3	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  000f7	89 3c 96	 mov	 DWORD PTR [esi+edx*4], edi

; 593  : #endif
; 594  : 			if( test == value ) {

  000fa	3b c8		 cmp	 ecx, eax
  000fc	0f 85 20 ff ff
	ff		 jne	 $LN36@judy_slot

; 595  : 
; 596  : 				// is this a leaf?
; 597  : 
; 598  : 				if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth )

  00102	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00105	85 c9		 test	 ecx, ecx
  00107	75 0c		 jne	 SHORT $LN66@judy_slot
  00109	84 c0		 test	 al, al
  0010b	0f 84 08 01 00
	00		 je	 $LN20@judy_slot
  00111	85 c9		 test	 ecx, ecx
  00113	74 09		 je	 SHORT $LN61@judy_slot
$LN66@judy_slot:
  00115	39 4d fc	 cmp	 DWORD PTR _depth$[ebp], ecx
  00118	0f 84 fb 00 00
	00		 je	 $LN20@judy_slot
$LN61@judy_slot:

; 600  : 
; 601  : 				next = node[-slot-1];

  0011e	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00121	8d 0c bd 04 00
	00 00		 lea	 ecx, DWORD PTR [edi*4+4]
  00128	2b c1		 sub	 eax, ecx
  0012a	8b 08		 mov	 ecx, DWORD PTR [eax]

; 602  : 				continue;

  0012c	e9 d7 00 00 00	 jmp	 $LN33@judy_slot
$LN18@judy_slot:

; 603  : 			}
; 604  : 
; 605  : 			return NULL;
; 606  : 
; 607  : 		case JUDY_radix:
; 608  : 			table = (JudySlot  *)(next & JUDY_mask); // outer radix

  00131	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 609  : 
; 610  : 			if( judy->depth )

  00134	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00138	8b d1		 mov	 edx, ecx
  0013a	74 1d		 je	 SHORT $LN15@judy_slot

; 611  : 				slot = (src[depth] >> ((JUDY_key_size - ++off & JUDY_key_mask) * 8)) & 0xff;

  0013c	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  0013f	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00142	43		 inc	 ebx
  00143	8b cb		 mov	 ecx, ebx
  00145	f7 d9		 neg	 ecx
  00147	83 e1 03	 and	 ecx, 3
  0014a	03 c9		 add	 ecx, ecx
  0014c	03 c9		 add	 ecx, ecx
  0014e	03 c9		 add	 ecx, ecx
  00150	d3 e8		 shr	 eax, cl
  00152	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00157	eb 02		 jmp	 SHORT $LN14@judy_slot
$LN15@judy_slot:

; 612  : 			else if( off < max )
; 613  : 				slot = buff[off++];
; 614  : 			else
; 615  : 				slot = 0;

  00159	33 c0		 xor	 eax, eax
$LN14@judy_slot:

; 616  : #ifndef ASKITIS
; 617  : 			//	put radix slot on judy stack
; 618  : 
; 619  : 			judy->stack[judy->level].slot = slot;

  0015b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0015e	8d 4c 49 0f	 lea	 ecx, DWORD PTR [ecx+ecx*2+15]
  00162	89 04 8e	 mov	 DWORD PTR [esi+ecx*4], eax

; 620  : #endif
; 621  : 			if( (next = table[slot >> 4]) )

  00165	8b c8		 mov	 ecx, eax
  00167	c1 f9 04	 sar	 ecx, 4
  0016a	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  0016d	85 c9		 test	 ecx, ecx
  0016f	0f 84 ad fe ff
	ff		 je	 $LN36@judy_slot

; 622  : 				table = (JudySlot  *)(next & JUDY_mask); // inner radix
; 623  : 			else
; 624  : 				return NULL;
; 625  : 
; 626  : 			if( judy->depth )

  00175	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  00178	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0017b	85 d2		 test	 edx, edx
  0017d	74 0d		 je	 SHORT $LN68@judy_slot

; 627  : 				if( !(off & JUDY_key_mask) )

  0017f	f6 c3 03	 test	 bl, 3
  00182	75 04		 jne	 SHORT $LN10@judy_slot

; 628  : 					depth++;

  00184	47		 inc	 edi
  00185	89 7d fc	 mov	 DWORD PTR _depth$[ebp], edi
$LN10@judy_slot:

; 629  : 
; 630  : 			if( !judy->depth && !slot || judy->depth && depth == judy->depth )	// leaf?

  00188	85 d2		 test	 edx, edx
  0018a	75 0c		 jne	 SHORT $LN70@judy_slot
$LN68@judy_slot:
  0018c	85 c0		 test	 eax, eax
  0018e	0f 84 98 00 00
	00		 je	 $LN8@judy_slot
  00194	85 d2		 test	 edx, edx
  00196	74 08		 je	 SHORT $LN5@judy_slot
$LN70@judy_slot:
  00198	3b fa		 cmp	 edi, edx
  0019a	0f 84 8c 00 00
	00		 je	 $LN8@judy_slot
$LN5@judy_slot:

; 632  : 					return &table[slot & 0x0F];
; 633  : 				else
; 634  : 					return NULL;
; 635  : 
; 636  : 			next = table[slot & 0x0F];

  001a0	83 e0 0f	 and	 eax, 15			; 0000000fH
  001a3	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]

; 637  : 			continue;

  001a6	eb 60		 jmp	 SHORT $LN33@judy_slot
$LN4@judy_slot:

; 638  : 
; 639  : #ifndef ASKITIS
; 640  : 		case JUDY_span:
; 641  : 			node = (JudySlot *)((next & JUDY_mask) + JudySize[JUDY_span]);

  001a8	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+28
  001ae	8b f9		 mov	 edi, ecx
  001b0	83 e7 f8	 and	 edi, -8			; fffffff8H
  001b3	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  001b6	89 45 f8	 mov	 DWORD PTR _node$[ebp], eax

; 642  : 			base = (uchar *)(next & JUDY_mask);
; 643  : 			cnt = tst = JUDY_span_bytes;
; 644  : 			if( tst > (int)(max - off) )

  001b9	8b c3		 mov	 eax, ebx
  001bb	f7 d8		 neg	 eax
  001bd	c7 45 f4 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  001c4	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  001c7	7d 03		 jge	 SHORT $LN3@judy_slot

; 645  : 				tst = max - off;

  001c9	89 45 f4	 mov	 DWORD PTR _tst$[ebp], eax
$LN3@judy_slot:

; 646  : 			value = strncmp((const char *)base, (const char *)(buff + off), tst);

  001cc	8b 4d f4	 mov	 ecx, DWORD PTR _tst$[ebp]
  001cf	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  001d2	51		 push	 ecx
  001d3	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  001d6	50		 push	 eax
  001d7	57		 push	 edi
  001d8	e8 00 00 00 00	 call	 _strncmp
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 647  : 			if( !value && tst < cnt && !base[tst] ) // leaf?

  001e0	85 c0		 test	 eax, eax
  001e2	0f 85 3a fe ff
	ff		 jne	 $LN36@judy_slot
  001e8	8b 45 f4	 mov	 eax, DWORD PTR _tst$[ebp]
  001eb	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  001ee	7d 09		 jge	 SHORT $LN71@judy_slot
  001f0	80 3c 38 00	 cmp	 BYTE PTR [eax+edi], 0
  001f4	74 4b		 je	 SHORT $LN47@judy_slot

; 649  : 
; 650  : 			if( !value && tst == cnt ) {

  001f6	83 f8 1c	 cmp	 eax, 28			; 0000001cH
$LN71@judy_slot:
  001f9	0f 85 23 fe ff
	ff		 jne	 $LN36@judy_slot

; 651  : 				next = node[-1];

  001ff	8b 4d f8	 mov	 ecx, DWORD PTR _node$[ebp]
  00202	8b 49 fc	 mov	 ecx, DWORD PTR [ecx-4]

; 652  : 				off += cnt;

  00205	83 c3 1c	 add	 ebx, 28			; 0000001cH
$LN33@judy_slot:

; 537  : #endif
; 538  : 
; 539  : 	while( next ) {

  00208	85 c9		 test	 ecx, ecx
  0020a	0f 85 20 fe ff
	ff		 jne	 $LL62@judy_slot

; 653  : 				continue;
; 654  : 			}
; 655  : 			return NULL;
; 656  : #endif
; 657  : 		}
; 658  : 	}
; 659  : 
; 660  : 	return NULL;

  00210	5f		 pop	 edi
  00211	5e		 pop	 esi
  00212	33 c0		 xor	 eax, eax
  00214	5b		 pop	 ebx

; 661  : }

  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
$LN20@judy_slot:

; 599  : 					return &node[-slot-1];

  00219	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  0021c	8d 14 bd 04 00
	00 00		 lea	 edx, DWORD PTR [edi*4+4]
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	2b c2		 sub	 eax, edx
  00227	5b		 pop	 ebx

; 661  : }

  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c3		 ret	 0
$LN8@judy_slot:

; 631  : 				if( table[slot & 0x0F] )	// occupied?

  0022c	83 e0 0f	 and	 eax, 15			; 0000000fH
  0022f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00232	8b 01		 mov	 eax, DWORD PTR [ecx]
  00234	f7 d8		 neg	 eax
  00236	5f		 pop	 edi
  00237	1b c0		 sbb	 eax, eax
  00239	5e		 pop	 esi
  0023a	23 c1		 and	 eax, ecx
  0023c	5b		 pop	 ebx

; 661  : }

  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
$LN47@judy_slot:

; 648  : 				return &node[-1];

  00241	8b 45 f8	 mov	 eax, DWORD PTR _node$[ebp]
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	83 c0 fc	 add	 eax, -4			; fffffffcH
  00249	5b		 pop	 ebx

; 661  : }

  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
  0024e	8b ff		 npad	 2
$LN73@judy_slot:
  00250	00 00 00 00	 DD	 $LN18@judy_slot
  00254	00 00 00 00	 DD	 $LN32@judy_slot
  00258	00 00 00 00	 DD	 $LN32@judy_slot
  0025c	00 00 00 00	 DD	 $LN32@judy_slot
  00260	00 00 00 00	 DD	 $LN32@judy_slot
  00264	00 00 00 00	 DD	 $LN32@judy_slot
  00268	00 00 00 00	 DD	 $LN32@judy_slot
  0026c	00 00 00 00	 DD	 $LN4@judy_slot
?judy_slot@@YAPAIPAUJudy@@PAEI@Z ENDP			; judy_slot
_TEXT	ENDS
PUBLIC	?judy_free@@YAXPAUJudy@@PAXH@Z			; judy_free
; Function compile flags: /Ogtp
;	COMDAT ?judy_free@@YAXPAUJudy@@PAXH@Z
_TEXT	SEGMENT
_judy$ = 8						; size = 4
?judy_free@@YAXPAUJudy@@PAXH@Z PROC			; judy_free, COMDAT
; _block$ = ecx
; _type$ = eax

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]

; 410  : 	if( type == JUDY_radix )

  00006	85 c0		 test	 eax, eax
  00008	75 13		 jne	 SHORT $LN2@judy_free

; 411  : 		type = JUDY_radix_equiv;

  0000a	b8 04 00 00 00	 mov	 eax, 4
  0000f	56		 push	 esi

; 416  : #endif
; 417  : 
; 418  : 	*((void **)(block)) = judy->reuse[type];

  00010	8b 74 82 04	 mov	 esi, DWORD PTR [edx+eax*4+4]
  00014	89 31		 mov	 DWORD PTR [ecx], esi

; 419  : 	judy->reuse[type] = (void **)block;

  00016	89 4c 82 04	 mov	 DWORD PTR [edx+eax*4+4], ecx
  0001a	5e		 pop	 esi

; 420  : 	return;
; 421  : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN2@judy_free:

; 412  : 
; 413  : #ifndef ASKITIS
; 414  : 	if( type == JUDY_span )

  0001d	83 f8 07	 cmp	 eax, 7
  00020	75 05		 jne	 SHORT $LN1@judy_free

; 415  : 		type = JUDY_span_equiv;

  00022	b8 03 00 00 00	 mov	 eax, 3
$LN1@judy_free:
  00027	56		 push	 esi

; 416  : #endif
; 417  : 
; 418  : 	*((void **)(block)) = judy->reuse[type];

  00028	8b 74 82 04	 mov	 esi, DWORD PTR [edx+eax*4+4]
  0002c	89 31		 mov	 DWORD PTR [ecx], esi

; 419  : 	judy->reuse[type] = (void **)block;

  0002e	89 4c 82 04	 mov	 DWORD PTR [edx+eax*4+4], ecx
  00032	5e		 pop	 esi

; 420  : 	return;
; 421  : }

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?judy_free@@YAXPAUJudy@@PAXH@Z ENDP			; judy_free
_TEXT	ENDS
PUBLIC	?judy_alloc@@YAPAXPAUJudy@@I@Z			; judy_alloc
; Function compile flags: /Ogtp
;	COMDAT ?judy_alloc@@YAPAXPAUJudy@@I@Z
_TEXT	SEGMENT
tv263 = -8						; size = 4
tv271 = -4						; size = 4
_judy$ = 8						; size = 4
?judy_alloc@@YAPAXPAUJudy@@I@Z PROC			; judy_alloc, COMDAT
; _type$ = ecx

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR _judy$[ebp]

; 269  : uint amt, idx, min;
; 270  : JudySeg *seg;
; 271  : void **block;
; 272  : void **rtn;
; 273  : 
; 274  : 	if( !judy->seg )

  0000a	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0000d	85 c0		 test	 eax, eax
  0000f	75 05		 jne	 SHORT $LN17@judy_alloc
  00011	5f		 pop	 edi

; 352  : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN17@judy_alloc:

; 275  : #if defined(STANDALONE) || defined(ASKITIS)
; 276  : 			judy_abort("illegal allocation from judy clone");
; 277  : #else
; 278  : 			return NULL;
; 279  : #endif
; 280  : 
; 281  : 	if( type == JUDY_radix )

  00016	85 c9		 test	 ecx, ecx
  00018	75 07		 jne	 SHORT $LN16@judy_alloc

; 282  : 		type = JUDY_radix_equiv;

  0001a	b9 04 00 00 00	 mov	 ecx, 4

; 283  : 
; 284  : #ifndef ASKITIS
; 285  : 	if( type == JUDY_span )

  0001f	eb 0a		 jmp	 SHORT $LN15@judy_alloc
$LN16@judy_alloc:
  00021	83 f9 07	 cmp	 ecx, 7
  00024	75 05		 jne	 SHORT $LN15@judy_alloc

; 286  : 		type = JUDY_span_equiv;

  00026	b9 03 00 00 00	 mov	 ecx, 3
$LN15@judy_alloc:

; 287  : #endif
; 288  : 
; 289  : 	amt = JudySize[type];

  0002b	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR ?JudySize@@3PAHA[ecx*4]
  00032	53		 push	 ebx
  00033	8b 18		 mov	 ebx, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR tv263[ebp], eax

; 290  : 
; 291  : 	if( amt & 0x07 )

  00038	f6 c3 07	 test	 bl, 7
  0003b	74 04		 je	 SHORT $LN32@judy_alloc

; 292  : 		amt |= 0x07, amt += 1;

  0003d	83 cb 07	 or	 ebx, 7
  00040	43		 inc	 ebx
$LN32@judy_alloc:

; 293  : 
; 294  : 	//	see if free block is already available
; 295  : 
; 296  : 	if( (block = judy->reuse[type]) ) {

  00041	8d 54 8f 04	 lea	 edx, DWORD PTR [edi+ecx*4+4]
  00045	56		 push	 esi
  00046	8b 32		 mov	 esi, DWORD PTR [edx]
  00048	89 55 fc	 mov	 DWORD PTR tv271[ebp], edx
  0004b	85 f6		 test	 esi, esi
  0004d	74 19		 je	 SHORT $LN13@judy_alloc

; 297  : 		judy->reuse[type] = (void**)*block;

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]

; 298  : 		memset (block, 0, amt);

  00051	53		 push	 ebx

; 350  : 	memset (rtn, 0, JudySize[type]);

  00052	6a 00		 push	 0
  00054	56		 push	 esi
  00055	89 02		 mov	 DWORD PTR [edx], eax
  00057	e8 00 00 00 00	 call	 _memset
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  0005f	8b c6		 mov	 eax, esi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
  00063	5f		 pop	 edi

; 352  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
$LN13@judy_alloc:

; 299  : 		return (void *)block;
; 300  : 	}
; 301  : 
; 302  : 	//	break down available larger block
; 303  : 	//	for reuse into smaller blocks
; 304  : 
; 305  : 	if( type >= JUDY_1 )

  00068	83 f9 01	 cmp	 ecx, 1
  0006b	72 1e		 jb	 SHORT $LN26@judy_alloc

; 306  : 	  for( idx = type; idx++ < JUDY_max; )

  0006d	8b c1		 mov	 eax, ecx
  0006f	83 f9 06	 cmp	 ecx, 6
  00072	73 17		 jae	 SHORT $LN26@judy_alloc
$LL11@judy_alloc:

; 307  : 		if( block = judy->reuse[idx] ) {

  00074	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00077	83 c2 04	 add	 edx, 4
  0007a	40		 inc	 eax
  0007b	85 f6		 test	 esi, esi
  0007d	0f 85 9f 00 00
	00		 jne	 $LN25@judy_alloc

; 306  : 	  for( idx = type; idx++ < JUDY_max; )

  00083	83 f8 06	 cmp	 eax, 6
  00086	72 ec		 jb	 SHORT $LL11@judy_alloc

; 307  : 		if( block = judy->reuse[idx] ) {

  00088	8b 55 fc	 mov	 edx, DWORD PTR tv271[ebp]
$LN26@judy_alloc:

; 314  : 		  return (void *)block;
; 315  : 		}
; 316  : 
; 317  : 	min = amt < JUDY_cache_line ? JUDY_cache_line : amt;

  0008b	b8 08 00 00 00	 mov	 eax, 8
  00090	83 fb 08	 cmp	 ebx, 8
  00093	72 02		 jb	 SHORT $LN21@judy_alloc
  00095	8b c3		 mov	 eax, ebx
$LN21@judy_alloc:

; 318  : 
; 319  : 	if( judy->seg->next < min + sizeof(*seg) ) {

  00097	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0009a	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0009d	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  000a0	73 2f		 jae	 SHORT $LN4@judy_alloc

; 320  : 		if( (seg = (JudySeg*)malloc (JUDY_seg)) ) {

  000a2	68 00 00 01 00	 push	 65536			; 00010000H
  000a7	e8 00 00 00 00	 call	 _malloc
  000ac	83 c4 04	 add	 esp, 4
  000af	85 c0		 test	 eax, eax
  000b1	0f 84 b6 00 00
	00		 je	 $LN5@judy_alloc

; 321  : 			seg->next = JUDY_seg;

  000b7	c7 40 04 00 00
	01 00		 mov	 DWORD PTR [eax+4], 65536 ; 00010000H

; 322  : 			seg->seg = judy->seg;

  000be	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 323  : 			judy->seg = seg;
; 324  : 			seg->next -= (JudySlot)seg & (JUDY_cache_line - 1);

  000c1	8b c8		 mov	 ecx, eax
  000c3	89 10		 mov	 DWORD PTR [eax], edx

; 325  : 		} else {

  000c5	8b 55 fc	 mov	 edx, DWORD PTR tv271[ebp]
  000c8	83 e1 07	 and	 ecx, 7
  000cb	89 47 24	 mov	 DWORD PTR [edi+36], eax
  000ce	29 48 04	 sub	 DWORD PTR [eax+4], ecx
$LN4@judy_alloc:

; 330  : #endif
; 331  : 		}
; 332  : 
; 333  : #if defined(STANDALONE) || defined(ASKITIS)
; 334  : 		MaxMem += JUDY_seg;
; 335  : #endif
; 336  : 	}
; 337  : 
; 338  : 	//	generate additional free blocks
; 339  : 	//	to fill up to cache line size
; 340  : 
; 341  : 	rtn = (void **)((uchar *)judy->seg + judy->seg->next - amt);

  000d1	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	2b f3		 sub	 esi, ebx
  000d9	03 f0		 add	 esi, eax

; 342  : 
; 343  : 	for( idx = type; amt & (JUDY_cache_line - 1); amt <<= 1 ) {

  000db	f6 c3 07	 test	 bl, 7
  000de	74 22		 je	 SHORT $LN1@judy_alloc
$LL31@judy_alloc:

; 344  : 		block = (void **)((uchar *)judy->seg + judy->seg->next - 2 * amt);

  000e0	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  000e3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000e6	8d 3c 1b	 lea	 edi, DWORD PTR [ebx+ebx]
  000e9	2b c7		 sub	 eax, edi
  000eb	8b 7d 08	 mov	 edi, DWORD PTR _judy$[ebp]
  000ee	03 c1		 add	 eax, ecx

; 345  : 		judy->reuse[idx++] = block;

  000f0	89 02		 mov	 DWORD PTR [edx], eax
  000f2	03 db		 add	 ebx, ebx
  000f4	83 c2 04	 add	 edx, 4

; 346  : 		*block = 0;

  000f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000fd	f6 c3 07	 test	 bl, 7
  00100	75 de		 jne	 SHORT $LL31@judy_alloc
$LN1@judy_alloc:

; 347  : 	}
; 348  : 
; 349  : 	judy->seg->next -= amt;

  00102	8b 47 24	 mov	 eax, DWORD PTR [edi+36]

; 350  : 	memset (rtn, 0, JudySize[type]);

  00105	8b 4d f8	 mov	 ecx, DWORD PTR tv263[ebp]
  00108	29 58 04	 sub	 DWORD PTR [eax+4], ebx
  0010b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010d	52		 push	 edx
  0010e	6a 00		 push	 0
  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 _memset
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  00119	8b c6		 mov	 eax, esi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	5f		 pop	 edi

; 352  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN25@judy_alloc:

; 308  : 		  judy->reuse[idx] = (void**)*block;

  00122	8d 54 87 04	 lea	 edx, DWORD PTR [edi+eax*4+4]
  00126	8b 3e		 mov	 edi, DWORD PTR [esi]
  00128	89 3a		 mov	 DWORD PTR [edx], edi

; 309  : 		  while( idx-- > type) {

  0012a	3b c1		 cmp	 eax, ecx
  0012c	76 2a		 jbe	 SHORT $LN30@judy_alloc
  0012e	8b ff		 npad	 2
$LL8@judy_alloc:

; 310  : 			judy->reuse[idx] = block + JudySize[idx] / sizeof(void *);

  00130	8b 3c 85 fc ff
	ff ff		 mov	 edi, DWORD PTR ?JudySize@@3PAHA[eax*4-4]
  00137	48		 dec	 eax
  00138	c1 ef 02	 shr	 edi, 2
  0013b	8d 3c be	 lea	 edi, DWORD PTR [esi+edi*4]
  0013e	83 ea 04	 sub	 edx, 4
  00141	89 3a		 mov	 DWORD PTR [edx], edi

; 311  : 			block[JudySize[idx] / sizeof(void *)] = 0;

  00143	8b 3c 85 00 00
	00 00		 mov	 edi, DWORD PTR ?JudySize@@3PAHA[eax*4]
  0014a	c1 ef 02	 shr	 edi, 2
  0014d	c7 04 be 00 00
	00 00		 mov	 DWORD PTR [esi+edi*4], 0
  00154	3b c1		 cmp	 eax, ecx
  00156	77 d8		 ja	 SHORT $LL8@judy_alloc
$LN30@judy_alloc:

; 312  : 		  }
; 313  : 		  memset (block, 0, amt);

  00158	53		 push	 ebx

; 350  : 	memset (rtn, 0, JudySize[type]);

  00159	6a 00		 push	 0
  0015b	56		 push	 esi
  0015c	e8 00 00 00 00	 call	 _memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 	return (void *)rtn;

  00164	8b c6		 mov	 eax, esi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	5f		 pop	 edi

; 352  : }

  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
$LN5@judy_alloc:
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx

; 326  : #if defined(STANDALONE) || defined(ASKITIS)
; 327  : 			judy_abort("Out of virtual memory");
; 328  : #else
; 329  : 			return NULL;

  0016f	33 c0		 xor	 eax, eax
  00171	5f		 pop	 edi

; 352  : }

  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c3		 ret	 0
?judy_alloc@@YAPAXPAUJudy@@I@Z ENDP			; judy_alloc
_TEXT	ENDS
PUBLIC	?judy_size@@YAIPAUJudy@@@Z			; judy_size
; Function compile flags: /Ogtp
;	COMDAT ?judy_size@@YAIPAUJudy@@@Z
_TEXT	SEGMENT
?judy_size@@YAIPAUJudy@@@Z PROC				; judy_size, COMDAT

; 252  : 	JudySeg* seg;
; 253  : 	uint count;
; 254  : 
; 255  : 	seg = judy->seg;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00005	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]

; 256  : 	count = 0;

  00008	33 c0		 xor	 eax, eax

; 257  : 	while (seg) {

  0000a	85 c9		 test	 ecx, ecx
  0000c	74 12		 je	 SHORT $LN1@judy_size
  0000e	8b ff		 npad	 2
$LL2@judy_size:

; 258  : 		count += JUDY_seg - seg->next;

  00010	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00015	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]

; 259  : 		seg = (JudySeg*)seg->seg;

  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	03 c2		 add	 eax, edx
  0001c	85 c9		 test	 ecx, ecx
  0001e	75 f0		 jne	 SHORT $LL2@judy_size
$LN1@judy_size:

; 260  : 	}
; 261  : 
; 262  : 	return count;
; 263  : }

  00020	c3		 ret	 0
?judy_size@@YAIPAUJudy@@@Z ENDP				; judy_size
_TEXT	ENDS
PUBLIC	?judy_close@@YAXPAUJudy@@@Z			; judy_close
; Function compile flags: /Ogtp
;	COMDAT ?judy_close@@YAXPAUJudy@@@Z
_TEXT	SEGMENT
?judy_close@@YAXPAUJudy@@@Z PROC			; judy_close, COMDAT

; 244  : JudySeg *seg, *nxt = judy->seg;
; 245  : 
; 246  : 	while( (seg = nxt) )

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00005	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00008	85 c0		 test	 eax, eax
  0000a	74 16		 je	 SHORT $LN1@judy_close
  0000c	56		 push	 esi
  0000d	8d 49 00	 npad	 3
$LL2@judy_close:

; 247  : 		nxt = (JudySeg*)seg->seg, free (seg);

  00010	8b 30		 mov	 esi, DWORD PTR [eax]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _free
  00018	83 c4 04	 add	 esp, 4
  0001b	8b c6		 mov	 eax, esi
  0001d	85 f6		 test	 esi, esi
  0001f	75 ef		 jne	 SHORT $LL2@judy_close
  00021	5e		 pop	 esi
$LN1@judy_close:

; 248  : }

  00022	c3		 ret	 0
?judy_close@@YAXPAUJudy@@@Z ENDP			; judy_close
_TEXT	ENDS
PUBLIC	?judy_open@@YAPAXII@Z				; judy_open
; Function compile flags: /Ogtp
;	COMDAT ?judy_open@@YAPAXII@Z
_TEXT	SEGMENT
?judy_open@@YAPAXII@Z PROC				; judy_open, COMDAT

; 204  : {

  00000	57		 push	 edi

; 205  : JudySeg *seg;
; 206  : Judy *judy;
; 207  : uint amt;
; 208  : 
; 209  : 	max++;		// allow for zero terminator on keys
; 210  : 
; 211  : 	if( (seg = (JudySeg*)malloc(JUDY_seg)) ) {

  00001	68 00 00 01 00	 push	 65536			; 00010000H
  00006	e8 00 00 00 00	 call	 _malloc
  0000b	8b f8		 mov	 edi, eax
  0000d	83 c4 04	 add	 esp, 4
  00010	85 ff		 test	 edi, edi
  00012	74 3f		 je	 SHORT $LN3@judy_open

; 219  : #endif
; 220  : 	}
; 221  : 
; 222  : 	amt = sizeof(Judy) + max * sizeof(JudyStack);
; 223  : 
; 224  : 	if( amt & (JUDY_cache_line - 1) )
; 225  : 		amt |= JUDY_cache_line - 1, amt++;
; 226  : 
; 227  : #if defined(STANDALONE) || defined(ASKITIS)
; 228  : 	MaxMem += JUDY_seg;
; 229  : #endif
; 230  : 
; 231  : 	seg->next -= (JudySlot)seg & (JUDY_cache_line - 1);

  00014	56		 push	 esi
  00015	8b cf		 mov	 ecx, edi
  00017	83 e1 07	 and	 ecx, 7

; 232  : 	seg->next -= amt;

  0001a	b8 b0 cf 00 00	 mov	 eax, 53168		; 0000cfb0H
  0001f	2b c1		 sub	 eax, ecx

; 233  : 
; 234  : 	judy = (Judy *)((uchar *)seg + seg->next);
; 235  : 	memset(judy, 0, amt);

  00021	68 50 30 00 00	 push	 12368			; 00003050H
  00026	8d 34 38	 lea	 esi, DWORD PTR [eax+edi]
  00029	6a 00		 push	 0
  0002b	56		 push	 esi
  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00032	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 236  : 	judy->depth = depth;
; 237  :  	judy->seg = seg;

  0003d	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00040	c7 46 30 01 00
	00 00		 mov	 DWORD PTR [esi+48], 1

; 238  : 	judy->max = max;

  00047	c7 46 2c 01 04
	00 00		 mov	 DWORD PTR [esi+44], 1025 ; 00000401H

; 239  : 	return judy;

  0004e	8b c6		 mov	 eax, esi
  00050	5e		 pop	 esi
  00051	5f		 pop	 edi

; 240  : }

  00052	c3		 ret	 0
$LN3@judy_open:

; 212  : 		seg->seg = NULL;
; 213  : 		seg->next = JUDY_seg;
; 214  : 	} else {
; 215  : #if defined(STANDALONE) || defined(ASKITIS)
; 216  : 		judy_abort ("No virtual memory");
; 217  : #else
; 218  : 		return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi

; 240  : }

  00056	c3		 ret	 0
?judy_open@@YAPAXII@Z ENDP				; judy_open
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\nedtries\nedtrie.h
_TEXT	ENDS
;	COMDAT ?nedtriebitscanr@@YAII@Z
_TEXT	SEGMENT
_bitpos$ = -4						; size = 4
?nedtriebitscanr@@YAII@Z PROC				; nedtriebitscanr, COMDAT
; _value$ = eax

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 134  : #ifdef _MSC_VER
; 135  :   unsigned long bitpos;
; 136  : #if defined(_M_IA64) || defined(_M_X64) || defined(WIN64)
; 137  :   assert(8==sizeof(size_t));
; 138  :   _BitScanReverse64(&bitpos, value | 1);
; 139  : #else
; 140  :   assert(4==sizeof(size_t));
; 141  :   _BitScanReverse(&bitpos, value | 1);

  00004	83 c8 01	 or	 eax, 1
  00007	0f bd c0	 bsr	 eax, eax
  0000a	89 45 fc	 mov	 DWORD PTR _bitpos$[ebp], eax

; 142  : #endif
; 143  :   return (unsigned) bitpos;
; 144  : #elif defined(__GNUC__)
; 145  :   return sizeof(value)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(value | 1);
; 146  : #else
; 147  :   /* The following code is illegal C, but it almost certainly will work.
; 148  :   If not use the legal implementation below */
; 149  :   unsigned bitpos;
; 150  : #if 1
; 151  : 	union {
; 152  : 		unsigned asInt[2];
; 153  : 		double asDouble;
; 154  : 	};
; 155  : 	int n;
; 156  : 
; 157  : 	asDouble = (double)value + 0.5;
; 158  : 	n = (asInt[0 /*Use 1 if your CPU is big endian!*/] >> 20) - 1023;
; 159  : #warning Make sure you change the line above me if your CPU is big endian!
; 160  : 	return (unsigned) n;
; 161  : #else
; 162  :   size_t x=value;
; 163  : 	x = x | (x >> 1);
; 164  : 	x = x | (x >> 2);
; 165  : 	x = x | (x >> 4);
; 166  : 	x = x | (x >> 8);
; 167  : 	x = x | (x >>16);
; 168  : 	x = ~x;
; 169  : 	x = x - ((x >> 1) & 0x55555555);
; 170  : 	x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
; 171  : 	x = (x + (x >> 4)) & 0x0F0F0F0F;
; 172  : 	x = x + (x << 8);
; 173  : 	x = x + (x << 16);
; 174  : 	return x >> 24;
; 175  : #endif
; 176  : #endif
; 177  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?nedtriebitscanr@@YAII@Z ENDP				; nedtriebitscanr
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN7@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN7@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 31   : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 49   : 		}

  00000	c3		 ret	 0
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\limits
_TEXT	ENDS
;	COMDAT ?max@?$numeric_limits@I@std@@SAIXZ
_TEXT	SEGMENT
?max@?$numeric_limits@I@std@@SAIXZ PROC			; std::numeric_limits<unsigned int>::max, COMDAT

; 778  : 		{	// return maximum value
; 779  : 		return (UINT_MAX);

  00000	83 c8 ff	 or	 eax, -1

; 780  : 		}

  00003	c3		 ret	 0
?max@?$numeric_limits@I@std@@SAIXZ ENDP			; std::numeric_limits<unsigned int>::max
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 62   : 	}

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Where$ = eax

; 57   : 	return (_Where);
; 58   : 	}

  00000	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = -4						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = esi

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fc	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b ce		 mov	 ecx, esi
  0000a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Message$[ebp], 0
  00011	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  0001c	8b c6		 mov	 eax, esi
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	_tommy_hashlin_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.c
;	COMDAT _tommy_hashlin_memory_usage
_TEXT	SEGMENT
_tommy_hashlin_memory_usage PROC			; COMDAT

; 318  : 	return hashlin->bucket_max * (tommy_size_t)sizeof(hashlin->bucket[0][0])
; 319  : 		+ hashlin->count * (tommy_size_t)sizeof(tommy_hashlin_node);

  00000	a1 a0 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  00005	8b 0d 84 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 320  : }

  00012	c3		 ret	 0
_tommy_hashlin_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_done
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_done
_TEXT	SEGMENT
_tommy_hashlin_done PROC				; COMDAT

; 61   : {

  00000	56		 push	 esi

; 62   : 	unsigned i;
; 63   : 	for(i=0;i<hashlin->bucket_mac;++i)

  00001	33 f6		 xor	 esi, esi
  00003	39 35 8c 00 00
	00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, esi
  00009	76 1e		 jbe	 SHORT $LN1@tommy_hash
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@tommy_hash:

; 64   : 		tommy_free(hashlin->bucket[i]);

  00010	8b 04 b5 00 00
	00 00		 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[esi*4]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _free
  0001d	46		 inc	 esi
  0001e	83 c4 04	 add	 esp, 4
  00021	3b 35 8c 00 00
	00		 cmp	 esi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  00027	72 e7		 jb	 SHORT $LL3@tommy_hash
$LN1@tommy_hash:
  00029	5e		 pop	 esi

; 65   : }

  0002a	c3		 ret	 0
_tommy_hashlin_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_init
_TEXT	SEGMENT
_tommy_hashlin_init PROC				; COMDAT

; 46   : 	/* fixed initial size */
; 47   : 	hashlin->bucket_bit = TOMMY_HASHLIN_BIT;
; 48   : 	hashlin->bucket_max = 1 << hashlin->bucket_bit;
; 49   : 	hashlin->bucket_mask = hashlin->bucket_max - 1;
; 50   : 	hashlin->bucket[0] = tommy_cast(tommy_hashlin_node**, tommy_malloc(hashlin->bucket_max * sizeof(tommy_hashlin_node*)));

  00000	68 00 01 00 00	 push	 256			; 00000100H
  00005	c7 05 80 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, 6
  0000f	c7 05 84 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, 64 ; 00000040H
  00019	c7 05 88 00 00
	00 3f 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, 63 ; 0000003fH
  00023	e8 00 00 00 00	 call	 _malloc

; 51   : 	memset(hashlin->bucket[0], 0, hashlin->bucket_max * sizeof(tommy_hashlin_node*));

  00028	68 00 01 00 00	 push	 256			; 00000100H
  0002d	6a 00		 push	 0
  0002f	50		 push	 eax
  00030	a3 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A, eax
  00035	e8 00 00 00 00	 call	 _memset
  0003a	83 c4 10	 add	 esp, 16			; 00000010H

; 52   : 	hashlin->bucket_mac = 1;

  0003d	c7 05 8c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, 1

; 53   : 
; 54   : 	/* stable state */
; 55   : 	hashlin->state = TOMMY_HASHLIN_STATE_STABLE;

  00047	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0

; 56   : 
; 57   : 	hashlin->count = 0;

  00051	c7 05 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, 0

; 58   : }

  0005b	c3		 ret	 0
_tommy_hashlin_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_done
_TEXT	SEGMENT
_tommy_hashdyn_done PROC				; COMDAT

; 50   : 	tommy_free(hashdyn->bucket);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free
  0000b	59		 pop	 ecx

; 51   : }

  0000c	c3		 ret	 0
_tommy_hashdyn_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashdyn_init
_TEXT	SEGMENT
_tommy_hashdyn_init PROC				; COMDAT

; 38   : 	/* fixed initial size */
; 39   : 	hashdyn->bucket_bit = TOMMY_HASHDYN_BIT;
; 40   : 	hashdyn->bucket_max = 1 << hashdyn->bucket_bit;
; 41   : 	hashdyn->bucket_mask = hashdyn->bucket_max - 1;
; 42   : 	hashdyn->bucket = tommy_cast(tommy_hashdyn_node**, tommy_malloc(hashdyn->bucket_max * sizeof(tommy_hashdyn_node*)));

  00000	6a 40		 push	 64			; 00000040H
  00002	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, 4
  0000c	c7 05 08 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, 16 ; 00000010H
  00016	c7 05 0c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, 15 ; 0000000fH
  00020	e8 00 00 00 00	 call	 _malloc

; 43   : 	memset(hashdyn->bucket, 0, hashdyn->bucket_max * sizeof(tommy_hashdyn_node*));

  00025	6a 40		 push	 64			; 00000040H
  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	a3 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 44   : 
; 45   : 	hashdyn->count = 0;

  00037	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, 0

; 46   : }

  00041	c3		 ret	 0
_tommy_hashdyn_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashtbl.c
;	COMDAT _tommy_hashtable_done
_TEXT	SEGMENT
_tommy_hashtable_done PROC				; COMDAT

; 54   : 	tommy_free(hashtable->bucket);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 _free
  0000b	59		 pop	 ecx

; 55   : }

  0000c	c3		 ret	 0
_tommy_hashtable_done ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_bucket
_TEXT	SEGMENT
_tommy_trie_inplace_bucket PROC				; COMDAT
; _key$ = edx

; 254  : 	tommy_trie_inplace_node* node;
; 255  : 	unsigned shift;
; 256  : 
; 257  : 	node = trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]

; 258  : 	shift = TOMMY_TRIE_INPLACE_BUCKET_SHIFT;

  0000c	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 259  : 
; 260  : 	while (node && node->key != key) {

  00011	85 c0		 test	 eax, eax
  00013	74 19		 je	 SHORT $LN1@tommy_trie
  00015	56		 push	 esi
$LL2@tommy_trie:
  00016	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00019	74 12		 je	 SHORT $LN9@tommy_trie

; 261  : 		node = node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  0001b	8b f2		 mov	 esi, edx
  0001d	d3 ee		 shr	 esi, cl

; 262  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  0001f	83 e9 02	 sub	 ecx, 2
  00022	83 e6 03	 and	 esi, 3
  00025	8b 44 b0 10	 mov	 eax, DWORD PTR [eax+esi*4+16]
  00029	85 c0		 test	 eax, eax
  0002b	75 e9		 jne	 SHORT $LL2@tommy_trie
$LN9@tommy_trie:
  0002d	5e		 pop	 esi
$LN1@tommy_trie:

; 263  : 	}
; 264  : 
; 265  : 	return node;
; 266  : }

  0002e	c3		 ret	 0
_tommy_trie_inplace_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_inplace_init
_TEXT	SEGMENT
_tommy_trie_inplace_init PROC				; COMDAT

; 99   : {

  00000	57		 push	 edi

; 100  : 	unsigned i;
; 101  : 
; 102  : 	for(i=0;i<TOMMY_TRIE_INPLACE_BUCKET_MAX;++i)
; 103  : 		trie_inplace->bucket[i] = 0;

  00001	33 c0		 xor	 eax, eax
  00003	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00008	bf 00 00 00 00	 mov	 edi, OFFSET ?trie_inplace@@3Utommy_trie_inplace_struct@@A ; trie_inplace
  0000d	f3 ab		 rep stosd

; 104  : 	
; 105  : 	trie_inplace->count = 0;

  0000f	a3 00 01 00 00	 mov	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, eax
  00014	5f		 pop	 edi

; 106  : }

  00015	c3		 ret	 0
_tommy_trie_inplace_init ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z PROC ; tommy_trie_inplace_list_remove, COMDAT
; _let_ptr$ = esi
; _node$ = eax

; 81   : 	tommy_trie_inplace_node* head = *let_ptr;
; 82   : 
; 83   : 	/* remove from the "circular" prev list */
; 84   : 	if (node->next) { 

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 16		 mov	 edx, DWORD PTR [esi]
  00004	85 c9		 test	 ecx, ecx
  00006	74 0a		 je	 SHORT $LN4@tommy_trie@2

; 85   : 		node->next->prev = node->prev;

  00008	57		 push	 edi
  00009	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000c	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0000f	5f		 pop	 edi

; 86   : 	} else {

  00010	eb 06		 jmp	 SHORT $LN3@tommy_trie@2
$LN4@tommy_trie@2:

; 87   : 		head->prev = node->prev; /* the last */

  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN3@tommy_trie@2:

; 88   : 	}
; 89   : 
; 90   : 	/* remove from the "0 terminated" next list */
; 91   : 	if (head == node) {

  00018	3b d0		 cmp	 edx, eax

; 92   : 		*let_ptr = node->next; /* the new first */

  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	75 03		 jne	 SHORT $LN2@tommy_trie@2
  0001e	89 16		 mov	 DWORD PTR [esi], edx

; 95   : 	}
; 96   : }

  00020	c3		 ret	 0
$LN2@tommy_trie@2:

; 93   : 	} else {
; 94   : 		node->prev->next = node->next;

  00021	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00024	89 11		 mov	 DWORD PTR [ecx], edx

; 95   : 	}
; 96   : }

  00026	c3		 ret	 0
?tommy_trie_inplace_list_remove@@YAXPAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ENDP ; tommy_trie_inplace_list_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z PROC ; tommy_trie_inplace_list_insert_tail_not_empty, COMDAT
; _head$ = ecx
; _node$ = eax

; 65   : 	/* insert in the list in the last position */
; 66   : 
; 67   : 	/* insert in the "circular" prev list */
; 68   : 	node->prev = head->prev;

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 69   : 	head->prev = node;

  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 70   : 
; 71   : 	/* insert in the "0 terminated" next list */
; 72   : 	node->next = 0;
; 73   : 	node->prev->next = node;

  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 74   : }

  00014	c3		 ret	 0
?tommy_trie_inplace_list_insert_tail_not_empty@@YAXPAUtommy_trie_inplace_node_struct@@0@Z ENDP ; tommy_trie_inplace_list_insert_tail_not_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z
_TEXT	SEGMENT
?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z PROC ; tommy_trie_inplace_list_insert_first, COMDAT
; _node$ = eax

; 50   : 	/* one element "circular" prev list */   
; 51   : 	node->prev = node;

  00000	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 52   : 
; 53   : 	/* one element "0 terminated" next list */
; 54   : 	node->next = 0;

  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 55   : 
; 56   : 	return node;
; 57   : }

  00009	c3		 ret	 0
?tommy_trie_inplace_list_insert_first@@YAPAUtommy_trie_inplace_node_struct@@PAU1@@Z ENDP ; tommy_trie_inplace_list_insert_first
_TEXT	ENDS
PUBLIC	_tommy_trie_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrie.c
;	COMDAT _tommy_trie_bucket
_TEXT	SEGMENT
_tommy_trie_bucket PROC					; COMDAT
; _key$ = edx

; 289  : 	tommy_trie_node* node;
; 290  : 	void* ptr;
; 291  : 	unsigned type;
; 292  : 	unsigned shift;
; 293  : 
; 294  : 	ptr = trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0000c	56		 push	 esi

; 295  : 
; 296  : 	shift = TOMMY_TRIE_BUCKET_SHIFT;

  0000d	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH

; 297  : 
; 298  : recurse:
; 299  : 	if (!ptr)

  00012	85 c0		 test	 eax, eax
  00014	74 16		 je	 SHORT $LN10@tommy_trie@3
$recurse$68723:

; 301  : 
; 302  : 	type = trie_get_type(ptr);

  00016	a8 01		 test	 al, 1

; 303  : 
; 304  : 	switch (type) {

  00018	74 16		 je	 SHORT $LN3@tommy_trie@3

; 308  : 			return 0;
; 309  : 		return node;
; 310  : 	default:
; 311  : 	case TOMMY_TRIE_TYPE_TREE :
; 312  : 		ptr = trie_get_tree(ptr)->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  0001a	8b f2		 mov	 esi, edx
  0001c	d3 ee		 shr	 esi, cl

; 313  : 		shift -= TOMMY_TRIE_TREE_BIT;

  0001e	83 e9 04	 sub	 ecx, 4
  00021	83 e6 0f	 and	 esi, 15			; 0000000fH
  00024	8b 44 b0 ff	 mov	 eax, DWORD PTR [eax+esi*4-1]
  00028	85 c0		 test	 eax, eax
  0002a	75 ea		 jne	 SHORT $recurse$68723
$LN10@tommy_trie@3:

; 300  : 		return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 314  : 		goto recurse;
; 315  : 	}
; 316  : }

  0002f	c3		 ret	 0
$LN3@tommy_trie@3:

; 305  : 	case TOMMY_TRIE_TYPE_NODE :
; 306  : 		node = tommy_cast(tommy_trie_node*, ptr);
; 307  : 		if (node->key != key)

  00030	33 c9		 xor	 ecx, ecx
  00032	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00035	5e		 pop	 esi
  00036	0f 95 c1	 setne	 cl
  00039	49		 dec	 ecx
  0003a	23 c1		 and	 eax, ecx

; 314  : 		goto recurse;
; 315  : 	}
; 316  : }

  0003c	c3		 ret	 0
_tommy_trie_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_init
_TEXT	SEGMENT
_tommy_trie_init PROC					; COMDAT

; 79   : 	unsigned i;
; 80   : 
; 81   : 	for(i=0;i<TOMMY_TRIE_BUCKET_MAX;++i)
; 82   : 		trie->bucket[i] = 0;

  00000	66 0f ef c0	 pxor	 xmm0, xmm0

; 83   :    
; 84   : 	trie->count = 0;

  00004	33 c0		 xor	 eax, eax
  00006	66 0f d6 05 00
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A, xmm0
  0000e	66 0f d6 05 08
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+8, xmm0
  00016	66 0f d6 05 10
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+16, xmm0
  0001e	66 0f d6 05 18
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+24, xmm0
  00026	66 0f d6 05 20
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+32, xmm0
  0002e	66 0f d6 05 28
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+40, xmm0
  00036	66 0f d6 05 30
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+48, xmm0
  0003e	66 0f d6 05 38
	00 00 00	 movq	 QWORD PTR ?trie@@3Utommy_trie_struct@@A+56, xmm0
  00046	a3 40 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64, eax

; 85   : 	trie->node_count = 0;

  0004b	a3 44 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+68, eax

; 86   : 
; 87   : 	trie->alloc = alloc;

  00050	c7 05 48 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+72, OFFSET ?trie_allocator@@3Utommy_allocator_struct@@A ; trie_allocator

; 88   : }

  0005a	c3		 ret	 0
_tommy_trie_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_allocator_free
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyalloc.c
;	COMDAT _tommy_allocator_free
_TEXT	SEGMENT
_tommy_allocator_free PROC				; COMDAT
; _alloc$ = eax
; _ptr$ = ecx

; 127  : 	tommy_allocator_entry* free_block = tommy_cast(tommy_allocator_entry*, ptr);
; 128  : 	
; 129  : 	/* put it in the free list */
; 130  : 	free_block->next = alloc->free_block;

  00000	8b 10		 mov	 edx, DWORD PTR [eax]
  00002	89 11		 mov	 DWORD PTR [ecx], edx

; 131  : 	alloc->free_block = free_block;
; 132  : 
; 133  : 	--alloc->count;

  00004	ff 48 10	 dec	 DWORD PTR [eax+16]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 134  : }

  00009	c3		 ret	 0
_tommy_allocator_free ENDP
_TEXT	ENDS
PUBLIC	_tommy_allocator_alloc
; Function compile flags: /Ogtp
;	COMDAT _tommy_allocator_alloc
_TEXT	SEGMENT
_tommy_allocator_alloc PROC				; COMDAT
; _alloc$ = esi

; 83   : 	void* ptr;
; 84   : 
; 85   : 	/* if no free block available */
; 86   : 	if (!alloc->free_block) {

  00000	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00003	75 50		 jne	 SHORT $LN1@tommy_allo

; 87   : 		tommy_uintptr_t off, mis;
; 88   : 		tommy_size_t size = TOMMY_ALLOCATOR_BLOCK_SIZE;

  00005	53		 push	 ebx
  00006	57		 push	 edi
  00007	bf c0 0f 00 00	 mov	 edi, 4032		; 00000fc0H

; 89   : 		char* data = tommy_cast(char*, tommy_malloc(size));

  0000c	57		 push	 edi
  0000d	e8 00 00 00 00	 call	 _malloc
  00012	8b c8		 mov	 ecx, eax

; 90   : 		tommy_allocator_entry* segment = (tommy_allocator_entry*)data;
; 91   : 
; 92   : 		/* put in the segment list */
; 93   : 		segment->next = alloc->used_segment;

  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 94   : 		alloc->used_segment = segment;
; 95   : 		data += sizeof(tommy_allocator_entry);
; 96   : 
; 97   : 		/* align if not aligned */
; 98   : 		off = (tommy_uintptr_t)data;
; 99   : 		mis = off % alloc->align_size;

  00019	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0001c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0001f	83 c1 04	 add	 ecx, 4
  00022	33 d2		 xor	 edx, edx
  00024	8b c1		 mov	 eax, ecx
  00026	f7 f3		 div	 ebx
  00028	83 c4 04	 add	 esp, 4

; 100  : 		if (mis != 0) {

  0002b	85 d2		 test	 edx, edx
  0002d	74 0e		 je	 SHORT $LN7@tommy_allo

; 101  : 			data += alloc->align_size - mis;

  0002f	8b c3		 mov	 eax, ebx
  00031	2b c2		 sub	 eax, edx
  00033	03 c8		 add	 ecx, eax

; 102  : 			size -= alloc->align_size - mis;

  00035	2b d3		 sub	 edx, ebx
  00037	8d ba c0 0f 00
	00		 lea	 edi, DWORD PTR [edx+4032]
$LN7@tommy_allo:

; 103  : 		}
; 104  : 
; 105  : 		/* insert in free list */
; 106  : 		while (size >= alloc->block_size) {

  0003d	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00040	72 11		 jb	 SHORT $LN9@tommy_allo
$LL2@tommy_allo:

; 107  : 			tommy_allocator_entry* free_block = (tommy_allocator_entry*)data;
; 108  : 			free_block->next = alloc->free_block;

  00042	8b 16		 mov	 edx, DWORD PTR [esi]
  00044	89 11		 mov	 DWORD PTR [ecx], edx

; 109  : 			alloc->free_block = free_block;
; 110  : 
; 111  : 			data += alloc->block_size;

  00046	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00049	89 0e		 mov	 DWORD PTR [esi], ecx

; 112  : 			size -= alloc->block_size;

  0004b	2b f8		 sub	 edi, eax
  0004d	03 c8		 add	 ecx, eax
  0004f	3b f8		 cmp	 edi, eax
  00051	73 ef		 jae	 SHORT $LL2@tommy_allo
$LN9@tommy_allo:
  00053	5f		 pop	 edi
  00054	5b		 pop	 ebx
$LN1@tommy_allo:

; 113  : 		}
; 114  : 	}
; 115  : 
; 116  : 	/* remove one from the free list */
; 117  : 	ptr = alloc->free_block;

  00055	8b 06		 mov	 eax, DWORD PTR [esi]

; 118  : 	alloc->free_block = alloc->free_block->next;

  00057	8b 08		 mov	 ecx, DWORD PTR [eax]

; 119  : 	
; 120  : 	++alloc->count;

  00059	ff 46 10	 inc	 DWORD PTR [esi+16]
  0005c	89 0e		 mov	 DWORD PTR [esi], ecx

; 121  : 
; 122  : 	return ptr;
; 123  : }

  0005e	c3		 ret	 0
_tommy_allocator_alloc ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z
_TEXT	SEGMENT
?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z PROC	; allocator_reset, COMDAT

; 64   : 	tommy_allocator_entry* block = alloc->used_segment;

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4

; 65   : 	while (block) {

  00005	85 c0		 test	 eax, eax
  00007	74 19		 je	 SHORT $LN1@allocator_
  00009	56		 push	 esi
  0000a	8d 9b 00 00 00
	00		 npad	 6
$LL2@allocator_:

; 66   : 		tommy_allocator_entry* block_next = block->next;

  00010	8b 30		 mov	 esi, DWORD PTR [eax]

; 67   : 		tommy_free(block);

  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _free
  00018	83 c4 04	 add	 esp, 4

; 68   : 		block = block_next;

  0001b	8b c6		 mov	 eax, esi
  0001d	85 f6		 test	 esi, esi
  0001f	75 ef		 jne	 SHORT $LL2@allocator_
  00021	5e		 pop	 esi
$LN1@allocator_:

; 69   : 	}
; 70   : 
; 71   : 	alloc->count = 0;

  00022	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, 0

; 72   : 	alloc->free_block = 0;

  0002c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, 0

; 73   : 	alloc->used_segment = 0;

  00036	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, 0

; 74   : }

  00040	c3		 ret	 0
?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ENDP	; allocator_reset
_TEXT	ENDS
PUBLIC	_tommy_allocator_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_allocator_init
_TEXT	SEGMENT
_tommy_allocator_init PROC				; COMDAT

; 42   : 	/* setup the minimal alignment */
; 43   : 	if (align_size < sizeof(void*))
; 44   : 		align_size = sizeof(void*);
; 45   : 
; 46   : 	/* ensure that the block_size keeps the alignment */
; 47   : 	if (block_size % align_size != 0) {
; 48   : 		block_size += align_size - block_size % align_size;
; 49   : 	}
; 50   : 
; 51   : 	alloc->block_size = block_size;

  00000	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00005	a3 08 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+8, eax

; 52   : 	alloc->align_size = align_size;

  0000a	a3 0c 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+12, eax

; 53   : 
; 54   : 	alloc->count = 0;

  0000f	33 c0		 xor	 eax, eax
  00011	a3 10 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, eax

; 55   : 	alloc->free_block = 0;

  00016	a3 00 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, eax

; 56   : 	alloc->used_segment = 0;

  0001b	a3 04 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, eax

; 57   : }

  00020	c3		 ret	 0
_tommy_allocator_init ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.h
_TEXT	ENDS
;	COMDAT _tommy_hashlin_count
_TEXT	SEGMENT
_tommy_hashlin_count PROC				; COMDAT

; 255  : 	return hashlin->count;

  00000	a1 a0 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 256  : }

  00005	c3		 ret	 0
_tommy_hashlin_count ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.h
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_count
_TEXT	SEGMENT
_tommy_hashdyn_count PROC				; COMDAT

; 245  : 	return hashdyn->count;

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 246  : }

  00005	c3		 ret	 0
_tommy_hashdyn_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_bucket
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_tommy_hashdyn_bucket PROC				; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 	return hashdyn->bucket[hash & hashdyn->bucket_mask];

  00003	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00008	23 45 08	 and	 eax, DWORD PTR _hash$[ebp]
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 209  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_tommy_hashdyn_bucket ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashtbl.h
_TEXT	ENDS
;	COMDAT _tommy_hashtable_count
_TEXT	SEGMENT
_tommy_hashtable_count PROC				; COMDAT

; 229  : 	return hashtable->count;

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 230  : }

  00005	c3		 ret	 0
_tommy_hashtable_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_hashtable_bucket
_TEXT	SEGMENT
_hash$ = 8						; size = 4
_tommy_hashtable_bucket PROC				; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 192  : 	return hashtable->bucket[hash & hashtable->bucket_mask];

  00003	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00008	23 45 08	 and	 eax, DWORD PTR _hash$[ebp]
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00011	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 193  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_tommy_hashtable_bucket ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrieinp.h
_TEXT	ENDS
;	COMDAT _tommy_trie_inplace_count
_TEXT	SEGMENT
_tommy_trie_inplace_count PROC				; COMDAT

; 228  : 	return trie_inplace->count;

  00000	a1 00 01 00 00	 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256

; 229  : }

  00005	c3		 ret	 0
_tommy_trie_inplace_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_trie_inplace_search
_TEXT	SEGMENT
_tommy_trie_inplace_search PROC				; COMDAT
; _key$ = edx

; 208  : 	tommy_trie_inplace_node* i = tommy_trie_inplace_bucket(trie_inplace, key);

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]
  0000c	56		 push	 esi
  0000d	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00012	85 c0		 test	 eax, eax
  00014	74 1d		 je	 SHORT $LN10@tommy_trie@4
$LL5@tommy_trie@4:
  00016	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00019	74 14		 je	 SHORT $LN4@tommy_trie@4
  0001b	8b f2		 mov	 esi, edx
  0001d	d3 ee		 shr	 esi, cl
  0001f	83 e9 02	 sub	 ecx, 2
  00022	83 e6 03	 and	 esi, 3
  00025	8b 44 b0 10	 mov	 eax, DWORD PTR [eax+esi*4+16]
  00029	85 c0		 test	 eax, eax
  0002b	75 e9		 jne	 SHORT $LL5@tommy_trie@4
  0002d	5e		 pop	 esi

; 214  : }

  0002e	c3		 ret	 0

; 208  : 	tommy_trie_inplace_node* i = tommy_trie_inplace_bucket(trie_inplace, key);

$LN4@tommy_trie@4:

; 209  : 
; 210  : 	if (!i)

  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN1@tommy_trie@4
$LN10@tommy_trie@4:

; 211  : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 214  : }

  00036	c3		 ret	 0
$LN1@tommy_trie@4:

; 212  : 
; 213  : 	return i->data;

  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	5e		 pop	 esi

; 214  : }

  0003b	c3		 ret	 0
_tommy_trie_inplace_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrie.h
_TEXT	ENDS
;	COMDAT _tommy_trie_count
_TEXT	SEGMENT
_tommy_trie_count PROC					; COMDAT

; 250  : 	return trie->count;

  00000	a1 40 00 00 00	 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A+64

; 251  : }

  00005	c3		 ret	 0
_tommy_trie_count ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_trie_search
_TEXT	SEGMENT
_tommy_trie_search PROC					; COMDAT
; _key$ = edx

; 230  : 	tommy_trie_node* i = tommy_trie_bucket(trie, key);

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  0000c	56		 push	 esi
  0000d	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00012	85 c0		 test	 eax, eax
  00014	74 1d		 je	 SHORT $LN15@tommy_trie@5
$recurse$172889:
  00016	a8 01		 test	 al, 1
  00018	74 14		 je	 SHORT $LN6@tommy_trie@5
  0001a	8b f2		 mov	 esi, edx
  0001c	d3 ee		 shr	 esi, cl
  0001e	83 e9 04	 sub	 ecx, 4
  00021	83 e6 0f	 and	 esi, 15			; 0000000fH
  00024	8b 44 b0 ff	 mov	 eax, DWORD PTR [eax+esi*4-1]
  00028	85 c0		 test	 eax, eax
  0002a	75 ea		 jne	 SHORT $recurse$172889
  0002c	5e		 pop	 esi

; 236  : }

  0002d	c3		 ret	 0

; 230  : 	tommy_trie_node* i = tommy_trie_bucket(trie, key);

$LN6@tommy_trie@5:
  0002e	39 50 0c	 cmp	 DWORD PTR [eax+12], edx

; 231  : 
; 232  : 	if (!i)

  00031	74 04		 je	 SHORT $LN1@tommy_trie@5
$LN15@tommy_trie@5:

; 233  : 		return 0;

  00033	33 c0		 xor	 eax, eax
  00035	5e		 pop	 esi

; 236  : }

  00036	c3		 ret	 0
$LN1@tommy_trie@5:

; 234  : 
; 235  : 	return i->data;

  00037	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003a	5e		 pop	 esi

; 236  : }

  0003b	c3		 ret	 0
_tommy_trie_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommylist.h
_TEXT	ENDS
;	COMDAT _tommy_list_insert_tail_not_empty
_TEXT	SEGMENT
_tommy_list_insert_tail_not_empty PROC			; COMDAT
; _head$ = ecx
; _node$ = eax

; 191  : 	/* insert in the "circular" prev list */
; 192  : 	node->prev = head->prev;

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 193  : 	head->prev = node;

  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 194  : 
; 195  : 	/* insert in the "0 terminated" next list */
; 196  : 	node->next = 0;
; 197  : 	node->prev->next = node;

  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00012	89 01		 mov	 DWORD PTR [ecx], eax

; 198  : }

  00014	c3		 ret	 0
_tommy_list_insert_tail_not_empty ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_insert_first
_TEXT	SEGMENT
_tommy_list_insert_first PROC				; COMDAT
; _list$ = ecx
; _node$ = eax

; 154  : 	/* one element "circular" prev list */   
; 155  : 	node->prev = node;

  00000	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 156  : 
; 157  : 	/* one element "0 terminated" next list */
; 158  : 	node->next = 0;

  00003	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 159  : 
; 160  : 	*list = node;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 161  : }

  0000b	c3		 ret	 0
_tommy_list_insert_first ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_head
_TEXT	SEGMENT
_tommy_list_head PROC					; COMDAT
; _list$ = eax

; 130  : 	return *list;

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 131  : }

  00002	c3		 ret	 0
_tommy_list_head ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhash.h
_TEXT	ENDS
;	COMDAT _tommy_inthash_u32
_TEXT	SEGMENT
_tommy_inthash_u32 PROC					; COMDAT
; _key$ = ecx

; 82   : 	key -= key << 6;

  00000	8b c1		 mov	 eax, ecx
  00002	c1 e0 06	 shl	 eax, 6
  00005	2b c8		 sub	 ecx, eax

; 83   : 	key ^= key >> 17;

  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 11	 shr	 edx, 17			; 00000011H
  0000c	33 ca		 xor	 ecx, edx

; 84   : 	key -= key << 9;

  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e0 09	 shl	 eax, 9
  00013	2b c8		 sub	 ecx, eax

; 85   : 	key ^= key << 4;

  00015	8b d1		 mov	 edx, ecx
  00017	c1 e2 04	 shl	 edx, 4
  0001a	33 ca		 xor	 ecx, edx

; 86   : 	key -= key << 3;

  0001c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00023	2b c8		 sub	 ecx, eax

; 87   : 	key ^= key << 10;

  00025	8b d1		 mov	 edx, ecx
  00027	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0002a	33 ca		 xor	 ecx, edx

; 88   : 	key ^= key >> 15;

  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00031	33 c1		 xor	 eax, ecx

; 89   : 
; 90   : 	return key;
; 91   : }

  00033	c3		 ret	 0
_tommy_inthash_u32 ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytypes.h
_TEXT	ENDS
;	COMDAT _tommy_roundup_pow2_u32
_TEXT	SEGMENT
_tommy_roundup_pow2_u32 PROC				; COMDAT
; _value$ = ecx

; 370  : 	/* Round up to the next highest power of 2 */
; 371  : 	/* from http://www-graphics.stanford.edu/~seander/bithacks.html */
; 372  : 
; 373  : 	--value;

  00000	49		 dec	 ecx

; 374  : 	value |= value >> 1;

  00001	8b c1		 mov	 eax, ecx
  00003	d1 e8		 shr	 eax, 1
  00005	0b c8		 or	 ecx, eax

; 375  : 	value |= value >> 2;

  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 02	 shr	 edx, 2
  0000c	0b ca		 or	 ecx, edx

; 376  : 	value |= value >> 4;

  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e8 04	 shr	 eax, 4
  00013	0b c8		 or	 ecx, eax

; 377  : 	value |= value >> 8;

  00015	8b d1		 mov	 edx, ecx
  00017	c1 ea 08	 shr	 edx, 8
  0001a	0b ca		 or	 ecx, edx

; 378  : 	value |= value >> 16;

  0001c	8b c1		 mov	 eax, ecx
  0001e	c1 e8 10	 shr	 eax, 16			; 00000010H
  00021	0b c1		 or	 eax, ecx

; 379  : 	++value;

  00023	40		 inc	 eax

; 380  : 
; 381  : 	return value;
; 382  : }

  00024	c3		 ret	 0
_tommy_roundup_pow2_u32 ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_ilog2_u32
_TEXT	SEGMENT
_count$ = -4						; size = 4
_value$ = 8						; size = 4
_tommy_ilog2_u32 PROC					; COMDAT

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 303  : #if defined(_MSC_VER)
; 304  : 	unsigned long count;
; 305  : 	_BitScanReverse(&count, value);

  00004	0f bd 45 08	 bsr	 eax, DWORD PTR _value$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax

; 306  : 	return count;
; 307  : #elif defined(__GNUC__)
; 308  : 	/*
; 309  : 	 * GCC implements __builtin_clz(x) as "__builtin_clz(x) = bsr(x) ^ 31"
; 310  : 	 *
; 311  : 	 * Where "x ^ 31 = 31 - x", but gcc does not optimize "31 - __builtin_clz(x)" to bsr(x),
; 312  : 	 * but generates 31 - (bsr(x) xor 31).
; 313  : 	 *
; 314  : 	 * So we write "__builtin_clz(x) ^ 31" instead of "31 - __builtin_clz(x)".
; 315  : 	 */
; 316  : 	return __builtin_clz(value) ^ 31;
; 317  : #else
; 318  : 	/* Find the log base 2 of an N-bit integer in O(lg(N)) operations with multiply and lookup */
; 319  : 	/* from http://graphics.stanford.edu/~seander/bithacks.html */
; 320  : 	static const int TOMMY_DE_BRUIJN_INDEX_ILOG2[32] = {
; 321  : 		0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30,
; 322  : 		8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31
; 323  : 	};
; 324  : 
; 325  : 	value |= value >> 1;
; 326  : 	value |= value >> 2;
; 327  : 	value |= value >> 4;
; 328  : 	value |= value >> 8;
; 329  : 	value |= value >> 16;
; 330  : 
; 331  : 	return TOMMY_DE_BRUIJN_INDEX_ILOG2[(tommy_uint32_t)(value * 0x07C4ACDDU) >> 27];
; 332  : #endif
; 333  : }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
_tommy_ilog2_u32 ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 164  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 248  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,int><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00012	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QAH@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z PROC ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 146  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@$$CBIPAUcpp_object@@@std@@QAE@$$QBI$$QAPAUcpp_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,cpp_object *>::_Pair_base<unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z
_TEXT	SEGMENT
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN3@construct
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN3@construct:

; 203  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@$$QAV32@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z PROC ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN3@Construct
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct:

; 49   : 	}

  00008	c3		 ret	 0
??$_Construct@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@ABV12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV10@@Z ENDP ; std::_Construct<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z PROC ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 256  : 		}

  0000a	c3		 ret	 0
??$?0$$CBIPAUcpp_object@@@?$pair@$$CBIPAUcpp_object@@@std@@QAE@$$QAU01@@Z ENDP ; std::pair<unsigned int const ,cpp_object *>::pair<unsigned int const ,cpp_object *><unsigned int const ,cpp_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIPAUgoogle_object@@@?$_Pair_base@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int,google_object *>::_Pair_base<unsigned int,google_object *><unsigned int &,google_object *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z PROC ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN7@Cons_val
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN7@Cons_val:

; 281  : 	}

  00008	c3		 ret	 0
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@$$QAV20@@Z ENDP ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 164  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z
_TEXT	SEGMENT
?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal, COMDAT
; _f$ = eax
; _parent$ = edx

; 699  :     btree_node *n = init_leaf(f, parent, kNodeValues);

  00000	32 c9		 xor	 cl, cl
  00002	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00008	88 48 03	 mov	 BYTE PTR [eax+3], cl
  0000b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 700  :     f->leaf = 0;

  0000e	88 08		 mov	 BYTE PTR [eax], cl

; 701  :     if (!NDEBUG) {
; 702  :       memset(f->children, 0, sizeof(f->children));
; 703  :     }
; 704  :     return n;
; 705  :   }

  00010	c3		 ret	 0
?init_internal@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUinternal_fields@12@PAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_internal
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z
_TEXT	SEGMENT
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 197  : 		_Construct(_Ptr, _Val);

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN5@construct@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct@2:

; 198  : 		}

  00008	c3		 ret	 0
?construct@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::construct
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z PROC ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@construct@3
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@3:

; 203  : 		}

  0000e	c3		 ret	 0
?construct@?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@QAEXPAU?$pair@$$CBIPAUcpp_object@@@2@$$QAU32@@Z ENDP ; std::allocator<std::pair<unsigned int const ,cpp_object *> >::construct
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init, COMDAT
; _this$ = eax
; _x$ = ecx

; 722  :   void value_init(int i, const value_type &x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 723  :     new (&fields_.values[i]) mutable_value_type(x);

  00003	8b 55 08	 mov	 edx, DWORD PTR _i$[ebp]
  00006	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  0000a	85 c0		 test	 eax, eax
  0000c	74 0a		 je	 SHORT $LN3@value_init
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 10		 mov	 DWORD PTR [eax], edx
  00012	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@value_init:

; 724  :   }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z
_TEXT	SEGMENT
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init, COMDAT
; _this$ = eax
; _i$ = ecx

; 720  :     new (&fields_.values[i]) mutable_value_type;

  00000	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]
  00004	85 c0		 test	 eax, eax
  00006	74 0d		 je	 SHORT $LN3@value_init@2
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN3@value_init@2:

; 721  :   }

  00015	c3		 ret	 0
?value_init@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child, COMDAT
; _i$ = ecx
; _c$ = eax

; 574  :   void set_child(int i, btree_node *c) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]

; 575  :     *mutable_child(i) = c;

  00006	89 84 8a 00 01
	00 00		 mov	 DWORD PTR [edx+ecx*4+256], eax

; 576  :     c->fields_.parent = this;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 577  :     c->fields_.position = i;

  00010	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 578  :   }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?set_child@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::set_child
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost, COMDAT
; _this$ = eax

; 1224 :   node_type** mutable_rightmost() { return root()->mutable_rightmost(); }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	05 80 01 00 00	 add	 eax, 384		; 00000180H
  00007	c3		 ret	 0
?mutable_rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_rightmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z PROC ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0IPAUgoogle_object@@@?$_Pair_base@$$CBIPAUgoogle_object@@@std@@QAE@$$QAI$$QAPAUgoogle_object@@@Z ENDP ; std::_Pair_base<unsigned int const ,google_object *>::_Pair_base<unsigned int const ,google_object *><unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z PROC ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIPAUgoogle_object@@@?$pair@IPAUgoogle_object@@@std@@QAE@AAI$$QAPAUgoogle_object@@@Z ENDP ; std::pair<unsigned int,google_object *>::pair<unsigned int,google_object *><unsigned int &,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$_Pair_base@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::_Pair_base<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z PROC ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 04		 je	 SHORT $LN9@Cons_val@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val@2:

; 281  : 	}

  00008	c3		 ret	 0
??$_Cons_val@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABV32@@std@@YAXAAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@ABV20@@Z ENDP ; std::_Cons_val<std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00006	3b ca		 cmp	 ecx, edx
  00008	74 19		 je	 SHORT $LN4@Uninit_mov
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00010	85 c0		 test	 eax, eax
  00012	74 04		 je	 SHORT $LN20@Uninit_mov
  00014	8b 31		 mov	 esi, DWORD PTR [ecx]
  00016	89 30		 mov	 DWORD PTR [eax], esi
$LN20@Uninit_mov:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00018	83 c1 04	 add	 ecx, 4
  0001b	83 c0 04	 add	 eax, 4
  0001e	3b ca		 cmp	 ecx, edx
  00020	75 ee		 jne	 SHORT $LL6@Uninit_mov
  00022	5e		 pop	 esi
$LN4@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);
; 438  : 	}

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@Construct@2
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 49   : 	}

  0000e	c3		 ret	 0
??$_Construct@U?$pair@$$CBIPAUgoogle_object@@@std@@ABU12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned int const ,google_object *>,std::pair<unsigned int const ,google_object *> const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z
_TEXT	SEGMENT
??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Pdest$ = eax
; __Src$ = ecx

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN7@Cons_val@3
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@3:

; 281  : 	}

  0000e	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@std@@U?$pair@$$CBIPAUcpp_object@@@2@U32@@std@@YAXAAV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@0@PAU?$pair@$$CBIPAUcpp_object@@@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<unsigned int const ,cpp_object *> >,std::pair<unsigned int const ,cpp_object *>,std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 248  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?0AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool><btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 146  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0?$_Pair_base@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::_Pair_base<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ
_TEXT	SEGMENT
?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy, COMDAT

; 713  :     for (int i = 0; i < count(); ++i) {
; 714  :       value_destroy(i);
; 715  :     }
; 716  :   }

  00000	c3		 ret	 0
?destroy@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::destroy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z
_TEXT	SEGMENT
?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z PROC ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare, COMDAT
; _x$ = eax
; _y$ = edx

; 234  :     return comp(x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 235  :   }

  00008	c3		 ret	 0
?bool_compare@?$btree_key_comparer@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@$0A@@btree@@SA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@2@ABI1@Z ENDP ; btree::btree_key_comparer<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> >,0>::bool_compare
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 228  : 		}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@QAE@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>::pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ
_TEXT	SEGMENT
?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root, COMDAT
; _this$ = eax

; 540  :     assert(parent()->is_root());
; 541  :     fields_.parent = fields_.parent->parent();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 542  :   }

  00009	c3		 ret	 0
?make_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::make_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ
_TEXT	SEGMENT
?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root, COMDAT
; _this$ = eax

; 538  :   bool is_root() const { return parent()->leaf(); }

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	c3		 ret	 0
?is_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBE_NXZ ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::is_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node, COMDAT
; _node$ = eax

; 1275 :     node->destroy();
; 1276 :     mutable_internal_allocator()->deallocate(
; 1277 :         reinterpret_cast<char*>(node),
; 1278 :         sizeof(base_fields) + node->max_count() * sizeof(value_type));

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 1279 :   }

  00007	c3		 ret	 0
?delete_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_leaf_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ
_TEXT	SEGMENT
?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node, COMDAT
; _this$ = eax

; 1270 :     root()->destroy();
; 1271 :     mutable_internal_allocator()->deallocate(
; 1272 :         reinterpret_cast<char*>(root()), sizeof(root_fields));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	51		 push	 ecx
  00003	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00008	59		 pop	 ecx

; 1273 :   }

  00009	c3		 ret	 0
?delete_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_root_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node, COMDAT
; _node$ = eax

; 1264 :     node->destroy();
; 1265 :     assert(node != root());
; 1266 :     mutable_internal_allocator()->deallocate(
; 1267 :         reinterpret_cast<char*>(node), sizeof(internal_fields));

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00006	59		 pop	 ecx

; 1268 :   }

  00007	c3		 ret	 0
?delete_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::delete_internal_node
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_swap_helper@I@btree@@YAXAAI0@Z
_TEXT	SEGMENT
??$btree_swap_helper@I@btree@@YAXAAI0@Z PROC		; btree::btree_swap_helper<unsigned int>, COMDAT
; _a$ = ecx
; _b$ = eax

; 133  :   using std::swap;
; 134  :   swap(a, b);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx
  00009	5e		 pop	 esi

; 135  : }

  0000a	c3		 ret	 0
??$btree_swap_helper@I@btree@@YAXAAI0@Z ENDP		; btree::btree_swap_helper<unsigned int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z
_TEXT	SEGMENT
??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z PROC ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 256  : 		}

  0000a	c3		 ret	 0
??$?0IPAUgoogle_object@@@?$pair@$$CBIPAUgoogle_object@@@std@@QAE@$$QAU?$pair@IPAUgoogle_object@@@1@@Z ENDP ; std::pair<unsigned int const ,google_object *>::pair<unsigned int const ,google_object *><unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z PROC ; std::make_pair<unsigned int,google_object *>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 368  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 370  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 371  : 	return (_Mypair((typename _Unrefwrap<_Ty1>::type)_Val1,

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 372  : 		_STD forward<_Ty2>(_Val2)));
; 373  : 	}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$make_pair@IPAUgoogle_object@@@std@@YA?AU?$pair@IPAUgoogle_object@@@0@ABI$$QAPAUgoogle_object@@@Z ENDP ; std::make_pair<unsigned int,google_object *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,bool><std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > &,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z
_TEXT	SEGMENT
??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z PROC ; btree::btree_compare_keys<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _x$ = eax
; _y$ = edx

; 265  :   typedef btree_key_comparer<Key, Compare,
; 266  :       btree_is_key_compare_to<Compare>::value> key_comparer;
; 267  :   return key_comparer::bool_compare(comp, x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 268  : }

  00008	c3		 ret	 0
??$btree_compare_keys@IU?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@btree@@YA_NABU?$btree_key_compare_to_adapter@U?$less@I@std@@@0@ABI1@Z ENDP ; btree::btree_compare_keys<unsigned int,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Count$ = eax
; __Pval$ = edx

; 558  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  00006	85 c0		 test	 eax, eax
  00008	74 15		 je	 SHORT $LN4@Uninit_fil
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_fil:

; 568  : 		_Cons_val(_Al, _First, *_Pval);

  00010	85 c9		 test	 ecx, ecx
  00012	74 04		 je	 SHORT $LN22@Uninit_fil
  00014	8b 32		 mov	 esi, DWORD PTR [edx]
  00016	89 31		 mov	 DWORD PTR [ecx], esi
$LN22@Uninit_fil:

; 559  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 560  : //	if (_Count < 0)
; 561  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 562  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 563  : 
; 564  : 	_FwdIt _Next = _First;
; 565  : 
; 566  : 	_TRY_BEGIN
; 567  : 	for (; 0 < _Count; --_Count, ++_First)

  00018	83 c1 04	 add	 ecx, 4
  0001b	48		 dec	 eax
  0001c	75 f2		 jne	 SHORT $LL6@Uninit_fil
  0001e	5e		 pop	 esi
$LN4@Uninit_fil:

; 569  : 	_CATCH_ALL
; 570  : 	for (; _Next != _First; ++_Next)
; 571  : 		_Dest_val(_Al, _Next);
; 572  : 	_RERAISE;
; 573  : 	_CATCH_END
; 574  : 	}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$173810 = -4					; size = 1
__Dest$ = 8						; size = 4
??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$173810[ebp]
  00007	50		 push	 eax
  00008	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00011	83 c4 08	 add	 esp, 8

; 472  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Uninitialized_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@Z PROC ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &,bool &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0000b	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00015	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001e	8a 0a		 mov	 cl, BYTE PTR [edx]
  00020	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 164  : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$?0AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AA_N@Z ENDP ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator &,bool &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z PROC	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0AAIABI@?$_Pair_base@II@std@@QAE@AAIABI@Z ENDP	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int &,unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z PROC	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0ABIAAI@?$_Pair_base@II@std@@QAE@ABIAAI@Z ENDP	; std::_Pair_base<unsigned int,unsigned int>::_Pair_base<unsigned int,unsigned int><unsigned int const &,unsigned int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >, COMDAT
; __Last$ = ecx
; __Val$ = edx

; 479  : 	{	// copy _Val throughout raw [_First, _Last), arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 480  : 	_DEBUG_RANGE(_First, _Last);
; 481  : 	_FwdIt _Next = _First;
; 482  : 
; 483  : 	_TRY_BEGIN
; 484  : 	for (; _First != _Last; ++_First)

  00006	3b c1		 cmp	 eax, ecx
  00008	74 1c		 je	 SHORT $LN4@Uninit_fil@2
  0000a	56		 push	 esi
  0000b	eb 03 8d 49 00	 npad	 5
$LL6@Uninit_fil@2:

; 485  : 		_Construct(&*_First, _Val);

  00010	85 c0		 test	 eax, eax
  00012	74 0a		 je	 SHORT $LN16@Uninit_fil@2
  00014	8b 32		 mov	 esi, DWORD PTR [edx]
  00016	89 30		 mov	 DWORD PTR [eax], esi
  00018	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001b	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN16@Uninit_fil@2:

; 480  : 	_DEBUG_RANGE(_First, _Last);
; 481  : 	_FwdIt _Next = _First;
; 482  : 
; 483  : 	_TRY_BEGIN
; 484  : 	for (; _First != _Last; ++_First)

  0001e	83 c0 08	 add	 eax, 8
  00021	3b c1		 cmp	 eax, ecx
  00023	75 eb		 jne	 SHORT $LL6@Uninit_fil@2
  00025	5e		 pop	 esi
$LN4@Uninit_fil@2:

; 486  : 	_CATCH_ALL
; 487  : 	for (; _Next != _First; ++_Next)
; 488  : 		_Destroy(&*_Next);
; 489  : 	_RERAISE;
; 490  : 	_CATCH_END
; 491  : 	}

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0ABIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0ABIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z PROC ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int const &,stx_object * &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0ABIAAPAUstx_object@@@?$_Pair_base@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z ENDP ; std::_Pair_base<unsigned int,stx_object *>::_Pair_base<unsigned int,stx_object *><unsigned int const &,stx_object * &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@AAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> &,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z PROC ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>, COMDAT
; ___$ReturnUdt$ = eax
; __Val1$ = ecx

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8a 0a		 mov	 cl, BYTE PTR [edx]
  00012	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$make_pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@YA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@0@$$QAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@$$QA_N@Z ENDP ; std::make_pair<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>,bool>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z
_TEXT	SEGMENT
_iter$ = 8						; size = 8
??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = eax

; 2188 : inline IterType btree<P>::internal_last(IterType iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2189 :   while (iter.node && iter.position == iter.node->count()) {

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp+4]
  00009	56		 push	 esi
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 1e		 je	 SHORT $LN2@internal_l
  0000e	8b ff		 npad	 2
$LL3@internal_l:
  00010	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  00014	3b d6		 cmp	 edx, esi
  00016	75 14		 jne	 SHORT $LN2@internal_l

; 2190 :     iter.position = iter.node->position();

  00018	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  0001c	89 55 0c	 mov	 DWORD PTR _iter$[ebp+4], edx

; 2191 :     iter.node = iter.node->parent();

  0001f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00022	89 4d 08	 mov	 DWORD PTR _iter$[ebp], ecx

; 2192 :     if (iter.node->leaf()) {

  00025	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00028	74 e6		 je	 SHORT $LL3@internal_l

; 2193 :       iter.node = NULL;

  0002a	33 c9		 xor	 ecx, ecx
$LN2@internal_l:

; 2194 :     }
; 2195 :   }
; 2196 :   return iter;

  0002c	89 08		 mov	 DWORD PTR [eax], ecx
  0002e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00031	5e		 pop	 esi

; 2197 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow, COMDAT
; _this$ = eax

; 1706 :   if (node->leaf()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 1707 :     assert(position <= -1);
; 1708 :     self_type save(*this);

  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	74 35		 je	 SHORT $LN7@decrement_
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1709 :     while (position < 0 && !node->is_root()) {

  0000d	85 d2		 test	 edx, edx
  0000f	79 21		 jns	 SHORT $LN5@decrement_
  00011	57		 push	 edi
$LL6@decrement_:
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00017	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0001a	75 15		 jne	 SHORT $LN39@decrement_

; 1710 :       assert(node->parent()->child(node->position()) == node);
; 1711 :       position = node->position() - 1;

  0001c	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  00020	49		 dec	 ecx
  00021	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1712 :       node = node->parent();

  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	7c e1		 jl	 SHORT $LL6@decrement_
$LN39@decrement_:
  00031	5f		 pop	 edi
$LN5@decrement_:

; 1713 :     }
; 1714 :     if (position < 0) {

  00032	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00036	7d 05		 jge	 SHORT $LN38@decrement_

; 1715 :       *this = save;

  00038	89 30		 mov	 DWORD PTR [eax], esi
  0003a	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN38@decrement_:
  0003d	5e		 pop	 esi

; 1724 :   }
; 1725 : }

  0003e	c3		 ret	 0
$LN7@decrement_:

; 1716 :     }
; 1717 :   } else {
; 1718 :     assert(position >= 0);
; 1719 :     node = node->child(position);

  0003f	8b 8c 91 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+256]
  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1720 :     while (!node->leaf()) {

  00048	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0004b	75 17		 jne	 SHORT $LN1@decrement_
  0004d	8d 49 00	 npad	 3
$LL2@decrement_:

; 1721 :       node = node->child(node->count());

  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00056	8b 8c 91 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+256]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
  0005f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00062	74 ec		 je	 SHORT $LL2@decrement_
$LN1@decrement_:

; 1722 :     }
; 1723 :     position = node->count() - 1;

  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0006a	4a		 dec	 edx
  0006b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1724 :   }
; 1725 : }

  0006e	c3		 ret	 0
?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow, COMDAT
; _this$ = eax

; 1666 :   if (node->leaf()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0

; 1667 :     assert(position >= node->count());
; 1668 :     self_type save(*this);

  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	74 40		 je	 SHORT $LN7@increment_
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1669 :     while (position == node->count() && !node->is_root()) {

  0000d	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00011	3b d1		 cmp	 edx, ecx
  00013	75 23		 jne	 SHORT $LN5@increment_
  00015	57		 push	 edi
$LL6@increment_:
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  0001b	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0001e	75 17		 jne	 SHORT $LN39@increment_

; 1670 :       assert(node->parent()->child(node->position()) == node);
; 1671 :       position = node->position();

  00020	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1672 :       node = node->parent();

  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002c	89 08		 mov	 DWORD PTR [eax], ecx
  0002e	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  00032	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00035	74 df		 je	 SHORT $LL6@increment_
$LN39@increment_:
  00037	5f		 pop	 edi
$LN5@increment_:

; 1673 :     }
; 1674 :     if (position == node->count()) {

  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0003e	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00041	75 05		 jne	 SHORT $LN38@increment_

; 1675 :       *this = save;

  00043	89 30		 mov	 DWORD PTR [eax], esi
  00045	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN38@increment_:
  00048	5e		 pop	 esi

; 1684 :   }
; 1685 : }

  00049	c3		 ret	 0
$LN7@increment_:

; 1676 :     }
; 1677 :   } else {
; 1678 :     assert(position < node->count());
; 1679 :     node = node->child(position + 1);

  0004a	8b 8c 91 04 01
	00 00		 mov	 ecx, DWORD PTR [ecx+edx*4+260]
  00051	89 08		 mov	 DWORD PTR [eax], ecx

; 1680 :     while (!node->leaf()) {

  00053	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00056	75 17		 jne	 SHORT $LN1@increment_
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL2@increment_:

; 1681 :       node = node->child(0);

  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [ecx+256]
  00068	89 10		 mov	 DWORD PTR [eax], edx
  0006a	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0006d	74 f1		 je	 SHORT $LL2@increment_
$LN1@increment_:

; 1682 :     }
; 1683 :     position = 0;

  0006f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1684 :   }
; 1685 : }

  00076	c3		 ret	 0
?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_node$ = 8						; size = 4
?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear, COMDAT
; _this$ = ecx

; 2333 : void btree<P>::internal_clear(node_type *node) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2334 :   if (!node->leaf()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _node$[ebp]
  00008	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	75 42		 jne	 SHORT $LN7@internal_c

; 2335 :     for (int i = 0; i <= node->count(); ++i) {

  00010	56		 push	 esi
  00011	33 f6		 xor	 esi, esi
  00013	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  00017	72 1f		 jb	 SHORT $LN4@internal_c
  00019	57		 push	 edi
  0001a	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
$LL44@internal_c:

; 2336 :       internal_clear(node->child(i));

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
  0002b	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  0002f	46		 inc	 esi
  00030	83 c7 04	 add	 edi, 4
  00033	3b f1		 cmp	 esi, ecx
  00035	7e e9		 jle	 SHORT $LL44@internal_c
  00037	5f		 pop	 edi
$LN4@internal_c:

; 2337 :     }
; 2338 :     if (node == root()) {

  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	5e		 pop	 esi
  0003e	3b d8		 cmp	 ebx, eax
  00040	75 10		 jne	 SHORT $LN7@internal_c

; 2339 :       delete_internal_root_node();

  00042	50		 push	 eax

; 2340 :     } else {
; 2341 :       delete_internal_node(node);
; 2342 :     }
; 2343 :   } else {
; 2344 :     delete_leaf_node(node);

  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	83 c4 04	 add	 esp, 4
  0004b	5b		 pop	 ebx

; 2345 :   }
; 2346 : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN7@internal_c:

; 2340 :     } else {
; 2341 :       delete_internal_node(node);
; 2342 :     }
; 2343 :   } else {
; 2344 :     delete_leaf_node(node);

  00052	53		 push	 ebx
  00053	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00058	83 c4 04	 add	 esp, 4
  0005b	5b		 pop	 ebx

; 2345 :   }
; 2346 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size, COMDAT

; 882  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 883  : 		}

  00005	c3		 ret	 0
?max_size@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000c	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z PROC ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00014	8a 0a		 mov	 cl, BYTE PTR [edx]
  00016	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 146  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0?$_Pair_base@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ENDP ; std::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::_Pair_base<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize, COMDAT
; _this$ = ecx

; 1520 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00008	2b d0		 sub	 edx, eax
  0000a	83 fa 01	 cmp	 edx, 1
  0000d	73 0a		 jae	 SHORT $LN1@Incsize

; 1521 : 			_Xlength_error("list<T> too long");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN11@Incsize:
$LN1@Incsize:

; 1522 : 		this->_Mysize += _Count;

  00019	40		 inc	 eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1523 : 		}

  0001d	c3		 ret	 0
$LN10@Incsize:
?_Incsize@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXI@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Incsize
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ
_TEXT	SEGMENT
tv137 = -4						; size = 4
tv133 = -4						; size = 4
?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor, COMDAT
; _this$ = eax

; 479  : 		{	// return elements per bucket

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 480  : 		return ((float)size() / (float)bucket_count());

  00004	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00007	db 40 08	 fild	 DWORD PTR [eax+8]
  0000a	85 c9		 test	 ecx, ecx
  0000c	79 06		 jns	 SHORT $LN9@load_facto
  0000e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN9@load_facto:
  00014	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00017	db 40 24	 fild	 DWORD PTR [eax+36]
  0001a	85 d2		 test	 edx, edx
  0001c	79 06		 jns	 SHORT $LN10@load_facto
  0001e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN10@load_facto:
  00024	de f9		 fdivp	 ST(1), ST(0)

; 481  : 		}

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?load_factor@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::load_factor
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement, COMDAT
; _this$ = eax

; 787  :     if (node->leaf() && --position >= 0) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	74 05		 je	 SHORT $LN1@decrement
  00007	ff 48 04	 dec	 DWORD PTR [eax+4]
  0000a	79 05		 jns	 SHORT $LN2@decrement
$LN1@decrement:

; 788  :       return;
; 789  :     }
; 790  :     decrement_slow();

  0000c	e9 00 00 00 00	 jmp	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN2@decrement:

; 791  :   }

  00011	c3		 ret	 0
?decrement@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z PROC ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0000a	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  0000e	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00014	8a 0a		 mov	 cl, BYTE PTR [edx]
  00016	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 228  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??0?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@QAE@$$QAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@$$QA_N@Z ENDP ; std::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>::pair<google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same, COMDAT
; _this$ = edx
; __Right$ = ecx

; 1467 : 		{	// splice _Right [_First, _Last) before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1468 : 		if (this != &_Right)

  00003	3b d1		 cmp	 edx, ecx
  00005	74 22		 je	 SHORT $LN1@Splice_sam

; 1469 : 			{	// splicing from another list, adjust counts
; 1470 : 			_Incsize(_Count);

  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	56		 push	 esi
  0000b	be fe ff ff 1f	 mov	 esi, 536870910		; 1ffffffeH
  00010	2b f0		 sub	 esi, eax
  00012	83 fe 01	 cmp	 esi, 1
  00015	5e		 pop	 esi
  00016	73 0a		 jae	 SHORT $LN4@Splice_sam
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0001d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN63@Splice_sam:
$LN4@Splice_sam:
  00022	40		 inc	 eax
  00023	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1471 : 			_Right._Mysize -= _Count;

  00026	ff 49 04	 dec	 DWORD PTR [ecx+4]
$LN1@Splice_sam:

; 1472 : 			}
; 1473 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1474 : 			_Last._Mynode();

  00029	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00032	89 11		 mov	 DWORD PTR [ecx], edx

; 1475 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1476 : 			_Where._Mynode();

  00034	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0003d	89 11		 mov	 DWORD PTR [ecx], edx

; 1477 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1478 : 			_First._Mynode();

  0003f	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 1479 : 
; 1480 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());

  0004a	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]

; 1481 : 		this->_Prevnode(_Where._Mynode()) =
; 1482 : 			this->_Prevnode(_Last._Mynode());

  0004d	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00050	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1483 : 		this->_Prevnode(_Last._Mynode()) =
; 1484 : 			this->_Prevnode(_First._Mynode());

  00059	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0005c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005f	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00062	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1485 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

  00065	8b 55 0c	 mov	 edx, DWORD PTR __First$[ebp]
  00068	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1486 : 		}

  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
$LN62@Splice_sam:
?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ
_TEXT	SEGMENT
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--, COMDAT
; _this$ = esi

; 817  :     decrement();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	80 38 00	 cmp	 BYTE PTR [eax], 0
  00005	74 05		 je	 SHORT $LN3@operator@7
  00007	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0000a	79 07		 jns	 SHORT $LN8@operator@7
$LN3@operator@7:
  0000c	8b c6		 mov	 eax, esi
  0000e	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN8@operator@7:

; 818  :     return *this;

  00013	8b c6		 mov	 eax, esi

; 819  :   }

  00015	c3		 ret	 0
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ
_TEXT	SEGMENT
?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment, COMDAT
; _this$ = eax

; 778  :     if (node->leaf() && ++position < node->count()) {

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	74 0c		 je	 SHORT $LN1@increment
  00007	ff 40 04	 inc	 DWORD PTR [eax+4]
  0000a	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0000e	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00011	7c 05		 jl	 SHORT $LN2@increment
$LN1@increment:

; 779  :       return;
; 780  :     }
; 781  :     increment_slow();

  00013	e9 00 00 00 00	 jmp	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
$LN2@increment:

; 782  :   }

  00018	c3		 ret	 0
?increment@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z
_TEXT	SEGMENT
?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z PROC ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap, COMDAT
; _a$ = ecx
; _b$ = eax

; 326  :     btree_swap_helper(a->first, b->first);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 30		 mov	 esi, DWORD PTR [eax]
  00005	89 31		 mov	 DWORD PTR [ecx], esi
  00007	89 10		 mov	 DWORD PTR [eax], edx

; 327  :     btree_swap_helper(a->second, b->second);

  00009	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00015	5e		 pop	 esi

; 328  :   }

  00016	c3		 ret	 0
?swap@?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@SAXPAU?$pair@IPAUgoogle_object@@@std@@0@Z ENDP ; btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::swap
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator(), COMDAT
; ___$ReturnUdt$ = eax
; _key$ = ecx

; 139  :       return STL_NAMESPACE::make_pair(key, T());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 140  :     }

  0000b	c3		 ret	 0
??RDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue::operator()
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ
_TEXT	SEGMENT
??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 242  :       return std::make_pair(key, data_type());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 243  :     }

  0000d	c3		 ret	 0
??Dgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QBE?AU?$pair@$$CBIPAUgoogle_object@@@std@@XZ ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value::operator*
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?key_lessequal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z
_TEXT	SEGMENT
?key_lessequal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_lessequal, COMDAT
; _a$ = ecx
; _b$ = eax

; 1419 :         return !m_key_less(b, a);

  00000	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00002	1b c0		 sbb	 eax, eax
  00004	40		 inc	 eax

; 1420 :     }

  00005	c3		 ret	 0
?key_lessequal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_lessequal
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z
_TEXT	SEGMENT
??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>, COMDAT
; _this$ = eax
; _d$ = ecx

; 888  :           data(d) {

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 889  :     }

  00004	c3		 ret	 0
??0?$empty_base_handle@V?$allocator@D@std@@PAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABV?$allocator@D@std@@ABQAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>::empty_base_handle<std::allocator<char>,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > *>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z
_TEXT	SEGMENT
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 826  :     self_type tmp = *this;

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]

; 827  :     --*this;

  00002	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00005	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00008	89 0e		 mov	 DWORD PTR [esi], ecx
  0000a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0000d	74 0a		 je	 SHORT $LN7@operator@8
  0000f	8d 4a ff	 lea	 ecx, DWORD PTR [edx-1]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00015	85 c9		 test	 ecx, ecx
  00017	79 05		 jns	 SHORT $LN12@operator@8
$LN7@operator@8:
  00019	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow
$LN12@operator@8:

; 828  :     return tmp;

  0001e	8b c6		 mov	 eax, esi

; 829  :   }

  00020	c3		 ret	 0
??F?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAE?AU01@H@Z ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ
_TEXT	SEGMENT
??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ PROC ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++, COMDAT
; _this$ = esi

; 813  :     increment();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	80 38 00	 cmp	 BYTE PTR [eax], 0
  00005	74 0c		 je	 SHORT $LN3@operator@9
  00007	ff 46 04	 inc	 DWORD PTR [esi+4]
  0000a	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  0000e	39 46 04	 cmp	 DWORD PTR [esi+4], eax
  00011	7c 07		 jl	 SHORT $LN10@operator@9
$LN3@operator@9:
  00013	8b c6		 mov	 eax, esi
  00015	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
$LN10@operator@9:

; 814  :     return *this;

  0001a	8b c6		 mov	 eax, esi

; 815  :   }

  0001c	c3		 ret	 0
??E?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEAAU01@XZ ENDP ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_i$ = 12						; size = 4
?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap, COMDAT
; _x$ = ecx
; _j$ = eax

; 567  :   void value_swap(int i, btree_node *x, int j) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 0c	 mov	 edx, DWORD PTR _i$[ebp]
  00006	53		 push	 ebx

; 568  :     params_type::swap(mutable_value(i), x->mutable_value(j));

  00007	8b 5c c1 08	 mov	 ebx, DWORD PTR [ecx+eax*8+8]
  0000b	56		 push	 esi
  0000c	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000f	57		 push	 edi
  00010	8b 7c d6 08	 mov	 edi, DWORD PTR [esi+edx*8+8]
  00014	89 5c d6 08	 mov	 DWORD PTR [esi+edx*8+8], ebx
  00018	89 7c c1 08	 mov	 DWORD PTR [ecx+eax*8+8], edi
  0001c	8d 44 c1 0c	 lea	 eax, DWORD PTR [ecx+eax*8+12]
  00020	8d 4c d6 0c	 lea	 ecx, DWORD PTR [esi+edx*8+12]
  00024	8b 30		 mov	 esi, DWORD PTR [eax]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	5f		 pop	 edi
  00029	89 31		 mov	 DWORD PTR [ecx], esi
  0002b	5e		 pop	 esi
  0002c	89 10		 mov	 DWORD PTR [eax], edx
  0002e	5b		 pop	 ebx

; 569  :   }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?value_swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::value_swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ
_TEXT	SEGMENT
?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size, COMDAT
; _this$ = eax

; 1231 :   size_type* mutable_size() { return root()->mutable_size(); }

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	05 84 01 00 00	 add	 eax, 388		; 00000184H
  00007	c3		 ret	 0
?mutable_size@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAIXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::mutable_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty, COMDAT
; _this$ = ecx

; 1141 :   bool empty() const { return root() == NULL; }

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al
  00007	c3		 ret	 0
?empty@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z
_TEXT	SEGMENT
?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys, COMDAT
; _x$ = eax
; _y$ = edx

; 1120 :     return btree_compare_keys(key_comp(), x, y);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00004	1b c0		 sbb	 eax, eax
  00006	f7 d8		 neg	 eax

; 1121 :   }

  00008	c3		 ret	 0
?compare_keys@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QBE_NABI0@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::compare_keys
_TEXT	ENDS
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z
_TEXT	SEGMENT
$T174939 = -16						; size = 12
$T174947 = -4						; size = 4
??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z PROC ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0000b	77 11		 ja	 SHORT $LN1@Allocate
  0000d	03 c0		 add	 eax, eax
  0000f	03 c0		 add	 eax, eax
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001c	75 28		 jne	 SHORT $LN7@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0001e	8d 4d fc	 lea	 ecx, DWORD PTR $T174947[ebp]
  00021	51		 push	 ecx
  00022	8d 4d f0	 lea	 ecx, DWORD PTR $T174939[ebp]
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T174947[ebp], 0
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 55 f0	 lea	 edx, DWORD PTR $T174939[ebp]
  00039	52		 push	 edx
  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T174939[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate:
$LN7@Allocate:

; 40   : 	}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN13@Allocate:
??$_Allocate@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPAV10@@Z ENDP ; std::_Allocate<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$174955 = -4					; size = 1
__Count$ = 8						; size = 4
??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; __First$ = ecx
; __Pval$ = edx

; 606  : 	{	// copy _Count * *_Pval to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 607  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 608  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$174955[ebp]
  00007	50		 push	 eax
  00008	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00011	83 c4 08	 add	 esp, 8

; 609  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Uninitialized_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z
_TEXT	SEGMENT
__Cat$174975 = 8					; size = 1
__Ptr$ = 8						; size = 4
??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Cat$174975[ebp]
  00006	50		 push	 eax
  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00010	83 c4 08	 add	 esp, 8

; 1326 : 		}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??$_Umove@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PAV21@00@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Umove<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z
_TEXT	SEGMENT
$T174981 = -16						; size = 12
$T174989 = -4						; size = 4
??$_Allocate@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z PROC ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d 0f 3e f8 00	 cmp	 eax, 16268815		; 00f83e0fH
  0000b	77 13		 ja	 SHORT $LN1@Allocate@2
  0000d	69 c0 08 01 00
	00		 imul	 eax, 264		; 00000108H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001e	75 28		 jne	 SHORT $LN7@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00020	8d 45 fc	 lea	 eax, DWORD PTR $T174989[ebp]
  00023	50		 push	 eax
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T174981[ebp]
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T174989[ebp], 0
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00033	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00038	8d 4d f0	 lea	 ecx, DWORD PTR $T174981[ebp]
  0003b	51		 push	 ecx
  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T174981[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00043	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@2:
$LN7@Allocate@2:

; 40   : 	}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN13@Allocate@2:
??$_Allocate@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z ENDP ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z
_TEXT	SEGMENT
$T174994 = -16						; size = 12
$T175002 = -4						; size = 4
??$_Allocate@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z PROC ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d 8d 89 f4 00	 cmp	 eax, 16025997		; 00f4898dH
  0000b	77 13		 ja	 SHORT $LN1@Allocate@3
  0000d	69 c0 0c 01 00
	00		 imul	 eax, 268		; 0000010cH
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00019	83 c4 04	 add	 esp, 4
  0001c	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001e	75 28		 jne	 SHORT $LN7@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00020	8d 45 fc	 lea	 eax, DWORD PTR $T175002[ebp]
  00023	50		 push	 eax
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T174994[ebp]
  00027	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T175002[ebp], 0
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00033	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00038	8d 4d f0	 lea	 ecx, DWORD PTR $T174994[ebp]
  0003b	51		 push	 ecx
  0003c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T174994[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00043	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@3:
$LN7@Allocate@3:

; 40   : 	}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN13@Allocate@3:
??$_Allocate@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@YAPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@IPAU123@@Z ENDP ; std::_Allocate<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T175007 = -16						; size = 12
$T175015 = -4						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	83 f8 ff	 cmp	 eax, -1
  00009	77 0d		 ja	 SHORT $LN1@Allocate@4
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	83 c4 04	 add	 esp, 4
  00014	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00016	75 28		 jne	 SHORT $LN7@Allocate@4
$LN1@Allocate@4:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00018	8d 45 fc	 lea	 eax, DWORD PTR $T175015[ebp]
  0001b	50		 push	 eax
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR $T175007[ebp]
  0001f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T175015[ebp], 0
  00026	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0002b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00030	8d 4d f0	 lea	 ecx, DWORD PTR $T175007[ebp]
  00033	51		 push	 ecx
  00034	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175007[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0003b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@4:
$LN7@Allocate@4:

; 40   : 	}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN13@Allocate@4:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z
_TEXT	SEGMENT
$T175020 = -16						; size = 12
$T175028 = -4						; size = 4
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z PROC ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  0000b	77 10		 ja	 SHORT $LN1@Allocate@5
  0000d	c1 e0 04	 shl	 eax, 4
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0001b	75 28		 jne	 SHORT $LN7@Allocate@5
$LN1@Allocate@5:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0001d	8d 45 fc	 lea	 eax, DWORD PTR $T175028[ebp]
  00020	50		 push	 eax
  00021	8d 4d f0	 lea	 ecx, DWORD PTR $T175020[ebp]
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T175028[ebp], 0
  0002b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00030	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00035	8d 4d f0	 lea	 ecx, DWORD PTR $T175020[ebp]
  00038	51		 push	 ecx
  00039	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175020[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00040	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@5:
$LN7@Allocate@5:

; 40   : 	}

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
$LN13@Allocate@5:
??$_Allocate@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@YAPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T175033 = -16						; size = 12
$T175041 = -4						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)
; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)
; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00006	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0000b	77 16		 ja	 SHORT $LN1@Allocate@6
  0000d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00010	03 c0		 add	 eax, eax
  00012	03 c0		 add	 eax, eax
  00014	03 c0		 add	 eax, eax
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001c	83 c4 04	 add	 esp, 4
  0001f	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00021	75 28		 jne	 SHORT $LN7@Allocate@6
$LN1@Allocate@6:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00023	8d 4d fc	 lea	 ecx, DWORD PTR $T175041[ebp]
  00026	51		 push	 ecx
  00027	8d 4d f0	 lea	 ecx, DWORD PTR $T175033[ebp]
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T175041[ebp], 0
  00031	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00036	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003b	8d 55 f0	 lea	 edx, DWORD PTR $T175033[ebp]
  0003e	52		 push	 edx
  0003f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175033[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00046	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@Allocate@6:
$LN7@Allocate@6:

; 40   : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
$LN13@Allocate@6:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAU01@@Z
_TEXT	SEGMENT
??$?0Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAU01@@Z PROC ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 195  : 		{	// construct from compatible pair

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00008	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00012	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00015	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00018	8a 49 10	 mov	 cl, BYTE PTR [ecx+16]
  0001b	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 196  : 		}

  0001e	c3		 ret	 0
??$?0Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@AAU01@@Z ENDP ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool><stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z
_TEXT	SEGMENT
??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z PROC		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1

; 248  : 		}

  0000b	c3		 ret	 0
??$?0AAIABI@?$pair@II@std@@QAE@AAIABI@Z ENDP		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int &,unsigned int const &>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z
_TEXT	SEGMENT
??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z PROC		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>, COMDAT
; _this$ = eax
; __Val2$ = ecx

; 247  : 		{	// construct from moved values

  00000	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  0000b	c3		 ret	 0
??$?0ABIAAI@?$pair@II@std@@QAE@ABIAAI@Z ENDP		; std::pair<unsigned int,unsigned int>::pair<unsigned int,unsigned int><unsigned int const &,unsigned int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z
_TEXT	SEGMENT
__Cat$175155 = -4					; size = 1
__Last$ = 8						; size = 4
??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z PROC ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >, COMDAT
; __First$ = ecx
; __Val$ = edx

; 504  : 	{	// copy _Val throughout raw [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 505  : 	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$175155[ebp]
  00007	50		 push	 eax
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000c	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00011	83 c4 08	 add	 esp, 8

; 506  : 	}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$uninitialized_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@@Z ENDP ; std::uninitialized_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0ABIAAPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??$?0ABIAAPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z PROC ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int const &,stx_object * &>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??$?0ABIAAPAUstx_object@@@?$pair@IPAUstx_object@@@std@@QAE@ABIAAPAUstx_object@@@Z ENDP ; std::pair<unsigned int,stx_object *>::pair<unsigned int,stx_object *><unsigned int const &,stx_object * &>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ
_TEXT	SEGMENT
?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear, COMDAT
; _this$ = esi

; 1959 :   if (root() != NULL) {

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN10@clear

; 1960 :     internal_clear(root());

  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN10@clear:

; 1961 :   }
; 1962 :   *mutable_root() = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1963 : }

  00014	c3		 ret	 0
?clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::clear
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >, COMDAT
; _this$ = eax

; 1732 :       root_(alloc, NULL) {

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1733 : }

  00006	c3		 ret	 0
??0?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  00002	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
$T175226 = -16						; size = 12
$T175224 = -4						; size = 4
?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 44		 je	 SHORT $LN1@allocate
  0000c	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00012	77 14		 ja	 SHORT $LN3@allocate
  00014	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00021	83 c4 04	 add	 esp, 4
  00024	85 c0		 test	 eax, eax
  00026	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00028	8d 4d fc	 lea	 ecx, DWORD PTR $T175224[ebp]
  0002b	51		 push	 ecx
  0002c	8d 4d f0	 lea	 ecx, DWORD PTR $T175226[ebp]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T175224[ebp], 0
  00036	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00040	8d 55 f0	 lea	 edx, DWORD PTR $T175226[ebp]
  00043	52		 push	 edx
  00044	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175226[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
$LN12@allocate:
?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z
_TEXT	SEGMENT
__Cat$175254 = -4					; size = 1
?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Pval$ = edx

; 1420 : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1421 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Alval);

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$175254[ebp]
  00007	50		 push	 eax
  00008	57		 push	 edi
  00009	8b c6		 mov	 eax, esi
  0000b	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >
  00010	83 c4 08	 add	 esp, 8

; 1422 : 		return (_Ptr + _Count);

  00013	8d 04 b7	 lea	 eax, DWORD PTR [edi+esi*4]

; 1423 : 		}

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Ufill@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@PAV32@IPBV32@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Ufill
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z
_TEXT	SEGMENT
?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to, COMDAT
; _this$ = ecx
; __Count$ = edx

; 1275 : 		size_type _Capacity = capacity();

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	c1 f8 02	 sar	 eax, 2

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00009	8b c8		 mov	 ecx, eax
  0000b	d1 e9		 shr	 ecx, 1
  0000d	be ff ff ff 3f	 mov	 esi, 1073741823		; 3fffffffH
  00012	2b f1		 sub	 esi, ecx
  00014	3b f0		 cmp	 esi, eax
  00016	5e		 pop	 esi
  00017	73 04		 jae	 SHORT $LN4@Grow_to
  00019	33 c0		 xor	 eax, eax
  0001b	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0001d	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  0001f	3b c2		 cmp	 eax, edx
  00021	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00023	8b c2		 mov	 eax, edx
$LN1@Grow_to:

; 1282 : 		}

  00025	c3		 ret	 0
?_Grow_to@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IBEII@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Grow_to
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >, COMDAT
; _this$ = eax
; __Parg$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  00002	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@std@@QAE@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >::_Vector_iterator<std::_Vector_val<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z PROC ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0000b	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00015	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001e	8a 0a		 mov	 cl, BYTE PTR [edx]
  00020	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 146  : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$_Pair_base@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z ENDP ; std::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::_Pair_base<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
_TEXT	ENDS
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$0
__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$2
__tryblocktable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$5
__ehfuncinfo$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$157771 = -24					; size = 4
__Tmp$157757 = -24					; size = 4
__Newvec$157738 = -24					; size = 4
__Capacity$175403 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$175637 = 8					; size = 1
__Cat$175578 = 8					; size = 1
__Cat$175546 = 8					; size = 1
__Cat$175503 = 8					; size = 1
__Cat$175474 = 8					; size = 1
__Cat$175445 = 8					; size = 1
__Where$ = 8						; size = 4
tv642 = 12						; size = 4
__Val$ = 12						; size = 4
?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n, COMDAT
; _this$ = edx
; __Count$ = ecx

; 1330 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	8b f9		 mov	 edi, ecx
  00020	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00023	8b f2		 mov	 esi, edx

; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_VICONT(_Where) != this
; 1333 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1334 : 			|| this->_Mylast < _VIPTR(_Where))
; 1335 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		if (_Count == 0)

  00025	85 ff		 test	 edi, edi
  00027	0f 84 04 02 00
	00		 je	 $LN143@Insert_n

; 1339 : 			;
; 1340 : 		else if (max_size() - size() < _Count)

  0002d	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00030	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00032	8b c3		 mov	 eax, ebx
  00034	2b c1		 sub	 eax, ecx
  00036	c1 f8 02	 sar	 eax, 2
  00039	ba ff ff ff 3f	 mov	 edx, 1073741823		; 3fffffffH
  0003e	2b d0		 sub	 edx, eax
  00040	3b d7		 cmp	 edx, edi
  00042	73 0a		 jae	 SHORT $LN11@Insert_n

; 1341 : 			_Xlen();	// result too long

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00049	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN159@Insert_n:
$LN11@Insert_n:

; 1342 : 		else if (capacity() < size() + _Count)

  0004e	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00051	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00054	2b c1		 sub	 eax, ecx
  00056	c1 f8 02	 sar	 eax, 2
  00059	3b c2		 cmp	 eax, edx
  0005b	0f 83 da 00 00
	00		 jae	 $LN9@Insert_n

; 1343 : 			{	// not enough room, reallocate
; 1344 : 			size_type _Capacity = _Grow_to(size() + _Count);

  00061	8b c8		 mov	 ecx, eax
  00063	d1 e9		 shr	 ecx, 1
  00065	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
  0006a	2b d9		 sub	 ebx, ecx
  0006c	3b d8		 cmp	 ebx, eax
  0006e	73 0c		 jae	 SHORT $LN44@Insert_n
  00070	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Capacity$175403[ebp], 0
  00077	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$175403[ebp]
  0007a	eb 05		 jmp	 SHORT $LN45@Insert_n
$LN44@Insert_n:
  0007c	03 c1		 add	 eax, ecx
  0007e	89 45 ec	 mov	 DWORD PTR __Capacity$175403[ebp], eax
$LN45@Insert_n:
  00081	3b c2		 cmp	 eax, edx
  00083	73 05		 jae	 SHORT $LN41@Insert_n
  00085	89 55 ec	 mov	 DWORD PTR __Capacity$175403[ebp], edx
  00088	8b c2		 mov	 eax, edx
$LN41@Insert_n:

; 1345 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  0008a	8b c8		 mov	 ecx, eax
  0008c	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@std@@QAEPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ; std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >::allocate

; 1346 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

  00091	8b 5d 08	 mov	 ebx, DWORD PTR __Where$[ebp]
  00094	2b 1e		 sub	 ebx, DWORD PTR [esi]

; 1347 : 			int _Ncopied = 0;
; 1348 : 
; 1349 : 			_TRY_BEGIN
; 1350 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1351 : 				_STD addressof(_Val));	// add new stuff

  00096	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00099	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$175445[ebp]
  000a3	89 45 e8	 mov	 DWORD PTR __Newvec$157738[ebp], eax
  000a6	c1 fb 02	 sar	 ebx, 2
  000a9	8d 04 98	 lea	 eax, DWORD PTR [eax+ebx*4]
  000ac	51		 push	 ecx
  000ad	50		 push	 eax
  000ae	8b c7		 mov	 eax, edi
  000b0	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1352 : 			++_Ncopied;
; 1353 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1354 : 				_Newvec);	// copy prefix

  000b5	8b 55 08	 mov	 edx, DWORD PTR __Cat$175474[ebp]
  000b8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ba	83 c4 08	 add	 esp, 8
  000bd	52		 push	 edx
  000be	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  000c1	50		 push	 eax
  000c2	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$157738[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1355 : 			++_Ncopied;
; 1356 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1357 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

  000ca	8b 45 08	 mov	 eax, DWORD PTR __Cat$175503[ebp]
  000cd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000d0	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  000d3	8b 5d e8	 mov	 ebx, DWORD PTR __Newvec$157738[ebp]
  000d6	83 c4 08	 add	 esp, 8
  000d9	50		 push	 eax
  000da	8d 04 8b	 lea	 eax, DWORD PTR [ebx+ecx*4]
  000dd	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1365 : 			_CATCH_END
; 1366 : 
; 1367 : 			_Count += size();

  000e6	8b 06		 mov	 eax, DWORD PTR [esi]
  000e8	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000eb	2b d0		 sub	 edx, eax
  000ed	c1 fa 02	 sar	 edx, 2
  000f0	83 c4 08	 add	 esp, 8
  000f3	03 fa		 add	 edi, edx

; 1368 : 			if (this->_Myfirst != 0)

  000f5	85 c0		 test	 eax, eax
  000f7	74 09		 je	 SHORT $LN84@Insert_n

; 1369 : 				{	// destroy and deallocate old array
; 1370 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1371 : 				this->_Alval.deallocate(this->_Myfirst,
; 1372 : 					this->_Myend - this->_Myfirst);

  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ff	83 c4 04	 add	 esp, 4
$LN84@Insert_n:

; 1373 : 				}
; 1374 : 
; 1375 : 			this->_Orphan_all();
; 1376 : 			this->_Myend = _Newvec + _Capacity;

  00102	8b 45 ec	 mov	 eax, DWORD PTR __Capacity$175403[ebp]
  00105	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]

; 1377 : 			this->_Mylast = _Newvec + _Count;

  00108	8d 14 bb	 lea	 edx, DWORD PTR [ebx+edi*4]
  0010b	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0010e	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 1378 : 			this->_Myfirst = _Newvec;

  00111	89 1e		 mov	 DWORD PTR [esi], ebx

; 1416 : 			}
; 1417 : 		}

  00113	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 08 00	 ret	 8
__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$0:

; 1358 : 			_CATCH_ALL
; 1359 : 			if (1 < _Ncopied)
; 1360 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1361 : 			if (0 < _Ncopied)
; 1362 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1363 : 			this->_Alval.deallocate(_Newvec, _Capacity);

  00126	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$157738[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0012f	83 c4 04	 add	 esp, 4
__catch$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z$2:

; 1364 : 			_RERAISE;

  00132	6a 00		 push	 0
  00134	6a 00		 push	 0
  00136	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN160@Insert_n:
$LN9@Insert_n:

; 1379 : 			}
; 1380 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1381 : 			< _Count)

  0013b	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0013e	8b d3		 mov	 edx, ebx
  00140	2b d1		 sub	 edx, ecx
  00142	c1 fa 02	 sar	 edx, 2
  00145	3b d7		 cmp	 edx, edi
  00147	73 7b		 jae	 SHORT $LN3@Insert_n

; 1382 : 			{	// new stuff spills off end
; 1383 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  00149	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0014c	8b 10		 mov	 edx, DWORD PTR [eax]
  0014e	89 55 e8	 mov	 DWORD PTR __Tmp$157757[ebp], edx

; 1384 : 
; 1385 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1386 : 				_VIPTR(_Where) + _Count);	// copy suffix

  00151	8b 55 08	 mov	 edx, DWORD PTR __Cat$175546[ebp]
  00154	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  0015b	52		 push	 edx
  0015c	89 45 0c	 mov	 DWORD PTR tv642[ebp], eax
  0015f	03 c1		 add	 eax, ecx
  00161	51		 push	 ecx
  00162	8b d3		 mov	 edx, ebx
  00164	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1387 : 
; 1388 : 			_TRY_BEGIN

  00169	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 1389 : 			_Ufill(this->_Mylast,
; 1390 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1391 : 				_STD addressof(_Tmp));	// insert new stuff off end

  00170	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00173	8b 55 08	 mov	 edx, DWORD PTR __Cat$175578[ebp]
  00176	8b c1		 mov	 eax, ecx
  00178	2b 45 08	 sub	 eax, DWORD PTR __Where$[ebp]
  0017b	52		 push	 edx
  0017c	c1 f8 02	 sar	 eax, 2
  0017f	2b f8		 sub	 edi, eax
  00181	8b c7		 mov	 eax, edi
  00183	51		 push	 ecx
  00184	8d 55 e8	 lea	 edx, DWORD PTR __Tmp$157757[ebp]
  00187	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@IV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAXPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@IPBV10@AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,unsigned int,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1392 : 			_CATCH_ALL
; 1393 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1394 : 				this->_Mylast + _Count);
; 1395 : 			_RERAISE;
; 1396 : 			_CATCH_END
; 1397 : 
; 1398 : 			this->_Mylast += _Count;

  0018c	8b 45 0c	 mov	 eax, DWORD PTR tv642[ebp]
  0018f	01 46 04	 add	 DWORD PTR [esi+4], eax
  00192	8b 76 04	 mov	 esi, DWORD PTR [esi+4]

; 1399 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1400 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1401 : 				_Tmp);	// insert up to old end

  00195	2b f0		 sub	 esi, eax
  00197	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0019a	83 c4 10	 add	 esp, 16			; 00000010H
  0019d	3b c6		 cmp	 eax, esi
  0019f	0f 84 8c 00 00
	00		 je	 $LN143@Insert_n
$LL116@Insert_n:
  001a5	8b 4d e8	 mov	 ecx, DWORD PTR __Tmp$157757[ebp]
  001a8	89 08		 mov	 DWORD PTR [eax], ecx
  001aa	83 c0 04	 add	 eax, 4
  001ad	3b c6		 cmp	 eax, esi
  001af	75 f4		 jne	 SHORT $LL116@Insert_n

; 1416 : 			}
; 1417 : 		}

  001b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c2 08 00	 ret	 8
$LN3@Insert_n:

; 1402 : 			}
; 1403 : 		else
; 1404 : 			{	// new stuff can all be assigned
; 1405 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

  001c4	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  001c7	8b 02		 mov	 eax, DWORD PTR [edx]

; 1406 : 
; 1407 : 			pointer _Oldend = this->_Mylast;
; 1408 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1409 : 				this->_Mylast);	// copy suffix

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$175637[ebp]
  001cc	89 45 e8	 mov	 DWORD PTR __Tmp$157771[ebp], eax
  001cf	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]
  001d6	8b fb		 mov	 edi, ebx
  001d8	2b f8		 sub	 edi, eax
  001da	51		 push	 ecx
  001db	89 45 0c	 mov	 DWORD PTR tv642[ebp], eax
  001de	57		 push	 edi
  001df	8b c3		 mov	 eax, ebx
  001e1	8b d3		 mov	 edx, ebx
  001e3	e8 00 00 00 00	 call	 ??$_Uninit_move@PAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@PAV12@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@V12@@std@@YAPAV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@0@PAV10@00AAV?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > *,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >,std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > >

; 1410 : 
; 1411 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1412 : 			_STD _Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1413 : 				_Oldend);	// copy hole

  001e8	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  001eb	89 46 04	 mov	 DWORD PTR [esi+4], eax
  001ee	8b c7		 mov	 eax, edi
  001f0	83 c4 08	 add	 esp, 8
  001f3	3b c8		 cmp	 ecx, eax
  001f5	74 19		 je	 SHORT $LN133@Insert_n
  001f7	2b df		 sub	 ebx, edi
  001f9	8d a4 24 00 00
	00 00		 npad	 7
$LL134@Insert_n:
  00200	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00203	83 e8 04	 sub	 eax, 4
  00206	89 14 03	 mov	 DWORD PTR [ebx+eax], edx
  00209	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0020c	3b c8		 cmp	 ecx, eax
  0020e	75 f0		 jne	 SHORT $LL134@Insert_n
$LN133@Insert_n:

; 1414 : 			_STD fill(_VIPTR(_Where),
; 1415 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  00210	8b 55 0c	 mov	 edx, DWORD PTR tv642[ebp]
  00213	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]
  00216	8b c1		 mov	 eax, ecx
  00218	3b ce		 cmp	 ecx, esi
  0021a	74 15		 je	 SHORT $LN143@Insert_n
  0021c	8d 64 24 00	 npad	 4
$LL145@Insert_n:
  00220	8b 4d e8	 mov	 ecx, DWORD PTR __Tmp$157771[ebp]
  00223	89 08		 mov	 DWORD PTR [eax], ecx
  00225	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00228	83 c0 04	 add	 eax, 4
  0022b	03 ca		 add	 ecx, edx
  0022d	3b c1		 cmp	 eax, ecx
  0022f	75 ef		 jne	 SHORT $LL145@Insert_n
$LN143@Insert_n:

; 1416 : 			}
; 1417 : 		}

  00231	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0023d	5b		 pop	 ebx
  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c2 08 00	 ret	 8
$LN158@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter, COMDAT
; ___$ReturnUdt$ = eax

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?_Make_iter@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Make_iter
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z
_TEXT	SEGMENT
$T175747 = -16						; size = 12
$T175739 = -4						; size = 4
?allocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	68 08 01 00 00	 push	 264			; 00000108H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 24		 jne	 SHORT $LN1@allocate@2
  00017	89 45 fc	 mov	 DWORD PTR $T175739[ebp], eax
  0001a	8d 45 fc	 lea	 eax, DWORD PTR $T175739[ebp]
  0001d	50		 push	 eax
  0001e	8d 4d f0	 lea	 ecx, DWORD PTR $T175747[ebp]
  00021	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00026	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR $T175747[ebp]
  0002e	51		 push	 ecx
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175747[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00036	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN13@allocate@2:
?allocate@?$allocator@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>::allocate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z
_TEXT	SEGMENT
$T175771 = -16						; size = 12
$T175763 = -4						; size = 4
?allocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z PROC ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	68 0c 01 00 00	 push	 268			; 0000010cH
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	83 c4 04	 add	 esp, 4
  00013	85 c0		 test	 eax, eax
  00015	75 24		 jne	 SHORT $LN1@allocate@3
  00017	89 45 fc	 mov	 DWORD PTR $T175763[ebp], eax
  0001a	8d 45 fc	 lea	 eax, DWORD PTR $T175763[ebp]
  0001d	50		 push	 eax
  0001e	8d 4d f0	 lea	 ecx, DWORD PTR $T175771[ebp]
  00021	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00026	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0002b	8d 4d f0	 lea	 ecx, DWORD PTR $T175771[ebp]
  0002e	51		 push	 ecx
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T175771[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00036	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN13@allocate@3:
?allocate@?$allocator@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@std@@QAEPAUleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@I@Z ENDP ; std::allocator<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z PROC ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	89 10		 mov	 DWORD PTR [eax], edx
  00007	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0000b	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00015	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Val2$[ebp]
  0001b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0001e	8a 0a		 mov	 cl, BYTE PTR [edx]
  00020	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 228  : 		}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@QAE@$$QAViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@$$QA_N@Z ENDP ; std::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>::pair<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z
_TEXT	SEGMENT
__First$ = -4						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = eax

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00004	8b 55 08	 mov	 edx, DWORD PTR __First_arg$[ebp]

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Last_arg$[ebp]
  0000a	53		 push	 ebx
  0000b	8b da		 mov	 ebx, edx
  0000d	89 5d fc	 mov	 DWORD PTR __First$[ebp], ebx
  00010	3b d1		 cmp	 edx, ecx
  00012	74 21		 je	 SHORT $LN47@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00014	56		 push	 esi
  00015	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00018	3b ce		 cmp	 ecx, esi
  0001a	74 15		 je	 SHORT $LN30@erase
  0001c	8d 64 24 00	 npad	 4
$LL32@erase:
  00020	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00022	89 1a		 mov	 DWORD PTR [edx], ebx
  00024	83 c1 04	 add	 ecx, 4
  00027	83 c2 04	 add	 edx, 4
  0002a	3b ce		 cmp	 ecx, esi
  0002c	75 f2		 jne	 SHORT $LL32@erase
  0002e	8b 5d fc	 mov	 ebx, DWORD PTR __First$[ebp]
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00031	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00034	5e		 pop	 esi
$LN47@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  00035	89 18		 mov	 DWORD PTR [eax], ebx
  00037	5b		 pop	 ebx

; 1214 : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
?erase@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@0@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert, COMDAT
; _this$ = edx
; __Val$ = eax

; 1058 : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1059 : 		_Insert_n(_Where, _Count, _Val);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000b	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 1060 : 		}

  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
?insert@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 792  : 		return (iterator(this->_Mylast, this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 793  : 		}

  00005	c3		 ret	 0
?end@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 782  : 		return (iterator(this->_Myfirst, this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 783  : 		}

  00004	c3		 ret	 0
?begin@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T176029 = -16						; size = 12
$T176021 = -4						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; __Count$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 3a		 je	 SHORT $LN1@allocate@4
  0000c	83 f9 ff	 cmp	 ecx, -1
  0000f	77 0d		 ja	 SHORT $LN3@allocate@4
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	75 28		 jne	 SHORT $LN1@allocate@4
$LN3@allocate@4:
  0001e	8d 45 fc	 lea	 eax, DWORD PTR $T176021[ebp]
  00021	50		 push	 eax
  00022	8d 4d f0	 lea	 ecx, DWORD PTR $T176029[ebp]
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T176021[ebp], 0
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00036	8d 4d f0	 lea	 ecx, DWORD PTR $T176029[ebp]
  00039	51		 push	 ecx
  0003a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T176029[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00041	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@4:
$LN1@allocate@4:

; 188  : 		}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
$LN12@allocate@4:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 41   : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : 		this->_Adopt(_Plist);
; 43   : 		}

  00002	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n, COMDAT
; _this$ = edx
; __Val$ = eax

; 1243 : 		{	// assign _Count * _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1244 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1245 : 		erase(begin(), end());

  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx
  0000f	3b f0		 cmp	 esi, eax
  00011	74 1f		 je	 SHORT $LN19@Assign_n
  00013	8b c8		 mov	 ecx, eax
  00015	3b c0		 cmp	 eax, eax
  00017	74 16		 je	 SHORT $LN48@Assign_n
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL50@Assign_n:
  00020	8b 39		 mov	 edi, DWORD PTR [ecx]
  00022	89 3e		 mov	 DWORD PTR [esi], edi
  00024	83 c1 04	 add	 ecx, 4
  00027	83 c6 04	 add	 esi, 4
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 f2		 jne	 SHORT $LL50@Assign_n
  0002e	5f		 pop	 edi
$LN48@Assign_n:
  0002f	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN19@Assign_n:

; 1246 : 		insert(begin(), _Count, _Tmp);

  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00037	51		 push	 ecx
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
  00041	5e		 pop	 esi

; 1247 : 		}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?_Assign_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Assign_n
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z
_TEXT	SEGMENT
$T176321 = -16						; size = 12
$T176313 = -4						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z PROC ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	6a 10		 push	 16			; 00000010H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 24		 jne	 SHORT $LN1@allocate@5
  00014	89 45 fc	 mov	 DWORD PTR $T176313[ebp], eax
  00017	8d 45 fc	 lea	 eax, DWORD PTR $T176313[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T176321[ebp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00023	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00028	8d 4d f0	 lea	 ecx, DWORD PTR $T176321[ebp]
  0002b	51		 push	 ecx
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T176321[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00033	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@5:
$LN1@allocate@5:

; 188  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN13@allocate@5:
?allocate@?$allocator@U_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@2@I@Z ENDP ; std::allocator<std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = eax

; 439  : 		}

  00000	c2 04 00	 ret	 4
??0?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_nod<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?allocate_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUinner_node@12@G@Z
_TEXT	SEGMENT
$T176405 = -12						; size = 12
$T176382 = 8						; size = 4
_level$ = 8						; size = 2
?allocate_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUinner_node@12@G@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_inner, COMDAT
; _this$ = edi

; 1476 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 1477 :         inner_node *n = new (inner_node_allocator().allocate(1)) inner_node();

  00007	68 08 01 00 00	 push	 264			; 00000108H
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	83 c4 04	 add	 esp, 4
  00016	85 f6		 test	 esi, esi
  00018	74 29		 je	 SHORT $LN11@allocate_i
  0001a	68 08 01 00 00	 push	 264			; 00000108H
  0001f	6a 00		 push	 0
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _memset

; 1478 :         n->initialize(level);

  00027	66 8b 45 08	 mov	 ax, WORD PTR _level$[ebp]
  0002b	66 89 06	 mov	 WORD PTR [esi], ax
  0002e	33 c9		 xor	 ecx, ecx
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	66 89 4e 02	 mov	 WORD PTR [esi+2], cx

; 1479 :         m_stats.innernodes++;

  00037	ff 47 14	 inc	 DWORD PTR [edi+20]

; 1480 :         return n;

  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 1481 :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4

; 1477 :         inner_node *n = new (inner_node_allocator().allocate(1)) inner_node();

$LN11@allocate_i:
  00043	8d 55 08	 lea	 edx, DWORD PTR $T176382[ebp]
  00046	52		 push	 edx
  00047	8d 4d f4	 lea	 ecx, DWORD PTR $T176405[ebp]
  0004a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T176382[ebp], 0
  00051	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00056	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005b	8d 45 f4	 lea	 eax, DWORD PTR $T176405[ebp]
  0005e	50		 push	 eax
  0005f	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T176405[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00066	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@allocate_i:
$LN29@allocate_i:
  0006b	cc		 int	 3
?allocate_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUinner_node@12@G@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_inner
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?allocate_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUleaf_node@12@XZ
_TEXT	SEGMENT
$T176469 = -16						; size = 12
$T176446 = -4						; size = 4
?allocate_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUleaf_node@12@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_leaf, COMDAT
; _this$ = edi

; 1467 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 1468 :         leaf_node *n = new (leaf_node_allocator().allocate(1)) leaf_node();

  00007	68 0c 01 00 00	 push	 268			; 0000010cH
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	83 c4 04	 add	 esp, 4
  00016	85 f6		 test	 esi, esi
  00018	74 24		 je	 SHORT $LN11@allocate_l
  0001a	68 0c 01 00 00	 push	 268			; 0000010cH
  0001f	6a 00		 push	 0
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _memset

; 1469 :         n->initialize();

  00027	33 c0		 xor	 eax, eax
  00029	89 06		 mov	 DWORD PTR [esi], eax
  0002b	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1470 :         m_stats.leaves++;

  00034	ff 47 10	 inc	 DWORD PTR [edi+16]

; 1471 :         return n;

  00037	8b c6		 mov	 eax, esi
  00039	5e		 pop	 esi

; 1472 :     }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0

; 1468 :         leaf_node *n = new (leaf_node_allocator().allocate(1)) leaf_node();

$LN11@allocate_l:
  0003e	8d 55 fc	 lea	 edx, DWORD PTR $T176446[ebp]
  00041	52		 push	 edx
  00042	8d 4d f0	 lea	 ecx, DWORD PTR $T176469[ebp]
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T176446[ebp], 0
  0004c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00051	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00056	8d 45 f0	 lea	 eax, DWORD PTR $T176469[ebp]
  00059	50		 push	 eax
  0005a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T176469[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00061	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN30@allocate_l:
$LN29@allocate_l:
  00066	cc		 int	 3
?allocate_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEPAUleaf_node@12@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::allocate_leaf
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z
_TEXT	SEGMENT
?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals, COMDAT
; _a$ = eax
; _b$ = edx

; 1199 :       return key_equal::operator()(a, b);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 1200 :     }

  00009	c3		 ret	 0
?equals@KeyInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABI0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::KeyInfo::equals
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??_5result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
??_5result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEAAU012@ABU012@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::operator|=, COMDAT
; _this$ = eax
; _other$ = ecx

; 2581 :             flags = result_flags_t(flags | other.flags);

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	09 10		 or	 DWORD PTR [eax], edx

; 2582 : 
; 2583 :             // we overwrite existing lastkeys on purpose
; 2584 :             if (other.has(btree_update_lastkey))

  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	d1 ea		 shr	 edx, 1
  00008	f6 c2 01	 test	 dl, 1
  0000b	74 06		 je	 SHORT $LN1@operator@10

; 2585 :                 lastkey = other.lastkey;

  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@operator@10:

; 2586 : 
; 2587 :             return *this;
; 2588 :         }

  00013	c3		 ret	 0
??_5result_t@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEAAU012@ABU012@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::result_t::operator|=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--, COMDAT
; _this$ = eax

; 250  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 251  : 		if (this->_Getcont() == 0
; 252  : 			|| this->_Ptr == 0
; 253  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 254  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("list iterator not decrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 263  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 264  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 265  : 
; 266  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 267  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	89 10		 mov	 DWORD PTR [eax], edx

; 268  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 269  : 
; 270  : 		return (*this);
; 271  : 		}

  00007	c3		 ret	 0
??F?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = eax

; 222  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 223  : 		if (this->_Getcont() == 0
; 224  : 			|| this->_Ptr == 0
; 225  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 226  : 			{	// report error
; 227  : 			_DEBUG_ERROR("list iterator not incrementable");
; 228  : 			_SCL_SECURE_OUT_OF_RANGE;
; 229  : 			}
; 230  : 
; 231  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 232  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 233  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 234  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 235  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 236  : 
; 237  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 11		 mov	 edx, DWORD PTR [ecx]
  00004	89 10		 mov	 DWORD PTR [eax], edx

; 238  : 		return (*this);
; 239  : 		}

  00006	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 184  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 185  : 		}

  00002	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  00002	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Tmp$176879 = -4					; size = 4
__Count$ = 8						; size = 4
?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign, COMDAT
; _this$ = edx
; __Val$ = eax

; 1046 : 		{	// assign _Count * _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1047 : 		_Assign_n(_Count, _Val);

  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	56		 push	 esi
  0000a	8b 32		 mov	 esi, DWORD PTR [edx]
  0000c	89 4d fc	 mov	 DWORD PTR __Tmp$176879[ebp], ecx
  0000f	3b f0		 cmp	 esi, eax
  00011	74 1f		 je	 SHORT $LN21@assign
  00013	8b c8		 mov	 ecx, eax
  00015	3b c0		 cmp	 eax, eax
  00017	74 16		 je	 SHORT $LN50@assign
  00019	57		 push	 edi
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL52@assign:
  00020	8b 39		 mov	 edi, DWORD PTR [ecx]
  00022	89 3e		 mov	 DWORD PTR [esi], edi
  00024	83 c1 04	 add	 ecx, 4
  00027	83 c6 04	 add	 esi, 4
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 f2		 jne	 SHORT $LL52@assign
  0002e	5f		 pop	 edi
$LN50@assign:
  0002f	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN21@assign:
  00032	8b 02		 mov	 eax, DWORD PTR [edx]
  00034	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$176879[ebp]
  00037	51		 push	 ecx
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n
  00041	5e		 pop	 esi

; 1048 : 		}

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?assign@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::assign
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T176932 = -16						; size = 12
$T176909 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 493  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

  00006	6a 10		 push	 16			; 00000010H
  00008	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 11		 je	 SHORT $LN13@List_val
  0001b	89 06		 mov	 DWORD PTR [esi], eax

; 496  : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  0001d	89 00		 mov	 DWORD PTR [eax], eax

; 497  : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 498  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4

; 494  : 		this->_Mysize = 0;
; 495  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN13@List_val:
  0002c	8d 45 fc	 lea	 eax, DWORD PTR $T176909[ebp]
  0002f	50		 push	 eax
  00030	8d 4d f0	 lea	 ecx, DWORD PTR $T176932[ebp]
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T176909[ebp], 0
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T176932[ebp]
  00047	51		 push	 ecx
  00048	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T176932[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN29@List_val:
$LN28@List_val:
  00054	cc		 int	 3
??0?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear, COMDAT
; _this$ = esi

; 1097 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1098 : 		this->_Orphan_ptr(*this, 0);
; 1099 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1100 : 
; 1101 : 		_Nodeptr _Pnext;
; 1102 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1103 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00004	89 09		 mov	 DWORD PTR [ecx], ecx

; 1104 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx

; 1105 : 		this->_Mysize = 0;

  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1106 : 
; 1107 : 		for (; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN1@clear@2
  00016	57		 push	 edi
$LL3@clear@2:

; 1108 : 			{	// delete an element
; 1109 : 			_Pnext = this->_Nextnode(_Pnode);

  00017	8b 38		 mov	 edi, DWORD PTR [eax]

; 1110 : 
; 1111 : 			_Dest_val(this->_Alnod, _Pnode);
; 1112 : 			this->_Alnod.deallocate(_Pnode, 1);

  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL3@clear@2
  00028	5f		 pop	 edi
$LN1@clear@2:

; 1113 : 			}
; 1114 : 		}

  00029	c3		 ret	 0
?clear@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T176984 = -16						; size = 12
$T176976 = -4						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate, COMDAT

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	75 24		 jne	 SHORT $LN1@allocate@6
  00014	89 45 fc	 mov	 DWORD PTR $T176976[ebp], eax
  00017	8d 45 fc	 lea	 eax, DWORD PTR $T176976[ebp]
  0001a	50		 push	 eax
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T176984[ebp]
  0001e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00023	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00028	8d 4d f0	 lea	 ecx, DWORD PTR $T176984[ebp]
  0002b	51		 push	 ecx
  0002c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T176984[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00033	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN14@allocate@6:
$LN1@allocate@6:

; 188  : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN13@allocate@6:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = eax

; 483  : 		}

  00000	c2 04 00	 ret	 4
??0?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear, COMDAT
; _this$ = edi

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00000	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00003	53		 push	 ebx
  00004	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00007	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  0000b	56		 push	 esi
  0000c	8b f3		 mov	 esi, ebx
  0000e	75 1e		 jne	 SHORT $LN7@clear@3
$LL9@clear@3:
  00010	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00013	51		 push	 ecx
  00014	8b cf		 mov	 ecx, edi
  00016	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase
  0001b	8b 36		 mov	 esi, DWORD PTR [esi]
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00023	83 c4 04	 add	 esp, 4
  00026	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002a	8b de		 mov	 ebx, esi
  0002c	74 e2		 je	 SHORT $LL9@clear@3
$LN7@clear@3:

; 1416 : 		_Root() = this->_Myhead;

  0002e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00031	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00034	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00037	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  00039	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003c	5e		 pop	 esi
  0003d	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00040	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00047	5b		 pop	 ebx

; 1420 : 		}

  00048	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_submaxkey$157032 = 8					; size = 4
_n$ = 8							; size = 4
_minkey$ = 12						; size = 4
_maxkey$ = 16						; size = 4
_subminkey$157031 = 20					; size = 4
_vstats$ = 20						; size = 4
?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_node, COMDAT
; _this$ = ecx

; 3651 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi

; 3652 :         BTREE_PRINT("verifynode " << n);
; 3653 : 
; 3654 :         if (n->isleafnode())

  00005	8b 7d 08	 mov	 edi, DWORD PTR _n$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000b	33 d2		 xor	 edx, edx

; 3655 :         {
; 3656 :             const leaf_node *leaf = static_cast<const leaf_node*>(n);
; 3657 : 
; 3658 :             assert( leaf == m_root || !leaf->isunderflow() );
; 3659 :             assert( leaf->slotuse > 0 );
; 3660 : 
; 3661 :             for(unsigned short slot = 0; slot < leaf->slotuse - 1; ++slot)

  0000d	33 c9		 xor	 ecx, ecx
  0000f	66 39 17	 cmp	 WORD PTR [edi], dx
  00012	75 3c		 jne	 SHORT $LN20@verify_nod
  00014	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00018	48		 dec	 eax
  00019	3b c2		 cmp	 eax, edx
  0001b	7e 0b		 jle	 SHORT $LN17@verify_nod
  0001d	8d 49 00	 npad	 3
$LL19@verify_nod:
  00020	41		 inc	 ecx
  00021	0f b7 d1	 movzx	 edx, cx
  00024	3b d0		 cmp	 edx, eax
  00026	7c f8		 jl	 SHORT $LL19@verify_nod
$LN17@verify_nod:

; 3662 :             {
; 3663 :                 assert(key_lessequal(leaf->slotkey[slot], leaf->slotkey[slot + 1]));
; 3664 :             }
; 3665 : 
; 3666 :             *minkey = leaf->slotkey[0];
; 3667 :             *maxkey = leaf->slotkey[leaf->slotuse - 1];

  00028	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  0002c	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _minkey$[ebp]
  00032	89 01		 mov	 DWORD PTR [ecx], eax
  00034	8b 44 97 08	 mov	 eax, DWORD PTR [edi+edx*4+8]
  00038	8b 4d 10	 mov	 ecx, DWORD PTR _maxkey$[ebp]
  0003b	89 01		 mov	 DWORD PTR [ecx], eax

; 3668 : 
; 3669 :             vstats.leaves++;

  0003d	8b 45 14	 mov	 eax, DWORD PTR _vstats$[ebp]
  00040	ff 40 04	 inc	 DWORD PTR [eax+4]

; 3670 :             vstats.itemcount += leaf->slotuse;

  00043	0f b7 57 02	 movzx	 edx, WORD PTR [edi+2]
  00047	01 10		 add	 DWORD PTR [eax], edx
  00049	5f		 pop	 edi

; 3703 :                 else
; 3704 :                     assert(key_equal(inner->slotkey[slot], submaxkey));
; 3705 : 
; 3706 :                 if (inner->level == 1 && slot < inner->slotuse)
; 3707 :                 {
; 3708 :                     // children are leaves and must be linked together in the
; 3709 :                     // correct order
; 3710 :                     const leaf_node *leafa = static_cast<const leaf_node*>(inner->childid[slot]);
; 3711 :                     const leaf_node *leafb = static_cast<const leaf_node*>(inner->childid[slot + 1]);
; 3712 : 
; 3713 :                     assert(leafa->nextleaf == leafb);
; 3714 :                     assert(leafa == leafb->prevleaf);
; 3715 :                     (void)leafa; (void)leafb;
; 3716 :                 }
; 3717 :                 if (inner->level == 2 && slot < inner->slotuse)
; 3718 :                 {
; 3719 :                     // verify leaf links between the adjacent inner nodes
; 3720 :                     const inner_node *parenta = static_cast<const inner_node*>(inner->childid[slot]);
; 3721 :                     const inner_node *parentb = static_cast<const inner_node*>(inner->childid[slot+1]);
; 3722 : 
; 3723 :                     const leaf_node *leafa = static_cast<const leaf_node*>(parenta->childid[parenta->slotuse]);
; 3724 :                     const leaf_node *leafb = static_cast<const leaf_node*>(parentb->childid[0]);
; 3725 : 
; 3726 :                     assert(leafa->nextleaf == leafb);
; 3727 :                     assert(leafa == leafb->prevleaf);
; 3728 :                     (void)leafa; (void)leafb;
; 3729 :                 }
; 3730 :             }
; 3731 :         }
; 3732 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 10 00	 ret	 16			; 00000010H
$LN20@verify_nod:
  00050	53		 push	 ebx

; 3671 :         }
; 3672 :         else // !n->isleafnode()
; 3673 :         {
; 3674 :             const inner_node *inner = static_cast<const inner_node*>(n);
; 3675 :             vstats.innernodes++;

  00051	8b 5d 14	 mov	 ebx, DWORD PTR _vstats$[ebp]
  00054	ff 43 08	 inc	 DWORD PTR [ebx+8]

; 3676 : 
; 3677 :             assert( inner == m_root || !inner->isunderflow() );
; 3678 :             assert( inner->slotuse > 0 );
; 3679 : 
; 3680 :             for(unsigned short slot = 0; slot < inner->slotuse - 1; ++slot)

  00057	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  0005b	48		 dec	 eax
  0005c	56		 push	 esi
  0005d	3b c2		 cmp	 eax, edx
  0005f	7e 08		 jle	 SHORT $LN13@verify_nod
$LL35@verify_nod:
  00061	41		 inc	 ecx
  00062	0f b7 f1	 movzx	 esi, cx
  00065	3b f0		 cmp	 esi, eax
  00067	7c f8		 jl	 SHORT $LL35@verify_nod
$LN13@verify_nod:

; 3681 :             {
; 3682 :                 assert(key_lessequal(inner->slotkey[slot], inner->slotkey[slot + 1]));
; 3683 :             }
; 3684 : 
; 3685 :             for(unsigned short slot = 0; slot <= inner->slotuse; ++slot)

  00069	33 f6		 xor	 esi, esi
  0006b	eb 05		 jmp	 SHORT $LN12@verify_nod
  0006d	8d 49 00	 npad	 3
$LL34@verify_nod:
  00070	33 d2		 xor	 edx, edx
$LN12@verify_nod:

; 3686 :             {
; 3687 :                 const node *subnode = inner->childid[slot];
; 3688 :                 key_type subminkey = key_type();
; 3689 :                 key_type submaxkey = key_type();
; 3690 : 
; 3691 :                 assert(subnode->level + 1 == inner->level);
; 3692 :                 verify_node(subnode, &subminkey, &submaxkey, vstats);

  00072	53		 push	 ebx
  00073	89 55 14	 mov	 DWORD PTR _subminkey$157031[ebp], edx
  00076	89 55 08	 mov	 DWORD PTR _submaxkey$157032[ebp], edx
  00079	8d 45 08	 lea	 eax, DWORD PTR _submaxkey$157032[ebp]
  0007c	50		 push	 eax
  0007d	0f b7 d6	 movzx	 edx, si
  00080	8b 84 97 84 00
	00 00		 mov	 eax, DWORD PTR [edi+edx*4+132]
  00087	8d 4d 14	 lea	 ecx, DWORD PTR _subminkey$157031[ebp]
  0008a	51		 push	 ecx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_node

; 3693 : 
; 3694 :                 BTREE_PRINT("verify subnode " << subnode << ": " << subminkey << " - " << submaxkey);
; 3695 : 
; 3696 :                 if (slot == 0)

  00094	66 85 f6	 test	 si, si
  00097	75 08		 jne	 SHORT $LN6@verify_nod

; 3697 :                     *minkey = subminkey;

  00099	8b 4d 14	 mov	 ecx, DWORD PTR _subminkey$157031[ebp]
  0009c	8b 55 0c	 mov	 edx, DWORD PTR _minkey$[ebp]
  0009f	89 0a		 mov	 DWORD PTR [edx], ecx
$LN6@verify_nod:

; 3698 :                 else
; 3699 :                     assert(key_greaterequal(subminkey, inner->slotkey[slot-1]));
; 3700 : 
; 3701 :                 if (slot == inner->slotuse)

  000a1	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  000a5	66 3b f0	 cmp	 si, ax
  000a8	75 08		 jne	 SHORT $LN11@verify_nod

; 3702 :                     *maxkey = submaxkey;

  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _submaxkey$157032[ebp]
  000ad	8b 55 10	 mov	 edx, DWORD PTR _maxkey$[ebp]
  000b0	89 0a		 mov	 DWORD PTR [edx], ecx
$LN11@verify_nod:

; 3681 :             {
; 3682 :                 assert(key_lessequal(inner->slotkey[slot], inner->slotkey[slot + 1]));
; 3683 :             }
; 3684 : 
; 3685 :             for(unsigned short slot = 0; slot <= inner->slotuse; ++slot)

  000b2	46		 inc	 esi
  000b3	66 3b f0	 cmp	 si, ax
  000b6	76 b8		 jbe	 SHORT $LL34@verify_nod
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx
  000ba	5f		 pop	 edi

; 3703 :                 else
; 3704 :                     assert(key_equal(inner->slotkey[slot], submaxkey));
; 3705 : 
; 3706 :                 if (inner->level == 1 && slot < inner->slotuse)
; 3707 :                 {
; 3708 :                     // children are leaves and must be linked together in the
; 3709 :                     // correct order
; 3710 :                     const leaf_node *leafa = static_cast<const leaf_node*>(inner->childid[slot]);
; 3711 :                     const leaf_node *leafb = static_cast<const leaf_node*>(inner->childid[slot + 1]);
; 3712 : 
; 3713 :                     assert(leafa->nextleaf == leafb);
; 3714 :                     assert(leafa == leafb->prevleaf);
; 3715 :                     (void)leafa; (void)leafb;
; 3716 :                 }
; 3717 :                 if (inner->level == 2 && slot < inner->slotuse)
; 3718 :                 {
; 3719 :                     // verify leaf links between the adjacent inner nodes
; 3720 :                     const inner_node *parenta = static_cast<const inner_node*>(inner->childid[slot]);
; 3721 :                     const inner_node *parentb = static_cast<const inner_node*>(inner->childid[slot+1]);
; 3722 : 
; 3723 :                     const leaf_node *leafa = static_cast<const leaf_node*>(parenta->childid[parenta->slotuse]);
; 3724 :                     const leaf_node *leafb = static_cast<const leaf_node*>(parentb->childid[0]);
; 3725 : 
; 3726 :                     assert(leafa->nextleaf == leafb);
; 3727 :                     assert(leafa == leafb->prevleaf);
; 3728 :                     (void)leafa; (void)leafb;
; 3729 :                 }
; 3730 :             }
; 3731 :         }
; 3732 :     }

  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 10 00	 ret	 16			; 00000010H
?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z
_TEXT	SEGMENT
?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::free_node, COMDAT
; _this$ = esi
; _n$ = eax

; 1487 :         if (n->isleafnode()) {

  00000	66 83 38 00	 cmp	 WORD PTR [eax], 0

; 1488 :             leaf_node *ln = static_cast<leaf_node*>(n);
; 1489 :             typename leaf_node::alloc_type a(leaf_node_allocator());
; 1490 :             a.destroy(ln);
; 1491 :             a.deallocate(ln, 1);

  00004	50		 push	 eax
  00005	75 0c		 jne	 SHORT $LN2@free_node
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 1492 :             m_stats.leaves--;

  0000f	ff 4e 10	 dec	 DWORD PTR [esi+16]

; 1500 :         }
; 1501 :     }

  00012	c3		 ret	 0
$LN2@free_node:

; 1493 :         }
; 1494 :         else {
; 1495 :             inner_node *in = static_cast<inner_node*>(n);
; 1496 :             typename inner_node::alloc_type a(inner_node_allocator());
; 1497 :             a.destroy(in);
; 1498 :             a.deallocate(in, 1);

  00013	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1499 :             m_stats.innernodes--;

  00018	ff 4e 14	 dec	 DWORD PTR [esi+20]
  0001b	83 c4 04	 add	 esp, 4

; 1500 :         }
; 1501 :     }

  0001e	c3		 ret	 0
?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::free_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key_less@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z
_TEXT	SEGMENT
_b$ = 8							; size = 4
?key_less@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_less, COMDAT
; _a$ = eax

; 1412 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1413 :         return m_key_less(a, b);

  00003	8b 08		 mov	 ecx, DWORD PTR [eax]
  00005	3b 4d 08	 cmp	 ecx, DWORD PTR _b$[ebp]
  00008	1b c0		 sbb	 eax, eax
  0000a	f7 d8		 neg	 eax

; 1414 :     }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?key_less@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABII@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_less
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z
_TEXT	SEGMENT
?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals, COMDAT
; _a$ = eax
; _b$ = edx

; 1212 :     return key_info.equals(a, b);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 94 c0	 sete	 al

; 1213 :   }

  00009	c3		 ret	 0
?equals@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::equals
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = eax
; _bucknum$ = esi

; 461  :     assert(settings.use_empty());  // we always need to know what's empty!
; 462  :     return equals(get_key(val_info.emptyval), get_key(table[bucknum]));

  00000	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00003	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  00006	33 c0		 xor	 eax, eax
  00008	3b 14 f1	 cmp	 edx, DWORD PTR [ecx+esi*8]
  0000b	0f 94 c0	 sete	 al

; 463  :   }

  0000e	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
  00000	c3		 ret	 0
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--, COMDAT
; _this$ = eax

; 383  : 		--(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00005	89 10		 mov	 DWORD PTR [eax], edx

; 384  : 		return (*this);
; 385  : 		}

  00007	c3		 ret	 0
??F?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = eax

; 370  : 		++(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 11		 mov	 edx, DWORD PTR [ecx]
  00004	89 10		 mov	 DWORD PTR [eax], edx

; 371  : 		return (*this);
; 372  : 		}

  00006	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z
_TEXT	SEGMENT
??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 342  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 		}

  00002	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE@PAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PBV?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 243  : 		_Myiter _Tmp = *this;

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00002	89 08		 mov	 DWORD PTR [eax], ecx

; 244  : 		++*this;

  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 0a		 mov	 DWORD PTR [edx], ecx

; 245  : 		return (_Tmp);
; 246  : 		}

  00008	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*, COMDAT
; _this$ = eax

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  00002	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@PAUleaf_node@12@G@Z
_TEXT	SEGMENT
_s$ = 8							; size = 2
??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@PAUleaf_node@12@G@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator, COMDAT
; _this$ = eax
; _l$ = ecx

; 505  :         { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	66 8b 55 08	 mov	 dx, WORD PTR _s$[ebp]
  00007	89 08		 mov	 DWORD PTR [eax], ecx
  00009	33 c9		 xor	 ecx, ecx
  0000b	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0000f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00012	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??0iterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@PAUleaf_node@12@G@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::iterator
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy, COMDAT
; _this$ = esi

; 1302 : 		if (this->_Myfirst != 0)

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00015	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 1312 : 		}

  00023	c3		 ret	 0
?_Tidy@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy, COMDAT
; _this$ = esi

; 1497 : 		clear();

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	89 09		 mov	 DWORD PTR [ecx], ecx
  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN3@Tidy@2
  00016	57		 push	 edi
$LL5@Tidy@2:
  00017	8b 38		 mov	 edi, DWORD PTR [eax]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL5@Tidy@2
  00028	5f		 pop	 edi
$LN3@Tidy@2:

; 1498 : 		}

  00029	c3		 ret	 0
?_Tidy@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Tidy
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T177405 = -16						; size = 12
$T177352 = -4						; size = 4
??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 612  : 		{	// construct empty list, allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 10		 push	 16			; 00000010H
  00008	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 0f		 je	 SHORT $LN18@list
  0001b	89 06		 mov	 DWORD PTR [esi], eax
  0001d	89 00		 mov	 DWORD PTR [eax], eax
  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 613  : 		}

  00024	8b c6		 mov	 eax, esi
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0

; 612  : 		{	// construct empty list, allocator

$LN18@list:
  0002a	8d 45 fc	 lea	 eax, DWORD PTR $T177352[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d f0	 lea	 ecx, DWORD PTR $T177405[ebp]
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T177352[ebp], 0
  00038	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00042	8d 4d f0	 lea	 ecx, DWORD PTR $T177405[ebp]
  00045	51		 push	 ecx
  00046	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T177405[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN35@list:
$LN34@list:
  00052	cc		 int	 3
??0?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 717  : 		{	// return begin iterator for bucket _Bucket

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  : 		return (_Vec_lo(_Bucket));

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Bucket$[ebp]
  00009	8b 14 ca	 mov	 edx, DWORD PTR [edx+ecx*8]
  0000c	89 10		 mov	 DWORD PTR [eax], edx

; 719  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T177477 = -16						; size = 12
$T177461 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 27		 je	 SHORT $LN15@Tree_val
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  0001e	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 551  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00042	8d 45 fc	 lea	 eax, DWORD PTR $T177461[ebp]
  00045	50		 push	 eax
  00046	8d 4d f0	 lea	 ecx, DWORD PTR $T177477[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T177461[ebp], 0
  00050	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00055	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005a	8d 4d f0	 lea	 ecx, DWORD PTR $T177477[ebp]
  0005d	51		 push	 ecx
  0005e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T177477[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00065	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006a	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound, COMDAT
; _this$ = eax
; __Keyval$ = edx

; 1742 : 		_Nodeptr _Pnode = _Root();

  00000	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00003	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00006	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000a	75 18		 jne	 SHORT $LN3@Lbound
  0000c	8b 12		 mov	 edx, DWORD PTR [edx]
  0000e	8b ff		 npad	 2
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00010	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00013	73 05		 jae	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00015	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  00018	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001a	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  0001e	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00022	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00024	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lbound
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?verify@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEXXZ
_TEXT	SEGMENT
_vstats$ = -20						; size = 12
_minkey$ = -8						; size = 4
_maxkey$ = -4						; size = 4
?verify@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEXXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify, COMDAT
; _this$ = ecx

; 3631 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 3632 :         key_type minkey, maxkey;
; 3633 :         tree_stats vstats;
; 3634 : 
; 3635 :         if (m_root)

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	33 d2		 xor	 edx, edx
  0000a	89 55 ec	 mov	 DWORD PTR _vstats$[ebp], edx
  0000d	89 55 f0	 mov	 DWORD PTR _vstats$[ebp+4], edx
  00010	89 55 f4	 mov	 DWORD PTR _vstats$[ebp+8], edx
  00013	3b c2		 cmp	 eax, edx
  00015	74 12		 je	 SHORT $LN1@verify

; 3636 :         {
; 3637 :             verify_node(m_root, &minkey, &maxkey, vstats);

  00017	8d 55 ec	 lea	 edx, DWORD PTR _vstats$[ebp]
  0001a	52		 push	 edx
  0001b	8d 55 fc	 lea	 edx, DWORD PTR _maxkey$[ebp]
  0001e	52		 push	 edx
  0001f	8d 55 f8	 lea	 edx, DWORD PTR _minkey$[ebp]
  00022	52		 push	 edx
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?verify_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEXPBUnode@12@PAI1AAUtree_stats@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify_node
$LN1@verify:

; 3638 : 
; 3639 :             assert( vstats.itemcount == m_stats.itemcount );
; 3640 :             assert( vstats.leaves == m_stats.leaves );
; 3641 :             assert( vstats.innernodes == m_stats.innernodes );
; 3642 : 
; 3643 :             verify_leaflinks();
; 3644 :         }
; 3645 :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?verify@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEXXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::verify
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?key_equal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABI0@Z
_TEXT	SEGMENT
?key_equal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABI0@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_equal, COMDAT
; _a$ = eax
; _b$ = ecx

; 1438 :         return !m_key_less(a, b) && !m_key_less(b, a);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00004	3b c8		 cmp	 ecx, eax
  00006	77 08		 ja	 SHORT $LN3@key_equal
  00008	72 06		 jb	 SHORT $LN3@key_equal
  0000a	b8 01 00 00 00	 mov	 eax, 1

; 1439 :     }

  0000f	c3		 ret	 0
$LN3@key_equal:

; 1438 :         return !m_key_less(a, b) && !m_key_less(b, a);

  00010	33 c0		 xor	 eax, eax

; 1439 :     }

  00012	c3		 ret	 0
?key_equal@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABE_NABI0@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::key_equal
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost, COMDAT
; _this$ = eax

; 1219 :     return (!root() || root()->leaf()) ? root() : root()->rightmost();

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	85 c0		 test	 eax, eax
  00004	74 0b		 je	 SHORT $LN15@rightmost
  00006	80 38 00	 cmp	 BYTE PTR [eax], 0
  00009	75 06		 jne	 SHORT $LN15@rightmost
  0000b	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
$LN15@rightmost:

; 1220 :   }

  00011	c3		 ret	 0
?rightmost@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rightmost
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z
_TEXT	SEGMENT
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 1138 :     alloc_impl(const libc_allocator_with_realloc<A>& a)

  00000	c3		 ret	 0
??0?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z
_TEXT	SEGMENT
tv134 = -12						; size = 8
tv68 = -12						; size = 8
tv143 = -8						; size = 4
tv136 = -8						; size = 4
tv70 = -8						; size = 4
tv139 = -2						; size = 2
tv131 = -2						; size = 2
?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds, COMDAT
; _this$ = ecx
; _num_buckets$ = eax

; 130  :   void reset_thresholds(size_type num_buckets) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 131  :     set_enlarge_threshold(enlarge_size(num_buckets));

  00006	89 45 f8	 mov	 DWORD PTR tv143[ebp], eax
  00009	db 45 f8	 fild	 DWORD PTR tv143[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN13@reset_thre
  00010	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN13@reset_thre:
  00016	d9 41 08	 fld	 DWORD PTR [ecx+8]

; 132  :     set_shrink_threshold(shrink_size(num_buckets));
; 133  :     // whatever caused us to reset already considered
; 134  :     set_consider_shrink(false);

  00019	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0
  0001d	d9 7d fe	 fnstcw	 WORD PTR tv139[ebp]
  00020	0f b7 45 fe	 movzx	 eax, WORD PTR tv139[ebp]
  00024	d8 c9		 fmul	 ST(0), ST(1)
  00026	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0002b	89 45 f8	 mov	 DWORD PTR tv136[ebp], eax
  0002e	d9 6d f8	 fldcw	 WORD PTR tv136[ebp]
  00031	df 7d f4	 fistp	 QWORD PTR tv134[ebp]
  00034	8b 55 f4	 mov	 edx, DWORD PTR tv134[ebp]
  00037	89 11		 mov	 DWORD PTR [ecx], edx
  00039	d9 6d fe	 fldcw	 WORD PTR tv139[ebp]
  0003c	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  0003f	d9 7d fe	 fnstcw	 WORD PTR tv131[ebp]
  00042	0f b7 45 fe	 movzx	 eax, WORD PTR tv131[ebp]
  00046	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0004b	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  0004e	d9 6d f8	 fldcw	 WORD PTR tv70[ebp]
  00051	df 7d f4	 fistp	 QWORD PTR tv68[ebp]
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00057	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0005a	d9 6d fe	 fldcw	 WORD PTR tv131[ebp]

; 135  :   }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?reset_thresholds@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEXI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::reset_thresholds
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z
_TEXT	SEGMENT
__Cat$177627 = 8					; size = 1
_table_end$ = 8						; size = 4
?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty, COMDAT
; _this$ = edx
; _table_start$ = ecx

; 474  :   void fill_range_with_empty(pointer table_start, pointer table_end) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 475  :     STL_NAMESPACE::uninitialized_fill(table_start, table_end, val_info.emptyval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Cat$177627[ebp]
  00006	50		 push	 eax
  00007	51		 push	 ecx
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _table_end$[ebp]
  0000b	83 c2 2c	 add	 edx, 44			; 0000002cH
  0000e	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00013	83 c4 08	 add	 esp, 8

; 476  :   }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?fill_range_with_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@0@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::fill_range_with_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z
_TEXT	SEGMENT
?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value, COMDAT
; _dst$ = eax
; _src$ = ecx

; 353  :     dst->~value_type();   // delete the old value, if any
; 354  :     new(dst) value_type(src);

  00000	85 c0		 test	 eax, eax
  00002	74 0a		 je	 SHORT $LN3@set_value
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]
  00006	89 10		 mov	 DWORD PTR [eax], edx
  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@set_value:

; 355  :   }

  0000e	c3		 ret	 0
?set_value@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXPAU?$pair@$$CBIPAUgoogle_object@@@std@@ABU34@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*, COMDAT
; _this$ = eax

; 360  : 		return ((reference)**(_Mybase *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 361  : 		}

  00005	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*, COMDAT
; _this$ = eax

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator*
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  00002	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = eax

; 49   : 		return (_Mytree::_Myval(_Ptr));

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 50   : 		}

  00005	c3		 ret	 0
??D?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >, COMDAT
; _this$ = esi

; 705  : 		_Tidy();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 09		 je	 SHORT $LN8@vector
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4
$LN8@vector:
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00015	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 706  : 		}

  00023	c3		 ret	 0
??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter, COMDAT
; ___$ReturnUdt$ = eax

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  00008	5d		 pop	 ebp
  00009	c2 04 00	 ret	 4
?_Make_iter@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Make_iter
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 792  : 		return (iterator(this->_Myhead, this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx

; 793  : 		}

  00004	c3		 ret	 0
?end@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 770  : 		_Tidy();

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	89 09		 mov	 DWORD PTR [ecx], ecx
  00006	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00008	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  0000b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00012	3b 06		 cmp	 eax, DWORD PTR [esi]
  00014	74 13		 je	 SHORT $LN5@list@2
  00016	57		 push	 edi
$LL7@list@2:
  00017	8b 38		 mov	 edi, DWORD PTR [eax]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	83 c4 04	 add	 esp, 4
  00022	8b c7		 mov	 eax, edi
  00024	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00026	75 ef		 jne	 SHORT $LL7@list@2
  00028	5f		 pop	 edi
$LN5@list@2:

; 771  : 		}

  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	59		 pop	 ecx
  00032	c3		 ret	 0
??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 0a		 jne	 SHORT $LN1@Min
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00008	8b c1		 mov	 eax, ecx
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00010	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  00012	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Min
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00000	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00003	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00007	75 12		 jne	 SHORT $LN1@Max
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00005	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00013	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  0001c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00022	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  00025	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00027	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00034	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00037	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003a	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00042	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00049	89 02		 mov	 DWORD PTR [edx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0004e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1810 : 		}

  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00009	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000d	75 1b		 jne	 SHORT $LN36@lower_boun
  0000f	56		 push	 esi
  00010	8b 75 08	 mov	 esi, DWORD PTR __Keyval$[ebp]
  00013	8b 36		 mov	 esi, DWORD PTR [esi]
$LL6@lower_boun:
  00015	39 71 0c	 cmp	 DWORD PTR [ecx+12], esi
  00018	73 05		 jae	 SHORT $LN4@lower_boun
  0001a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0001d	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001f	8b d1		 mov	 edx, ecx
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN3@lower_boun:
  00023	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00027	74 ec		 je	 SHORT $LL6@lower_boun
  00029	5e		 pop	 esi
$LN36@lower_boun:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 1451 : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T178131 = -16						; size = 12
$T178065 = -4						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 25		 je	 SHORT $LN20@Tree
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001e	89 00		 mov	 DWORD PTR [eax], eax
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 699  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T178065[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T178131[ebp]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T178065[ebp], 0
  0004e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00053	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00058	8d 4d f0	 lea	 ecx, DWORD PTR $T178131[ebp]
  0005b	51		 push	 ecx
  0005c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T178131[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  00068	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?end@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 1582 :         return iterator(m_tailleaf, m_tailleaf ? m_tailleaf->slotuse : 0);

  00000	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00003	85 c9		 test	 ecx, ecx
  00005	74 06		 je	 SHORT $LN3@end
  00007	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  0000b	eb 02		 jmp	 SHORT $LN4@end
$LN3@end:
  0000d	33 d2		 xor	 edx, edx
$LN4@end:
  0000f	89 08		 mov	 DWORD PTR [eax], ecx
  00011	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00015	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  0001c	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 1583 :     }

  00023	c3		 ret	 0
?end@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ
_TEXT	SEGMENT
?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 951  :     return iterator(rightmost(), rightmost() ? rightmost()->count() : 0);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	85 c9		 test	 ecx, ecx
  00004	74 0d		 je	 SHORT $LN7@end@2
  00006	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00009	75 08		 jne	 SHORT $LN7@end@2
  0000b	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00011	eb 02		 jmp	 SHORT $LN19@end@2
$LN7@end@2:
  00013	8b d1		 mov	 edx, ecx
$LN19@end@2:
  00015	85 d2		 test	 edx, edx
  00017	74 1d		 je	 SHORT $LN3@end@2
  00019	85 c9		 test	 ecx, ecx
  0001b	74 11		 je	 SHORT $LN23@end@2
  0001d	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00020	75 0c		 jne	 SHORT $LN23@end@2
  00022	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00028	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0002c	eb 0a		 jmp	 SHORT $LN4@end@2
$LN23@end@2:
  0002e	8b d1		 mov	 edx, ecx
  00030	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00034	eb 02		 jmp	 SHORT $LN4@end@2
$LN3@end@2:
  00036	33 d2		 xor	 edx, edx
$LN4@end@2:
  00038	85 c9		 test	 ecx, ecx
  0003a	74 0b		 je	 SHORT $LN41@end@2
  0003c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0003f	75 06		 jne	 SHORT $LN41@end@2
  00041	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN41@end@2:
  00047	89 08		 mov	 DWORD PTR [eax], ecx
  00049	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 952  :   }

  0004c	c3		 ret	 0
?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
__Cat$178370 = 8					; size = 1
_this$ = 8						; size = 4
?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key, COMDAT
; _val$ = eax

; 481  :   void set_empty_key(const_reference val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 482  :     // Once you set the empty key, you can't change it
; 483  :     assert(!settings.use_empty() && "Calling set_empty_key multiple times");
; 484  :     // The deleted indicator (if specified) and the empty indicator
; 485  :     // must be different.
; 486  :     assert((!settings.use_deleted() || !equals(get_key(val), key_info.delkey))
; 487  :            && "Setting the empty key the same as the deleted key");
; 488  :     settings.set_use_empty(true);
; 489  :     set_value(&val_info.emptyval, val);

  00009	8d 7b 2c	 lea	 edi, DWORD PTR [ebx+44]
  0000c	c6 43 11 01	 mov	 BYTE PTR [ebx+17], 1
  00010	85 ff		 test	 edi, edi
  00012	74 0a		 je	 SHORT $LN7@set_empty_
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	89 0f		 mov	 DWORD PTR [edi], ecx
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001b	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN7@set_empty_:

; 490  : 
; 491  :     assert(!table);                  // must set before first use
; 492  :     // num_buckets was set in constructor even though table was NULL
; 493  :     table = val_info.allocate(num_buckets);

  0001e	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  00021	03 f6		 add	 esi, esi
  00023	03 f6		 add	 esi, esi
  00025	03 f6		 add	 esi, esi
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 _malloc

; 494  :     assert(table);
; 495  :     fill_range_with_empty(table, table + num_buckets);

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Cat$178370[ebp]
  00030	51		 push	 ecx
  00031	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  00034	50		 push	 eax
  00035	8b d7		 mov	 edx, edi
  00037	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  0003a	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx

; 496  :   }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?set_empty_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
  00000	c3		 ret	 0
??1?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~alloc_impl<google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo, COMDAT
  00000	c3		 ret	 0
??1ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::~ValInfo
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->, COMDAT
; _this$ = eax

; 365  : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 08	 add	 eax, 8

; 366  : 		}

  00005	c3		 ret	 0
??C?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 300  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 301  : 		}

  00009	c3		 ret	 0
??9?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->, COMDAT
; _this$ = eax

; 401  : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->, COMDAT
; _this$ = eax

; 54   : 		return (&**this);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 55   : 		}

  00005	c3		 ret	 0
??C?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPBU?$pair@$$CBIPAUcpp_object@@@1@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator->
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 335  : 		return (!(*this == _Right));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	33 c0		 xor	 eax, eax
  00004	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00006	0f 95 c0	 setne	 al

; 336  : 		}

  00009	c3		 ret	 0
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??Citerator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPAU?$pair@IPAUstx_object@@@std@@XZ
_TEXT	SEGMENT
??Citerator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPAU?$pair@IPAUstx_object@@@std@@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator->, COMDAT
; _this$ = eax

; 525  :             temp_value = pair_to_value_type()( pair_type(key(),data()) );

  00000	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00004	8b 10		 mov	 edx, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	8b 74 8a 0c	 mov	 esi, DWORD PTR [edx+ecx*4+12]
  0000b	8b 8c 8a 8c 00
	00 00		 mov	 ecx, DWORD PTR [edx+ecx*4+140]
  00012	83 c0 08	 add	 eax, 8
  00015	89 30		 mov	 DWORD PTR [eax], esi
  00017	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 526  :             return &temp_value;
; 527  :         }

  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??Citerator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QBEPAU?$pair@IPAUstx_object@@@std@@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::iterator::operator->
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 337  : 		return (_List.end());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 338  : 		}

  00005	c3		 ret	 0
?end@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT
; _this$ = esi

; 316  : 		}

  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN10@Hash
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN10@Hash:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN18@Hash
$LL20@Hash:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL20@Hash
$LN18@Hash:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
  0004f	5f		 pop	 edi
  00050	c3		 ret	 0
??1?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 817  : 		return (iterator(this->_Myhead, this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	89 10		 mov	 DWORD PTR [eax], edx

; 818  : 		}

  00005	c3		 ret	 0
?end@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree_map.h
_TEXT	ENDS
;	COMDAT ?end@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ
_TEXT	SEGMENT
?end@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::end, COMDAT
; ___$ReturnUdt$ = eax

; 258  :     {

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree

; 259  : 	return tree.end();

  00006	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 06		 je	 SHORT $LN5@end@3
  0000d	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00011	eb 02		 jmp	 SHORT $LN6@end@3
$LN5@end@3:
  00013	33 d2		 xor	 edx, edx
$LN6@end@3:
  00015	89 08		 mov	 DWORD PTR [eax], ecx
  00017	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  0001b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00022	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 260  :     }

  00029	c3		 ret	 0
?end@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@XZ ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >, COMDAT
; _this$ = esi

; 940  :     clear();

  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN12@btree
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN12@btree:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 941  :   }

  00014	c3		 ret	 0
??1?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::~btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ
_TEXT	SEGMENT
?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end, COMDAT
; ___$ReturnUdt$ = eax

; 62   :   iterator end() { return tree_.end(); }

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0d		 je	 SHORT $LN9@end@4
  0000c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0000f	75 08		 jne	 SHORT $LN9@end@4
  00011	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00017	eb 02		 jmp	 SHORT $LN21@end@4
$LN9@end@4:
  00019	8b d1		 mov	 edx, ecx
$LN21@end@4:
  0001b	85 d2		 test	 edx, edx
  0001d	74 1d		 je	 SHORT $LN5@end@4
  0001f	85 c9		 test	 ecx, ecx
  00021	74 11		 je	 SHORT $LN25@end@4
  00023	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00026	75 0c		 jne	 SHORT $LN25@end@4
  00028	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  0002e	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00032	eb 0a		 jmp	 SHORT $LN6@end@4
$LN25@end@4:
  00034	8b d1		 mov	 edx, ecx
  00036	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0003a	eb 02		 jmp	 SHORT $LN6@end@4
$LN5@end@4:
  0003c	33 d2		 xor	 edx, edx
$LN6@end@4:
  0003e	85 c9		 test	 ecx, ecx
  00040	74 0b		 je	 SHORT $LN43@end@4
  00042	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00045	75 06		 jne	 SHORT $LN43@end@4
  00047	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN43@end@4:
  0004d	89 08		 mov	 DWORD PTR [eax], ecx
  0004f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00052	c3		 ret	 0
?end@?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 727  :     if (table) {

  00000	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN9@dense_hash

; 728  :       destroy_buckets(0, num_buckets);
; 729  :       val_info.deallocate(table, num_buckets);

  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	59		 pop	 ecx
$LN9@dense_hash:

; 730  :     }
; 731  :   }

  0000e	c3		 ret	 0
??1?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z
_TEXT	SEGMENT
__Cat$179101 = -4					; size = 1
?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key, COMDAT
; _key$ = eax

; 294  :   void set_empty_key(const key_type& key)   {           // YOU MUST CALL THIS!

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 295  :     rep.set_empty_key(value_type(key, data_type()));    // rep wants a value

  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000e	8d 5e 2c	 lea	 ebx, DWORD PTR [esi+44]
  00011	57		 push	 edi
  00012	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1
  00016	85 db		 test	 ebx, ebx
  00018	74 09		 je	 SHORT $LN17@set_empty_@2
  0001a	89 03		 mov	 DWORD PTR [ebx], eax
  0001c	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0
$LN17@set_empty_@2:
  00023	8b 7e 28	 mov	 edi, DWORD PTR [esi+40]
  00026	03 ff		 add	 edi, edi
  00028	03 ff		 add	 edi, edi
  0002a	03 ff		 add	 edi, edi
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _malloc
  00032	8b 4d fc	 mov	 ecx, DWORD PTR __Cat$179101[ebp]
  00035	51		 push	 ecx
  00036	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  00039	50		 push	 eax
  0003a	8b d3		 mov	 edx, ebx
  0003c	89 46 34	 mov	 DWORD PTR [esi+52], eax
  0003f	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  :   }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?set_empty_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_empty_key
_TEXT	ENDS
PUBLIC	?test_cache_miss@@YAXXZ				; test_cache_miss
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
;	COMDAT ?test_cache_miss@@YAXXZ
_TEXT	SEGMENT
_t$179114 = -64						; size = 8
_stop$153167 = -56					; size = 8
_t$179108 = -48						; size = 8
tv293 = -40						; size = 8
tv302 = -32						; size = 8
_start$153166 = -24					; size = 8
_result$ = -16						; size = 8
tv248 = -8						; size = 4
_DATA$ = -4						; size = 4
?test_cache_miss@@YAXXZ PROC				; test_cache_miss, COMDAT

; 2302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 2303 : 	unsigned size = 512*1024*1024;
; 2304 : 	unsigned char* DATA = (unsigned char*)malloc(size);

  00009	68 00 00 00 20	 push	 536870912		; 20000000H
  0000e	e8 00 00 00 00	 call	 _malloc
  00013	83 c4 04	 add	 esp, 4

; 2305 : 	unsigned delta = 512;
; 2306 : 	tommy_uint64_t miss_time;
; 2307 : 	unsigned i, j;
; 2308 : 	tommy_uint64_t result = 0;
; 2309 : 
; 2310 : 	memset(DATA, 0, size);

  00016	68 00 00 00 20	 push	 536870912		; 20000000H
  0001b	8b f0		 mov	 esi, eax
  0001d	6a 00		 push	 0
  0001f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00023	56		 push	 esi
  00024	89 75 fc	 mov	 DWORD PTR _DATA$[ebp], esi
  00027	66 0f 13 45 f0	 movlpd	 QWORD PTR _result$[ebp], xmm0
  0002c	e8 00 00 00 00	 call	 _memset
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR tv248[ebp], 8
  0003b	eb 06		 jmp	 SHORT $LN8@test_cache
  0003d	8d 49 00	 npad	 3
$LL22@test_cache:

; 2303 : 	unsigned size = 512*1024*1024;
; 2304 : 	unsigned char* DATA = (unsigned char*)malloc(size);

  00040	8b 75 fc	 mov	 esi, DWORD PTR _DATA$[ebp]
$LN8@test_cache:

; 2313 : 		tommy_uint64_t start, stop;
; 2314 : 		start = nano();

  00043	8d 45 d0	 lea	 eax, DWORD PTR _t$179108[ebp]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0004d	85 c0		 test	 eax, eax
  0004f	75 0e		 jne	 SHORT $LN11@test_cache
  00051	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00055	66 0f 13 45 e8	 movlpd	 QWORD PTR _start$153166[ebp], xmm0
  0005a	8b 7d e8	 mov	 edi, DWORD PTR _start$153166[ebp]
  0005d	eb 5a		 jmp	 SHORT $LN12@test_cache
$LN11@test_cache:
  0005f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00065	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _t$179108[ebp+4]
  0006e	8b 55 d0	 mov	 edx, DWORD PTR _t$179108[ebp]
  00071	57		 push	 edi
  00072	56		 push	 esi
  00073	51		 push	 ecx
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 __alldvrm
  0007a	6a 00		 push	 0
  0007c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00081	53		 push	 ebx
  00082	51		 push	 ecx
  00083	89 45 e0	 mov	 DWORD PTR tv302[ebp], eax
  00086	89 55 e4	 mov	 DWORD PTR tv302[ebp+4], edx
  00089	e8 00 00 00 00	 call	 __allmul
  0008e	57		 push	 edi
  0008f	56		 push	 esi
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 __alldiv
  00097	8b 4d e0	 mov	 ecx, DWORD PTR tv302[ebp]
  0009a	6a 00		 push	 0
  0009c	8b f8		 mov	 edi, eax
  0009e	8b 45 e4	 mov	 eax, DWORD PTR tv302[ebp+4]
  000a1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  000a6	50		 push	 eax
  000a7	51		 push	 ecx
  000a8	8b da		 mov	 ebx, edx
  000aa	e8 00 00 00 00	 call	 __allmul
  000af	8b 75 fc	 mov	 esi, DWORD PTR _DATA$[ebp]
  000b2	03 f8		 add	 edi, eax
  000b4	13 da		 adc	 ebx, edx
  000b6	89 5d ec	 mov	 DWORD PTR _start$153166[ebp+4], ebx
$LN12@test_cache:

; 2315 : 		for(i=0;i<size;i += delta) {

  000b9	33 c0		 xor	 eax, eax
  000bb	eb 03 8d 49 00	 npad	 5
$LL5@test_cache:

; 2316 : 			++DATA[i];

  000c0	fe 04 30	 inc	 BYTE PTR [eax+esi]
  000c3	05 00 02 00 00	 add	 eax, 512		; 00000200H
  000c8	3d 00 00 00 20	 cmp	 eax, 536870912		; 20000000H
  000cd	72 f1		 jb	 SHORT $LL5@test_cache

; 2317 : 		}
; 2318 : 		stop = nano();

  000cf	8d 55 c0	 lea	 edx, DWORD PTR _t$179114[ebp]
  000d2	52		 push	 edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  000d9	85 c0		 test	 eax, eax
  000db	75 11		 jne	 SHORT $LN14@test_cache
  000dd	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000e1	66 0f 13 45 c8	 movlpd	 QWORD PTR _stop$153167[ebp], xmm0
  000e6	8b 5d cc	 mov	 ebx, DWORD PTR _stop$153167[ebp+4]
  000e9	8b 75 c8	 mov	 esi, DWORD PTR _stop$153167[ebp]
  000ec	eb 59		 jmp	 SHORT $LN15@test_cache
$LN14@test_cache:
  000ee	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR _win_frequency
  000f9	8b 4d c4	 mov	 ecx, DWORD PTR _t$179114[ebp+4]
  000fc	8b 55 c0	 mov	 edx, DWORD PTR _t$179114[ebp]
  000ff	56		 push	 esi
  00100	50		 push	 eax
  00101	51		 push	 ecx
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 __alldvrm
  00108	6a 00		 push	 0
  0010a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0010f	53		 push	 ebx
  00110	51		 push	 ecx
  00111	89 45 d8	 mov	 DWORD PTR tv293[ebp], eax
  00114	89 55 dc	 mov	 DWORD PTR tv293[ebp+4], edx
  00117	e8 00 00 00 00	 call	 __allmul
  0011c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _win_frequency
  00122	56		 push	 esi
  00123	51		 push	 ecx
  00124	52		 push	 edx
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 __alldiv
  0012b	6a 00		 push	 0
  0012d	8b da		 mov	 ebx, edx
  0012f	8b 55 dc	 mov	 edx, DWORD PTR tv293[ebp+4]
  00132	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00137	8b f0		 mov	 esi, eax
  00139	8b 45 d8	 mov	 eax, DWORD PTR tv293[ebp]
  0013c	52		 push	 edx
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 __allmul
  00143	03 f0		 add	 esi, eax
  00145	13 da		 adc	 ebx, edx
$LN15@test_cache:

; 2319 : 
; 2320 : 		if (!result || result > stop - start)

  00147	8b 4d f0	 mov	 ecx, DWORD PTR _result$[ebp]
  0014a	8b 55 f4	 mov	 edx, DWORD PTR _result$[ebp+4]
  0014d	0b ca		 or	 ecx, edx
  0014f	74 14		 je	 SHORT $LN21@test_cache
  00151	8b ce		 mov	 ecx, esi
  00153	2b cf		 sub	 ecx, edi
  00155	8b c3		 mov	 eax, ebx
  00157	1b 45 ec	 sbb	 eax, DWORD PTR _start$153166[ebp+4]
  0015a	3b d0		 cmp	 edx, eax
  0015c	72 12		 jb	 SHORT $LN7@test_cache
  0015e	77 05		 ja	 SHORT $LN21@test_cache
  00160	39 4d f0	 cmp	 DWORD PTR _result$[ebp], ecx
  00163	76 0b		 jbe	 SHORT $LN7@test_cache
$LN21@test_cache:

; 2321 : 			result = stop - start;

  00165	2b f7		 sub	 esi, edi
  00167	1b 5d ec	 sbb	 ebx, DWORD PTR _start$153166[ebp+4]
  0016a	89 75 f0	 mov	 DWORD PTR _result$[ebp], esi
  0016d	89 5d f4	 mov	 DWORD PTR _result$[ebp+4], ebx
$LN7@test_cache:

; 2311 : 
; 2312 : 	for(j=0;j<8;++j) {

  00170	ff 4d f8	 dec	 DWORD PTR tv248[ebp]
  00173	0f 85 c7 fe ff
	ff		 jne	 $LL22@test_cache

; 2322 : 	}
; 2323 : 
; 2324 : 	free(DATA);

  00179	8b 55 fc	 mov	 edx, DWORD PTR _DATA$[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 _free

; 2325 : 
; 2326 : 	miss_time = result * delta / size;

  00182	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  00185	8b 4d f4	 mov	 ecx, DWORD PTR _result$[ebp+4]
  00188	0f a4 c1 09	 shld	 ecx, eax, 9
  0018c	c1 e0 09	 shl	 eax, 9
  0018f	0f ac c8 1d	 shrd	 eax, ecx, 29
  00193	83 c4 04	 add	 esp, 4

; 2327 : 
; 2328 : 	printf("Cache miss %d [ns]\n", (unsigned)miss_time);

  00196	50		 push	 eax
  00197	68 00 00 00 00	 push	 OFFSET $SG-129
  0019c	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  0019f	e8 00 00 00 00	 call	 _printf
  001a4	83 c4 08	 add	 esp, 8

; 2329 : }

  001a7	5f		 pop	 edi
  001a8	5e		 pop	 esi
  001a9	5b		 pop	 ebx
  001aa	8b e5		 mov	 esp, ebp
  001ac	5d		 pop	 ebp
  001ad	c3		 ret	 0
?test_cache_miss@@YAXXZ ENDP				; test_cache_miss
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN15@btree_cont
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN15@btree_cont:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN18@btree_uniq
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN18@btree_uniq:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN21@btree_map_
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN21@btree_map_:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@XZ ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::~btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi
  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN12@unordered_
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN12@unordered_:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN20@unordered_
$LL22@unordered_:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL22@unordered_
$LN20@unordered_:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	83 c4 04	 add	 esp, 4
  0004f	5f		 pop	 edi
  00050	c3		 ret	 0
??1?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ
_TEXT	SEGMENT
??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>, COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN24@btree_map
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN24@btree_map:
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	c3		 ret	 0
??1?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@XZ ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::~btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ
_TEXT	SEGMENT
??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax
  00000	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00003	85 c0		 test	 eax, eax
  00005	74 07		 je	 SHORT $LN11@dense_hash@2
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	59		 pop	 ecx
$LN11@dense_hash@2:
  0000e	c3		 ret	 0
??1?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@XZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::~dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00003	57		 push	 edi
  00004	33 ff		 xor	 edi, edi
  00006	3b c7		 cmp	 eax, edi
  00008	74 09		 je	 SHORT $LN15@scalar@2
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
$LN15@scalar@2:
  00013	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00016	89 7e 14	 mov	 DWORD PTR [esi+20], edi
  00019	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0001c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 09		 mov	 DWORD PTR [ecx], ecx
  00023	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00026	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00029	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002c	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0002f	74 12		 je	 SHORT $LN23@scalar@2
$LL25@scalar@2:
  00031	8b 38		 mov	 edi, DWORD PTR [eax]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00039	83 c4 04	 add	 esp, 4
  0003c	8b c7		 mov	 eax, edi
  0003e	3b 7e 04	 cmp	 edi, DWORD PTR [esi+4]
  00041	75 ee		 jne	 SHORT $LL25@scalar@2
$LN23@scalar@2:
  00043	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004c	56		 push	 esi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00052	83 c4 08	 add	 esp, 8
  00055	8b c6		 mov	 eax, esi
  00057	5f		 pop	 edi
  00058	c3		 ret	 0
??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 06		 mov	 eax, DWORD PTR [esi]
  00002	85 c0		 test	 eax, eax
  00004	74 08		 je	 SHORT $LN18@scalar@3
  00006	50		 push	 eax
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN18@scalar@3:
  0000e	56		 push	 esi
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b c6		 mov	 eax, esi
  0001f	c3		 ret	 0
??_G?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAEPAXI@Z ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::`scalar deleting destructor'
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z
_TEXT	SEGMENT
??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00003	85 c0		 test	 eax, eax
  00005	74 09		 je	 SHORT $LN14@scalar@4
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _free
  0000d	83 c4 04	 add	 esp, 4
$LN14@scalar@4:
  00010	56		 push	 esi
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4
  00019	8b c6		 mov	 eax, esi
  0001b	c3		 ret	 0
??_G?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEPAXI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?order_init@@YAXHH@Z				; order_init
; Function compile flags: /Ogtp
;	COMDAT ?order_init@@YAXHH@Z
_TEXT	SEGMENT
tv431 = -8						; size = 4
tv195 = -8						; size = 4
tv181 = -4						; size = 4
tv71 = -4						; size = 4
_t$145934 = -4						; size = 4
tv297 = 8						; size = 4
_i$ = 8							; size = 4
_sparse$ = 8						; size = 4
?order_init@@YAXHH@Z PROC				; order_init, COMDAT

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 687  : 	int i;
; 688  : 
; 689  : 	FORWARD = (unsigned*)malloc(max * sizeof(unsigned));

  0000f	8d 34 9d 00 00
	00 00		 lea	 esi, DWORD PTR [ebx*4]
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _malloc
  0001c	83 c4 04	 add	 esp, 4

; 690  : 	RAND0 = (unsigned*)malloc(max * sizeof(unsigned));

  0001f	56		 push	 esi
  00020	a3 00 00 00 00	 mov	 DWORD PTR ?FORWARD@@3PAIA, eax ; FORWARD
  00025	e8 00 00 00 00	 call	 _malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	8b f8		 mov	 edi, eax

; 691  : 	RAND1 = (unsigned*)malloc(max * sizeof(unsigned));

  0002f	56		 push	 esi
  00030	89 3d 00 00 00
	00		 mov	 DWORD PTR ?RAND0@@3PAIA, edi ; RAND0
  00036	e8 00 00 00 00	 call	 _malloc
  0003b	83 c4 04	 add	 esp, 4

; 692  : 
; 693  : 	/* generated forward orders */
; 694  : 	if (sparse) {

  0003e	83 7d 08 00	 cmp	 DWORD PTR _sparse$[ebp], 0
  00042	8b c8		 mov	 ecx, eax
  00044	89 0d 00 00 00
	00		 mov	 DWORD PTR ?RAND1@@3PAIA, ecx ; RAND1
  0004a	74 3c		 je	 SHORT $LN11@order_init

; 695  : 		for(i=0;i<max;++i) {

  0004c	85 db		 test	 ebx, ebx
  0004e	7e 6f		 jle	 SHORT $LN4@order_init
  00050	83 c8 ff	 or	 eax, -1
  00053	33 d2		 xor	 edx, edx
  00055	f7 f3		 div	 ebx
  00057	33 f6		 xor	 esi, esi
  00059	8b d7		 mov	 edx, edi
  0005b	89 5d fc	 mov	 DWORD PTR tv181[ebp], ebx
  0005e	89 45 f8	 mov	 DWORD PTR tv195[ebp], eax
  00061	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00066	2b c7		 sub	 eax, edi
  00068	2b cf		 sub	 ecx, edi
  0006a	89 4d 08	 mov	 DWORD PTR tv297[ebp], ecx
  0006d	8d 49 00	 npad	 3
$LL10@order_init:

; 696  : 			FORWARD[i] = 0xffffffff / max * i;
; 697  : 			RAND0[i] = FORWARD[i];
; 698  : 			RAND1[i] = FORWARD[i];

  00070	8b 4d 08	 mov	 ecx, DWORD PTR tv297[ebp]
  00073	89 34 10	 mov	 DWORD PTR [eax+edx], esi
  00076	89 32		 mov	 DWORD PTR [edx], esi
  00078	89 34 11	 mov	 DWORD PTR [ecx+edx], esi
  0007b	03 75 f8	 add	 esi, DWORD PTR tv195[ebp]
  0007e	83 c2 04	 add	 edx, 4
  00081	ff 4d fc	 dec	 DWORD PTR tv181[ebp]
  00084	75 ea		 jne	 SHORT $LL10@order_init

; 699  : 		}

  00086	eb 31		 jmp	 SHORT $LN20@order_init
$LN11@order_init:

; 700  : 	} else {
; 701  : 		for(i=0;i<max;++i) {

  00088	85 db		 test	 ebx, ebx
  0008a	7e 33		 jle	 SHORT $LN4@order_init
  0008c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00092	2b f7		 sub	 esi, edi
  00094	2b cf		 sub	 ecx, edi
  00096	8b d7		 mov	 edx, edi
  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	89 4d 08	 mov	 DWORD PTR tv297[ebp], ecx
  000a0	89 5d fc	 mov	 DWORD PTR tv71[ebp], ebx
$LL6@order_init:

; 702  : 			FORWARD[i] = 0x80000000 + i * 2;
; 703  : 			RAND0[i] = FORWARD[i];
; 704  : 			RAND1[i] = FORWARD[i];

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR tv297[ebp]
  000a6	89 04 32	 mov	 DWORD PTR [edx+esi], eax
  000a9	89 02		 mov	 DWORD PTR [edx], eax
  000ab	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax
  000ae	83 c0 02	 add	 eax, 2
  000b1	83 c2 04	 add	 edx, 4
  000b4	ff 4d fc	 dec	 DWORD PTR tv71[ebp]
  000b7	75 ea		 jne	 SHORT $LL6@order_init
$LN20@order_init:

; 700  : 	} else {
; 701  : 		for(i=0;i<max;++i) {

  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND1@@3PAIA ; RAND1
$LN4@order_init:

; 705  : 		}
; 706  : 	}
; 707  : 
; 708  : 	/* randomize using the Fisher-Yates shuffle, http://en.wikipedia.org/wiki/Fisher-Yates_shuffle */
; 709  : 	for(i=max-1;i>=0;--i) {

  000bf	8d 43 ff	 lea	 eax, DWORD PTR [ebx-1]
  000c2	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  000c5	85 c0		 test	 eax, eax
  000c7	78 59		 js	 SHORT $LN1@order_init
  000c9	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]
  000cc	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  000cf	8b c7		 mov	 eax, edi
  000d1	2b c1		 sub	 eax, ecx
  000d3	89 45 f8	 mov	 DWORD PTR tv431[ebp], eax
$LL3@order_init:

; 710  : 		unsigned j, t;
; 711  : 		j = rnd(i+1);

  000d6	53		 push	 ebx
  000d7	e8 00 00 00 00	 call	 ?rnd@@YAII@Z		; rnd

; 712  : 		t = RAND0[i];

  000dc	8b 4d f8	 mov	 ecx, DWORD PTR tv431[ebp]
  000df	8b 14 31	 mov	 edx, DWORD PTR [ecx+esi]
  000e2	89 55 fc	 mov	 DWORD PTR _t$145934[ebp], edx

; 713  : 		RAND0[i] = RAND0[j];

  000e5	8b 14 87	 mov	 edx, DWORD PTR [edi+eax*4]
  000e8	89 14 31	 mov	 DWORD PTR [ecx+esi], edx

; 714  : 		RAND0[j] = t;

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _t$145934[ebp]
  000ee	83 c4 04	 add	 esp, 4

; 715  : 
; 716  : 		j = rnd(i+1);

  000f1	53		 push	 ebx
  000f2	89 0c 87	 mov	 DWORD PTR [edi+eax*4], ecx
  000f5	e8 00 00 00 00	 call	 ?rnd@@YAII@Z		; rnd

; 717  : 		t = RAND1[i];
; 718  : 		RAND1[i] = RAND1[j];

  000fa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  00100	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  00103	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00105	89 16		 mov	 DWORD PTR [esi], edx

; 719  : 		RAND1[j] = t;

  00107	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0010d	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00110	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00113	48		 dec	 eax
  00114	83 c4 04	 add	 esp, 4
  00117	4b		 dec	 ebx
  00118	83 ee 04	 sub	 esi, 4
  0011b	89 45 08	 mov	 DWORD PTR _i$[ebp], eax
  0011e	85 c0		 test	 eax, eax
  00120	79 b4		 jns	 SHORT $LL3@order_init
$LN1@order_init:

; 720  : 	}
; 721  : }

  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5b		 pop	 ebx
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
?order_init@@YAXHH@Z ENDP				; order_init
_TEXT	ENDS
PUBLIC	?stop@@YAXXZ					; stop
; Function compile flags: /Ogtp
;	COMDAT ?stop@@YAXXZ
_TEXT	SEGMENT
?stop@@YAXXZ PROC					; stop, COMDAT

; 616  : {

  00000	51		 push	 ecx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 617  : 	tommy_uint64_t elapsed = nano() - the_time;

  00003	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00008	8b f0		 mov	 esi, eax
  0000a	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA

; 618  : 
; 619  : 	if (!is_select(the_start_data))

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00015	8b fa		 mov	 edi, edx
  00017	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  0001d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00023	75 62		 jne	 SHORT $LN3@stop

; 620  : 		return;
; 621  : 
; 622  : 	if (!the_log) {

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0002c	75 1e		 jne	 SHORT $LN1@stop

; 623  : 		printf("%4u [ns]\n", (unsigned)(elapsed / the_max));

  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00034	6a 00		 push	 0
  00036	51		 push	 ecx
  00037	57		 push	 edi
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 __aulldiv
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET $SG-102
  00044	e8 00 00 00 00	 call	 _printf
  00049	83 c4 08	 add	 esp, 8
$LN1@stop:

; 624  : 	} 
; 625  : 
; 626  : 	LOG[the_retry][the_data][the_order][the_operation] = (unsigned)(elapsed / the_max);

  0004c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00052	6a 00		 push	 0
  00054	52		 push	 edx
  00055	57		 push	 edi
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 __aulldiv
  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00062	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00068	c1 e1 04	 shl	 ecx, 4
  0006b	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  00071	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00074	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0007a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0007d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00080	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN3@stop:

; 627  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	59		 pop	 ecx
  0008a	c3		 ret	 0
?stop@@YAXXZ ENDP					; stop
_TEXT	ENDS
PUBLIC	?start@@YAHI@Z					; start
; Function compile flags: /Ogtp
;	COMDAT ?start@@YAHI@Z
_TEXT	SEGMENT
?start@@YAHI@Z PROC					; start, COMDAT
; _data$ = eax

; 602  : {

  00000	51		 push	 ecx

; 603  : 	the_start_data = data;

  00001	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data

; 604  : 
; 605  : 	if (!is_select(the_start_data))

  00006	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0000c	74 04		 je	 SHORT $LN2@start

; 606  : 		return 0;

  0000e	33 c0		 xor	 eax, eax
  00010	59		 pop	 ecx

; 613  : }

  00011	c3		 ret	 0
$LN2@start:

; 607  : 
; 608  : 	if (!the_log)

  00012	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00019	75 30		 jne	 SHORT $LN1@start

; 609  : 		printf("%10s, %10s, %12s, ", ORDER_NAME[the_order], OPERATION_NAME[the_operation], DATA_NAME[data]);

  0001b	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00028	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0002f	50		 push	 eax
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00035	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0003c	52		 push	 edx
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET $SG-101
  00043	e8 00 00 00 00	 call	 _printf
  00048	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@start:

; 610  : 
; 611  : 	the_time = nano();

  0004b	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00055	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx

; 612  : 	return 1;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	59		 pop	 ecx

; 613  : }

  00061	c3		 ret	 0
?start@@YAHI@Z ENDP					; start
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??Rcpp_tommy_inthash_u32@@QBEII@Z
_TEXT	SEGMENT
??Rcpp_tommy_inthash_u32@@QBEII@Z PROC			; cpp_tommy_inthash_u32::operator(), COMDAT
; _key$ = ecx

; 322  : 	unsigned operator()(unsigned key) const { return tommy_inthash_u32(key); }

  00000	8b c1		 mov	 eax, ecx
  00002	c1 e0 06	 shl	 eax, 6
  00005	2b c8		 sub	 ecx, eax
  00007	8b d1		 mov	 edx, ecx
  00009	c1 ea 11	 shr	 edx, 17			; 00000011H
  0000c	33 ca		 xor	 ecx, edx
  0000e	8b c1		 mov	 eax, ecx
  00010	c1 e0 09	 shl	 eax, 9
  00013	2b c8		 sub	 ecx, eax
  00015	8b d1		 mov	 edx, ecx
  00017	c1 e2 04	 shl	 edx, 4
  0001a	33 ca		 xor	 ecx, edx
  0001c	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00023	2b c8		 sub	 ecx, eax
  00025	8b d1		 mov	 edx, ecx
  00027	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0002a	33 ca		 xor	 ecx, edx
  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00031	33 c1		 xor	 eax, ecx
  00033	c3		 ret	 0
??Rcpp_tommy_inthash_u32@@QBEII@Z ENDP			; cpp_tommy_inthash_u32::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z
_TEXT	SEGMENT
_last$145657 = -20					; size = 4
_inc$145653 = -16					; size = 4
tv344 = -12						; size = 4
_site$145656 = -8					; size = 4
_x$ = -4						; size = 4
_key$ = 8						; size = 4
_ret$ = 12						; size = 4
?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z PROC		; kh_put_word, COMDAT

; 306  : KHASH_MAP_INIT_INT(word, struct khash_object*)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  0000f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00012	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  00015	72 18		 jb	 SHORT $LN17@kh_put_wor
  00017	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001a	8b 07		 mov	 eax, DWORD PTR [edi]
  0001c	03 c9		 add	 ecx, ecx
  0001e	3b c1		 cmp	 eax, ecx
  00020	76 03		 jbe	 SHORT $LN18@kh_put_wor
  00022	48		 dec	 eax
  00023	eb 01		 jmp	 SHORT $LN29@kh_put_wor
$LN18@kh_put_wor:
  00025	40		 inc	 eax
$LN29@kh_put_wor:
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?kh_resize_word@@YAXPAUkh_word_t@@I@Z ; kh_resize_word
  0002c	83 c4 04	 add	 esp, 4
$LN17@kh_put_wor:
  0002f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00031	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00034	33 d2		 xor	 edx, edx
  00036	f7 f1		 div	 ecx
  00038	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0003b	89 4d f8	 mov	 DWORD PTR _site$145656[ebp], ecx
  0003e	89 4d fc	 mov	 DWORD PTR _x$[ebp], ecx
  00041	8b da		 mov	 ebx, edx
  00043	8b f3		 mov	 esi, ebx
  00045	c1 ee 04	 shr	 esi, 4
  00048	03 f6		 add	 esi, esi
  0004a	03 f6		 add	 esi, esi
  0004c	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  0004f	83 e2 0f	 and	 edx, 15			; 0000000fH
  00052	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00055	d3 e8		 shr	 eax, cl
  00057	89 4d f4	 mov	 DWORD PTR tv344[ebp], ecx
  0005a	a8 02		 test	 al, 2
  0005c	74 07		 je	 SHORT $LN16@kh_put_wor
  0005e	8b f3		 mov	 esi, ebx
  00060	e9 a8 00 00 00	 jmp	 $LN5@kh_put_wor
$LN16@kh_put_wor:
  00065	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00067	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0006a	8d 49 ff	 lea	 ecx, DWORD PTR [ecx-1]
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 f1		 div	 ecx
  00071	8b 4d f4	 mov	 ecx, DWORD PTR tv344[ebp]
  00074	89 5d ec	 mov	 DWORD PTR _last$145657[ebp], ebx
  00077	42		 inc	 edx
  00078	89 55 f0	 mov	 DWORD PTR _inc$145653[ebp], edx
  0007b	eb 06		 jmp	 SHORT $LN14@kh_put_wor
  0007d	8d 49 00	 npad	 3
$LL28@kh_put_wor:
  00080	8b 55 f0	 mov	 edx, DWORD PTR _inc$145653[ebp]
$LN14@kh_put_wor:
  00083	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00086	8b 34 30	 mov	 esi, DWORD PTR [eax+esi]
  00089	d3 ee		 shr	 esi, cl
  0008b	83 e6 01	 and	 esi, 1
  0008e	75 0b		 jne	 SHORT $LN24@kh_put_wor
  00090	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00093	8b 0c 98	 mov	 ecx, DWORD PTR [eax+ebx*4]
  00096	3b 4d 08	 cmp	 ecx, DWORD PTR _key$[ebp]
  00099	74 43		 je	 SHORT $LN26@kh_put_wor
$LN24@kh_put_wor:
  0009b	85 f6		 test	 esi, esi
  0009d	74 03		 je	 SHORT $LN25@kh_put_wor
  0009f	89 5d f8	 mov	 DWORD PTR _site$145656[ebp], ebx
$LN25@kh_put_wor:
  000a2	8b 07		 mov	 eax, DWORD PTR [edi]
  000a4	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  000a7	3b c8		 cmp	 ecx, eax
  000a9	72 06		 jb	 SHORT $LN10@kh_put_wor
  000ab	2b d0		 sub	 edx, eax
  000ad	03 da		 add	 ebx, edx
  000af	eb 02		 jmp	 SHORT $LN9@kh_put_wor
$LN10@kh_put_wor:
  000b1	8b d9		 mov	 ebx, ecx
$LN9@kh_put_wor:
  000b3	3b 5d ec	 cmp	 ebx, DWORD PTR _last$145657[ebp]
  000b6	74 20		 je	 SHORT $LN23@kh_put_wor
  000b8	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000bb	8b f3		 mov	 esi, ebx
  000bd	c1 ee 04	 shr	 esi, 4
  000c0	03 f6		 add	 esi, esi
  000c2	8b d3		 mov	 edx, ebx
  000c4	83 e2 0f	 and	 edx, 15			; 0000000fH
  000c7	03 f6		 add	 esi, esi
  000c9	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  000cc	8b 14 06	 mov	 edx, DWORD PTR [esi+eax]
  000cf	d3 ea		 shr	 edx, cl
  000d1	f6 c2 02	 test	 dl, 2
  000d4	74 aa		 je	 SHORT $LL28@kh_put_wor
  000d6	eb 06		 jmp	 SHORT $LN26@kh_put_wor
$LN23@kh_put_wor:
  000d8	8b 45 f8	 mov	 eax, DWORD PTR _site$145656[ebp]
  000db	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
$LN26@kh_put_wor:
  000de	8b 37		 mov	 esi, DWORD PTR [edi]
  000e0	39 75 fc	 cmp	 DWORD PTR _x$[ebp], esi
  000e3	75 25		 jne	 SHORT $LN27@kh_put_wor
  000e5	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  000e8	8b d3		 mov	 edx, ebx
  000ea	8b cb		 mov	 ecx, ebx
  000ec	c1 ea 04	 shr	 edx, 4
  000ef	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  000f2	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000f5	03 c9		 add	 ecx, ecx
  000f7	d3 e8		 shr	 eax, cl
  000f9	a8 02		 test	 al, 2
  000fb	74 0a		 je	 SHORT $LN6@kh_put_wor
  000fd	8b 45 f8	 mov	 eax, DWORD PTR _site$145656[ebp]
  00100	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax
  00103	3b c6		 cmp	 eax, esi
  00105	75 03		 jne	 SHORT $LN27@kh_put_wor
$LN6@kh_put_wor:
  00107	89 5d fc	 mov	 DWORD PTR _x$[ebp], ebx
$LN27@kh_put_wor:
  0010a	8b 75 fc	 mov	 esi, DWORD PTR _x$[ebp]
$LN5@kh_put_wor:
  0010d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00110	8b d6		 mov	 edx, esi
  00112	c1 ea 04	 shr	 edx, 4
  00115	03 d2		 add	 edx, edx
  00117	8b ce		 mov	 ecx, esi
  00119	03 d2		 add	 edx, edx
  0011b	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0011e	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00121	03 c9		 add	 ecx, ecx
  00123	d3 e8		 shr	 eax, cl
  00125	a8 02		 test	 al, 2
  00127	74 30		 je	 SHORT $LN4@kh_put_wor
  00129	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0012c	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  0012f	89 1c b0	 mov	 DWORD PTR [eax+esi*4], ebx
  00132	03 57 10	 add	 edx, DWORD PTR [edi+16]
  00135	b8 03 00 00 00	 mov	 eax, 3
  0013a	d3 e0		 shl	 eax, cl
  0013c	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  0013f	f7 d0		 not	 eax
  00141	21 02		 and	 DWORD PTR [edx], eax
  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	01 47 04	 add	 DWORD PTR [edi+4], eax
  0014b	01 47 08	 add	 DWORD PTR [edi+8], eax
  0014e	5f		 pop	 edi
  0014f	89 01		 mov	 DWORD PTR [ecx], eax
  00151	8b c6		 mov	 eax, esi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c3		 ret	 0
$LN4@kh_put_wor:
  00159	a8 01		 test	 al, 1
  0015b	74 2e		 je	 SHORT $LN2@kh_put_wor
  0015d	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00160	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  00163	89 1c b0	 mov	 DWORD PTR [eax+esi*4], ebx
  00166	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00169	03 c2		 add	 eax, edx
  0016b	ba 03 00 00 00	 mov	 edx, 3
  00170	d3 e2		 shl	 edx, cl
  00172	f7 d2		 not	 edx
  00174	21 10		 and	 DWORD PTR [eax], edx
  00176	8b 45 0c	 mov	 eax, DWORD PTR _ret$[ebp]
  00179	ff 47 04	 inc	 DWORD PTR [edi+4]
  0017c	5f		 pop	 edi
  0017d	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
  00183	8b c6		 mov	 eax, esi
  00185	5e		 pop	 esi
  00186	5b		 pop	 ebx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
$LN2@kh_put_wor:
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _ret$[ebp]
  0018e	5f		 pop	 edi
  0018f	8b c6		 mov	 eax, esi
  00191	5e		 pop	 esi
  00192	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00198	5b		 pop	 ebx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ENDP		; kh_put_word
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z
_TEXT	SEGMENT
_bitpos$179977 = -4					; size = 4
?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z PROC ; nedtrie_t_NEDTRIE_FIND, COMDAT
; _r$ = eax

; 304  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0000b	56		 push	 esi
  0000c	8b 70 14	 mov	 esi, DWORD PTR [eax+20]
  0000f	74 4b		 je	 SHORT $LN22@nedtrie_t_
  00011	8b ce		 mov	 ecx, esi
  00013	83 c9 01	 or	 ecx, 1
  00016	0f bd d1	 bsr	 edx, ecx
  00019	8b ca		 mov	 ecx, edx
  0001b	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  00022	89 55 fc	 mov	 DWORD PTR _bitpos$179977[ebp], edx
  00025	85 c0		 test	 eax, eax
  00027	74 33		 je	 SHORT $LN22@nedtrie_t_
  00029	ba 01 00 00 00	 mov	 edx, 1
  0002e	d3 e2		 shl	 edx, cl
  00030	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  00033	74 19		 je	 SHORT $end$145401
$LL6@nedtrie_t_:
  00035	d1 ea		 shr	 edx, 1
  00037	8b ca		 mov	 ecx, edx
  00039	23 ce		 and	 ecx, esi
  0003b	f7 d9		 neg	 ecx
  0003d	1b c9		 sbb	 ecx, ecx
  0003f	f7 d9		 neg	 ecx
  00041	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  00045	85 c0		 test	 eax, eax
  00047	74 13		 je	 SHORT $LN22@nedtrie_t_
  00049	39 70 14	 cmp	 DWORD PTR [eax+20], esi
  0004c	75 e7		 jne	 SHORT $LL6@nedtrie_t_
$end$145401:
  0004e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00051	85 c9		 test	 ecx, ecx
  00053	74 09		 je	 SHORT $LN9@nedtrie_t_
  00055	8b c1		 mov	 eax, ecx
  00057	5e		 pop	 esi
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN22@nedtrie_t_:
  0005c	33 c0		 xor	 eax, eax
$LN9@nedtrie_t_:
  0005e	5e		 pop	 esi
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z ENDP ; nedtrie_t_NEDTRIE_FIND
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z
_TEXT	SEGMENT
?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z PROC ; nedtrie_t_NEDTRIE_REMOVE, COMDAT
; _r$ = edx

; 304  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00003	85 c0		 test	 eax, eax
  00005	74 18		 je	 SHORT $LN15@nedtrie_t_@2
  00007	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  0000a	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0000d	85 d2		 test	 edx, edx
  0000f	0f 84 90 00 00
	00		 je	 $LN24@nedtrie_t_@2
  00015	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00018	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
$functexit$145354:
  0001e	c3		 ret	 0
$LN15@nedtrie_t_@2:
  0001f	56		 push	 esi
  00020	8b 32		 mov	 esi, DWORD PTR [edx]
  00022	8b c6		 mov	 eax, esi
  00024	83 e0 03	 and	 eax, 3
  00027	57		 push	 edi
  00028	3c 03		 cmp	 al, 3
  0002a	75 0e		 jne	 SHORT $LN12@nedtrie_t_@2
  0002c	8b ce		 mov	 ecx, esi
  0002e	c1 e9 02	 shr	 ecx, 2
  00031	8d 3c 8d 04 00
	00 00		 lea	 edi, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  00038	eb 0b		 jmp	 SHORT $LN19@nedtrie_t_@2
$LN12@nedtrie_t_@2:
  0003a	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0003d	39 56 04	 cmp	 DWORD PTR [esi+4], edx
  00040	74 03		 je	 SHORT $LN19@nedtrie_t_@2
  00042	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
$LN19@nedtrie_t_@2:
  00045	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00048	33 c0		 xor	 eax, eax
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 0b		 je	 SHORT $LN10@nedtrie_t_@2
  0004e	8b c1		 mov	 eax, ecx
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  00057	eb 2a		 jmp	 SHORT $end$145367
$LN10@nedtrie_t_@2:
  00059	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  0005c	75 05		 jne	 SHORT $LN8@nedtrie_t_@2
  0005e	39 42 08	 cmp	 DWORD PTR [edx+8], eax
  00061	74 3e		 je	 SHORT $LN1@nedtrie_t_@2
$LN8@nedtrie_t_@2:
  00063	8b cf		 mov	 ecx, edi
$LL6@nedtrie_t_@2:
  00065	8b 01		 mov	 eax, DWORD PTR [ecx]
  00067	83 c0 04	 add	 eax, 4
  0006a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006d	75 08		 jne	 SHORT $LN4@nedtrie_t_@2
  0006f	83 c0 04	 add	 eax, 4
  00072	83 38 00	 cmp	 DWORD PTR [eax], 0
  00075	74 04		 je	 SHORT $LN5@nedtrie_t_@2
$LN4@nedtrie_t_@2:
  00077	8b c8		 mov	 ecx, eax
  00079	eb ea		 jmp	 SHORT $LL6@nedtrie_t_@2
$LN5@nedtrie_t_@2:
  0007b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$end$145367:
  00083	85 c0		 test	 eax, eax
  00085	74 1a		 je	 SHORT $LN1@nedtrie_t_@2
  00087	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0008a	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  0008d	89 30		 mov	 DWORD PTR [eax], esi
  0008f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00092	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00095	85 c9		 test	 ecx, ecx
  00097	74 02		 je	 SHORT $LN2@nedtrie_t_@2
  00099	89 01		 mov	 DWORD PTR [ecx], eax
$LN2@nedtrie_t_@2:
  0009b	85 d2		 test	 edx, edx
  0009d	74 02		 je	 SHORT $LN1@nedtrie_t_@2
  0009f	89 02		 mov	 DWORD PTR [edx], eax
$LN1@nedtrie_t_@2:
  000a1	89 07		 mov	 DWORD PTR [edi], eax
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
$LN24@nedtrie_t_@2:
  000a5	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
$functexit_1$145354:
  000ab	c3		 ret	 0
?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ENDP ; nedtrie_t_NEDTRIE_REMOVE
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z
_TEXT	SEGMENT
_bitpos$180005 = -4					; size = 4
?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z PROC ; nedtrie_t_NEDTRIE_INSERT, COMDAT
; _r$ = esi

; 304  : NEDTRIE_GENERATE(static, nedtrie_t, nedtrie_object, link, nedtrie_func, NEDTRIE_NOBBLEZEROS(nedtrie_t));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5e 14	 mov	 ebx, DWORD PTR [esi+20]
  00008	57		 push	 edi
  00009	8b c3		 mov	 eax, ebx
  0000b	bf 01 00 00 00	 mov	 edi, 1
  00010	0b c7		 or	 eax, edi
  00012	0f bd c8	 bsr	 ecx, eax
  00015	8b 14 8d 04 00
	00 00		 mov	 edx, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  0001c	66 0f ef c0	 pxor	 xmm0, xmm0
  00020	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00024	66 0f d6 46 08	 movq	 QWORD PTR [esi+8], xmm0
  00029	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00030	89 4d fc	 mov	 DWORD PTR _bitpos$180005[ebp], ecx
  00033	85 d2		 test	 edx, edx
  00035	75 1f		 jne	 SHORT $LN8@nedtrie_t_@3
  00037	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  0003e	83 ca 03	 or	 edx, 3
  00041	01 3d 00 00 00
	00		 add	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, edi
  00047	5f		 pop	 edi
  00048	89 16		 mov	 DWORD PTR [esi], edx
  0004a	89 34 8d 04 00
	00 00		 mov	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4], esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
$LN8@nedtrie_t_@3:
  00056	d3 e7		 shl	 edi, cl
  00058	39 5a 14	 cmp	 DWORD PTR [edx+20], ebx
  0005b	74 1e		 je	 SHORT $LN19@nedtrie_t_@3
  0005d	8d 49 00	 npad	 3
$LL6@nedtrie_t_@3:
  00060	d1 ef		 shr	 edi, 1
  00062	8b c7		 mov	 eax, edi
  00064	23 c3		 and	 eax, ebx
  00066	f7 d8		 neg	 eax
  00068	1b c0		 sbb	 eax, eax
  0006a	f7 d8		 neg	 eax
  0006c	8b 4c 82 04	 mov	 ecx, DWORD PTR [edx+eax*4+4]
  00070	85 c9		 test	 ecx, ecx
  00072	74 2c		 je	 SHORT $LN20@nedtrie_t_@3
  00074	8b d1		 mov	 edx, ecx
  00076	39 59 14	 cmp	 DWORD PTR [ecx+20], ebx
  00079	75 e5		 jne	 SHORT $LL6@nedtrie_t_@3
$LN19@nedtrie_t_@3:
  0007b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0007e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00084	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00087	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0008a	89 72 10	 mov	 DWORD PTR [edx+16], esi
  0008d	85 c0		 test	 eax, eax
  0008f	74 15		 je	 SHORT $LN22@nedtrie_t_@3
  00091	5f		 pop	 edi
  00092	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00095	ff 05 00 00 00
	00		 inc	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN20@nedtrie_t_@3:
  000a0	89 16		 mov	 DWORD PTR [esi], edx
  000a2	89 74 82 04	 mov	 DWORD PTR [edx+eax*4+4], esi
$LN22@nedtrie_t_@3:
  000a6	ff 05 00 00 00
	00		 inc	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  000ac	5f		 pop	 edi
$end$145335:
  000ad	5b		 pop	 ebx
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ENDP ; nedtrie_t_NEDTRIE_INSERT
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z
_TEXT	SEGMENT
_path$ = -520						; size = 512
_nodep$ = -4						; size = 4
?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z PROC	; rbt_remove, COMDAT
; _node$ = edx

; 295  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 02 00
	00		 sub	 esp, 524		; 0000020cH
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?tree@@3Urbtree_t@@A
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nodep$[ebp], 0
  00019	89 8d f8 fd ff
	ff		 mov	 DWORD PTR _path$[ebp], ecx
  0001f	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00025	bb 01 00 00 00	 mov	 ebx, 1
  0002a	81 f9 04 00 00
	00		 cmp	 ecx, OFFSET ?tree@@3Urbtree_t@@A+4
  00030	74 77		 je	 SHORT $LN274@rbt_remove
  00032	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
$LL282@rbt_remove:
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0003a	3b fe		 cmp	 edi, esi
  0003c	7d 05		 jge	 SHORT $LN286@rbt_remove
  0003e	83 c9 ff	 or	 ecx, -1
  00041	eb 07		 jmp	 SHORT $LN285@rbt_remove
$LN286@rbt_remove:
  00043	33 c9		 xor	 ecx, ecx
  00045	3b fe		 cmp	 edi, esi
  00047	0f 9f c1	 setg	 cl
$LN285@rbt_remove:
  0004a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004d	85 c9		 test	 ecx, ecx
  0004f	79 09		 jns	 SHORT $LN279@rbt_remove
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00055	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00058	eb 0f		 jmp	 SHORT $LN281@rbt_remove
$LN279@rbt_remove:
  0005a	8b 30		 mov	 esi, DWORD PTR [eax]
  0005c	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0005f	83 e6 fe	 and	 esi, -2			; fffffffeH
  00062	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00065	85 c9		 test	 ecx, ecx
  00067	74 0d		 je	 SHORT $LN292@rbt_remove
$LN281@rbt_remove:
  00069	83 c0 08	 add	 eax, 8
  0006c	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  00072	75 c1		 jne	 SHORT $LL282@rbt_remove
  00074	eb 33		 jmp	 SHORT $LN274@rbt_remove
$LN292@rbt_remove:
  00076	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00079	89 45 fc	 mov	 DWORD PTR _nodep$[ebp], eax
  0007c	83 c0 08	 add	 eax, 8
  0007f	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  00085	74 22		 je	 SHORT $LN274@rbt_remove
  00087	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL276@rbt_remove:
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00094	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  0009b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0009e	83 c0 08	 add	 eax, 8
  000a1	81 38 04 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  000a7	75 e7		 jne	 SHORT $LL276@rbt_remove
$LN274@rbt_remove:
  000a9	8b 48 f8	 mov	 ecx, DWORD PTR [eax-8]
  000ac	83 e8 08	 sub	 eax, 8
  000af	3b ca		 cmp	 ecx, edx
  000b1	0f 84 88 00 00
	00		 je	 $LN273@rbt_remove
  000b7	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000ba	8b fe		 mov	 edi, esi
  000bc	23 fb		 and	 edi, ebx
  000be	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c1	33 de		 xor	 ebx, esi
  000c3	83 e3 01	 and	 ebx, 1
  000c6	33 de		 xor	 ebx, esi
  000c8	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  000cb	8b 32		 mov	 esi, DWORD PTR [edx]
  000cd	89 31		 mov	 DWORD PTR [ecx], esi
  000cf	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000d2	33 71 04	 xor	 esi, DWORD PTR [ecx+4]
  000d5	bb 01 00 00 00	 mov	 ebx, 1
  000da	23 f3		 and	 esi, ebx
  000dc	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  000df	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000e2	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  000e5	83 e6 fe	 and	 esi, -2			; fffffffeH
  000e8	0b f7		 or	 esi, edi
  000ea	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000ed	8b 75 fc	 mov	 esi, DWORD PTR _nodep$[ebp]
  000f0	89 0e		 mov	 DWORD PTR [esi], ecx
  000f2	89 10		 mov	 DWORD PTR [eax], edx
  000f4	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  000fa	3b f2		 cmp	 esi, edx
  000fc	75 23		 jne	 SHORT $LN260@rbt_remove
  000fe	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00100	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
$LN234@rbt_remove:
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	84 59 04	 test	 BYTE PTR [ecx+4], bl
  0010b	0f 84 83 00 00
	00		 je	 $LN233@rbt_remove
  00111	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  00114	c7 02 04 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ?tree@@3Urbtree_t@@A+4
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
$LN260@rbt_remove:
  00121	83 7e fc 00	 cmp	 DWORD PTR [esi-4], 0
  00125	7d 09		 jge	 SHORT $LN253@rbt_remove
  00127	8b 56 f8	 mov	 edx, DWORD PTR [esi-8]
  0012a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0012c	89 0a		 mov	 DWORD PTR [edx], ecx
  0012e	eb d6		 jmp	 SHORT $LN234@rbt_remove
$LN253@rbt_remove:
  00130	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  00133	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00136	23 d3		 and	 edx, ebx
  00138	0b 16		 or	 edx, DWORD PTR [esi]
  0013a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0013d	eb c7		 jmp	 SHORT $LN234@rbt_remove
$LN273@rbt_remove:
  0013f	8b 12		 mov	 edx, DWORD PTR [edx]
  00141	81 fa 04 00 00
	00		 cmp	 edx, OFFSET ?tree@@3Urbtree_t@@A+4
  00147	74 30		 je	 SHORT $LN249@rbt_remove
  00149	83 62 04 fe	 and	 DWORD PTR [edx+4], -2	; fffffffeH
$LN75@rbt_remove:
  0014d	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  00153	3b c1		 cmp	 eax, ecx
  00155	0f 85 1b 01 00
	00		 jne	 $LN245@rbt_remove
  0015b	89 15 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, edx
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	5b		 pop	 ebx
  00164	8b e5		 mov	 esp, ebp
  00166	5d		 pop	 ebp
  00167	c3		 ret	 0
$LN238@rbt_remove:
  00168	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0016b	23 cb		 and	 ecx, ebx
  0016d	0b ca		 or	 ecx, edx
  0016f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00172	5f		 pop	 edi
  00173	5e		 pop	 esi
  00174	5b		 pop	 ebx
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c3		 ret	 0
$LN249@rbt_remove:
  00179	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0017f	3b c2		 cmp	 eax, edx
  00181	75 83		 jne	 SHORT $LN234@rbt_remove
  00183	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, OFFSET ?tree@@3Urbtree_t@@A+4
  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5b		 pop	 ebx
  00190	8b e5		 mov	 esp, ebp
  00192	5d		 pop	 ebp
  00193	c3		 ret	 0
$LN233@rbt_remove:
  00194	c7 00 04 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ?tree@@3Urbtree_t@@A+4
  0019a	83 e8 08	 sub	 eax, 8
  0019d	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR _path$[ebp]
  001a3	3b c1		 cmp	 eax, ecx
  001a5	72 77		 jb	 SHORT $LN227@rbt_remove
$LN229@rbt_remove:
  001a7	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  001ab	8b 10		 mov	 edx, DWORD PTR [eax]
  001ad	7d 32		 jge	 SHORT $LN128@rbt_remove
  001af	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001b2	89 0a		 mov	 DWORD PTR [edx], ecx
  001b4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b7	84 cb		 test	 cl, bl
  001b9	75 75		 jne	 SHORT $LN293@rbt_remove
  001bb	83 e1 fe	 and	 ecx, -2			; fffffffeH
  001be	8b 31		 mov	 esi, DWORD PTR [ecx]
  001c0	84 5e 04	 test	 BYTE PTR [esi+4], bl
  001c3	0f 85 c3 00 00
	00		 jne	 $LN294@rbt_remove
  001c9	09 5a 04	 or	 DWORD PTR [edx+4], ebx
  001cc	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001cf	8b f1		 mov	 esi, ecx
  001d1	83 e6 fe	 and	 esi, -2			; fffffffeH
  001d4	23 cb		 and	 ecx, ebx
  001d6	0b 0e		 or	 ecx, DWORD PTR [esi]
  001d8	89 30		 mov	 DWORD PTR [eax], esi
  001da	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001dd	89 16		 mov	 DWORD PTR [esi], edx
  001df	eb 30		 jmp	 SHORT $LN1@rbt_remove
$LN128@rbt_remove:
  001e1	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001e4	23 cb		 and	 ecx, ebx
  001e6	0b 48 08	 or	 ecx, DWORD PTR [eax+8]
  001e9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  001ec	8b 32		 mov	 esi, DWORD PTR [edx]
  001ee	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  001f1	84 d3		 test	 dl, bl
  001f3	0f 85 ff 00 00
	00		 jne	 $LN295@rbt_remove
  001f9	84 cb		 test	 cl, bl
  001fb	0f 85 6d 01 00
	00		 jne	 $LN296@rbt_remove
  00201	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00203	84 59 04	 test	 BYTE PTR [ecx+4], bl
  00206	0f 85 c2 01 00
	00		 jne	 $LN297@rbt_remove
  0020c	0b d3		 or	 edx, ebx
  0020e	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN1@rbt_remove:
  00211	83 e8 08	 sub	 eax, 8
  00214	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  0021a	3b c2		 cmp	 eax, edx
  0021c	73 89		 jae	 SHORT $LN229@rbt_remove
$LN227@rbt_remove:
  0021e	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00224	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00229	5f		 pop	 edi
  0022a	5e		 pop	 esi
  0022b	5b		 pop	 ebx
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN293@rbt_remove:
  00230	8b ca		 mov	 ecx, edx
  00232	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00235	83 e2 fe	 and	 edx, -2			; fffffffeH
  00238	8b 32		 mov	 esi, DWORD PTR [edx]
  0023a	84 5e 04	 test	 BYTE PTR [esi+4], bl
  0023d	74 26		 je	 SHORT $LN195@rbt_remove
  0023f	83 61 04 fe	 and	 DWORD PTR [ecx+4], -2	; fffffffeH
  00243	8b 32		 mov	 esi, DWORD PTR [edx]
  00245	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00248	83 e7 fe	 and	 edi, -2			; fffffffeH
  0024b	89 3a		 mov	 DWORD PTR [edx], edi
  0024d	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00250	23 fb		 and	 edi, ebx
  00252	0b fa		 or	 edi, edx
  00254	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00257	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0025a	23 d3		 and	 edx, ebx
  0025c	0b d6		 or	 edx, esi
  0025e	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00261	8b f2		 mov	 esi, edx
  00263	eb 03		 jmp	 SHORT $LN304@rbt_remove
$LN195@rbt_remove:
  00265	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
$LN304@rbt_remove:
  00268	8b d6		 mov	 edx, esi
  0026a	83 e2 fe	 and	 edx, -2			; fffffffeH
  0026d	23 f3		 and	 esi, ebx
  0026f	0b 32		 or	 esi, DWORD PTR [edx]
  00271	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00274	89 0a		 mov	 DWORD PTR [edx], ecx
$LN245@rbt_remove:
  00276	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  0027a	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  0027d	0f 8d e5 fe ff
	ff		 jge	 $LN238@rbt_remove
  00283	89 10		 mov	 DWORD PTR [eax], edx
  00285	5f		 pop	 edi
  00286	5e		 pop	 esi
  00287	5b		 pop	 ebx
  00288	8b e5		 mov	 esp, ebp
  0028a	5d		 pop	 ebp
  0028b	c3		 ret	 0
$LN294@rbt_remove:
  0028c	83 66 04 fe	 and	 DWORD PTR [esi+4], -2	; fffffffeH
  00290	8b 31		 mov	 esi, DWORD PTR [ecx]
  00292	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00295	83 e2 fe	 and	 edx, -2			; fffffffeH
  00298	89 11		 mov	 DWORD PTR [ecx], edx
  0029a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0029d	23 d3		 and	 edx, ebx
  0029f	0b d1		 or	 edx, ecx
  002a1	89 56 04	 mov	 DWORD PTR [esi+4], edx
  002a4	8b 10		 mov	 edx, DWORD PTR [eax]
  002a6	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002a9	23 cb		 and	 ecx, ebx
  002ab	0b ce		 or	 ecx, esi
  002ad	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002b0	8b f1		 mov	 esi, ecx
  002b2	83 e6 fe	 and	 esi, -2			; fffffffeH
  002b5	23 cb		 and	 ecx, ebx
  002b7	0b 0e		 or	 ecx, DWORD PTR [esi]
  002b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  002bc	89 16		 mov	 DWORD PTR [esi], edx
  002be	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  002c4	3b c2		 cmp	 eax, edx
  002c6	75 0d		 jne	 SHORT $LN152@rbt_remove
  002c8	89 35 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, esi
  002ce	5f		 pop	 edi
  002cf	5e		 pop	 esi
  002d0	5b		 pop	 ebx
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	c3		 ret	 0
$LN152@rbt_remove:
  002d5	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  002d9	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  002dc	7d 09		 jge	 SHORT $LN145@rbt_remove
  002de	89 30		 mov	 DWORD PTR [eax], esi
  002e0	5f		 pop	 edi
  002e1	5e		 pop	 esi
  002e2	5b		 pop	 ebx
  002e3	8b e5		 mov	 esp, ebp
  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
$LN145@rbt_remove:
  002e7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002ea	23 cb		 and	 ecx, ebx
  002ec	0b ce		 or	 ecx, esi
  002ee	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002f1	5f		 pop	 edi
  002f2	5e		 pop	 esi
  002f3	5b		 pop	 ebx
  002f4	8b e5		 mov	 esp, ebp
  002f6	5d		 pop	 ebp
  002f7	c3		 ret	 0
$LN295@rbt_remove:
  002f8	8b f2		 mov	 esi, edx
  002fa	83 e6 fe	 and	 esi, -2			; fffffffeH
  002fd	8b 16		 mov	 edx, DWORD PTR [esi]
  002ff	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00302	84 cb		 test	 cl, bl
  00304	74 4e		 je	 SHORT $LN89@rbt_remove
  00306	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00309	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0030c	8b 10		 mov	 edx, DWORD PTR [eax]
  0030e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00310	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00313	83 e6 fe	 and	 esi, -2			; fffffffeH
  00316	89 32		 mov	 DWORD PTR [edx], esi
  00318	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0031b	23 f3		 and	 esi, ebx
  0031d	0b f2		 or	 esi, edx
  0031f	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00322	8b 32		 mov	 esi, DWORD PTR [edx]
  00324	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00327	83 e7 fe	 and	 edi, -2			; fffffffeH
  0032a	89 3a		 mov	 DWORD PTR [edx], edi
  0032c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0032f	23 fb		 and	 edi, ebx
  00331	0b fa		 or	 edi, edx
  00333	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00336	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00339	23 d3		 and	 edx, ebx
  0033b	0b d6		 or	 edx, esi
  0033d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00340	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00343	83 e2 fe	 and	 edx, -2			; fffffffeH
  00346	23 f3		 and	 esi, ebx
  00348	0b 32		 or	 esi, DWORD PTR [edx]
  0034a	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0034d	89 0a		 mov	 DWORD PTR [edx], ecx
  0034f	e9 f9 fd ff ff	 jmp	 $LN75@rbt_remove
$LN89@rbt_remove:
  00354	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  00357	8b 08		 mov	 ecx, DWORD PTR [eax]
  00359	8b 11		 mov	 edx, DWORD PTR [ecx]
  0035b	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0035e	83 e6 fe	 and	 esi, -2			; fffffffeH
  00361	89 31		 mov	 DWORD PTR [ecx], esi
  00363	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00366	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00369	e9 df fd ff ff	 jmp	 $LN75@rbt_remove
$LN296@rbt_remove:
  0036e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00370	84 5f 04	 test	 BYTE PTR [edi+4], bl
  00373	74 49		 je	 SHORT $LN34@rbt_remove
  00375	8b 10		 mov	 edx, DWORD PTR [eax]
  00377	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0037a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0037d	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  00380	83 67 04 fe	 and	 DWORD PTR [edi+4], -2	; fffffffeH
  00384	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00386	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00389	83 e6 fe	 and	 esi, -2			; fffffffeH
  0038c	89 32		 mov	 DWORD PTR [edx], esi
  0038e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00391	23 f3		 and	 esi, ebx
  00393	0b f2		 or	 esi, edx
  00395	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00399	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0039c	7d 0c		 jge	 SHORT $LN38@rbt_remove
  0039e	8b 50 f8	 mov	 edx, DWORD PTR [eax-8]
  003a1	89 0a		 mov	 DWORD PTR [edx], ecx
  003a3	5f		 pop	 edi
  003a4	5e		 pop	 esi
  003a5	5b		 pop	 ebx
  003a6	8b e5		 mov	 esp, ebp
  003a8	5d		 pop	 ebp
  003a9	c3		 ret	 0
$LN38@rbt_remove:
  003aa	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
$LN7@rbt_remove:
  003ad	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b0	23 d3		 and	 edx, ebx
  003b2	0b d1		 or	 edx, ecx
  003b4	89 50 04	 mov	 DWORD PTR [eax+4], edx
  003b7	5f		 pop	 edi
  003b8	5e		 pop	 esi
  003b9	5b		 pop	 ebx
  003ba	8b e5		 mov	 esp, ebp
  003bc	5d		 pop	 ebp
  003bd	c3		 ret	 0
$LN34@rbt_remove:
  003be	8b 00		 mov	 eax, DWORD PTR [eax]
  003c0	09 5e 04	 or	 DWORD PTR [esi+4], ebx
  003c3	83 60 04 fe	 and	 DWORD PTR [eax+4], -2	; fffffffeH
  003c7	5f		 pop	 edi
  003c8	5e		 pop	 esi
  003c9	5b		 pop	 ebx
  003ca	8b e5		 mov	 esp, ebp
  003cc	5d		 pop	 ebp
  003cd	c3		 ret	 0
$LN297@rbt_remove:
  003ce	83 61 04 fe	 and	 DWORD PTR [ecx+4], -2	; fffffffeH
  003d2	8b 10		 mov	 edx, DWORD PTR [eax]
  003d4	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003d6	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  003d9	83 e6 fe	 and	 esi, -2			; fffffffeH
  003dc	89 32		 mov	 DWORD PTR [edx], esi
  003de	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  003e1	23 f3		 and	 esi, ebx
  003e3	0b f2		 or	 esi, edx
  003e5	8d 95 f8 fd ff
	ff		 lea	 edx, DWORD PTR _path$[ebp]
  003eb	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  003ee	3b c2		 cmp	 eax, edx
  003f0	75 0d		 jne	 SHORT $LN14@rbt_remove
  003f2	89 0d 00 00 00
	00		 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, ecx
  003f8	5f		 pop	 edi
  003f9	5e		 pop	 esi
  003fa	5b		 pop	 ebx
  003fb	8b e5		 mov	 esp, ebp
  003fd	5d		 pop	 ebp
  003fe	c3		 ret	 0
$LN14@rbt_remove:
  003ff	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00403	8b 40 f8	 mov	 eax, DWORD PTR [eax-8]
  00406	7d a5		 jge	 SHORT $LN7@rbt_remove
  00408	5f		 pop	 edi
  00409	5e		 pop	 esi
  0040a	89 08		 mov	 DWORD PTR [eax], ecx
  0040c	5b		 pop	 ebx
  0040d	8b e5		 mov	 esp, ebp
  0040f	5d		 pop	 ebp
  00410	c3		 ret	 0
?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ENDP	; rbt_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z
_TEXT	SEGMENT
_path$ = -512						; size = 512
?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z PROC	; rbt_insert, COMDAT
; _node$ = eax

; 295  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	b8 04 00 00 00	 mov	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00013	83 c8 01	 or	 eax, 1
  00016	c7 07 04 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ?tree@@3Urbtree_t@@A+4
  0001c	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00024	89 85 00 fe ff
	ff		 mov	 DWORD PTR _path$[ebp], eax
  0002a	8d b5 00 fe ff
	ff		 lea	 esi, DWORD PTR _path$[ebp]
  00030	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00035	74 41		 je	 SHORT $LN60@rbt_insert
  00037	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL62@rbt_insert:
  00040	8b 16		 mov	 edx, DWORD PTR [esi]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	3b c8		 cmp	 ecx, eax
  00047	7d 05		 jge	 SHORT $LN78@rbt_insert
  00049	83 c8 ff	 or	 eax, -1
  0004c	eb 09		 jmp	 SHORT $LN77@rbt_insert
$LN78@rbt_insert:
  0004e	33 d2		 xor	 edx, edx
  00050	3b c8		 cmp	 ecx, eax
  00052	0f 9f c2	 setg	 dl
  00055	8b c2		 mov	 eax, edx
$LN77@rbt_insert:
  00057	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005a	85 c0		 test	 eax, eax
  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	79 04		 jns	 SHORT $LN59@rbt_insert
  00060	8b 10		 mov	 edx, DWORD PTR [eax]
  00062	eb 06		 jmp	 SHORT $LN86@rbt_insert
$LN59@rbt_insert:
  00064	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00067	83 e2 fe	 and	 edx, -2			; fffffffeH
$LN86@rbt_insert:
  0006a	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0006d	83 c6 08	 add	 esi, 8
  00070	81 3e 04 00 00
	00		 cmp	 DWORD PTR [esi], OFFSET ?tree@@3Urbtree_t@@A+4
  00076	75 c8		 jne	 SHORT $LL62@rbt_insert
$LN60@rbt_insert:
  00078	89 3e		 mov	 DWORD PTR [esi], edi
  0007a	83 ee 08	 sub	 esi, 8
  0007d	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00083	3b f0		 cmp	 esi, eax
  00085	0f 82 a1 00 00
	00		 jb	 $LN55@rbt_insert
$LN57@rbt_insert:
  0008b	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  0008f	8b 06		 mov	 eax, DWORD PTR [esi]
  00091	7d 36		 jge	 SHORT $LN54@rbt_insert
  00093	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00096	89 08		 mov	 DWORD PTR [eax], ecx
  00098	f6 41 04 01	 test	 BYTE PTR [ecx+4], 1
  0009c	0f 84 99 00 00
	00		 je	 $LN1@rbt_insert
  000a2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a7	f6 c1 01	 test	 cl, 1
  000aa	74 6d		 je	 SHORT $LN20@rbt_insert
  000ac	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000af	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b7	83 e2 fe	 and	 edx, -2			; fffffffeH
  000ba	89 10		 mov	 DWORD PTR [eax], edx
  000bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bf	83 e2 01	 and	 edx, 1
  000c2	0b d0		 or	 edx, eax
  000c4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000c7	eb 4e		 jmp	 SHORT $LN87@rbt_insert
$LN54@rbt_insert:
  000c9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cc	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  000cf	83 e1 01	 and	 ecx, 1
  000d2	0b cf		 or	 ecx, edi
  000d4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000d7	f6 47 04 01	 test	 BYTE PTR [edi+4], 1
  000db	74 5e		 je	 SHORT $LN1@rbt_insert
  000dd	8b 18		 mov	 ebx, DWORD PTR [eax]
  000df	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  000e2	f6 c2 01	 test	 dl, 1
  000e5	74 10		 je	 SHORT $LN30@rbt_insert
  000e7	83 e2 fe	 and	 edx, -2			; fffffffeH
  000ea	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000ed	83 67 04 fe	 and	 DWORD PTR [edi+4], -2	; fffffffeH
  000f1	83 48 04 01	 or	 DWORD PTR [eax+4], 1
  000f5	eb 22		 jmp	 SHORT $LN20@rbt_insert
$LN30@rbt_insert:
  000f7	8b d1		 mov	 edx, ecx
  000f9	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000fc	8b 39		 mov	 edi, DWORD PTR [ecx]
  000fe	83 e2 01	 and	 edx, 1
  00101	0b fa		 or	 edi, edx
  00103	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00106	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00109	83 e7 fe	 and	 edi, -2			; fffffffeH
  0010c	0b fa		 or	 edi, edx
  0010e	89 01		 mov	 DWORD PTR [ecx], eax
  00110	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00113	83 48 04 01	 or	 DWORD PTR [eax+4], 1
$LN87@rbt_insert:
  00117	8b c1		 mov	 eax, ecx
$LN20@rbt_insert:
  00119	89 06		 mov	 DWORD PTR [esi], eax
  0011b	83 ee 08	 sub	 esi, 8
  0011e	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00124	3b f0		 cmp	 esi, eax
  00126	0f 83 5f ff ff
	ff		 jae	 $LN57@rbt_insert
$LN55@rbt_insert:
  0012c	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR _path$[ebp]
  00132	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00137	83 60 04 fe	 and	 DWORD PTR [eax+4], -2	; fffffffeH
$LN1@rbt_insert:
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx
  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ENDP	; rbt_insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z
_TEXT	SEGMENT
?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z PROC	; rbt_search, COMDAT
; _key$ = ecx

; 295  : rb_gen(static, rbt_, rbtree_t, struct rbt_object, link, rbt_compare)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00005	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  0000a	74 28		 je	 SHORT $LN15@rbt_search
  0000c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000f	90		 npad	 1
$LL5@rbt_search:
  00010	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00013	3b d1		 cmp	 edx, ecx
  00015	7c 12		 jl	 SHORT $LN14@rbt_search
  00017	7e 14		 jle	 SHORT $LN8@rbt_search
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	83 e0 fe	 and	 eax, -2			; fffffffeH
$LN2@rbt_search:
  0001f	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00024	75 ea		 jne	 SHORT $LL5@rbt_search
  00026	33 c0		 xor	 eax, eax
  00028	c3		 ret	 0
$LN14@rbt_search:
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	eb f2		 jmp	 SHORT $LN2@rbt_search
$LN8@rbt_search:
  0002d	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00032	75 02		 jne	 SHORT $LN1@rbt_search
$LN15@rbt_search:
  00034	33 c0		 xor	 eax, eax
$LN1@rbt_search:
  00036	c3		 ret	 0
?rbt_search@@YAPAUrbt_object@@PAUrbtree_t@@PAU1@@Z ENDP	; rbt_search
_TEXT	ENDS
PUBLIC	?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z		; judy_splitspan
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z
_TEXT	SEGMENT
_node$ = -4						; size = 4
_judy$ = 8						; size = 4
_cnt$ = 12						; size = 4
_next$ = 12						; size = 4
?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z PROC		; judy_splitspan, COMDAT
; _base$ = edi

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1263 : JudySlot *node = (JudySlot *)(base + JudySize[JUDY_span]);

  00004	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  00009	53		 push	 ebx
  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _next$[ebp]
  0000d	03 c7		 add	 eax, edi
  0000f	56		 push	 esi
  00010	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 1264 : uint cnt = JUDY_span_bytes;

  00013	c7 45 0c 1c 00
	00 00		 mov	 DWORD PTR _cnt$[ebp], 28 ; 0000001cH

; 1265 : uchar *newbase;
; 1266 : uint off = 0;

  0001a	33 f6		 xor	 esi, esi
  0001c	8d 64 24 00	 npad	 4
$LL6@judy_split:

; 1267 : #if BYTE_ORDER != BIG_ENDIAN
; 1268 : int i;
; 1269 : #endif
; 1270 : 
; 1271 : 	do {
; 1272 : 		newbase = (uchar*)judy_alloc (judy, JUDY_1);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00023	51		 push	 ecx
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1273 : 		*next = (JudySlot)newbase | JUDY_1;

  0002e	8b d0		 mov	 edx, eax
  00030	83 c4 04	 add	 esp, 4
  00033	83 ca 01	 or	 edx, 1
  00036	89 13		 mov	 DWORD PTR [ebx], edx

; 1274 : 
; 1275 : #if BYTE_ORDER != BIG_ENDIAN
; 1276 : 		i = JUDY_key_size;

  00038	b9 04 00 00 00	 mov	 ecx, 4
  0003d	8d 49 00	 npad	 3
$LL3@judy_split:

; 1277 : 		while( i-- )

  00040	49		 dec	 ecx

; 1278 : 			*newbase++ = base[off + i];

  00041	8d 14 31	 lea	 edx, DWORD PTR [ecx+esi]
  00044	8a 14 3a	 mov	 dl, BYTE PTR [edx+edi]
  00047	88 10		 mov	 BYTE PTR [eax], dl
  00049	40		 inc	 eax
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 f2		 jne	 SHORT $LL3@judy_split

; 1279 : #else
; 1280 : 		memcpy (newbase, base + off, JUDY_key_size);
; 1281 : 		newbase += JUDY_key_size;
; 1282 : #endif
; 1283 : 		next = (JudySlot *)newbase;
; 1284 : 
; 1285 : 		off += JUDY_key_size;

  0004e	83 c6 04	 add	 esi, 4

; 1286 : 		cnt -= JUDY_key_size;

  00051	83 6d 0c 04	 sub	 DWORD PTR _cnt$[ebp], 4
  00055	8b d8		 mov	 ebx, eax

; 1287 : 	} while( cnt && base[off - 1] );

  00057	74 06		 je	 SHORT $LN1@judy_split
  00059	38 4c 3e ff	 cmp	 BYTE PTR [esi+edi-1], cl
  0005d	75 c1		 jne	 SHORT $LL6@judy_split
$LN1@judy_split:

; 1288 : 
; 1289 : 	*next = node[-1];

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _node$[ebp]
  00062	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00065	89 10		 mov	 DWORD PTR [eax], edx

; 1290 : 	judy_free (judy, base, JUDY_span);

  00067	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  0006a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0006d	5e		 pop	 esi
  0006e	89 0f		 mov	 DWORD PTR [edi], ecx
  00070	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00073	5b		 pop	 ebx

; 1291 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z ENDP		; judy_splitspan
_TEXT	ENDS
PUBLIC	?judy_prv@@YAPAIPAUJudy@@@Z			; judy_prv
; Function compile flags: /Ogtp
;	COMDAT ?judy_prv@@YAPAIPAUJudy@@@Z
_TEXT	SEGMENT
_node$ = -12						; size = 4
_depth$ = -8						; size = 4
_off$ = -4						; size = 4
?judy_prv@@YAPAIPAUJudy@@@Z PROC			; judy_prv, COMDAT
; _judy$ = ecx

; 1074 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1075 : int slot, size, keysize;
; 1076 : JudySlot *table, *inner;
; 1077 : JudySlot *node, next;
; 1078 : uchar *base;
; 1079 : uint depth;
; 1080 : uint off;
; 1081 : 
; 1082 : 	if( !judy->level )

  00006	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0000a	75 12		 jne	 SHORT $LN42@judy_prv

; 1083 : 		return judy_last (judy, *judy->root, 0, 0);

  0000c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  00017	83 c4 08	 add	 esp, 8

; 1148 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN42@judy_prv:
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
$LL22@judy_prv:

; 1086 : 		next = judy->stack[judy->level].next;

  00021	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  00024	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  00027	8b 74 81 34	 mov	 esi, DWORD PTR [ecx+eax*4+52]
  0002b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1087 : 		slot = judy->stack[judy->level].slot;
; 1088 : 		off = judy->stack[judy->level].off;

  0002e	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 1089 : 		size = JudySize[next & 0x07];
; 1090 : 		depth = off / JUDY_key_size;

  00031	8b d8		 mov	 ebx, eax
  00033	89 45 fc	 mov	 DWORD PTR _off$[ebp], eax

; 1091 : 
; 1092 : 		switch( next & 0x07 ) {

  00036	8b c6		 mov	 eax, esi
  00038	c1 eb 02	 shr	 ebx, 2
  0003b	83 e0 07	 and	 eax, 7
  0003e	8d 54 7f 0f	 lea	 edx, DWORD PTR [edi+edi*2+15]
  00042	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00045	89 5d f8	 mov	 DWORD PTR _depth$[ebp], ebx
  00048	83 f8 07	 cmp	 eax, 7
  0004b	77 2c		 ja	 SHORT $LN41@judy_prv
  0004d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN49@judy_prv[eax*4]
$LN18@judy_prv:

; 1093 : 		case JUDY_1:
; 1094 : 		case JUDY_2:
; 1095 : 		case JUDY_4:
; 1096 : 		case JUDY_8:
; 1097 : 		case JUDY_16:
; 1098 : 		case JUDY_32:
; 1099 : #ifdef ASKITIS
; 1100 : 		case JUDY_64:
; 1101 : #endif
; 1102 : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00054	8b de		 mov	 ebx, esi
  00056	83 e3 f8	 and	 ebx, -8			; fffffff8H
  00059	03 1c 85 00 00
	00 00		 add	 ebx, DWORD PTR ?JudySize@@3PAHA[eax*4]
  00060	89 5d f4	 mov	 DWORD PTR _node$[ebp], ebx

; 1103 : 			if( !slot || !node[-slot] ) {

  00063	85 d2		 test	 edx, edx
  00065	74 0e		 je	 SHORT $LN1@judy_prv
  00067	8d 04 95 00 00
	00 00		 lea	 eax, DWORD PTR [edx*4]
  0006e	2b d8		 sub	 ebx, eax
  00070	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00073	75 5a		 jne	 SHORT $LN17@judy_prv
$LN1@judy_prv:

; 1139 : 
; 1140 : #ifndef ASKITIS
; 1141 : 		case JUDY_span:
; 1142 : 			judy->level--;

  00075	4f		 dec	 edi
  00076	89 79 28	 mov	 DWORD PTR [ecx+40], edi
$LN41@judy_prv:

; 1084 : 	
; 1085 : 	while( judy->level ) {

  00079	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  0007d	75 a2		 jne	 SHORT $LL22@judy_prv

; 1143 : 			continue;
; 1144 : #endif
; 1145 : 		}
; 1146 : 	}
; 1147 : 	return NULL;

  0007f	33 c0		 xor	 eax, eax
$LN44@judy_prv:
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 1148 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN12@judy_prv:

; 1119 : 
; 1120 : 		case JUDY_radix:
; 1121 : 			table = (JudySlot *)(next & JUDY_mask);

  00088	83 e6 f8	 and	 esi, -8			; fffffff8H

; 1122 : 
; 1123 : 			if( judy->depth )

  0008b	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  0008f	74 09		 je	 SHORT $LN38@judy_prv

; 1124 : 			  if( !((off + 1) & JUDY_key_mask) )

  00091	8b 45 fc	 mov	 eax, DWORD PTR _off$[ebp]
  00094	40		 inc	 eax
  00095	a8 03		 test	 al, 3
  00097	75 01		 jne	 SHORT $LN38@judy_prv

; 1125 : 				depth++;

  00099	43		 inc	 ebx
$LN38@judy_prv:

; 1126 : 
; 1127 : 			while( slot-- ) {

  0009a	85 d2		 test	 edx, edx
  0009c	74 2c		 je	 SHORT $LN40@judy_prv
  0009e	8b ff		 npad	 2
$LL9@judy_prv:

; 1128 : 			  judy->stack[judy->level].slot--;

  000a0	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  000a3	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000a7	ff 0c 81	 dec	 DWORD PTR [ecx+eax*4]
  000aa	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000ad	4a		 dec	 edx

; 1129 : 			  if( (inner = (JudySlot *)(table[slot >> 4] & JUDY_mask)) )

  000ae	8b c2		 mov	 eax, edx
  000b0	c1 f8 04	 sar	 eax, 4
  000b3	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  000b6	83 e0 f8	 and	 eax, -8			; fffffff8H
  000b9	74 0b		 je	 SHORT $LN2@judy_prv

; 1130 : 				if( inner[slot & 0x0F] )

  000bb	8b fa		 mov	 edi, edx
  000bd	83 e7 0f	 and	 edi, 15			; 0000000fH
  000c0	83 3c b8 00	 cmp	 DWORD PTR [eax+edi*4], 0
  000c4	75 7c		 jne	 SHORT $LN31@judy_prv
$LN2@judy_prv:

; 1126 : 
; 1127 : 			while( slot-- ) {

  000c6	85 d2		 test	 edx, edx
  000c8	75 d6		 jne	 SHORT $LL9@judy_prv
$LN40@judy_prv:

; 1135 : 			}
; 1136 : 
; 1137 : 			judy->level--;

  000ca	ff 49 28	 dec	 DWORD PTR [ecx+40]

; 1138 : 			continue;

  000cd	eb aa		 jmp	 SHORT $LN41@judy_prv
$LN17@judy_prv:

; 1104 : 				judy->level--;
; 1105 : 				continue;
; 1106 : 			}
; 1107 : 
; 1108 : 			base = (uchar *)(next & JUDY_mask);
; 1109 : 			judy->stack[judy->level].slot--;

  000cf	8b c7		 mov	 eax, edi
  000d1	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  000d5	ff 0c 81	 dec	 DWORD PTR [ecx+eax*4]
  000d8	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1111 : 
; 1112 : #if BYTE_ORDER != BIG_ENDIAN
; 1113 : 			if( !judy->depth && !base[(slot - 1) * keysize] || judy->depth && ++depth == judy->depth )

  000db	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  000de	85 c0		 test	 eax, eax
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _off$[ebp]
  000e3	75 1b		 jne	 SHORT $LN37@judy_prv

; 1110 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  000e5	8b f8		 mov	 edi, eax
  000e7	83 e7 03	 and	 edi, 3
  000ea	bb 04 00 00 00	 mov	 ebx, 4
  000ef	2b df		 sub	 ebx, edi

; 1111 : 
; 1112 : #if BYTE_ORDER != BIG_ENDIAN
; 1113 : 			if( !judy->depth && !base[(slot - 1) * keysize] || judy->depth && ++depth == judy->depth )

  000f1	8d 7a ff	 lea	 edi, DWORD PTR [edx-1]
  000f4	0f af df	 imul	 ebx, edi
  000f7	83 e6 f8	 and	 esi, -8			; fffffff8H
  000fa	80 3c 33 00	 cmp	 BYTE PTR [ebx+esi], 0
  000fe	74 0f		 je	 SHORT $LN14@judy_prv
$LN37@judy_prv:
  00100	8b 79 30	 mov	 edi, DWORD PTR [ecx+48]
  00103	8b 75 f8	 mov	 esi, DWORD PTR _depth$[ebp]
  00106	85 ff		 test	 edi, edi
  00108	74 18		 je	 SHORT $LN15@judy_prv
  0010a	46		 inc	 esi
  0010b	3b f7		 cmp	 esi, edi
  0010d	75 13		 jne	 SHORT $LN15@judy_prv
$LN14@judy_prv:

; 1114 : #else
; 1115 : 			if( !judy->depth && !base[(slot - 1) * keysize + keysize - 1] || judy->depth && ++depth == judy->depth )
; 1116 : #endif
; 1117 : 				return &node[-slot];

  0010f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00112	5f		 pop	 edi
  00113	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  0011a	5e		 pop	 esi
  0011b	2b c1		 sub	 eax, ecx
  0011d	5b		 pop	 ebx

; 1148 : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c3		 ret	 0
$LN15@judy_prv:

; 1118 : 			return judy_last (judy, node[-slot], (off | JUDY_key_mask) + 1, depth);

  00122	83 c8 03	 or	 eax, 3
  00125	40		 inc	 eax
  00126	56		 push	 esi
  00127	50		 push	 eax
  00128	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0012b	03 d2		 add	 edx, edx
  0012d	03 d2		 add	 edx, edx
  0012f	2b c2		 sub	 eax, edx
  00131	8b 00		 mov	 eax, DWORD PTR [eax]
  00133	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  00138	83 c4 08	 add	 esp, 8
  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	5b		 pop	 ebx

; 1148 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN31@judy_prv:

; 1131 : 				  if( !judy->depth && !slot || judy->depth && depth == judy->depth )

  00142	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00145	85 f6		 test	 esi, esi
  00147	75 0c		 jne	 SHORT $LN48@judy_prv
  00149	85 d2		 test	 edx, edx
  0014b	0f 84 30 ff ff
	ff		 je	 $LN44@judy_prv
  00151	85 f6		 test	 esi, esi
  00153	74 08		 je	 SHORT $LN5@judy_prv
$LN48@judy_prv:
  00155	3b de		 cmp	 ebx, esi

; 1132 : 					return &inner[0];

  00157	0f 84 24 ff ff
	ff		 je	 $LN44@judy_prv
$LN5@judy_prv:

; 1133 : 				  else
; 1134 : 				    return judy_last(judy, inner[slot & 0x0F], off + 1, depth);

  0015d	8b 75 fc	 mov	 esi, DWORD PTR _off$[ebp]
  00160	83 e2 0f	 and	 edx, 15			; 0000000fH
  00163	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00166	53		 push	 ebx
  00167	46		 inc	 esi
  00168	56		 push	 esi
  00169	e8 00 00 00 00	 call	 ?judy_last@@YAPAIPAUJudy@@III@Z ; judy_last
  0016e	83 c4 08	 add	 esp, 8
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 1148 : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
$LN49@judy_prv:
  00178	00 00 00 00	 DD	 $LN12@judy_prv
  0017c	00 00 00 00	 DD	 $LN18@judy_prv
  00180	00 00 00 00	 DD	 $LN18@judy_prv
  00184	00 00 00 00	 DD	 $LN18@judy_prv
  00188	00 00 00 00	 DD	 $LN18@judy_prv
  0018c	00 00 00 00	 DD	 $LN18@judy_prv
  00190	00 00 00 00	 DD	 $LN18@judy_prv
  00194	00 00 00 00	 DD	 $LN1@judy_prv
?judy_prv@@YAPAIPAUJudy@@@Z ENDP			; judy_prv
_TEXT	ENDS
PUBLIC	?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z		; judy_radix
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z
_TEXT	SEGMENT
_base$ = -20						; size = 4
tv526 = -16						; size = 4
tv257 = -16						; size = 4
_cnt$ = -12						; size = 4
_oldnode$ = -8						; size = 4
tv524 = -4						; size = 4
_table$ = -4						; size = 4
tv449 = 8						; size = 4
_judy$ = 8						; size = 4
_old$ = 12						; size = 4
tv588 = 16						; size = 4
_start$ = 16						; size = 4
tv520 = 20						; size = 4
_size$ = 20						; size = 4
_key$ = 20						; size = 1
_depth$ = 24						; size = 4
?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z PROC		; judy_radix, COMDAT
; _radix$ = edx
; _slot$ = eax
; _keysize$ = edi

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 728  : int size, idx, cnt = slot - start, newcnt;

  00006	2b 45 10	 sub	 eax, DWORD PTR _start$[ebp]

; 729  : JudySlot *node, *oldnode;
; 730  : uint type = JUDY_1 - 1;
; 731  : JudySlot *table;
; 732  : uchar *base;
; 733  : 
; 734  : 	//	if necessary, setup inner radix node
; 735  : 
; 736  : 	if( !(table = (JudySlot *)(radix[key >> 4] & JUDY_mask)) ) {

  00009	0f b6 4d 14	 movzx	 ecx, BYTE PTR _key$[ebp]
  0000d	89 45 f4	 mov	 DWORD PTR _cnt$[ebp], eax
  00010	53		 push	 ebx
  00011	8b c1		 mov	 eax, ecx
  00013	c1 e8 04	 shr	 eax, 4
  00016	56		 push	 esi
  00017	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]
  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	33 db		 xor	 ebx, ebx
  0001e	83 e0 f8	 and	 eax, -8			; fffffff8H
  00021	89 4d f0	 mov	 DWORD PTR tv257[ebp], ecx
  00024	89 45 fc	 mov	 DWORD PTR _table$[ebp], eax
  00027	75 16		 jne	 SHORT $LN18@judy_radix

; 737  : 		table = (JudySlot*)judy_alloc (judy, JUDY_radix);

  00029	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  0002c	50		 push	 eax
  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 738  : 		radix[key >> 4] = (JudySlot)table | JUDY_radix;

  00034	8b 4d f0	 mov	 ecx, DWORD PTR tv257[ebp]
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 fc	 mov	 DWORD PTR _table$[ebp], eax
  0003d	89 06		 mov	 DWORD PTR [esi], eax
$LN18@judy_radix:

; 739  : 	}
; 740  : 
; 741  : 	oldnode = (JudySlot *)(old + JudySize[JUDY_max]);

  0003f	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+24

; 742  : 
; 743  : 	// is this slot a leaf?
; 744  : 
; 745  : 	if( !judy->depth && (!key || !keysize) || judy->depth && !keysize && depth == judy->depth) {

  00045	8b 75 08	 mov	 esi, DWORD PTR _judy$[ebp]
  00048	03 55 0c	 add	 edx, DWORD PTR _old$[ebp]
  0004b	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  0004e	89 55 f8	 mov	 DWORD PTR _oldnode$[ebp], edx
  00051	85 f6		 test	 esi, esi
  00053	75 0d		 jne	 SHORT $LN21@judy_radix
  00055	38 5d 14	 cmp	 BYTE PTR _key$[ebp], bl
  00058	74 11		 je	 SHORT $LN9@judy_radix
  0005a	85 ff		 test	 edi, edi
  0005c	74 0d		 je	 SHORT $LN9@judy_radix
  0005e	85 f6		 test	 esi, esi
  00060	74 23		 je	 SHORT $LN14@judy_radix
$LN21@judy_radix:
  00062	85 ff		 test	 edi, edi
  00064	75 1f		 jne	 SHORT $LN14@judy_radix
  00066	39 75 18	 cmp	 DWORD PTR _depth$[ebp], esi
  00069	75 1a		 jne	 SHORT $LN14@judy_radix
$LN9@judy_radix:

; 746  : 		table[key & 0x0F] = oldnode[-start-1];

  0006b	8b 75 10	 mov	 esi, DWORD PTR _start$[ebp]
  0006e	8d 34 b5 04 00
	00 00		 lea	 esi, DWORD PTR [esi*4+4]
  00075	2b d6		 sub	 edx, esi
  00077	8b 12		 mov	 edx, DWORD PTR [edx]
  00079	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0007c	5e		 pop	 esi
  0007d	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00080	5b		 pop	 ebx

; 774  : 	}
; 775  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN14@judy_radix:
  00085	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00088	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL7@judy_radix:

; 747  : 		return;
; 748  : 	}
; 749  : 
; 750  : 	//	calculate new node big enough to contain slots
; 751  : 
; 752  : 	do {
; 753  : 		type++;
; 754  : 		size = JudySize[type];

  00090	8b 04 9d 04 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[ebx*4+4]
  00097	43		 inc	 ebx

; 755  : 		newcnt = size / (sizeof(JudySlot) + keysize);

  00098	33 d2		 xor	 edx, edx
  0009a	89 45 14	 mov	 DWORD PTR _size$[ebp], eax
  0009d	f7 f1		 div	 ecx
  0009f	8b f0		 mov	 esi, eax

; 756  : 	} while( cnt > newcnt && type < JUDY_max );

  000a1	39 75 f4	 cmp	 DWORD PTR _cnt$[ebp], esi
  000a4	7e 05		 jle	 SHORT $LN4@judy_radix
  000a6	83 fb 06	 cmp	 ebx, 6
  000a9	72 e5		 jb	 SHORT $LL7@judy_radix
$LN4@judy_radix:

; 757  : 
; 758  : 	//	store new node pointer in inner table
; 759  : 
; 760  : 	base = (uchar*)judy_alloc (judy, type);

  000ab	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  000ae	50		 push	 eax
  000af	8b cb		 mov	 ecx, ebx
  000b1	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 761  : 	node = (JudySlot *)(base + size);

  000b6	8b 4d 14	 mov	 ecx, DWORD PTR _size$[ebp]
  000b9	03 c8		 add	 ecx, eax

; 762  : 	table[key & 0x0F] = (JudySlot)base | type;

  000bb	8b d0		 mov	 edx, eax
  000bd	89 45 ec	 mov	 DWORD PTR _base$[ebp], eax
  000c0	8b 45 f0	 mov	 eax, DWORD PTR tv257[ebp]
  000c3	0b d3		 or	 edx, ebx
  000c5	8b 5d fc	 mov	 ebx, DWORD PTR _table$[ebp]
  000c8	83 e0 0f	 and	 eax, 15			; 0000000fH
  000cb	89 14 83	 mov	 DWORD PTR [ebx+eax*4], edx

; 763  : 
; 764  : 	//	allocate node and copy old contents
; 765  : 	//	shorten keys by 1 byte during copy
; 766  : 
; 767  : 	for( idx = 0; idx < cnt; idx++ ) {

  000ce	8b 5d f4	 mov	 ebx, DWORD PTR _cnt$[ebp]
  000d1	83 c4 04	 add	 esp, 4
  000d4	85 db		 test	 ebx, ebx
  000d6	7e 76		 jle	 SHORT $LN1@judy_radix

; 757  : 
; 758  : 	//	store new node pointer in inner table
; 759  : 
; 760  : 	base = (uchar*)judy_alloc (judy, type);

  000d8	8b d7		 mov	 edx, edi
  000da	f7 da		 neg	 edx
  000dc	89 55 fc	 mov	 DWORD PTR tv524[ebp], edx
  000df	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000e2	8b d0		 mov	 edx, eax
  000e4	f7 da		 neg	 edx
  000e6	89 55 f0	 mov	 DWORD PTR tv526[ebp], edx
  000e9	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
  000f0	2b ca		 sub	 ecx, edx
  000f2	89 4d 08	 mov	 DWORD PTR tv449[ebp], ecx
  000f5	8b 4d 10	 mov	 ecx, DWORD PTR _start$[ebp]
  000f8	03 cb		 add	 ecx, ebx
  000fa	8b 5d f8	 mov	 ebx, DWORD PTR _oldnode$[ebp]
  000fd	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  00104	0f af c8	 imul	 ecx, eax
  00107	8b 45 0c	 mov	 eax, DWORD PTR _old$[ebp]
  0010a	4e		 dec	 esi
  0010b	0f af f7	 imul	 esi, edi
  0010e	03 75 ec	 add	 esi, DWORD PTR _base$[ebp]
  00111	2b da		 sub	 ebx, edx
  00113	8b 55 f4	 mov	 edx, DWORD PTR _cnt$[ebp]
  00116	2b cf		 sub	 ecx, edi
  00118	8d 4c 01 ff	 lea	 ecx, DWORD PTR [ecx+eax-1]
  0011c	89 4d 14	 mov	 DWORD PTR tv520[ebp], ecx
  0011f	89 55 10	 mov	 DWORD PTR tv588[ebp], edx
$LL17@judy_radix:

; 768  : #if BYTE_ORDER != BIG_ENDIAN
; 769  : 		memcpy (base + (newcnt - idx - 1) * keysize, old + (start + cnt - idx - 1) * (keysize + 1), keysize);

  00122	8b 45 14	 mov	 eax, DWORD PTR tv520[ebp]
  00125	57		 push	 edi
  00126	50		 push	 eax
  00127	56		 push	 esi
  00128	e8 00 00 00 00	 call	 _memcpy

; 770  : #else
; 771  : 		memcpy (base + (newcnt - idx - 1) * keysize, old + (start + cnt - idx - 1) * (keysize + 1) + 1, keysize);
; 772  : #endif
; 773  : 		node[-(newcnt - idx)] = oldnode[-(start + cnt - idx)];

  0012d	8b 45 08	 mov	 eax, DWORD PTR tv449[ebp]
  00130	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00132	8b 55 f0	 mov	 edx, DWORD PTR tv526[ebp]
  00135	01 55 14	 add	 DWORD PTR tv520[ebp], edx
  00138	03 75 fc	 add	 esi, DWORD PTR tv524[ebp]
  0013b	89 08		 mov	 DWORD PTR [eax], ecx
  0013d	83 c0 04	 add	 eax, 4
  00140	83 c4 0c	 add	 esp, 12			; 0000000cH
  00143	83 c3 04	 add	 ebx, 4
  00146	ff 4d 10	 dec	 DWORD PTR tv588[ebp]
  00149	89 45 08	 mov	 DWORD PTR tv449[ebp], eax
  0014c	75 d4		 jne	 SHORT $LL17@judy_radix
$LN1@judy_radix:
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx

; 774  : 	}
; 775  : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ENDP		; judy_radix
_TEXT	ENDS
PUBLIC	?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z		; judy_promote
; Function compile flags: /Ogtp
;	COMDAT ?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z
_TEXT	SEGMENT
_result$ = -40						; size = 4
tv338 = -36						; size = 4
tv356 = -32						; size = 4
tv339 = -32						; size = 4
_node$ = -28						; size = 4
tv357 = -24						; size = 4
tv221 = -24						; size = 4
tv322 = -20						; size = 4
_newnode$ = -16						; size = 4
_slot$ = -12						; size = 4
_newcnt$ = -8						; size = 4
_oldcnt$ = -4						; size = 4
_judy$ = 8						; size = 4
_next$ = 12						; size = 4
tv347 = 16						; size = 4
_idx$ = 16						; size = 4
_value$ = 20						; size = 4
?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z PROC		; judy_promote, COMDAT
; _keysize$ = eax

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax

; 667  : uchar *base = (uchar *)(*next & JUDY_mask);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _next$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b c8		 mov	 ecx, eax

; 668  : int oldcnt, newcnt, slot;
; 669  : #if BYTE_ORDER == BIG_ENDIAN
; 670  : 	int i;
; 671  : #endif
; 672  : JudySlot *newnode, *node;
; 673  : JudySlot *result;
; 674  : uchar *newbase;
; 675  : uint type;
; 676  : 
; 677  : 	type = (*next & 0x07) + 1;

  00011	83 e0 07	 and	 eax, 7
  00014	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00017	57		 push	 edi
  00018	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 678  : 	node = (JudySlot *)((*next & JUDY_mask) + JudySize[type-1]);

  0001b	8b 04 bd fc ff
	ff ff		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4-4]
  00022	89 4d ec	 mov	 DWORD PTR tv322[ebp], ecx
  00025	03 c8		 add	 ecx, eax

; 679  : 	oldcnt = JudySize[type-1] / (sizeof(JudySlot) + keysize);

  00027	33 d2		 xor	 edx, edx
  00029	89 4d e4	 mov	 DWORD PTR _node$[ebp], ecx
  0002c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002f	f7 f1		 div	 ecx

; 680  : 	newcnt = JudySize[type] / (sizeof(JudySlot) + keysize);

  00031	33 d2		 xor	 edx, edx
  00033	89 45 fc	 mov	 DWORD PTR _oldcnt$[ebp], eax
  00036	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]
  0003d	f7 f1		 div	 ecx

; 681  : 
; 682  : 	// promote node to next larger size
; 683  : 
; 684  : 	newbase = (uchar*)judy_alloc (judy, type);

  0003f	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]
  00042	52		 push	 edx
  00043	8b cf		 mov	 ecx, edi
  00045	89 45 f8	 mov	 DWORD PTR _newcnt$[ebp], eax
  00048	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 685  : 	newnode = (JudySlot *)(newbase + JudySize[type]);
; 686  : 	*next = (JudySlot)newbase | type;

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _next$[ebp]
  00050	8b d8		 mov	 ebx, eax
  00052	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]

; 687  : 
; 688  : 	//	open up slot at idx
; 689  : 
; 690  : 	memcpy(newbase + (newcnt - oldcnt - 1) * keysize, base, idx * keysize);	// copy keys

  00059	8b 55 ec	 mov	 edx, DWORD PTR tv322[ebp]
  0005c	03 c3		 add	 eax, ebx
  0005e	89 45 f0	 mov	 DWORD PTR _newnode$[ebp], eax
  00061	8b c3		 mov	 eax, ebx
  00063	0b c7		 or	 eax, edi
  00065	89 01		 mov	 DWORD PTR [ecx], eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _newcnt$[ebp]
  0006a	2b 4d fc	 sub	 ecx, DWORD PTR _oldcnt$[ebp]
  0006d	8b 45 10	 mov	 eax, DWORD PTR _idx$[ebp]
  00070	89 4d e0	 mov	 DWORD PTR tv339[ebp], ecx
  00073	0f af c6	 imul	 eax, esi
  00076	49		 dec	 ecx
  00077	0f af ce	 imul	 ecx, esi
  0007a	50		 push	 eax
  0007b	52		 push	 edx
  0007c	03 cb		 add	 ecx, ebx
  0007e	51		 push	 ecx
  0007f	89 45 dc	 mov	 DWORD PTR tv338[ebp], eax
  00082	e8 00 00 00 00	 call	 _memcpy
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 691  : 
; 692  : 	for( slot = 0; slot < idx; slot++ )

  0008a	83 7d 10 00	 cmp	 DWORD PTR _idx$[ebp], 0
  0008e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _slot$[ebp], 0
  00095	7e 2a		 jle	 SHORT $LN4@judy_promo

; 667  : uchar *base = (uchar *)(*next & JUDY_mask);

  00097	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _oldcnt$[ebp]
  0009d	8b 55 f0	 mov	 edx, DWORD PTR _newnode$[ebp]
  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  000a6	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  000a9	8b 55 10	 mov	 edx, DWORD PTR _idx$[ebp]
  000ac	89 55 e8	 mov	 DWORD PTR tv221[ebp], edx

; 691  : 
; 692  : 	for( slot = 0; slot < idx; slot++ )

  000af	89 55 f4	 mov	 DWORD PTR _slot$[ebp], edx
$LL6@judy_promo:

; 693  : 		newnode[-(slot + newcnt - oldcnt)] = node[-(slot + 1)];	// copy ptr

  000b2	8b 10		 mov	 edx, DWORD PTR [eax]
  000b4	89 11		 mov	 DWORD PTR [ecx], edx
  000b6	83 e8 04	 sub	 eax, 4
  000b9	83 e9 04	 sub	 ecx, 4
  000bc	ff 4d e8	 dec	 DWORD PTR tv221[ebp]
  000bf	75 f1		 jne	 SHORT $LL6@judy_promo
$LN4@judy_promo:

; 694  : 
; 695  : 	//	fill in new node
; 696  : 
; 697  : #if BYTE_ORDER != BIG_ENDIAN
; 698  : 	memcpy(newbase + (idx + newcnt - oldcnt - 1) * keysize, &value, keysize);	// copy key

  000c1	8b 45 e0	 mov	 eax, DWORD PTR tv339[ebp]
  000c4	03 45 10	 add	 eax, DWORD PTR _idx$[ebp]
  000c7	56		 push	 esi
  000c8	89 45 e0	 mov	 DWORD PTR tv356[ebp], eax
  000cb	48		 dec	 eax
  000cc	89 45 e8	 mov	 DWORD PTR tv357[ebp], eax
  000cf	0f af c6	 imul	 eax, esi
  000d2	8d 55 14	 lea	 edx, DWORD PTR _value$[ebp]
  000d5	52		 push	 edx
  000d6	03 c3		 add	 eax, ebx
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _memcpy

; 699  : #else
; 700  : 	i = keysize;
; 701  : 
; 702  : 	while( i-- )
; 703  : 	  newbase[(idx + newcnt - oldcnt - 1) * keysize + i] = value, value >>= 8;
; 704  : #endif
; 705  : 	result = &newnode[-(idx + newcnt - oldcnt)];

  000de	8b 45 fc	 mov	 eax, DWORD PTR _oldcnt$[ebp]
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _newnode$[ebp]
  000e4	8b c8		 mov	 ecx, eax

; 706  : 
; 707  : 	//	copy rest of old node
; 708  : 
; 709  : 	memcpy(newbase + (idx + newcnt - oldcnt) * keysize, base + (idx * keysize), (oldcnt - slot) * keysize);	// copy keys

  000e6	2b 45 f4	 sub	 eax, DWORD PTR _slot$[ebp]
  000e9	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  000ec	2b 4d 10	 sub	 ecx, DWORD PTR _idx$[ebp]
  000ef	89 45 10	 mov	 DWORD PTR tv347[ebp], eax
  000f2	0f af c6	 imul	 eax, esi
  000f5	50		 push	 eax
  000f6	8b 45 e0	 mov	 eax, DWORD PTR tv356[ebp]
  000f9	0f af c6	 imul	 eax, esi
  000fc	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  000ff	8b 55 dc	 mov	 edx, DWORD PTR tv338[ebp]
  00102	03 55 ec	 add	 edx, DWORD PTR tv322[ebp]
  00105	03 c3		 add	 eax, ebx
  00107	52		 push	 edx
  00108	50		 push	 eax
  00109	89 4d d8	 mov	 DWORD PTR _result$[ebp], ecx
  0010c	e8 00 00 00 00	 call	 _memcpy

; 710  : 
; 711  : 	for( ; slot < oldcnt; slot++ )

  00111	8b 45 f4	 mov	 eax, DWORD PTR _slot$[ebp]
  00114	83 c4 18	 add	 esp, 24			; 00000018H
  00117	3b 45 fc	 cmp	 eax, DWORD PTR _oldcnt$[ebp]
  0011a	7d 28		 jge	 SHORT $LN1@judy_promo

; 694  : 
; 695  : 	//	fill in new node
; 696  : 
; 697  : #if BYTE_ORDER != BIG_ENDIAN
; 698  : 	memcpy(newbase + (idx + newcnt - oldcnt - 1) * keysize, &value, keysize);	// copy key

  0011c	8b 55 10	 mov	 edx, DWORD PTR tv347[ebp]
  0011f	8b 75 f0	 mov	 esi, DWORD PTR _newnode$[ebp]
  00122	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00129	8b 45 e4	 mov	 eax, DWORD PTR _node$[ebp]
  0012c	2b c1		 sub	 eax, ecx
  0012e	8b ca		 mov	 ecx, edx
  00130	2b 4d f8	 sub	 ecx, DWORD PTR _newcnt$[ebp]
  00133	8d 4c 8e fc	 lea	 ecx, DWORD PTR [esi+ecx*4-4]
$LL3@judy_promo:

; 712  : 		newnode[-(slot + newcnt - oldcnt + 1)] = node[-(slot + 1)];	// copy ptr

  00137	8b 30		 mov	 esi, DWORD PTR [eax]
  00139	89 31		 mov	 DWORD PTR [ecx], esi
  0013b	83 e8 04	 sub	 eax, 4
  0013e	83 e9 04	 sub	 ecx, 4
  00141	4a		 dec	 edx
  00142	75 f3		 jne	 SHORT $LL3@judy_promo
$LN1@judy_promo:

; 713  : 
; 714  : #ifndef ASKITIS
; 715  : 	judy->stack[judy->level].next = *next;
; 716  : 	judy->stack[judy->level].slot = idx + newcnt - oldcnt - 1;
; 717  : #endif
; 718  : 	judy_free (judy, (void **)base, type - 1);

  00144	4f		 dec	 edi
  00145	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00148	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0014b	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  0014e	8b 45 0c	 mov	 eax, DWORD PTR _next$[ebp]
  00151	8b 00		 mov	 eax, DWORD PTR [eax]
  00153	89 44 91 34	 mov	 DWORD PTR [ecx+edx*4+52], eax
  00157	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0015a	8d 54 40 0f	 lea	 edx, DWORD PTR [eax+eax*2+15]
  0015e	8b 45 e8	 mov	 eax, DWORD PTR tv357[ebp]
  00161	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
  00164	75 07		 jne	 SHORT $LN10@judy_promo
  00166	bf 04 00 00 00	 mov	 edi, 4
  0016b	eb 0a		 jmp	 SHORT $LN9@judy_promo
$LN10@judy_promo:
  0016d	83 ff 07	 cmp	 edi, 7
  00170	75 05		 jne	 SHORT $LN9@judy_promo
  00172	bf 03 00 00 00	 mov	 edi, 3
$LN9@judy_promo:
  00177	8b 54 b9 04	 mov	 edx, DWORD PTR [ecx+edi*4+4]
  0017b	8b 45 ec	 mov	 eax, DWORD PTR tv322[ebp]
  0017e	89 10		 mov	 DWORD PTR [eax], edx
  00180	89 44 b9 04	 mov	 DWORD PTR [ecx+edi*4+4], eax

; 719  : 	return result;

  00184	8b 45 d8	 mov	 eax, DWORD PTR _result$[ebp]
  00187	5f		 pop	 edi
  00188	5e		 pop	 esi
  00189	5b		 pop	 ebx

; 720  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z ENDP		; judy_promote
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN10@scalar@5
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN10@scalar@5:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
$T180177 = 8						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@PBD@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx

; 114  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 4d 08	 lea	 ecx, DWORD PTR $T180177[ebp]
  0000c	51		 push	 ecx
  0000d	8b ce		 mov	 ecx, esi
  0000f	89 45 08	 mov	 DWORD PTR $T180177[ebp], eax
  00012	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 115  : 		}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0length_error@std@@QAE@PBD@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar@6
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar@6:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.c
_TEXT	ENDS
;	COMDAT ?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z
_TEXT	SEGMENT
_count$180188 = -4					; size = 4
?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z PROC ; tommy_hashlin_pos, COMDAT
; _pos$ = eax

; 71   : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   : 	unsigned bsr;  
; 73   :  
; 74   : 	/* special case for the first bucket */
; 75   : 	if (pos < (1 << TOMMY_HASHLIN_BIT)) {

  00004	83 f8 40	 cmp	 eax, 64			; 00000040H
  00007	73 0d		 jae	 SHORT $LN1@tommy_hash@2

; 76   : 		return &hashlin->bucket[0][pos];

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A

; 84   : 
; 85   : 	return &hashlin->bucket[bsr - TOMMY_HASHLIN_BIT + 1][pos];

  0000f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 86   : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
$LN1@tommy_hash@2:

; 77   : 	}
; 78   : 
; 79   : 	/* get the highest bit set */
; 80   : 	bsr = tommy_ilog2_u32(pos);

  00016	0f bd d0	 bsr	 edx, eax
  00019	89 55 fc	 mov	 DWORD PTR _count$180188[ebp], edx

; 81   : 
; 82   : 	/* clear the highest bit */
; 83   : 	pos -= 1 << bsr;

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _count$180188[ebp]
  0001f	ba 01 00 00 00	 mov	 edx, 1
  00024	d3 e2		 shl	 edx, cl

; 84   : 
; 85   : 	return &hashlin->bucket[bsr - TOMMY_HASHLIN_BIT + 1][pos];

  00026	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  0002d	2b c2		 sub	 eax, edx
  0002f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 86   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?tommy_hashlin_pos@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ENDP ; tommy_hashlin_pos
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_memory_usage
_TEXT	SEGMENT
_tommy_hashdyn_memory_usage PROC			; COMDAT

; 189  : 	return hashdyn->bucket_max * (tommy_size_t)sizeof(hashdyn->bucket[0])
; 190  : 		+ tommy_hashdyn_count(hashdyn) * (tommy_size_t)sizeof(tommy_hashdyn_node);

  00000	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  00005	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 191  : }

  00012	c3		 ret	 0
_tommy_hashdyn_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashtbl.c
;	COMDAT _tommy_hashtable_memory_usage
_TEXT	SEGMENT
_tommy_hashtable_memory_usage PROC			; COMDAT

; 102  : 	return hashtable->bucket_max * (tommy_size_t)sizeof(hashtable->bucket[0])
; 103  : 		+ tommy_hashtable_count(hashtable) * (tommy_size_t)sizeof(tommy_hashtable_node);

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00005	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	03 c0		 add	 eax, eax
  00010	03 c0		 add	 eax, eax

; 104  : }

  00012	c3		 ret	 0
_tommy_hashtable_memory_usage ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_init
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashtable_init
_TEXT	SEGMENT
_tommy_hashtable_init PROC				; COMDAT
; _bucket_max$ = eax

; 38   : 	if (bucket_max < 16) {

  00000	83 f8 10	 cmp	 eax, 16			; 00000010H
  00003	73 07		 jae	 SHORT $LN2@tommy_hash@3

; 39   : 		bucket_max = 16;

  00005	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H

; 40   : 	} else {

  0000a	eb 24		 jmp	 SHORT $LN1@tommy_hash@3
$LN2@tommy_hash@3:

; 41   : 		bucket_max = tommy_roundup_pow2_u32(bucket_max);

  0000c	48		 dec	 eax
  0000d	8b c8		 mov	 ecx, eax
  0000f	d1 e9		 shr	 ecx, 1
  00011	0b c1		 or	 eax, ecx
  00013	8b d0		 mov	 edx, eax
  00015	c1 ea 02	 shr	 edx, 2
  00018	0b c2		 or	 eax, edx
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e9 04	 shr	 ecx, 4
  0001f	0b c1		 or	 eax, ecx
  00021	8b d0		 mov	 edx, eax
  00023	c1 ea 08	 shr	 edx, 8
  00026	0b c2		 or	 eax, edx
  00028	8b c8		 mov	 ecx, eax
  0002a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0002d	0b c8		 or	 ecx, eax
  0002f	41		 inc	 ecx
$LN1@tommy_hash@3:

; 42   : 	}
; 43   : 
; 44   : 	hashtable->bucket_max = bucket_max;
; 45   : 	hashtable->bucket_mask = hashtable->bucket_max - 1;
; 46   : 	hashtable->bucket = tommy_cast(tommy_hashtable_node**, tommy_malloc(hashtable->bucket_max * sizeof(tommy_hashtable_node*)));

  00030	56		 push	 esi
  00031	8d 34 8d 00 00
	00 00		 lea	 esi, DWORD PTR [ecx*4]
  00038	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  0003b	56		 push	 esi
  0003c	89 0d 04 00 00
	00		 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4, ecx
  00042	a3 08 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8, eax
  00047	e8 00 00 00 00	 call	 _malloc

; 47   : 	memset(hashtable->bucket, 0, hashtable->bucket_max * sizeof(tommy_hashtable_node*));

  0004c	56		 push	 esi
  0004d	6a 00		 push	 0
  0004f	50		 push	 eax
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A, eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	83 c4 10	 add	 esp, 16			; 00000010H

; 48   : 
; 49   : 	hashtable->count = 0;

  0005d	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12, 0
  00067	5e		 pop	 esi

; 50   : }

  00068	c3		 ret	 0
_tommy_hashtable_init ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_memory_usage
_TEXT	SEGMENT
_tommy_trie_inplace_memory_usage PROC			; COMDAT

; 270  : 	return tommy_trie_inplace_count(trie_inplace) * (tommy_size_t)sizeof(tommy_trie_inplace_node);

  00000	a1 00 01 00 00	 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00005	c1 e0 05	 shl	 eax, 5

; 271  : }

  00008	c3		 ret	 0
_tommy_trie_inplace_memory_usage ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z
_TEXT	SEGMENT
_let_ptr$ = 8						; size = 4
?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z PROC ; trie_inplace_bucket_remove, COMDAT
; _key$ = edx

; 148  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _let_ptr$[ebp]

; 149  : 	tommy_trie_inplace_node* node;
; 150  : 	int i;
; 151  : 	tommy_trie_inplace_node** leaf_let_ptr;
; 152  : 	tommy_trie_inplace_node* leaf;
; 153  : 
; 154  : 	node = *let_ptr;

  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	56		 push	 esi
  0000a	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 155  : 	while (node && node->key != key) {

  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $LN43@trie_inpla
$LL15@trie_inpla:
  00013	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00016	74 1a		 je	 SHORT $LN44@trie_inpla

; 156  : 		let_ptr = &node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  00018	8b f2		 mov	 esi, edx
  0001a	d3 ee		 shr	 esi, cl

; 157  : 		node = *let_ptr;
; 158  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  0001c	83 e9 02	 sub	 ecx, 2
  0001f	83 e6 03	 and	 esi, 3
  00022	8d 5c b0 10	 lea	 ebx, DWORD PTR [eax+esi*4+16]
  00026	8b 03		 mov	 eax, DWORD PTR [ebx]
  00028	85 c0		 test	 eax, eax
  0002a	75 e7		 jne	 SHORT $LL15@trie_inpla
$LN43@trie_inpla:
  0002c	5e		 pop	 esi

; 159  : 	}
; 160  : 
; 161  : 	if (!node)
; 162  : 		return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	5b		 pop	 ebx

; 213  : 
; 214  : 	return remove;
; 215  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN44@trie_inpla:

; 163  : 
; 164  : 	/* if the node to remove is not specified */
; 165  : 	if (!remove) {
; 166  : 		/* remove the first */
; 167  : 		remove = node;
; 168  : 	}
; 169  : 
; 170  : 	tommy_trie_inplace_list_remove(let_ptr, remove);

  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 13		 mov	 edx, DWORD PTR [ebx]
  00036	85 c9		 test	 ecx, ecx
  00038	74 08		 je	 SHORT $LN21@trie_inpla
  0003a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0003d	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00040	eb 06		 jmp	 SHORT $LN20@trie_inpla
$LN21@trie_inpla:
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN20@trie_inpla:
  00048	3b d0		 cmp	 edx, eax
  0004a	8b 10		 mov	 edx, DWORD PTR [eax]
  0004c	75 04		 jne	 SHORT $LN19@trie_inpla
  0004e	89 13		 mov	 DWORD PTR [ebx], edx
  00050	eb 05		 jmp	 SHORT $LN18@trie_inpla
$LN19@trie_inpla:
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	89 11		 mov	 DWORD PTR [ecx], edx
$LN18@trie_inpla:

; 171  : 
; 172  : 	/* if we have a substitute */
; 173  : 	if (*let_ptr != 0) {

  00057	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00059	85 c9		 test	 ecx, ecx
  0005b	74 1c		 je	 SHORT $LN11@trie_inpla

; 174  : 		/* copy the child pointers to the new one */
; 175  : 		node = *let_ptr;
; 176  : 		for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i) {
; 177  : 			node->map[i] = remove->map[i];

  0005d	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00060	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00063	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00066	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00069	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0006c	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  0006f	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00072	5e		 pop	 esi
  00073	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00076	5b		 pop	 ebx

; 213  : 
; 214  : 	return remove;
; 215  : }

  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
$LN11@trie_inpla:

; 178  : 		}
; 179  : 		return remove;
; 180  : 	}
; 181  : 
; 182  : 	/* find a leaf */
; 183  : 	leaf_let_ptr = 0;

  00079	33 f6		 xor	 esi, esi

; 184  : 	leaf = remove;

  0007b	8b c8		 mov	 ecx, eax
  0007d	57		 push	 edi
$LN45@trie_inpla:

; 185  : 
; 186  : 	/* search backward, statistically we have more zeros than ones */
; 187  : 	i = TOMMY_TRIE_INPLACE_TREE_MAX-1;

  0007e	ba 03 00 00 00	 mov	 edx, 3
$LL7@trie_inpla:

; 189  : 		if (leaf->map[i]) {

  00083	83 7c 91 10 00	 cmp	 DWORD PTR [ecx+edx*4+16], 0
  00088	8d 7c 91 10	 lea	 edi, DWORD PTR [ecx+edx*4+16]
  0008c	74 06		 je	 SHORT $LN5@trie_inpla

; 190  : 			leaf_let_ptr = &leaf->map[i];

  0008e	8b f7		 mov	 esi, edi

; 191  : 			leaf = *leaf_let_ptr;

  00090	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 192  : 			i = TOMMY_TRIE_INPLACE_TREE_MAX-1;
; 193  : 			continue;

  00092	eb ea		 jmp	 SHORT $LN45@trie_inpla
$LN5@trie_inpla:

; 194  : 		}
; 195  : 		--i;

  00094	4a		 dec	 edx

; 188  : 	while (i >= 0) {

  00095	79 ec		 jns	 SHORT $LL7@trie_inpla

; 196  : 	}
; 197  : 
; 198  : 	/* if it's itself a leaf */
; 199  : 	if (!leaf_let_ptr) {

  00097	5f		 pop	 edi
  00098	85 f6		 test	 esi, esi

; 200  : 		return remove;

  0009a	74 20		 je	 SHORT $LN16@trie_inpla

; 201  : 	}
; 202  : 
; 203  : 	/* remove the leaf */
; 204  : 	*leaf_let_ptr = 0;

  0009c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 205  : 
; 206  : 	/* copy the child pointers */
; 207  : 	for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i) {
; 208  : 		leaf->map[i] = remove->map[i];

  000a2	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000a5	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000a8	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ab	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  000ae	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  000b1	89 51 18	 mov	 DWORD PTR [ecx+24], edx
  000b4	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000b7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 209  : 	}
; 210  : 
; 211  : 	/* put it in place */
; 212  : 	*let_ptr = leaf;

  000ba	89 0b		 mov	 DWORD PTR [ebx], ecx
$LN16@trie_inpla:
  000bc	5e		 pop	 esi
  000bd	5b		 pop	 ebx

; 213  : 
; 214  : 	return remove;
; 215  : }

  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ENDP ; trie_inplace_bucket_remove
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z
_TEXT	SEGMENT
?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z PROC ; trie_inplace_bucket_insert, COMDAT
; _let_ptr$ = edx
; _insert$ = edi
; _key$ = esi

; 110  : 	tommy_trie_inplace_node* node;
; 111  : 
; 112  : 	node = *let_ptr;

  00000	8b 02		 mov	 eax, DWORD PTR [edx]
  00002	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH

; 113  : 	while (node && node->key != key) {

  00007	85 c0		 test	 eax, eax
  00009	74 1e		 je	 SHORT $LN13@trie_inpla@2
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@trie_inpla@2:
  00010	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00013	74 20		 je	 SHORT $LN2@trie_inpla@2

; 114  : 		let_ptr = &node->map[(key >> shift) & TOMMY_TRIE_INPLACE_TREE_MASK];

  00015	8b d6		 mov	 edx, esi
  00017	d3 ea		 shr	 edx, cl

; 115  : 		node = *let_ptr;
; 116  : 		shift -= TOMMY_TRIE_INPLACE_TREE_BIT;

  00019	83 e9 02	 sub	 ecx, 2
  0001c	83 e2 03	 and	 edx, 3
  0001f	8d 54 90 10	 lea	 edx, DWORD PTR [eax+edx*4+16]
  00023	8b 02		 mov	 eax, DWORD PTR [edx]
  00025	85 c0		 test	 eax, eax
  00027	75 e7		 jne	 SHORT $LL4@trie_inpla@2
$LN13@trie_inpla@2:

; 117  : 	}
; 118  : 
; 119  : 	/* if null, just insert the node */
; 120  : 	if (!node) {
; 121  : 		/* setup the node as a list */
; 122  : 		*let_ptr = tommy_trie_inplace_list_insert_first(insert);

  00029	89 7f 04	 mov	 DWORD PTR [edi+4], edi

; 123  : 	} else {
; 124  : 		/* if it's the same key, insert in the list */
; 125  : 		tommy_trie_inplace_list_insert_tail_not_empty(node, insert);

  0002c	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00032	89 3a		 mov	 DWORD PTR [edx], edi

; 126  : 	}
; 127  : }

  00034	c3		 ret	 0
$LN2@trie_inpla@2:

; 123  : 	} else {
; 124  : 		/* if it's the same key, insert in the list */
; 125  : 		tommy_trie_inplace_list_insert_tail_not_empty(node, insert);

  00035	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00038	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0003b	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0003e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00041	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00047	89 3a		 mov	 DWORD PTR [edx], edi

; 126  : 	}
; 127  : }

  00049	c3		 ret	 0
?trie_inplace_bucket_insert@@YAXIPAPAUtommy_trie_inplace_node_struct@@PAU1@I@Z ENDP ; trie_inplace_bucket_insert
_TEXT	ENDS
PUBLIC	_tommy_trie_memory_usage
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrie.c
;	COMDAT _tommy_trie_memory_usage
_TEXT	SEGMENT
_tommy_trie_memory_usage PROC				; COMDAT

; 320  : 	return tommy_trie_count(trie) * (tommy_size_t)sizeof(tommy_trie_node)
; 321  : 		+ trie->node_count * (tommy_size_t)TOMMY_TRIE_BLOCK_SIZE;

  00000	a1 44 00 00 00	 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A+68
  00005	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  0000b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000e	c1 e0 04	 shl	 eax, 4

; 322  : }

  00011	c3		 ret	 0
_tommy_trie_memory_usage ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_shift$ = -4						; size = 4
_let_ptr$ = 8						; size = 4
_insert$ = 12						; size = 4
_key$ = 16						; size = 4
?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z PROC ; trie_bucket_insert, COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 55 08	 mov	 edx, DWORD PTR _let_ptr$[ebp]
  00009	8b 45 0c	 mov	 eax, DWORD PTR _insert$[ebp]
  0000c	53		 push	 ebx

; 92   : 	tommy_trie_tree* tree;
; 93   : 	tommy_trie_node* node;
; 94   : 	void* ptr;
; 95   : 	unsigned i, j;
; 96   : 
; 97   : recurse:
; 98   : 	ptr = *let_ptr;

  0000d	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0000f	56		 push	 esi
  00010	8b 75 10	 mov	 esi, DWORD PTR _key$[ebp]
  00013	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  00018	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx

; 99   : 
; 100  : 	/* if null, just insert the node */
; 101  : 	if (!ptr) {

  0001b	85 db		 test	 ebx, ebx
  0001d	74 1d		 je	 SHORT $LN27@trie_bucke
  0001f	90		 npad	 1
$recurse$68438:

; 104  : 		return;
; 105  : 	}
; 106  : 
; 107  : 	if (trie_get_type(ptr) == TOMMY_TRIE_TYPE_TREE) {

  00020	f6 c3 01	 test	 bl, 1
  00023	74 28		 je	 SHORT $LN6@trie_bucke

; 108  : 		/* repeat the process one level down */
; 109  : 		let_ptr = &trie_get_tree(ptr)->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  00025	8b d6		 mov	 edx, esi
  00027	d3 ea		 shr	 edx, cl

; 110  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00029	83 e9 04	 sub	 ecx, 4
  0002c	83 e2 0f	 and	 edx, 15			; 0000000fH
  0002f	8d 54 93 ff	 lea	 edx, DWORD PTR [ebx+edx*4-1]
  00033	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00035	85 db		 test	 ebx, ebx
  00037	75 e7		 jne	 SHORT $recurse$68438

; 92   : 	tommy_trie_tree* tree;
; 93   : 	tommy_trie_node* node;
; 94   : 	void* ptr;
; 95   : 	unsigned i, j;
; 96   : 
; 97   : recurse:
; 98   : 	ptr = *let_ptr;

  00039	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx
$LN27@trie_bucke:
  0003c	5e		 pop	 esi

; 102  : 		/* setup the node as a list */
; 103  : 		tommy_list_insert_first(let_ptr, insert);

  0003d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00046	89 02		 mov	 DWORD PTR [edx], eax
  00048	5b		 pop	 ebx

; 151  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN6@trie_bucke:

; 92   : 	tommy_trie_tree* tree;
; 93   : 	tommy_trie_node* node;
; 94   : 	void* ptr;
; 95   : 	unsigned i, j;
; 96   : 
; 97   : recurse:
; 98   : 	ptr = *let_ptr;

  0004d	89 5d f8	 mov	 DWORD PTR _ptr$[ebp], ebx

; 110  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00050	89 4d fc	 mov	 DWORD PTR _shift$[ebp], ecx
  00053	89 55 08	 mov	 DWORD PTR _let_ptr$[ebp], edx

; 111  : 		goto recurse;
; 112  : 	}
; 113  : 
; 114  : 	node = tommy_cast(tommy_trie_node*, ptr);
; 115  : 
; 116  : 	/* if it's the same key, insert in the list */
; 117  : 	if (node->key == key) {

  00056	39 73 0c	 cmp	 DWORD PTR [ebx+12], esi
  00059	75 1a		 jne	 SHORT $LN42@trie_bucke

; 118  : 		tommy_list_insert_tail_not_empty(node, insert);

  0005b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0005e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00061	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00064	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00067	5e		 pop	 esi
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0006e	89 02		 mov	 DWORD PTR [edx], eax
  00070	5b		 pop	 ebx

; 151  : }

  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN42@trie_bucke:
  00075	57		 push	 edi
  00076	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$expand$68455:

; 119  : 		return;
; 120  : 	}
; 121  : 
; 122  : expand:
; 123  : 	/* convert to a tree */
; 124  : 	tree = tommy_cast(tommy_trie_tree*, tommy_allocator_alloc(trie->alloc));

  00080	8b 35 48 00 00
	00		 mov	 esi, DWORD PTR ?trie@@3Utommy_trie_struct@@A+72
  00086	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00089	75 55		 jne	 SHORT $LN14@trie_bucke
  0008b	bf c0 0f 00 00	 mov	 edi, 4032		; 00000fc0H
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 _malloc
  00096	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00099	8b c8		 mov	 ecx, eax
  0009b	89 11		 mov	 DWORD PTR [ecx], edx
  0009d	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  000a0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000a3	83 c1 04	 add	 ecx, 4
  000a6	33 d2		 xor	 edx, edx
  000a8	8b c1		 mov	 eax, ecx
  000aa	f7 f3		 div	 ebx
  000ac	83 c4 04	 add	 esp, 4
  000af	85 d2		 test	 edx, edx
  000b1	74 0e		 je	 SHORT $LN40@trie_bucke
  000b3	8b c3		 mov	 eax, ebx
  000b5	2b c2		 sub	 eax, edx
  000b7	03 c8		 add	 ecx, eax
  000b9	2b d3		 sub	 edx, ebx
  000bb	8d ba c0 0f 00
	00		 lea	 edi, DWORD PTR [edx+4032]
$LN40@trie_bucke:
  000c1	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  000c4	72 11		 jb	 SHORT $LN41@trie_bucke
$LL15@trie_bucke:
  000c6	8b 16		 mov	 edx, DWORD PTR [esi]
  000c8	89 11		 mov	 DWORD PTR [ecx], edx
  000ca	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000cd	89 0e		 mov	 DWORD PTR [esi], ecx
  000cf	2b f8		 sub	 edi, eax
  000d1	03 c8		 add	 ecx, eax
  000d3	3b f8		 cmp	 edi, eax
  000d5	73 ef		 jae	 SHORT $LL15@trie_bucke
$LN41@trie_bucke:
  000d7	8b 5d f8	 mov	 ebx, DWORD PTR _ptr$[ebp]
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _shift$[ebp]
  000dd	8b 55 08	 mov	 edx, DWORD PTR _let_ptr$[ebp]
$LN14@trie_bucke:
  000e0	8b 06		 mov	 eax, DWORD PTR [esi]
  000e2	8b 38		 mov	 edi, DWORD PTR [eax]
  000e4	89 3e		 mov	 DWORD PTR [esi], edi

; 125  : 	++trie->node_count;
; 126  : 	*let_ptr = tommy_cast(tommy_trie_node*, trie_set_tree(tree));
; 127  : 
; 128  : 	/* initialize it */
; 129  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {
; 130  : 		tree->map[i] = 0;

  000e6	66 0f ef c0	 pxor	 xmm0, xmm0
  000ea	bf 01 00 00 00	 mov	 edi, 1
  000ef	01 7e 10	 add	 DWORD PTR [esi+16], edi
  000f2	01 3d 44 00 00
	00		 add	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+68, edi
  000f8	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
  000fb	89 32		 mov	 DWORD PTR [edx], esi

; 131  : 	}
; 132  : 
; 133  : 	/* get the position of the two elements */
; 134  : 	i = (node->key >> shift) & TOMMY_TRIE_TREE_MASK;
; 135  : 	j = (key >> shift) & TOMMY_TRIE_TREE_MASK;

  000fd	8b 75 10	 mov	 esi, DWORD PTR _key$[ebp]
  00100	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00104	66 0f d6 40 08	 movq	 QWORD PTR [eax+8], xmm0
  00109	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  0010e	66 0f d6 40 18	 movq	 QWORD PTR [eax+24], xmm0
  00113	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0
  00118	66 0f d6 40 28	 movq	 QWORD PTR [eax+40], xmm0
  0011d	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  00122	66 0f d6 40 38	 movq	 QWORD PTR [eax+56], xmm0
  00127	8b 53 0c	 mov	 edx, DWORD PTR [ebx+12]
  0012a	d3 ea		 shr	 edx, cl
  0012c	d3 ee		 shr	 esi, cl
  0012e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00131	83 e6 0f	 and	 esi, 15			; 0000000fH

; 136  : 
; 137  : 	/* if they don't collide */
; 138  : 	if (i != j) {

  00134	3b d6		 cmp	 edx, esi
  00136	75 11		 jne	 SHORT $LN28@trie_bucke

; 144  : 		return;
; 145  : 	}
; 146  : 
; 147  : 	/* expand one more level */
; 148  : 	let_ptr = &tree->map[i];

  00138	8d 14 90	 lea	 edx, DWORD PTR [eax+edx*4]

; 149  : 	shift -= TOMMY_TRIE_TREE_BIT;

  0013b	83 e9 04	 sub	 ecx, 4
  0013e	89 55 08	 mov	 DWORD PTR _let_ptr$[ebp], edx
  00141	89 4d fc	 mov	 DWORD PTR _shift$[ebp], ecx

; 150  : 	goto expand;

  00144	e9 37 ff ff ff	 jmp	 $expand$68455
$LN28@trie_bucke:

; 139  : 		/* insert the already existing element */
; 140  : 		tree->map[i] = node;
; 141  : 
; 142  : 		/* insert the new node */
; 143  : 		tommy_list_insert_first(&tree->map[j], insert);

  00149	8b 4d 0c	 mov	 ecx, DWORD PTR _insert$[ebp]
  0014c	89 1c 90	 mov	 DWORD PTR [eax+edx*4], ebx
  0014f	5f		 pop	 edi
  00150	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00153	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00159	89 0c b0	 mov	 DWORD PTR [eax+esi*4], ecx
  0015c	5e		 pop	 esi
  0015d	5b		 pop	 ebx

; 151  : }

  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c3		 ret	 0
?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ENDP ; trie_bucket_insert
_TEXT	ENDS
PUBLIC	_tommy_allocator_done
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyalloc.c
;	COMDAT _tommy_allocator_done
_TEXT	SEGMENT
_tommy_allocator_done PROC				; COMDAT

; 78   : 	allocator_reset(alloc);

  00000	e9 00 00 00 00	 jmp	 ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ; allocator_reset
_tommy_allocator_done ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.h
_TEXT	ENDS
;	COMDAT _tommy_hashdyn_search
_TEXT	SEGMENT
_tommy_hashdyn_search PROC				; COMDAT
; _cmp_arg$ = edx
; _hash$ = ecx

; 223  : 	tommy_hashdyn_node* i = tommy_hashdyn_bucket(hashdyn, hash);

  00000	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00005	56		 push	 esi
  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  0000c	23 c1		 and	 eax, ecx
  0000e	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00011	57		 push	 edi

; 224  : 	while (i) {

  00012	85 c0		 test	 eax, eax
  00014	74 15		 je	 SHORT $LN2@tommy_hash@4
$LL3@tommy_hash@4:

; 225  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 226  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00016	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00019	75 0a		 jne	 SHORT $LN1@tommy_hash@4
  0001b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0001e	8b 3a		 mov	 edi, DWORD PTR [edx]
  00020	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00023	74 0b		 je	 SHORT $LN12@tommy_hash@4
$LN1@tommy_hash@4:

; 228  : 		i = i->next;

  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	85 c0		 test	 eax, eax
  00029	75 eb		 jne	 SHORT $LL3@tommy_hash@4
$LN2@tommy_hash@4:
  0002b	5f		 pop	 edi

; 229  : 	}
; 230  : 	return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 231  : }

  0002f	c3		 ret	 0
$LN12@tommy_hash@4:
  00030	5f		 pop	 edi

; 227  : 			return i->data;

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 231  : }

  00034	c3		 ret	 0
_tommy_hashdyn_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashtbl.h
_TEXT	ENDS
;	COMDAT _tommy_hashtable_search
_TEXT	SEGMENT
_tommy_hashtable_search PROC				; COMDAT
; _cmp_arg$ = edx
; _hash$ = ecx

; 207  : 	tommy_hashtable_node* i = tommy_hashtable_bucket(hashtable, hash);

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00005	56		 push	 esi
  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0000c	23 c1		 and	 eax, ecx
  0000e	8b 04 86	 mov	 eax, DWORD PTR [esi+eax*4]
  00011	57		 push	 edi

; 208  : 	while (i) {

  00012	85 c0		 test	 eax, eax
  00014	74 15		 je	 SHORT $LN2@tommy_hash@5
$LL3@tommy_hash@5:

; 209  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 210  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00016	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00019	75 0a		 jne	 SHORT $LN1@tommy_hash@5
  0001b	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0001e	8b 3a		 mov	 edi, DWORD PTR [edx]
  00020	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00023	74 0b		 je	 SHORT $LN12@tommy_hash@5
$LN1@tommy_hash@5:

; 212  : 		i = i->next;

  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	85 c0		 test	 eax, eax
  00029	75 eb		 jne	 SHORT $LL3@tommy_hash@5
$LN2@tommy_hash@5:
  0002b	5f		 pop	 edi

; 213  : 	}
; 214  : 	return 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	5e		 pop	 esi

; 215  : }

  0002f	c3		 ret	 0
$LN12@tommy_hash@5:
  00030	5f		 pop	 edi

; 211  : 			return i->data;

  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi

; 215  : }

  00034	c3		 ret	 0
_tommy_hashtable_search ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommylist.h
_TEXT	ENDS
;	COMDAT _tommy_list_empty
_TEXT	SEGMENT
_tommy_list_empty PROC					; COMDAT
; _list$ = ecx

; 307  : 	return tommy_list_head(list) == 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 01		 cmp	 DWORD PTR [ecx], eax
  00004	0f 94 c0	 sete	 al

; 308  : }

  00007	c3		 ret	 0
_tommy_list_empty ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_remove_existing
_TEXT	SEGMENT
_tommy_list_remove_existing PROC			; COMDAT
; _list$ = esi
; _node$ = eax

; 264  : 	tommy_node* head = tommy_list_head(list);
; 265  : 
; 266  : 	/* remove from the "circular" prev list */
; 267  : 	if (node->next) { 

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 16		 mov	 edx, DWORD PTR [esi]
  00004	85 c9		 test	 ecx, ecx
  00006	74 0a		 je	 SHORT $LN4@tommy_list

; 268  : 		node->next->prev = node->prev;

  00008	57		 push	 edi
  00009	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0000c	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0000f	5f		 pop	 edi

; 269  : 	} else {

  00010	eb 06		 jmp	 SHORT $LN3@tommy_list
$LN4@tommy_list:

; 270  : 		head->prev = node->prev; /* the last */

  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN3@tommy_list:

; 271  : 	}
; 272  : 
; 273  : 	/* remove from the "0 terminated" next list */
; 274  : 	if (head == node) {

  00018	3b d0		 cmp	 edx, eax

; 275  : 		*list = node->next; /* the new head, in case 0 */

  0001a	8b 10		 mov	 edx, DWORD PTR [eax]
  0001c	75 06		 jne	 SHORT $LN2@tommy_list
  0001e	89 16		 mov	 DWORD PTR [esi], edx

; 278  : 	}
; 279  : 
; 280  : 	return node->data;

  00020	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 281  : }

  00023	c3		 ret	 0
$LN2@tommy_list:

; 276  : 	} else {
; 277  : 		node->prev->next = node->next;

  00024	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00027	89 11		 mov	 DWORD PTR [ecx], edx

; 278  : 	}
; 279  : 
; 280  : 	return node->data;

  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 281  : }

  0002c	c3		 ret	 0
_tommy_list_remove_existing ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_insert_tail
_TEXT	SEGMENT
_tommy_list_insert_tail PROC				; COMDAT
; _list$ = edx
; _node$ = eax
; _data$ = esi

; 225  : 	tommy_node* head = tommy_list_head(list);

  00000	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 226  : 
; 227  : 	if (head) {

  00002	85 c9		 test	 ecx, ecx
  00004	74 18		 je	 SHORT $LN2@tommy_list@2

; 228  : 		tommy_list_insert_tail_not_empty(head, node);

  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00018	89 01		 mov	 DWORD PTR [ecx], eax

; 231  : 	}
; 232  : 
; 233  : 	node->data = data;

  0001a	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 234  : }

  0001d	c3		 ret	 0
$LN2@tommy_list@2:

; 229  : 	} else {
; 230  : 		tommy_list_insert_first(list, node);

  0001e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00021	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00027	89 02		 mov	 DWORD PTR [edx], eax

; 231  : 	}
; 232  : 
; 233  : 	node->data = data;

  00029	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 234  : }

  0002c	c3		 ret	 0
_tommy_list_insert_tail ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _tommy_list_tail
_TEXT	SEGMENT
_tommy_list_tail PROC					; COMDAT
; _list$ = eax

; 139  : 	tommy_node* head = tommy_list_head(list);

  00000	8b 00		 mov	 eax, DWORD PTR [eax]

; 140  : 
; 141  : 	if (!head)

  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN1@tommy_list@3

; 145  : }

  00006	c3		 ret	 0
$LN1@tommy_list@3:

; 142  : 		return 0;
; 143  : 
; 144  : 	return head->prev;

  00007	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 145  : }

  0000a	c3		 ret	 0
_tommy_list_tail ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _k$ = ecx
; _e$ = edx

; 594  :   int linear_search_plain_compare(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	33 c0		 xor	 eax, eax

; 595  :       const key_type &k, int s, int e, const Compare &comp) const {
; 596  :     while (s < e) {

  00005	85 d2		 test	 edx, edx
  00007	7e 16		 jle	 SHORT $LN17@linear_sea

; 597  :       if (!btree_compare_keys(comp, key(s), k)) {

  00009	56		 push	 esi
  0000a	8b 31		 mov	 esi, DWORD PTR [ecx]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 08	 add	 ecx, 8
$LL3@linear_sea:
  00012	39 31		 cmp	 DWORD PTR [ecx], esi
  00014	73 08		 jae	 SHORT $LN21@linear_sea

; 598  :         break;
; 599  :       }
; 600  :       ++s;

  00016	40		 inc	 eax
  00017	83 c1 08	 add	 ecx, 8
  0001a	3b c2		 cmp	 eax, edx
  0001c	7c f4		 jl	 SHORT $LL3@linear_sea
$LN21@linear_sea:
  0001e	5e		 pop	 esi
$LN17@linear_sea:

; 601  :     }
; 602  :     return s;
; 603  :   }

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??$linear_search_plain_compare@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIHHABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::linear_search_plain_compare<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
_comp$ = 12						; size = 1
?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z PROC ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound, COMDAT
; _n$ = ecx

; 376  :   static int lower_bound(const K &k, const N &n, Compare comp)  {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :     return n.linear_search_plain_compare(k, 0, n.count(), comp);

  00003	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN21@lower_boun@2
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _k$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 08	 add	 ecx, 8
$LL7@lower_boun@2:
  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN25@lower_boun@2
  0001a	40		 inc	 eax
  0001b	83 c1 08	 add	 ecx, 8
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL7@lower_boun@2
$LN25@lower_boun@2:
  00022	5e		 pop	 esi
$LN21@lower_boun@2:

; 378  :   }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?lower_bound@?$btree_linear_search_plain_compare@IV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@btree@@SAHABIABV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@U?$btree_key_compare_to_adapter@U?$less@I@std@@@2@@Z ENDP ; btree::btree_linear_search_plain_compare<unsigned int,btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_key_compare_to_adapter<std::less<unsigned int> > >::lower_bound
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >, COMDAT
; _this$ = ecx

; 582  :   int lower_bound(const key_type &k, const Compare &comp) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  :     return search_type::lower_bound(k, *this, comp);

  00003	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN25@lower_boun@3
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _k$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 08	 add	 ecx, 8
$LL11@lower_boun@3:
  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN29@lower_boun@3
  0001a	40		 inc	 eax
  0001b	83 c1 08	 add	 ecx, 8
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL11@lower_boun@3
$LN29@lower_boun@3:
  00022	5e		 pop	 esi
$LN25@lower_boun@3:

; 584  :   }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$lower_bound@U?$btree_key_compare_to_adapter@U?$less@I@std@@@btree@@@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QBEHABIABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::lower_bound<btree::btree_key_compare_to_adapter<std::less<unsigned int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
$T180587 = -12						; size = 12
$T180565 = 8						; size = 4
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 541  : 		_Nodeptr _Buynode(_Nodeptr _Next,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 542  : 		_Nodeptr _Prev, _Valty&& _Val)
; 543  : 		{	// allocate a node and set links and value
; 544  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

  00006	6a 10		 push	 16			; 00000010H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	85 c0		 test	 eax, eax
  00012	74 22		 je	 SHORT $LN10@Buynode

; 545  : 
; 546  : 		_TRY_BEGIN
; 547  : 		this->_Nextnode(_Pnode) = _Next;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Next$[ebp]

; 548  : 		this->_Prevnode(_Pnode) = _Prev;

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Prev$[ebp]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 549  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Pnode)),
; 550  : 			_STD forward<_Valty>(_Val));

  0001c	8d 48 08	 lea	 ecx, DWORD PTR [eax+8]
  0001f	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00022	85 c9		 test	 ecx, ecx
  00024	74 0a		 je	 SHORT $LN2@Buynode
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	89 11		 mov	 DWORD PTR [ecx], edx
  0002a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Buynode:

; 551  : 		_CATCH_ALL
; 552  : 		this->_Alnod.deallocate(_Pnode, 1);
; 553  : 		_RERAISE;
; 554  : 		_CATCH_END
; 555  : 
; 556  : 		return (_Pnode);
; 557  : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8

; 542  : 		_Nodeptr _Prev, _Valty&& _Val)
; 543  : 		{	// allocate a node and set links and value
; 544  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

$LN10@Buynode:
  00036	8d 45 08	 lea	 eax, DWORD PTR $T180565[ebp]
  00039	50		 push	 eax
  0003a	8d 4d f4	 lea	 ecx, DWORD PTR $T180587[ebp]
  0003d	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T180565[ebp], 0
  00044	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00049	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0004e	8d 4d f4	 lea	 ecx, DWORD PTR $T180587[ebp]
  00051	51		 push	 ecx
  00052	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T180587[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00059	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN59@Buynode:
$LN58@Buynode:
  0005e	cc		 int	 3
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_iter$ = 12						; size = 8
??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = eax

; 2238 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 7d 0c	 mov	 edi, DWORD PTR _iter$[ebp]
  00009	8d a4 24 00 00
	00 00		 npad	 7
$LL3@internal_l@2:

; 2239 :   for (;;) {
; 2240 :     iter.position = iter.node->lower_bound(key, key_comp());

  00010	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  00014	33 c9		 xor	 ecx, ecx
  00016	85 f6		 test	 esi, esi
  00018	7e 14		 jle	 SHORT $LN61@internal_l@2
  0001a	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  0001d	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0001f	8d 57 08	 lea	 edx, DWORD PTR [edi+8]
$LL18@internal_l@2:
  00022	39 1a		 cmp	 DWORD PTR [edx], ebx
  00024	73 08		 jae	 SHORT $LN61@internal_l@2
  00026	41		 inc	 ecx
  00027	83 c2 08	 add	 edx, 8
  0002a	3b ce		 cmp	 ecx, esi
  0002c	7c f4		 jl	 SHORT $LL18@internal_l@2
$LN61@internal_l@2:
  0002e	89 4d 10	 mov	 DWORD PTR _iter$[ebp+4], ecx

; 2241 :     if (iter.node->leaf()) {

  00031	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00034	75 0c		 jne	 SHORT $LN59@internal_l@2

; 2242 :       break;
; 2243 :     }
; 2244 :     iter.node = iter.node->child(iter.position);

  00036	8b bc 8f 00 01
	00 00		 mov	 edi, DWORD PTR [edi+ecx*4+256]
  0003d	89 7d 0c	 mov	 DWORD PTR _iter$[ebp], edi

; 2245 :   }

  00040	eb ce		 jmp	 SHORT $LL3@internal_l@2
$LN59@internal_l@2:

; 2246 :   return std::make_pair(iter, 0);

  00042	89 38		 mov	 DWORD PTR [eax], edi
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00049	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  00050	5b		 pop	 ebx

; 2247 : }

  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z
_TEXT	SEGMENT
?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root, COMDAT
; _f$ = eax
; _parent$ = ecx

; 707  :     btree_node *n = init_internal(f, parent);

  00000	32 d2		 xor	 dl, dl
  00002	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00008	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 708  :     f->rightmost = parent;

  00010	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx

; 709  :     f->size = parent->count();

  00016	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0001a	89 88 84 01 00
	00		 mov	 DWORD PTR [eax+388], ecx

; 710  :     return n;
; 711  :   }

  00020	c3		 ret	 0
?init_root@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@SAPAV12@PAUroot_fields@12@PAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::init_root
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z
_TEXT	SEGMENT
$T180948 = -12						; size = 12
$T180926 = 8						; size = 4
_parent$ = 8						; size = 4
?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node, COMDAT

; 1252 :   node_type* new_leaf_node(node_type *parent) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1253 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1254 :         mutable_internal_allocator()->allocate(sizeof(leaf_fields)));

  00006	68 00 01 00 00	 push	 256			; 00000100H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 12		 je	 SHORT $LN7@new_leaf_n

; 1255 :     return node_type::init_leaf(p, parent, kNodeValues);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  0001c	c7 00 01 00 1f
	00		 mov	 DWORD PTR [eax], 2031617 ; 001f0001H
  00022	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1256 :   }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4

; 1253 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1254 :         mutable_internal_allocator()->allocate(sizeof(leaf_fields)));

$LN7@new_leaf_n:
  0002b	8d 55 08	 lea	 edx, DWORD PTR $T180926[ebp]
  0002e	89 4d 08	 mov	 DWORD PTR $T180926[ebp], ecx
  00031	52		 push	 edx
  00032	8d 4d f4	 lea	 ecx, DWORD PTR $T180948[ebp]
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0003f	8d 45 f4	 lea	 eax, DWORD PTR $T180948[ebp]
  00042	50		 push	 eax
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T180948[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@new_leaf_n:
$LN21@new_leaf_n:
  0004f	cc		 int	 3
?new_leaf_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ
_TEXT	SEGMENT
$T180994 = -12						; size = 12
$T180972 = 8						; size = 4
_this$ = 8						; size = 4
?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node, COMDAT

; 1247 :   node_type* new_internal_root_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1248 :     root_fields *p = reinterpret_cast<root_fields*>(
; 1249 :         mutable_internal_allocator()->allocate(sizeof(root_fields)));

  00006	68 88 01 00 00	 push	 392			; 00000188H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 d2		 xor	 edx, edx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c2		 cmp	 eax, edx
  00017	74 2c		 je	 SHORT $LN7@new_intern

; 1250 :     return node_type::init_root(p, root()->parent());

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00021	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00027	88 50 03	 mov	 BYTE PTR [eax+3], dl
  0002a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0002d	88 10		 mov	 BYTE PTR [eax], dl
  0002f	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx
  00035	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00039	89 90 84 01 00
	00		 mov	 DWORD PTR [eax+388], edx

; 1251 :   }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4

; 1248 :     root_fields *p = reinterpret_cast<root_fields*>(
; 1249 :         mutable_internal_allocator()->allocate(sizeof(root_fields)));

$LN7@new_intern:
  00045	8d 45 08	 lea	 eax, DWORD PTR $T180972[ebp]
  00048	50		 push	 eax
  00049	8d 4d f4	 lea	 ecx, DWORD PTR $T180994[ebp]
  0004c	89 55 08	 mov	 DWORD PTR $T180972[ebp], edx
  0004f	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00054	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00059	8d 4d f4	 lea	 ecx, DWORD PTR $T180994[ebp]
  0005c	51		 push	 ecx
  0005d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T180994[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00064	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@new_intern:
$LN32@new_intern:
  00069	cc		 int	 3
?new_internal_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@XZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_root_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z
_TEXT	SEGMENT
$T181074 = -12						; size = 12
$T181052 = 8						; size = 4
_parent$ = 8						; size = 4
?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node, COMDAT

; 1242 :   node_type* new_internal_node(node_type *parent) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1243 :     internal_fields *p = reinterpret_cast<internal_fields*>(
; 1244 :         mutable_internal_allocator()->allocate(sizeof(internal_fields)));

  00006	68 80 01 00 00	 push	 384			; 00000180H
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 17		 je	 SHORT $LN7@new_intern@2

; 1245 :     return node_type::init_internal(p, parent);

  00019	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  0001c	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  00022	88 48 03	 mov	 BYTE PTR [eax+3], cl
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00028	88 08		 mov	 BYTE PTR [eax], cl

; 1246 :   }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4

; 1243 :     internal_fields *p = reinterpret_cast<internal_fields*>(
; 1244 :         mutable_internal_allocator()->allocate(sizeof(internal_fields)));

$LN7@new_intern@2:
  00030	8d 45 08	 lea	 eax, DWORD PTR $T181052[ebp]
  00033	89 4d 08	 mov	 DWORD PTR $T181052[ebp], ecx
  00036	50		 push	 eax
  00037	8d 4d f4	 lea	 ecx, DWORD PTR $T181074[ebp]
  0003a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00044	8d 4d f4	 lea	 ecx, DWORD PTR $T181074[ebp]
  00047	51		 push	 ecx
  00048	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T181074[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN25@new_intern@2:
$LN24@new_intern@2:
  00054	cc		 int	 3
?new_internal_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@PAV32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_internal_node
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 746  : 		void _Insert_rv(const_iterator _Where,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 747  : 		_Valty&& _Val)
; 748  : 		{	// insert _Val at _Where
; 749  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 750  : 		if (_Where._Getcont() != this)
; 751  : 			_DEBUG_ERROR("list insert iterator outside range");
; 752  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 753  : 
; 754  : 		_Nodeptr _Pnode = _Where._Mynode();
; 755  : 		_Nodeptr _Newnode =
; 756  : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
; 757  : 				_STD forward<_Valty>(_Val));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00009	53		 push	 ebx
  0000a	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000d	57		 push	 edi
  0000e	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00011	51		 push	 ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >

; 758  : 		_Incsize(1);

  00018	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001b	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  00020	2b d1		 sub	 edx, ecx
  00022	83 fa 01	 cmp	 edx, 1
  00025	73 0a		 jae	 SHORT $LN9@Insert_rv
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN26@Insert_rv:
$LN9@Insert_rv:
  00031	41		 inc	 ecx
  00032	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx

; 759  : 		this->_Prevnode(_Pnode) = _Newnode;

  00035	89 07		 mov	 DWORD PTR [edi], eax

; 760  : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	5f		 pop	 edi
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	5b		 pop	 ebx

; 761  : 		}

  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
$LN25@Insert_rv:
??$_Insert_rv@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Insert_rv<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_k$ = 8							; size = 4
_iter$ = 12						; size = 8
??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi

; 840  :   static std::pair<Iter, int> dispatch(const K &k, const T &t, Iter iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 841  :     return t.internal_locate_plain_compare(k, iter);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	8b c4		 mov	 eax, esp
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 55 10	 mov	 edx, DWORD PTR _iter$[ebp+4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  00016	50		 push	 eax
  00017	8b c6		 mov	 eax, esi
  00019	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0001e	8b c6		 mov	 eax, esi

; 842  :   }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$dispatch@IV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@btree_internal_locate_plain_compare@btree@@SA?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIABV?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@1@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree_internal_locate_plain_compare::dispatch<unsigned int,btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z
_TEXT	SEGMENT
_n$ = -12						; size = 4
__Tmp$181360 = -8					; size = 4
__Tmp$181349 = -8					; size = 4
$T181157 = -8						; size = 4
tv276 = -4						; size = 4
tv203 = -4						; size = 4
$T181156 = -4						; size = 4
?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap, COMDAT
; _this$ = edx
; _x$ = edi

; 1624 : void btree_node<P>::swap(btree_node *x) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1625 :   assert(leaf() == x->leaf());
; 1626 : 
; 1627 :   // Swap the values.
; 1628 :   for (int i = count(); i < x->count(); ++i) {

  00003	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  00007	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	53		 push	 ebx
  0000f	56		 push	 esi
  00010	3b c1		 cmp	 eax, ecx
  00012	7d 21		 jge	 SHORT $LN154@swap
  00014	8d 4c c2 08	 lea	 ecx, DWORD PTR [edx+eax*8+8]
$LL25@swap:

; 1629 :     value_init(i);

  00018	85 c9		 test	 ecx, ecx
  0001a	74 0d		 je	 SHORT $LN34@swap
  0001c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00022	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN34@swap:

; 1625 :   assert(leaf() == x->leaf());
; 1626 : 
; 1627 :   // Swap the values.
; 1628 :   for (int i = count(); i < x->count(); ++i) {

  00029	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  0002d	40		 inc	 eax
  0002e	83 c1 08	 add	 ecx, 8
  00031	3b c6		 cmp	 eax, esi
  00033	7c e3		 jl	 SHORT $LL25@swap
$LN154@swap:

; 1630 :   }
; 1631 :   for (int i = x->count(); i < count(); ++i) {

  00035	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00039	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0003d	3b c1		 cmp	 eax, ecx
  0003f	7d 21		 jge	 SHORT $LN155@swap
  00041	8d 4c c7 08	 lea	 ecx, DWORD PTR [edi+eax*8+8]
$LL22@swap:

; 1632 :     x->value_init(i);

  00045	85 c9		 test	 ecx, ecx
  00047	74 0d		 je	 SHORT $LN48@swap
  00049	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0004f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
$LN48@swap:

; 1630 :   }
; 1631 :   for (int i = x->count(); i < count(); ++i) {

  00056	0f b6 72 03	 movzx	 esi, BYTE PTR [edx+3]
  0005a	40		 inc	 eax
  0005b	83 c1 08	 add	 ecx, 8
  0005e	3b c6		 cmp	 eax, esi
  00060	7c e3		 jl	 SHORT $LL22@swap
$LN155@swap:

; 1633 :   }
; 1634 :   int n = std::max(count(), x->count());

  00062	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  00066	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  0006a	89 45 fc	 mov	 DWORD PTR $T181156[ebp], eax
  0006d	3b c8		 cmp	 ecx, eax
  0006f	89 4d f8	 mov	 DWORD PTR $T181157[ebp], ecx
  00072	8d 45 fc	 lea	 eax, DWORD PTR $T181156[ebp]
  00075	7c 03		 jl	 SHORT $LN63@swap
  00077	8d 45 f8	 lea	 eax, DWORD PTR $T181157[ebp]
$LN63@swap:
  0007a	8b 18		 mov	 ebx, DWORD PTR [eax]
  0007c	89 5d f4	 mov	 DWORD PTR _n$[ebp], ebx

; 1635 :   for (int i = 0; i < n; ++i) {

  0007f	85 db		 test	 ebx, ebx
  00081	7e 3b		 jle	 SHORT $LN17@swap
  00083	8b f7		 mov	 esi, edi
  00085	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00088	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0008b	2b f2		 sub	 esi, edx
  0008d	89 5d fc	 mov	 DWORD PTR tv276[ebp], ebx
$LL19@swap:

; 1636 :     value_swap(i, x, i);

  00090	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
  00093	89 5d f8	 mov	 DWORD PTR __Tmp$181349[ebp], ebx
  00096	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00098	89 58 fc	 mov	 DWORD PTR [eax-4], ebx
  0009b	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$181349[ebp]
  0009e	89 19		 mov	 DWORD PTR [ecx], ebx
  000a0	8b 18		 mov	 ebx, DWORD PTR [eax]
  000a2	89 5d f8	 mov	 DWORD PTR __Tmp$181360[ebp], ebx
  000a5	8b 1c 06	 mov	 ebx, DWORD PTR [esi+eax]
  000a8	89 18		 mov	 DWORD PTR [eax], ebx
  000aa	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$181360[ebp]
  000ad	89 1c 06	 mov	 DWORD PTR [esi+eax], ebx
  000b0	83 c1 08	 add	 ecx, 8
  000b3	83 c0 08	 add	 eax, 8
  000b6	ff 4d fc	 dec	 DWORD PTR tv276[ebp]
  000b9	75 d5		 jne	 SHORT $LL19@swap

; 1635 :   for (int i = 0; i < n; ++i) {

  000bb	8b 5d f4	 mov	 ebx, DWORD PTR _n$[ebp]
$LN17@swap:

; 1637 :   }
; 1638 :   for (int i = count(); i < x->count(); ++i) {
; 1639 :     x->value_destroy(i);
; 1640 :   }
; 1641 :   for (int i = x->count(); i < count(); ++i) {
; 1642 :     value_destroy(i);
; 1643 :   }
; 1644 : 
; 1645 :   if (!leaf()) {

  000be	80 3a 00	 cmp	 BYTE PTR [edx], 0
  000c1	75 60		 jne	 SHORT $LN1@swap

; 1646 :     // Swap the child pointers.
; 1647 :     for (int i = 0; i <= n; ++i) {

  000c3	85 db		 test	 ebx, ebx
  000c5	78 20		 js	 SHORT $LN156@swap
  000c7	8b cf		 mov	 ecx, edi
  000c9	2b ca		 sub	 ecx, edx
  000cb	43		 inc	 ebx
  000cc	8d 82 00 01 00
	00		 lea	 eax, DWORD PTR [edx+256]
  000d2	89 5d fc	 mov	 DWORD PTR tv203[ebp], ebx
$LL9@swap:

; 1648 :       btree_swap_helper(*mutable_child(i), *x->mutable_child(i));

  000d5	8b 1c 08	 mov	 ebx, DWORD PTR [eax+ecx]
  000d8	8b 30		 mov	 esi, DWORD PTR [eax]
  000da	89 18		 mov	 DWORD PTR [eax], ebx
  000dc	89 34 08	 mov	 DWORD PTR [eax+ecx], esi
  000df	83 c0 04	 add	 eax, 4
  000e2	ff 4d fc	 dec	 DWORD PTR tv203[ebp]
  000e5	75 ee		 jne	 SHORT $LL9@swap
$LN156@swap:

; 1649 :     }
; 1650 :     for (int i = 0; i <= count(); ++i) {

  000e7	33 c0		 xor	 eax, eax
  000e9	38 42 03	 cmp	 BYTE PTR [edx+3], al
  000ec	72 17		 jb	 SHORT $LN157@swap
  000ee	8d 8f 00 01 00
	00		 lea	 ecx, DWORD PTR [edi+256]
$LL6@swap:

; 1651 :       x->child(i)->fields_.parent = x;

  000f4	8b 31		 mov	 esi, DWORD PTR [ecx]
  000f6	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000f9	0f b6 72 03	 movzx	 esi, BYTE PTR [edx+3]
  000fd	40		 inc	 eax
  000fe	83 c1 04	 add	 ecx, 4
  00101	3b c6		 cmp	 eax, esi
  00103	7e ef		 jle	 SHORT $LL6@swap
$LN157@swap:

; 1652 :     }
; 1653 :     for (int i = 0; i <= x->count(); ++i) {

  00105	33 c0		 xor	 eax, eax
  00107	38 47 03	 cmp	 BYTE PTR [edi+3], al
  0010a	72 17		 jb	 SHORT $LN1@swap
  0010c	8d 8a 00 01 00
	00		 lea	 ecx, DWORD PTR [edx+256]
$LL3@swap:

; 1654 :       child(i)->fields_.parent = this;

  00112	8b 31		 mov	 esi, DWORD PTR [ecx]
  00114	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00117	0f b6 77 03	 movzx	 esi, BYTE PTR [edi+3]
  0011b	40		 inc	 eax
  0011c	83 c1 04	 add	 ecx, 4
  0011f	3b c6		 cmp	 eax, esi
  00121	7e ef		 jle	 SHORT $LL3@swap
$LN1@swap:

; 1655 :     }
; 1656 :   }
; 1657 : 
; 1658 :   // Swap the counts.
; 1659 :   btree_swap_helper(fields_.count, x->fields_.count);

  00123	8a 4f 03	 mov	 cl, BYTE PTR [edi+3]
  00126	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  00129	5e		 pop	 esi
  0012a	88 4a 03	 mov	 BYTE PTR [edx+3], cl
  0012d	88 47 03	 mov	 BYTE PTR [edi+3], al
  00130	5b		 pop	 ebx

; 1660 : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
tv987 = -12						; size = 4
__Tmp$182075 = -12					; size = 4
__Tmp$182064 = -12					; size = 4
__Tmp$181936 = -12					; size = 4
__Tmp$181925 = -12					; size = 4
__Tmp$181662 = -12					; size = 4
__Tmp$181651 = -12					; size = 4
tv1096 = -8						; size = 4
_i$162273 = -8						; size = 4
_i$162264 = -8						; size = 4
tv1045 = -4						; size = 4
?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right, COMDAT
; _this$ = esi
; _dest$ = eax
; _to_move$ = ecx

; 1506 : void btree_node<P>::rebalance_left_to_right(btree_node *dest, int to_move) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1507 :   assert(parent() == dest->parent());
; 1508 :   assert(position() + 1 == dest->position());
; 1509 :   assert(count() >= dest->count());
; 1510 :   assert(to_move >= 1);
; 1511 :   assert(to_move <= count());
; 1512 : 
; 1513 :   // Make room in the right node for the new values.
; 1514 :   for (int i = 0; i < to_move; ++i) {

  00007	33 db		 xor	 ebx, ebx
  00009	33 d2		 xor	 edx, edx
  0000b	57		 push	 edi
  0000c	3b cb		 cmp	 ecx, ebx
  0000e	7e 18		 jle	 SHORT $LN14@rebalance_
$LL16@rebalance_:

; 1515 :     dest->value_init(i + dest->count());

  00010	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  00014	03 fa		 add	 edi, edx
  00016	8d 7c f8 08	 lea	 edi, DWORD PTR [eax+edi*8+8]
  0001a	3b fb		 cmp	 edi, ebx
  0001c	74 05		 je	 SHORT $LN23@rebalance_
  0001e	89 1f		 mov	 DWORD PTR [edi], ebx
  00020	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN23@rebalance_:

; 1507 :   assert(parent() == dest->parent());
; 1508 :   assert(position() + 1 == dest->position());
; 1509 :   assert(count() >= dest->count());
; 1510 :   assert(to_move >= 1);
; 1511 :   assert(to_move <= count());
; 1512 : 
; 1513 :   // Make room in the right node for the new values.
; 1514 :   for (int i = 0; i < to_move; ++i) {

  00023	42		 inc	 edx
  00024	3b d1		 cmp	 edx, ecx
  00026	7c e8		 jl	 SHORT $LL16@rebalance_
$LN14@rebalance_:

; 1516 :   }
; 1517 :   for (int i = dest->count() - 1; i >= 0; --i) {

  00028	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  0002c	4a		 dec	 edx
  0002d	89 55 f8	 mov	 DWORD PTR _i$162264[ebp], edx
  00030	78 3f		 js	 SHORT $LN11@rebalance_
  00032	8d 7c d0 08	 lea	 edi, DWORD PTR [eax+edx*8+8]
  00036	03 d1		 add	 edx, ecx
  00038	8d 54 d0 08	 lea	 edx, DWORD PTR [eax+edx*8+8]
  0003c	8d 64 24 00	 npad	 4
$LL13@rebalance_:

; 1518 :     dest->value_swap(i, dest, i + to_move);

  00040	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00042	89 5d f4	 mov	 DWORD PTR __Tmp$181651[ebp], ebx
  00045	8b 1a		 mov	 ebx, DWORD PTR [edx]
  00047	89 1f		 mov	 DWORD PTR [edi], ebx
  00049	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$181651[ebp]
  0004c	89 1a		 mov	 DWORD PTR [edx], ebx
  0004e	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00051	89 5d f4	 mov	 DWORD PTR __Tmp$181662[ebp], ebx
  00054	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00057	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0005a	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$181662[ebp]
  0005d	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  00060	8b 5d f8	 mov	 ebx, DWORD PTR _i$162264[ebp]
  00063	4b		 dec	 ebx
  00064	83 ea 08	 sub	 edx, 8
  00067	83 ef 08	 sub	 edi, 8
  0006a	89 5d f8	 mov	 DWORD PTR _i$162264[ebp], ebx
  0006d	85 db		 test	 ebx, ebx
  0006f	79 cf		 jns	 SHORT $LL13@rebalance_
$LN11@rebalance_:

; 1519 :   }
; 1520 : 
; 1521 :   // Move the delimiting value to the right node and the new delimiting value
; 1522 :   // from the left node.
; 1523 :   dest->value_swap(to_move - 1, parent(), position());

  00071	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  00075	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00078	8b 5c d7 08	 mov	 ebx, DWORD PTR [edi+edx*8+8]
  0007c	8d 54 d7 08	 lea	 edx, DWORD PTR [edi+edx*8+8]
  00080	8b 3c c8	 mov	 edi, DWORD PTR [eax+ecx*8]
  00083	89 1c c8	 mov	 DWORD PTR [eax+ecx*8], ebx
  00086	89 3a		 mov	 DWORD PTR [edx], edi
  00088	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0008b	8b 7c c8 04	 mov	 edi, DWORD PTR [eax+ecx*8+4]
  0008f	89 5c c8 04	 mov	 DWORD PTR [eax+ecx*8+4], ebx
  00093	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1524 :   parent()->value_swap(position(), this, count() - to_move);

  00096	0f b6 7e 01	 movzx	 edi, BYTE PTR [esi+1]
  0009a	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  0009e	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000a1	8d 7c fb 08	 lea	 edi, DWORD PTR [ebx+edi*8+8]
  000a5	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000a7	2b d1		 sub	 edx, ecx
  000a9	8d 54 d6 08	 lea	 edx, DWORD PTR [esi+edx*8+8]
  000ad	89 5d f4	 mov	 DWORD PTR __Tmp$181925[ebp], ebx
  000b0	8b 1a		 mov	 ebx, DWORD PTR [edx]
  000b2	89 1f		 mov	 DWORD PTR [edi], ebx
  000b4	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$181925[ebp]
  000b7	89 1a		 mov	 DWORD PTR [edx], ebx
  000b9	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000bc	89 5d f4	 mov	 DWORD PTR __Tmp$181936[ebp], ebx
  000bf	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c2	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000c5	8b 7d f4	 mov	 edi, DWORD PTR __Tmp$181936[ebp]
  000c8	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1525 :   value_destroy(count() - to_move);
; 1526 : 
; 1527 :   // Move the values from the left to the right node.
; 1528 :   for (int i = 1; i < to_move; ++i) {

  000cb	ba 01 00 00 00	 mov	 edx, 1
  000d0	3b ca		 cmp	 ecx, edx
  000d2	7e 37		 jle	 SHORT $LN209@rebalance_
$LL10@rebalance_:

; 1529 :     value_swap(count() - to_move + i, dest, i - 1);

  000d4	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  000d8	2b f9		 sub	 edi, ecx
  000da	03 fa		 add	 edi, edx
  000dc	8b 5c fe 08	 mov	 ebx, DWORD PTR [esi+edi*8+8]
  000e0	8d 7c fe 08	 lea	 edi, DWORD PTR [esi+edi*8+8]
  000e4	89 5d f4	 mov	 DWORD PTR __Tmp$182064[ebp], ebx
  000e7	8b 1c d0	 mov	 ebx, DWORD PTR [eax+edx*8]
  000ea	89 1f		 mov	 DWORD PTR [edi], ebx
  000ec	8b 5d f4	 mov	 ebx, DWORD PTR __Tmp$182064[ebp]
  000ef	89 1c d0	 mov	 DWORD PTR [eax+edx*8], ebx
  000f2	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000f5	89 5d f4	 mov	 DWORD PTR __Tmp$182075[ebp], ebx
  000f8	8b 5c d0 04	 mov	 ebx, DWORD PTR [eax+edx*8+4]
  000fc	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000ff	8b 7d f4	 mov	 edi, DWORD PTR __Tmp$182075[ebp]
  00102	89 7c d0 04	 mov	 DWORD PTR [eax+edx*8+4], edi
  00106	42		 inc	 edx
  00107	3b d1		 cmp	 edx, ecx
  00109	7c c9		 jl	 SHORT $LL10@rebalance_
$LN209@rebalance_:

; 1530 :     value_destroy(count() - to_move + i);
; 1531 :   }
; 1532 : 
; 1533 :   if (!leaf()) {

  0010b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0010e	0f 85 97 00 00
	00		 jne	 $LN208@rebalance_

; 1534 :     // Move the child pointers from the left to the right node.
; 1535 :     for (int i = dest->count(); i >= 0; --i) {

  00114	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  00118	89 55 f8	 mov	 DWORD PTR _i$162273[ebp], edx
  0011b	85 d2		 test	 edx, edx
  0011d	78 41		 js	 SHORT $LN4@rebalance_
  0011f	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]
  00122	89 7d f4	 mov	 DWORD PTR tv987[ebp], edi
  00125	8d bc b8 00 01
	00 00		 lea	 edi, DWORD PTR [eax+edi*4+256]
  0012c	8d 94 90 00 01
	00 00		 lea	 edx, DWORD PTR [eax+edx*4+256]
  00133	89 7d fc	 mov	 DWORD PTR tv1045[ebp], edi
$LL6@rebalance_:

; 1536 :       dest->set_child(i + to_move, dest->child(i));

  00136	8b 3a		 mov	 edi, DWORD PTR [edx]
  00138	8b 5d fc	 mov	 ebx, DWORD PTR tv1045[ebp]
  0013b	ff 4d f8	 dec	 DWORD PTR _i$162273[ebp]
  0013e	83 6d fc 04	 sub	 DWORD PTR tv1045[ebp], 4
  00142	89 3b		 mov	 DWORD PTR [ebx], edi
  00144	8b 5d f4	 mov	 ebx, DWORD PTR tv987[ebp]
  00147	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  0014a	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1537 :       *dest->mutable_child(i) = NULL;

  0014d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00153	4b		 dec	 ebx
  00154	83 ea 04	 sub	 edx, 4
  00157	83 7d f8 00	 cmp	 DWORD PTR _i$162273[ebp], 0
  0015b	89 5d f4	 mov	 DWORD PTR tv987[ebp], ebx
  0015e	7d d6		 jge	 SHORT $LL6@rebalance_
$LN4@rebalance_:

; 1538 :     }
; 1539 :     for (int i = 1; i <= to_move; ++i) {

  00160	ba 01 00 00 00	 mov	 edx, 1
  00165	3b ca		 cmp	 ecx, edx
  00167	7c 42		 jl	 SHORT $LN208@rebalance_
  00169	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  0016f	89 7d f8	 mov	 DWORD PTR tv1096[ebp], edi
$LL3@rebalance_:

; 1540 :       dest->set_child(i - 1, child(count() - to_move + i));

  00172	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  00176	8b 5d f8	 mov	 ebx, DWORD PTR tv1096[ebp]
  00179	83 45 f8 04	 add	 DWORD PTR tv1096[ebp], 4
  0017d	2b f9		 sub	 edi, ecx
  0017f	03 fa		 add	 edi, edx
  00181	8b bc be 00 01
	00 00		 mov	 edi, DWORD PTR [esi+edi*4+256]
  00188	89 3b		 mov	 DWORD PTR [ebx], edi
  0018a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0018d	8d 5a ff	 lea	 ebx, DWORD PTR [edx-1]
  00190	88 5f 01	 mov	 BYTE PTR [edi+1], bl

; 1541 :       *mutable_child(count() - to_move + i) = NULL;

  00193	0f b6 7e 03	 movzx	 edi, BYTE PTR [esi+3]
  00197	2b f9		 sub	 edi, ecx
  00199	03 fa		 add	 edi, edx
  0019b	42		 inc	 edx
  0019c	c7 84 be 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi*4+256], 0
  001a7	3b d1		 cmp	 edx, ecx
  001a9	7e c7		 jle	 SHORT $LL3@rebalance_
$LN208@rebalance_:

; 1542 :     }
; 1543 :   }
; 1544 : 
; 1545 :   // Fixup the counts on the src and dest nodes.
; 1546 :   set_count(count() - to_move);

  001ab	28 4e 03	 sub	 BYTE PTR [esi+3], cl

; 1547 :   dest->set_count(dest->count() + to_move);

  001ae	00 48 03	 add	 BYTE PTR [eax+3], cl
  001b1	5f		 pop	 edi
  001b2	5b		 pop	 ebx

; 1548 : }

  001b3	8b e5		 mov	 esp, ebp
  001b5	5d		 pop	 ebp
  001b6	c3		 ret	 0
?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
tv916 = -8						; size = 4
__Tmp$182727 = -8					; size = 4
__Tmp$182716 = -8					; size = 4
$T182754 = -8						; size = 4
_i$162243 = -8						; size = 4
tv984 = -4						; size = 4
$T182761 = -4						; size = 4
tv1040 = 8						; size = 4
__Tmp$182593 = 8					; size = 4
__Tmp$182582 = 8					; size = 4
$T182742 = 8						; size = 4
__Tmp$182314 = 8					; size = 4
__Tmp$182302 = 8					; size = 4
_i$162230 = 8						; size = 4
_this$ = 8						; size = 4
?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left, COMDAT
; _src$ = eax
; _to_move$ = edx

; 1459 : void btree_node<P>::rebalance_right_to_left(btree_node *src, int to_move) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 1460 :   assert(parent() == src->parent());
; 1461 :   assert(position() + 1 == src->position());
; 1462 :   assert(src->count() >= count());
; 1463 :   assert(to_move >= 1);
; 1464 :   assert(to_move <= src->count());
; 1465 : 
; 1466 :   // Make room in the left node for the new values.
; 1467 :   for (int i = 0; i < to_move; ++i) {

  0000b	33 db		 xor	 ebx, ebx
  0000d	33 f6		 xor	 esi, esi
  0000f	57		 push	 edi
  00010	3b d3		 cmp	 edx, ebx
  00012	7e 18		 jle	 SHORT $LN17@rebalance_@2
$LL19@rebalance_@2:

; 1468 :     value_init(i + count());

  00014	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00018	03 fe		 add	 edi, esi
  0001a	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  0001e	3b fb		 cmp	 edi, ebx
  00020	74 05		 je	 SHORT $LN26@rebalance_@2
  00022	89 1f		 mov	 DWORD PTR [edi], ebx
  00024	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN26@rebalance_@2:

; 1460 :   assert(parent() == src->parent());
; 1461 :   assert(position() + 1 == src->position());
; 1462 :   assert(src->count() >= count());
; 1463 :   assert(to_move >= 1);
; 1464 :   assert(to_move <= src->count());
; 1465 : 
; 1466 :   // Make room in the left node for the new values.
; 1467 :   for (int i = 0; i < to_move; ++i) {

  00027	46		 inc	 esi
  00028	3b f2		 cmp	 esi, edx
  0002a	7c e8		 jl	 SHORT $LL19@rebalance_@2
$LN17@rebalance_@2:

; 1469 :   }
; 1470 : 
; 1471 :   // Move the delimiting value to the left node and the new delimiting value
; 1472 :   // from the right node.
; 1473 :   value_swap(count(), parent(), position());

  0002c	0f b6 71 01	 movzx	 esi, BYTE PTR [ecx+1]
  00030	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00033	8d 74 f7 08	 lea	 esi, DWORD PTR [edi+esi*8+8]
  00037	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  0003b	8b 5c f9 08	 mov	 ebx, DWORD PTR [ecx+edi*8+8]
  0003f	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  00043	89 5d 08	 mov	 DWORD PTR __Tmp$182302[ebp], ebx
  00046	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00048	89 1f		 mov	 DWORD PTR [edi], ebx
  0004a	8b 5d 08	 mov	 ebx, DWORD PTR __Tmp$182302[ebp]
  0004d	89 1e		 mov	 DWORD PTR [esi], ebx
  0004f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  00052	89 5d 08	 mov	 DWORD PTR __Tmp$182314[ebp], ebx
  00055	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00058	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0005b	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$182314[ebp]
  0005e	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 1474 :   parent()->value_swap(position(), src, to_move - 1);

  00061	0f b6 71 01	 movzx	 esi, BYTE PTR [ecx+1]
  00065	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00068	8b 1c d0	 mov	 ebx, DWORD PTR [eax+edx*8]
  0006b	8d 74 f7 08	 lea	 esi, DWORD PTR [edi+esi*8+8]
  0006f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00071	89 1e		 mov	 DWORD PTR [esi], ebx
  00073	89 3c d0	 mov	 DWORD PTR [eax+edx*8], edi
  00076	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00079	8b 5c d0 04	 mov	 ebx, DWORD PTR [eax+edx*8+4]
  0007d	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 1475 : 
; 1476 :   // Move the values from the right to the left node.
; 1477 :   for (int i = 1; i < to_move; ++i) {

  00080	be 01 00 00 00	 mov	 esi, 1
  00085	89 7c d0 04	 mov	 DWORD PTR [eax+edx*8+4], edi
  00089	3b d6		 cmp	 edx, esi
  0008b	7e 38		 jle	 SHORT $LN208@rebalance_@2
  0008d	8d 49 00	 npad	 3
$LL16@rebalance_@2:

; 1478 :     value_swap(count() + i, src, i - 1);

  00090	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00094	03 fe		 add	 edi, esi
  00096	8b 5c f9 08	 mov	 ebx, DWORD PTR [ecx+edi*8+8]
  0009a	8d 7c f9 08	 lea	 edi, DWORD PTR [ecx+edi*8+8]
  0009e	89 5d 08	 mov	 DWORD PTR __Tmp$182582[ebp], ebx
  000a1	8b 1c f0	 mov	 ebx, DWORD PTR [eax+esi*8]
  000a4	89 1f		 mov	 DWORD PTR [edi], ebx
  000a6	8b 5d 08	 mov	 ebx, DWORD PTR __Tmp$182582[ebp]
  000a9	89 1c f0	 mov	 DWORD PTR [eax+esi*8], ebx
  000ac	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000af	89 5d 08	 mov	 DWORD PTR __Tmp$182593[ebp], ebx
  000b2	8b 5c f0 04	 mov	 ebx, DWORD PTR [eax+esi*8+4]
  000b6	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000b9	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$182593[ebp]
  000bc	89 7c f0 04	 mov	 DWORD PTR [eax+esi*8+4], edi
  000c0	46		 inc	 esi
  000c1	3b f2		 cmp	 esi, edx
  000c3	7c cb		 jl	 SHORT $LL16@rebalance_@2
$LN208@rebalance_@2:

; 1479 :   }
; 1480 :   // Shift the values in the right node to their correct position.
; 1481 :   for (int i = to_move; i < src->count(); ++i) {

  000c5	0f b6 70 03	 movzx	 esi, BYTE PTR [eax+3]
  000c9	89 55 08	 mov	 DWORD PTR _i$162230[ebp], edx
  000cc	3b d6		 cmp	 edx, esi
  000ce	7d 4b		 jge	 SHORT $LN11@rebalance_@2
  000d0	8d 74 d0 08	 lea	 esi, DWORD PTR [eax+edx*8+8]
  000d4	8d 78 08	 lea	 edi, DWORD PTR [eax+8]
  000d7	eb 0a		 jmp	 SHORT $LN13@rebalance_@2
  000d9	8d a4 24 00 00
	00 00		 npad	 7
$LL207@rebalance_@2:
  000e0	8b 7d f8	 mov	 edi, DWORD PTR tv916[ebp]
$LN13@rebalance_@2:

; 1482 :     src->value_swap(i - to_move, src, i);

  000e3	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000e5	89 5d f8	 mov	 DWORD PTR __Tmp$182716[ebp], ebx
  000e8	8b 1e		 mov	 ebx, DWORD PTR [esi]
  000ea	89 1f		 mov	 DWORD PTR [edi], ebx
  000ec	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$182716[ebp]
  000ef	89 1e		 mov	 DWORD PTR [esi], ebx
  000f1	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  000f4	89 5d f8	 mov	 DWORD PTR __Tmp$182727[ebp], ebx
  000f7	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  000fa	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000fd	8b 5d f8	 mov	 ebx, DWORD PTR __Tmp$182727[ebp]
  00100	83 c7 08	 add	 edi, 8
  00103	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00106	8b 5d 08	 mov	 ebx, DWORD PTR _i$162230[ebp]
  00109	89 7d f8	 mov	 DWORD PTR tv916[ebp], edi
  0010c	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  00110	43		 inc	 ebx
  00111	83 c6 08	 add	 esi, 8
  00114	89 5d 08	 mov	 DWORD PTR _i$162230[ebp], ebx
  00117	3b df		 cmp	 ebx, edi
  00119	7c c5		 jl	 SHORT $LL207@rebalance_@2
$LN11@rebalance_@2:

; 1483 :   }
; 1484 :   for (int i = 1; i <= to_move; ++i) {
; 1485 :     src->value_destroy(src->count() - i);
; 1486 :   }
; 1487 : 
; 1488 :   if (!leaf()) {

  0011b	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0011e	0f 85 8b 00 00
	00		 jne	 $LN205@rebalance_@2

; 1489 :     // Move the child pointers from the right to the left node.
; 1490 :     for (int i = 0; i < to_move; ++i) {

  00124	33 f6		 xor	 esi, esi
  00126	85 d2		 test	 edx, edx
  00128	7e 38		 jle	 SHORT $LN4@rebalance_@2
  0012a	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  00130	89 7d fc	 mov	 DWORD PTR tv984[ebp], edi
$LL6@rebalance_@2:

; 1491 :       set_child(1 + count() + i, src->child(i));

  00133	8b 7d fc	 mov	 edi, DWORD PTR tv984[ebp]
  00136	8b 3f		 mov	 edi, DWORD PTR [edi]
  00138	83 45 fc 04	 add	 DWORD PTR tv984[ebp], 4
  0013c	89 7d 08	 mov	 DWORD PTR $T182742[ebp], edi
  0013f	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  00143	8d 7c 37 01	 lea	 edi, DWORD PTR [edi+esi+1]
  00147	89 7d f8	 mov	 DWORD PTR $T182754[ebp], edi
  0014a	8b 7d 08	 mov	 edi, DWORD PTR $T182742[ebp]
  0014d	8b 5d f8	 mov	 ebx, DWORD PTR $T182754[ebp]
  00150	46		 inc	 esi
  00151	89 bc 99 00 01
	00 00		 mov	 DWORD PTR [ecx+ebx*4+256], edi
  00158	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  0015b	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  0015e	3b f2		 cmp	 esi, edx
  00160	7c d1		 jl	 SHORT $LL6@rebalance_@2
$LN4@rebalance_@2:

; 1492 :     }
; 1493 :     for (int i = 0; i <= src->count() - to_move; ++i) {

  00162	0f b6 70 03	 movzx	 esi, BYTE PTR [eax+3]
  00166	2b f2		 sub	 esi, edx
  00168	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$162243[ebp], 0
  0016f	78 3e		 js	 SHORT $LN205@rebalance_@2
  00171	8d b8 00 01 00
	00		 lea	 edi, DWORD PTR [eax+256]
  00177	8d b4 90 00 01
	00 00		 lea	 esi, DWORD PTR [eax+edx*4+256]
  0017e	89 7d 08	 mov	 DWORD PTR tv1040[ebp], edi
$LL206@rebalance_@2:

; 1494 :       assert(i + to_move <= src->max_count());
; 1495 :       src->set_child(i, src->child(i + to_move));

  00181	8b 3e		 mov	 edi, DWORD PTR [esi]
  00183	8b 5d 08	 mov	 ebx, DWORD PTR tv1040[ebp]
  00186	83 45 08 04	 add	 DWORD PTR tv1040[ebp], 4
  0018a	89 3b		 mov	 DWORD PTR [ebx], edi
  0018c	8b 5d f8	 mov	 ebx, DWORD PTR _i$162243[ebp]
  0018f	88 5f 01	 mov	 BYTE PTR [edi+1], bl
  00192	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00195	89 7d fc	 mov	 DWORD PTR $T182761[ebp], edi

; 1496 :       *src->mutable_child(i + to_move) = NULL;

  00198	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0019e	0f b6 78 03	 movzx	 edi, BYTE PTR [eax+3]
  001a2	43		 inc	 ebx
  001a3	2b fa		 sub	 edi, edx
  001a5	83 c6 04	 add	 esi, 4
  001a8	89 5d f8	 mov	 DWORD PTR _i$162243[ebp], ebx
  001ab	3b df		 cmp	 ebx, edi
  001ad	7e d2		 jle	 SHORT $LL206@rebalance_@2
$LN205@rebalance_@2:

; 1497 :     }
; 1498 :   }
; 1499 : 
; 1500 :   // Fixup the counts on the src and dest nodes.
; 1501 :   set_count(count() + to_move);

  001af	00 51 03	 add	 BYTE PTR [ecx+3], dl

; 1502 :   src->set_count(src->count() - to_move);

  001b2	28 50 03	 sub	 BYTE PTR [eax+3], dl
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx

; 1503 : }

  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c2 04 00	 ret	 4
?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value, COMDAT
; _this$ = esi
; _i$ = eax
; _x$ = ecx

; 1422 : inline void btree_node<P>::insert_value(int i, const value_type &x) {

  00000	57		 push	 edi
  00001	8b f8		 mov	 edi, eax

; 1423 :   assert(i <= count());
; 1424 :   value_init(count(), x);

  00003	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00007	8d 44 c6 08	 lea	 eax, DWORD PTR [esi+eax*8+8]
  0000b	85 c0		 test	 eax, eax
  0000d	74 0a		 je	 SHORT $LN14@insert_val
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 10		 mov	 DWORD PTR [eax], edx
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN14@insert_val:

; 1425 :   for (int j = count(); j > i; --j) {

  00019	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0001d	3b cf		 cmp	 ecx, edi
  0001f	7e 24		 jle	 SHORT $LN5@insert_val
  00021	8d 44 ce 08	 lea	 eax, DWORD PTR [esi+ecx*8+8]
  00025	2b cf		 sub	 ecx, edi
  00027	53		 push	 ebx
$LL7@insert_val:

; 1426 :     value_swap(j, this, j - 1);

  00028	8b 58 f8	 mov	 ebx, DWORD PTR [eax-8]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	89 18		 mov	 DWORD PTR [eax], ebx
  0002f	89 50 f8	 mov	 DWORD PTR [eax-8], edx
  00032	8b 58 fc	 mov	 ebx, DWORD PTR [eax-4]
  00035	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00038	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0003b	89 50 fc	 mov	 DWORD PTR [eax-4], edx
  0003e	83 c0 f8	 add	 eax, -8			; fffffff8H
  00041	49		 dec	 ecx
  00042	75 e4		 jne	 SHORT $LL7@insert_val
  00044	5b		 pop	 ebx
$LN5@insert_val:

; 1427 :   }
; 1428 :   set_count(count() + 1);

  00045	fe 46 03	 inc	 BYTE PTR [esi+3]

; 1429 : 
; 1430 :   if (!leaf()) {

  00048	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0004b	8a 46 03	 mov	 al, BYTE PTR [esi+3]
  0004e	75 2b		 jne	 SHORT $LN4@insert_val

; 1432 :     for (int j = count(); j > i; --j) {

  00050	0f b6 c0	 movzx	 eax, al
  00053	47		 inc	 edi
  00054	3b c7		 cmp	 eax, edi
  00056	7e 18		 jle	 SHORT $LN1@insert_val

; 1431 :     ++i;

  00058	8d 8c 86 00 01
	00 00		 lea	 ecx, DWORD PTR [esi+eax*4+256]
  0005f	90		 npad	 1
$LL3@insert_val:

; 1433 :       *mutable_child(j) = child(j - 1);

  00060	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00063	89 11		 mov	 DWORD PTR [ecx], edx

; 1434 :       child(j)->set_position(j);

  00065	88 42 01	 mov	 BYTE PTR [edx+1], al
  00068	48		 dec	 eax
  00069	83 e9 04	 sub	 ecx, 4
  0006c	3b c7		 cmp	 eax, edi
  0006e	7f f0		 jg	 SHORT $LL3@insert_val
$LN1@insert_val:

; 1435 :     }
; 1436 :     *mutable_child(i) = NULL;

  00070	c7 84 be 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [esi+edi*4+256], 0
$LN4@insert_val:
  0007b	5f		 pop	 edi

; 1437 :   }
; 1438 : }

  0007c	c3		 ret	 0
?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T183030 = -16						; size = 12
$T183013 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode, COMDAT
; _this$ = esi

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	33 c9		 xor	 ecx, ecx
  0000f	83 c4 04	 add	 esp, 4
  00012	3b c1		 cmp	 eax, ecx
  00014	74 19		 je	 SHORT $LN5@Buynode@2

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00016	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001e	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  00027	66 89 48 14	 mov	 WORD PTR [eax+20], cx

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@2:
  0002f	8d 45 fc	 lea	 eax, DWORD PTR $T183013[ebp]
  00032	89 4d fc	 mov	 DWORD PTR $T183013[ebp], ecx
  00035	50		 push	 eax
  00036	8d 4d f0	 lea	 ecx, DWORD PTR $T183030[ebp]
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 4d f0	 lea	 ecx, DWORD PTR $T183030[ebp]
  00046	51		 push	 ecx
  00047	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T183030[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@2:
$LN26@Buynode@2:
  00053	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
$T183119 = -16						; size = 12
$T183071 = -4						; size = 4
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = esi
; __Val$ = edi

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00006	6a 18		 push	 24			; 00000018H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	33 d2		 xor	 edx, edx
  0000f	83 c4 04	 add	 esp, 4
  00012	3b c2		 cmp	 eax, edx
  00014	74 2a		 je	 SHORT $LN12@Buynode@3
  00016	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00019	89 08		 mov	 DWORD PTR [eax], ecx
  0001b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00021	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00024	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  00027	8d 48 0c	 lea	 ecx, DWORD PTR [eax+12]
  0002a	66 89 50 14	 mov	 WORD PTR [eax+20], dx
  0002e	3b ca		 cmp	 ecx, edx
  00030	74 0a		 je	 SHORT $LN2@Buynode@3
  00032	8b 17		 mov	 edx, DWORD PTR [edi]
  00034	89 11		 mov	 DWORD PTR [ecx], edx
  00036	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00039	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN2@Buynode@3:

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);
; 599  : 		}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@3:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T183071[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T183119[ebp]
  00047	89 55 fc	 mov	 DWORD PTR $T183071[ebp], edx
  0004a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0004f	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00054	8d 4d f0	 lea	 ecx, DWORD PTR $T183119[ebp]
  00057	51		 push	 ecx
  00058	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T183119[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0005f	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN68@Buynode@3:
$LN67@Buynode@3:
  00064	cc		 int	 3
??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_iter$ = 12						; size = 8
??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi

; 2232 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2233 :   return internal_locate_type::dispatch(key, *this, iter);

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00007	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  0000a	83 ec 08	 sub	 esp, 8
  0000d	8b c4		 mov	 eax, esp
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00014	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00017	50		 push	 eax
  00018	8b c6		 mov	 eax, esi
  0001a	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0001f	8b c6		 mov	 eax, esi
  00021	59		 pop	 ecx

; 2234 : }

  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
??$internal_locate@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z
_TEXT	SEGMENT
?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value, COMDAT
; _this$ = ecx
; _i$ = eax

; 1442 :   if (!leaf()) {

  00000	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f8		 mov	 edi, eax
  00007	75 3a		 jne	 SHORT $LN7@remove_val

; 1443 :     assert(child(i + 1)->count() == 0);
; 1444 :     for (int j = i + 1; j < count(); ++j) {

  00009	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0000d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  00010	3b c2		 cmp	 eax, edx
  00012	7d 20		 jge	 SHORT $LN4@remove_val
  00014	8d 94 81 00 01
	00 00		 lea	 edx, DWORD PTR [ecx+eax*4+256]
  0001b	eb 03 8d 49 00	 npad	 5
$LL6@remove_val:

; 1445 :       *mutable_child(j) = child(j + 1);

  00020	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00023	89 32		 mov	 DWORD PTR [edx], esi

; 1446 :       child(j)->set_position(j);

  00025	88 46 01	 mov	 BYTE PTR [esi+1], al
  00028	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  0002c	40		 inc	 eax
  0002d	83 c2 04	 add	 edx, 4
  00030	3b c6		 cmp	 eax, esi
  00032	7c ec		 jl	 SHORT $LL6@remove_val
$LN4@remove_val:

; 1447 :     }
; 1448 :     *mutable_child(count()) = NULL;

  00034	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00038	c7 84 81 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ecx+eax*4+256], 0
$LN7@remove_val:

; 1449 :   }
; 1450 : 
; 1451 :   set_count(count() - 1);

  00043	fe 49 03	 dec	 BYTE PTR [ecx+3]

; 1452 :   for (; i < count(); ++i) {

  00046	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0004a	3b fa		 cmp	 edi, edx
  0004c	7d 26		 jge	 SHORT $LN1@remove_val

; 1449 :   }
; 1450 : 
; 1451 :   set_count(count() - 1);

  0004e	8d 44 f9 0c	 lea	 eax, DWORD PTR [ecx+edi*8+12]
$LL3@remove_val:

; 1453 :     value_swap(i, this, i + 1);

  00052	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00055	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00058	89 70 fc	 mov	 DWORD PTR [eax-4], esi
  0005b	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005e	8b 10		 mov	 edx, DWORD PTR [eax]
  00060	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00063	89 30		 mov	 DWORD PTR [eax], esi
  00065	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00068	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  0006c	47		 inc	 edi
  0006d	83 c0 08	 add	 eax, 8
  00070	3b fa		 cmp	 edi, edx
  00072	7c de		 jl	 SHORT $LL3@remove_val
$LN1@remove_val:
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi

; 1454 :   }
; 1455 :   value_destroy(i);
; 1456 : }

  00076	c3		 ret	 0
?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink, COMDAT

; 2161 : void btree<P>::try_shrink() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00007	57		 push	 edi

; 2162 :   if (root()->count() > 0) {

  00008	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0000a	80 7f 03 00	 cmp	 BYTE PTR [edi+3], 0
  0000e	77 54		 ja	 SHORT $LN56@try_shrink

; 2163 :     return;
; 2164 :   }
; 2165 :   // Deleted the last item on the root node, shrink the height of the tree.
; 2166 :   if (root()->leaf()) {

  00010	80 3f 00	 cmp	 BYTE PTR [edi], 0
  00013	74 15		 je	 SHORT $LN4@try_shrink

; 2167 :     assert(size() == 0);
; 2168 :     delete_leaf_node(root());

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001b	83 c4 04	 add	 esp, 4
  0001e	5f		 pop	 edi

; 2169 :     *mutable_root() = NULL;

  0001f	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  00025	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@try_shrink:
  0002a	56		 push	 esi

; 2170 :   } else {
; 2171 :     node_type *child = root()->child(0);

  0002b	8b b7 00 01 00
	00		 mov	 esi, DWORD PTR [edi+256]

; 2172 :     if (child->leaf()) {

  00031	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00034	74 1d		 je	 SHORT $LN2@try_shrink

; 2173 :       // The child is a leaf node so simply make it the root node in the tree.
; 2174 :       child->make_root();

  00036	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2175 :       delete_internal_root_node();

  0003f	8b 13		 mov	 edx, DWORD PTR [ebx]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2182 :       delete_internal_node(child);

  00047	83 c4 04	 add	 esp, 4
  0004a	89 33		 mov	 DWORD PTR [ebx], esi
  0004c	5e		 pop	 esi
  0004d	5f		 pop	 edi
  0004e	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN2@try_shrink:

; 2176 :       *mutable_root() = child;
; 2177 :     } else {
; 2178 :       // The child is an internal node. We want to keep the existing root node
; 2179 :       // so we move all of the values from the child node into the existing
; 2180 :       // (empty) root node.
; 2181 :       child->swap(root());

  00053	8b d6		 mov	 edx, esi
  00055	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2182 :       delete_internal_node(child);

  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00060	83 c4 04	 add	 esp, 4
  00063	5e		 pop	 esi
$LN56@try_shrink:
  00064	5f		 pop	 edi
  00065	5b		 pop	 ebx

; 2183 :     }
; 2184 :   }
; 2185 : }

  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = eax

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	74 06		 je	 SHORT $LN8@operator@11

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00008	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000d	c3		 ret	 0
$LN8@operator@11:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00014	75 18		 jne	 SHORT $LN40@operator@11

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00016	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00019	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0001d	75 0c		 jne	 SHORT $LN21@operator@11
  0001f	90		 npad	 1
$LL22@operator@11:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00025	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00029	74 f5		 je	 SHORT $LL22@operator@11
$LN21@operator@11:
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002d	c3		 ret	 0
$LN40@operator@11:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00031	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00035	75 11		 jne	 SHORT $LN3@operator@11
$LL4@operator@11:
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003b	75 0b		 jne	 SHORT $LN3@operator@11

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ef		 je	 SHORT $LL4@operator@11
$LN3@operator@11:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00048	8b 10		 mov	 edx, DWORD PTR [eax]
  0004a	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0004e	75 02		 jne	 SHORT $LN1@operator@11

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00050	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@operator@11:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00052	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--, COMDAT
; _this$ = esi

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00000	8b c6		 mov	 eax, esi
  00002	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00007	8b c6		 mov	 eax, esi

; 306  : 		}

  00009	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 782  : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  00006	c3		 ret	 0
?begin@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
__Where$ = 12						; size = 4
?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket, COMDAT
; _this$ = ecx
; __Bucket$ = esi

; 764  : 		{	// fix iterators after inserting _Plist before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 		if (_Vec_lo(_Bucket) == end())

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 14 f0	 mov	 edx, DWORD PTR [eax+esi*8]
  00009	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  0000c	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000f	75 13		 jne	 SHORT $LN5@Insert_buc

; 766  : 			{	// make bucket non-empty
; 767  : 			_Vec_lo(_Bucket) = _Plist;

  00011	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]
  00014	89 10		 mov	 DWORD PTR [eax], edx

; 768  : 			_Vec_hi(_Bucket) = _Plist;

  00016	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Plist$[ebp]
  0001c	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx

; 774  : 		}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN5@Insert_buc:

; 769  : 			}
; 770  : 		else if (_Vec_lo(_Bucket) == _Where)

  00024	3b 55 0c	 cmp	 edx, DWORD PTR __Where$[ebp]
  00027	75 09		 jne	 SHORT $LN3@Insert_buc

; 771  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

  00029	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]

; 773  : 			--_Vec_hi(_Bucket);	// or not

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 774  : 		}

  0002e	5d		 pop	 ebp
  0002f	c2 08 00	 ret	 8
$LN3@Insert_buc:

; 772  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

  00032	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00035	8b 12		 mov	 edx, DWORD PTR [edx]
  00037	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003a	3b 55 08	 cmp	 edx, DWORD PTR __Plist$[ebp]
  0003d	74 10		 je	 SHORT $LN64@Insert_buc

; 773  : 			--_Vec_hi(_Bucket);	// or not

  0003f	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00042	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  00046	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00049	8d 44 f0 04	 lea	 eax, DWORD PTR [eax+esi*8+4]
  0004d	89 10		 mov	 DWORD PTR [eax], edx
$LN64@Insert_buc:

; 774  : 		}

  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?_Insert_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@0I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert_bucket
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Addleft$ = 16						; size = 1
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; __Wherenode$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00007	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  0000a	57		 push	 edi
  0000b	81 fa fe ff ff
	1f		 cmp	 edx, 536870910		; 1ffffffeH
  00011	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001c	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  00024	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN378@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;
; 1642 : 		_Newnode->_Parent = _Wherenode;

  00029	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002c	42		 inc	 edx
  0002d	89 53 08	 mov	 DWORD PTR [ebx+8], edx
  00030	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00033	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00036	32 c0		 xor	 al, al
  00038	3b ca		 cmp	 ecx, edx
  0003a	75 0d		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003c	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00042	89 39		 mov	 DWORD PTR [ecx], edi

; 1648 : 			_Rmost() = _Newnode;

  00044	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00047	eb 1d		 jmp	 SHORT $LN376@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  00049	38 45 10	 cmp	 BYTE PTR __Addleft$[ebp], al
  0004c	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  0004e	89 39		 mov	 DWORD PTR [ecx], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00050	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00053	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00055	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00057	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  00059	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005b	89 79 08	 mov	 DWORD PTR [ecx+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  0005e	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00061	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  00064	75 03		 jne	 SHORT $LN11@Insert
$LN376@Insert:

; 1660 : 				_Rmost() = _Newnode;

  00066	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00069	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006c	8b cf		 mov	 ecx, edi
  0006e	38 42 14	 cmp	 BYTE PTR [edx+20], al
  00071	0f 85 91 01 00
	00		 jne	 $LN9@Insert
  00077	56		 push	 esi
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00078	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007b	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0007e	3b 16		 cmp	 edx, DWORD PTR [esi]
  00080	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  00086	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00089	38 46 14	 cmp	 BYTE PTR [esi+20], al
  0008c	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0008e	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  00092	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  00096	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00099	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0009c	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0009f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000a2	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1677 : 					}
; 1678 : 				else

  000a5	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000aa	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  000ad	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000af	8b ca		 mov	 ecx, edx

; 1683 : 						_Lrotate(_Pnode);

  000b1	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000b4	8b 32		 mov	 esi, DWORD PTR [edx]
  000b6	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  000b9	8b 32		 mov	 esi, DWORD PTR [edx]
  000bb	38 46 15	 cmp	 BYTE PTR [esi+21], al
  000be	75 03		 jne	 SHORT $LN110@Insert
  000c0	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN110@Insert:
  000c3	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000c6	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000c9	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000cc	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  000cf	75 05		 jne	 SHORT $LN109@Insert
  000d1	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000d4	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000d6	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d9	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  000db	75 04		 jne	 SHORT $LN107@Insert
  000dd	89 16		 mov	 DWORD PTR [esi], edx
  000df	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e1	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000e4	89 0a		 mov	 DWORD PTR [edx], ecx
  000e6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000e9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000ec	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000f6	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  000f9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000ff	8b 32		 mov	 esi, DWORD PTR [edx]
  00101	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00104	89 3a		 mov	 DWORD PTR [edx], edi
  00106	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00109	38 47 15	 cmp	 BYTE PTR [edi+21], al
  0010c	75 03		 jne	 SHORT $LN173@Insert
  0010e	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00111	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00114	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00117	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0011a	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  0011d	75 0b		 jne	 SHORT $LN172@Insert
  0011f	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00122	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00125	e9 cb 00 00 00	 jmp	 $LN377@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  0012a	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0012d	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00130	75 0b		 jne	 SHORT $LN170@Insert
  00132	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00135	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00138	e9 b8 00 00 00	 jmp	 $LN377@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  0013d	89 37		 mov	 DWORD PTR [edi], esi
  0013f	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00142	e9 ae 00 00 00	 jmp	 $LN377@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  00147	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00149	38 46 14	 cmp	 BYTE PTR [esi+20], al
  0014c	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  0014e	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  00152	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  00156	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00159	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0015c	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  0015f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00162	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1703 : 					}
; 1704 : 				else

  00165	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  0016a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0016c	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  0016e	8b ca		 mov	 ecx, edx

; 1709 : 						_Rrotate(_Pnode);

  00170	8b 11		 mov	 edx, DWORD PTR [ecx]
  00172	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00175	89 31		 mov	 DWORD PTR [ecx], esi
  00177	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017a	38 46 15	 cmp	 BYTE PTR [esi+21], al
  0017d	75 03		 jne	 SHORT $LN252@Insert
  0017f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN252@Insert:
  00182	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00185	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00188	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0018b	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0018e	75 05		 jne	 SHORT $LN251@Insert
  00190	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00193	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  00195	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00198	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0019b	75 05		 jne	 SHORT $LN249@Insert
  0019d	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a0	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001a2	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001a4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  001a7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001aa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001ad	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001b4	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001b7	88 42 14	 mov	 BYTE PTR [edx+20], al

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001bd	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c0	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001c3	8b 3e		 mov	 edi, DWORD PTR [esi]
  001c5	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001c8	8b 3e		 mov	 edi, DWORD PTR [esi]
  001ca	38 47 15	 cmp	 BYTE PTR [edi+21], al
  001cd	75 03		 jne	 SHORT $LN315@Insert
  001cf	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001d2	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001d5	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001d8	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  001db	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001de	75 05		 jne	 SHORT $LN314@Insert
  001e0	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001e3	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001e5	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001e8	3b 17		 cmp	 edx, DWORD PTR [edi]
  001ea	75 04		 jne	 SHORT $LN312@Insert
  001ec	89 37		 mov	 DWORD PTR [edi], esi
  001ee	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f0	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001f3	89 16		 mov	 DWORD PTR [esi], edx
$LN377@Insert:
  001f5	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  001f8	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  001fb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001fe	38 42 14	 cmp	 BYTE PTR [edx+20], al
  00201	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  00207	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00208	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0020b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  0020e	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00211	89 38		 mov	 DWORD PTR [eax], edi
  00213	5f		 pop	 edi
  00214	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00218	5b		 pop	 ebx

; 1721 : 		}

  00219	5d		 pop	 ebp
  0021a	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ
_TEXT	SEGMENT
?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front, COMDAT
; _this$ = eax

; 897  : 		return (*begin());

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b 01		 mov	 eax, DWORD PTR [ecx]
  00004	83 c0 08	 add	 eax, 8

; 898  : 		}

  00007	c3		 ret	 0
?front@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEAAU?$pair@$$CBIPAUcpp_object@@@2@XZ ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::front
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 327  : 		return (_List.begin());

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 328  : 		}

  00007	c3		 ret	 0
?begin@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@XZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z
_TEXT	SEGMENT
$T184710 = -12						; size = 12
$T184688 = 8						; size = 4
_max_count$ = 8						; size = 4
?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node, COMDAT

; 1257 :   node_type* new_leaf_root_node(int max_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _max_count$[ebp]

; 1258 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1259 :         mutable_internal_allocator()->allocate(
; 1260 :             sizeof(base_fields) + max_count * sizeof(value_type)));

  0000a	8d 0c dd 08 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8+8]
  00011	33 c0		 xor	 eax, eax
  00013	85 c9		 test	 ecx, ecx
  00015	74 12		 je	 SHORT $LN8@new_leaf_r
  00017	83 f9 ff	 cmp	 ecx, -1
  0001a	77 23		 ja	 SHORT $LN7@new_leaf_r
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	74 16		 je	 SHORT $LN7@new_leaf_r
$LN8@new_leaf_r:

; 1261 :     return node_type::init_leaf(p, reinterpret_cast<node_type*>(p), max_count);

  00029	88 58 02	 mov	 BYTE PTR [eax+2], bl
  0002c	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00031	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00035	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00038	5b		 pop	 ebx

; 1262 :   }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4

; 1258 :     leaf_fields *p = reinterpret_cast<leaf_fields*>(
; 1259 :         mutable_internal_allocator()->allocate(
; 1260 :             sizeof(base_fields) + max_count * sizeof(value_type)));

$LN7@new_leaf_r:
  0003f	8d 45 08	 lea	 eax, DWORD PTR $T184688[ebp]
  00042	50		 push	 eax
  00043	8d 4d f4	 lea	 ecx, DWORD PTR $T184710[ebp]
  00046	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T184688[ebp], 0
  0004d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00052	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00057	8d 4d f4	 lea	 ecx, DWORD PTR $T184710[ebp]
  0005a	51		 push	 ecx
  0005b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T184710[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00062	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN21@new_leaf_r:
$LN20@new_leaf_r:
  00067	cc		 int	 3
?new_leaf_root_node@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@H@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::new_leaf_root_node
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ??$find_lower@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUleaf_node@01@ABI@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
??$find_lower@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUleaf_node@01@ABI@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>, COMDAT
; _n$ = ecx

; 1635 :     inline int find_lower(const node_type *n, const key_type& key) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1672 :             while (lo < n->slotuse && key_less(n->slotkey[lo],key)) ++lo;

  00003	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN1@find_lower

; 1636 :     {
; 1637 :         if ( 0 && sizeof(n->slotkey) > traits::binsearch_threshold )
; 1638 :         {
; 1639 :             if (n->slotuse == 0) return 0;
; 1640 : 
; 1641 :             int lo = 0, hi = n->slotuse;
; 1642 : 
; 1643 :             while (lo < hi)
; 1644 :             {
; 1645 :                 int mid = (lo + hi) >> 1;
; 1646 : 
; 1647 :                 if (key_lessequal(key, n->slotkey[mid])) {
; 1648 :                     hi = mid; // key <= mid
; 1649 :                 }
; 1650 :                 else {
; 1651 :                     lo = mid + 1; // key > mid
; 1652 :                 }
; 1653 :             }
; 1654 : 
; 1655 :             BTREE_PRINT("btree::find_lower: on " << n << " key " << key << " -> " << lo << " / " << hi);
; 1656 : 
; 1657 :             // verify result using simple linear search
; 1658 :             if (selfverify)
; 1659 :             {
; 1660 :                 int i = 0;
; 1661 :                 while (i < n->slotuse && key_less(n->slotkey[i],key)) ++i;
; 1662 : 
; 1663 :                 BTREE_PRINT("btree::find_lower: testfind: " << i);
; 1664 :                 BTREE_ASSERT(i == lo);
; 1665 :             }
; 1666 : 
; 1667 :             return lo;
; 1668 :         }
; 1669 :         else // for nodes <= binsearch_threshold do linear search.
; 1670 :         {
; 1671 :             int lo = 0;

  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _key$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 0c	 add	 ecx, 12			; 0000000cH
$LL2@find_lower:

; 1672 :             while (lo < n->slotuse && key_less(n->slotkey[lo],key)) ++lo;

  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN40@find_lower
  0001a	40		 inc	 eax
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL2@find_lower
$LN40@find_lower:
  00022	5e		 pop	 esi
$LN1@find_lower:

; 1673 :             return lo;
; 1674 :         }
; 1675 :     }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$find_lower@Uleaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUleaf_node@01@ABI@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::leaf_node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$find_lower@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUinner_node@01@ABI@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
??$find_lower@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUinner_node@01@ABI@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>, COMDAT
; _n$ = ecx

; 1635 :     inline int find_lower(const node_type *n, const key_type& key) const

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1672 :             while (lo < n->slotuse && key_less(n->slotkey[lo],key)) ++lo;

  00003	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00007	33 c0		 xor	 eax, eax
  00009	85 d2		 test	 edx, edx
  0000b	7e 16		 jle	 SHORT $LN1@find_lower@2

; 1636 :     {
; 1637 :         if ( 0 && sizeof(n->slotkey) > traits::binsearch_threshold )
; 1638 :         {
; 1639 :             if (n->slotuse == 0) return 0;
; 1640 : 
; 1641 :             int lo = 0, hi = n->slotuse;
; 1642 : 
; 1643 :             while (lo < hi)
; 1644 :             {
; 1645 :                 int mid = (lo + hi) >> 1;
; 1646 : 
; 1647 :                 if (key_lessequal(key, n->slotkey[mid])) {
; 1648 :                     hi = mid; // key <= mid
; 1649 :                 }
; 1650 :                 else {
; 1651 :                     lo = mid + 1; // key > mid
; 1652 :                 }
; 1653 :             }
; 1654 : 
; 1655 :             BTREE_PRINT("btree::find_lower: on " << n << " key " << key << " -> " << lo << " / " << hi);
; 1656 : 
; 1657 :             // verify result using simple linear search
; 1658 :             if (selfverify)
; 1659 :             {
; 1660 :                 int i = 0;
; 1661 :                 while (i < n->slotuse && key_less(n->slotkey[i],key)) ++i;
; 1662 : 
; 1663 :                 BTREE_PRINT("btree::find_lower: testfind: " << i);
; 1664 :                 BTREE_ASSERT(i == lo);
; 1665 :             }
; 1666 : 
; 1667 :             return lo;
; 1668 :         }
; 1669 :         else // for nodes <= binsearch_threshold do linear search.
; 1670 :         {
; 1671 :             int lo = 0;

  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _key$[ebp]
  00011	8b 36		 mov	 esi, DWORD PTR [esi]
  00013	83 c1 04	 add	 ecx, 4
$LL2@find_lower@2:

; 1672 :             while (lo < n->slotuse && key_less(n->slotkey[lo],key)) ++lo;

  00016	39 31		 cmp	 DWORD PTR [ecx], esi
  00018	73 08		 jae	 SHORT $LN40@find_lower@2
  0001a	40		 inc	 eax
  0001b	83 c1 04	 add	 ecx, 4
  0001e	3b c2		 cmp	 eax, edx
  00020	7c f4		 jl	 SHORT $LL2@find_lower@2
$LN40@find_lower@2:
  00022	5e		 pop	 esi
$LN1@find_lower@2:

; 1673 :             return lo;
; 1674 :         }
; 1675 :     }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??$find_lower@Uinner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@ABEHPBUinner_node@01@ABI@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find_lower<stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::inner_node>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z
_TEXT	SEGMENT
_res$159067 = -20					; size = 12
$T184796 = -8						; size = 8
_iter$ = 8						; size = 8
??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >, COMDAT
; ___$ReturnUdt$ = esi
; _key$ = edi

; 2301 :     const key_type &key, IterType iter) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2302 :   if (iter.node) {

  00003	8b 55 08	 mov	 edx, DWORD PTR _iter$[ebp]
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	85 d2		 test	 edx, edx
  0000b	74 76		 je	 SHORT $LN1@internal_f

; 2303 :     std::pair<IterType, int> res = internal_locate(key, iter);

  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00010	83 ec 08	 sub	 esp, 8
  00013	8b c4		 mov	 eax, esp
  00015	89 10		 mov	 DWORD PTR [eax], edx
  00017	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001a	57		 push	 edi
  0001b	8d 45 ec	 lea	 eax, DWORD PTR _res$159067[ebp]
  0001e	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >

; 2304 :     if (res.second == kExactMatch) {

  00023	8b 45 f4	 mov	 eax, DWORD PTR _res$159067[ebp+8]
  00026	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  0002b	75 13		 jne	 SHORT $LN3@internal_f

; 2305 :       return res.first;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR _res$159067[ebp]
  00030	8b 4d f0	 mov	 ecx, DWORD PTR _res$159067[ebp+4]
  00033	89 06		 mov	 DWORD PTR [esi], eax
  00035	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  00038	8b c6		 mov	 eax, esi

; 2315 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
$LN3@internal_f:

; 2306 :     }
; 2307 :     if (!res.second) {

  00040	85 c0		 test	 eax, eax
  00042	75 3f		 jne	 SHORT $LN1@internal_f

; 2308 :       iter = internal_last(res.first);

  00044	8b 55 ec	 mov	 edx, DWORD PTR _res$159067[ebp]
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _res$159067[ebp+4]
  0004a	83 ec 08	 sub	 esp, 8
  0004d	8b c4		 mov	 eax, esp
  0004f	89 10		 mov	 DWORD PTR [eax], edx
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00054	8d 45 f8	 lea	 eax, DWORD PTR $T184796[ebp]
  00057	e8 00 00 00 00	 call	 ??$internal_last@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@CA?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@U21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_last<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	89 4d 08	 mov	 DWORD PTR _iter$[ebp], ecx
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	83 c4 08	 add	 esp, 8
  00067	89 45 0c	 mov	 DWORD PTR _iter$[ebp+4], eax

; 2309 :       if (iter.node && !compare_keys(key, iter.key())) {

  0006a	85 c9		 test	 ecx, ecx
  0006c	74 15		 je	 SHORT $LN1@internal_f
  0006e	8b 17		 mov	 edx, DWORD PTR [edi]
  00070	3b 54 c1 08	 cmp	 edx, DWORD PTR [ecx+eax*8+8]
  00074	72 0d		 jb	 SHORT $LN1@internal_f

; 2310 :         return iter;

  00076	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00079	89 0e		 mov	 DWORD PTR [esi], ecx

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  0007b	8b c6		 mov	 eax, esi

; 2315 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 08 00	 ret	 8
$LN1@internal_f:

; 2311 :       }
; 2312 :     }
; 2313 :   }
; 2314 :   return IterType(NULL, 0);

  00083	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00089	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00090	8b c6		 mov	 eax, esi

; 2315 : }

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = edx
; _it$ = eax

; 469  :     assert(settings.use_empty());  // we always need to know what's empty!
; 470  :     return equals(get_key(val_info.emptyval), get_key(*it));

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00006	33 d2		 xor	 edx, edx
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	0f 94 c0	 sete	 al

; 471  :   }

  0000d	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?split_inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUinner_node@12@PAIPAPAUnode@12@I@Z
_TEXT	SEGMENT
$T185026 = -12						; size = 12
_this$ = 8						; size = 4
__newkey$ = 12						; size = 4
__newinner$ = 16					; size = 4
$T185035 = 20						; size = 2
$T184966 = 20						; size = 4
_addslot$ = 20						; size = 4
?split_inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUinner_node@12@PAIPAPAUnode@12@I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_inner_node, COMDAT
; _inner$ = esi

; 2363 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2364 :         BTREE_ASSERT(inner->isfull());
; 2365 : 
; 2366 :         unsigned int mid = (inner->slotuse >> 1);

  00003	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	53		 push	 ebx
  0000b	57		 push	 edi
  0000c	8b f8		 mov	 edi, eax
  0000e	d1 ef		 shr	 edi, 1

; 2367 : 
; 2368 :         BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);
; 2369 : 
; 2370 :         // if the split is uneven and the overflowing item will be put into the
; 2371 :         // larger node, then the smaller split node may underflow
; 2372 :         if (addslot <= mid && mid > inner->slotuse - (mid + 1))

  00010	39 7d 14	 cmp	 DWORD PTR _addslot$[ebp], edi
  00013	77 08		 ja	 SHORT $LN6@split_inne
  00015	2b c7		 sub	 eax, edi
  00017	48		 dec	 eax
  00018	3b f8		 cmp	 edi, eax
  0001a	76 01		 jbe	 SHORT $LN6@split_inne

; 2373 :             mid--;

  0001c	4f		 dec	 edi
$LN6@split_inne:

; 2374 : 
; 2375 :         BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);
; 2376 : 
; 2377 :         BTREE_PRINT("btree::split_inner_node on " << inner << " into two nodes " << mid << " and " << inner->slotuse - (mid + 1) << " sized");
; 2378 : 
; 2379 :         inner_node *newinner = allocate_inner(inner->level);

  0001d	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00020	68 08 01 00 00	 push	 264			; 00000108H
  00025	89 45 14	 mov	 DWORD PTR $T185035[ebp], eax
  00028	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002d	8b d8		 mov	 ebx, eax
  0002f	83 c4 04	 add	 esp, 4
  00032	85 db		 test	 ebx, ebx
  00034	0f 84 9a 00 00
	00		 je	 $LN26@split_inne
  0003a	68 08 01 00 00	 push	 264			; 00000108H
  0003f	6a 00		 push	 0
  00041	53		 push	 ebx
  00042	e8 00 00 00 00	 call	 _memset
  00047	66 8b 4d 14	 mov	 cx, WORD PTR $T185035[ebp]
  0004b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	33 d2		 xor	 edx, edx
  00050	66 89 53 02	 mov	 WORD PTR [ebx+2], dx
  00054	66 89 0b	 mov	 WORD PTR [ebx], cx
  00057	ff 40 14	 inc	 DWORD PTR [eax+20]

; 2380 : 
; 2381 :         newinner->slotuse = inner->slotuse - (mid + 1);

  0005a	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  0005e	66 2b c7	 sub	 ax, di
  00061	66 48		 dec	 ax
  00063	66 89 43 02	 mov	 WORD PTR [ebx+2], ax

; 2382 : 
; 2383 :         std::copy(inner->slotkey + mid+1, inner->slotkey + inner->slotuse,
; 2384 :                   newinner->slotkey);

  00067	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  0006b	8d 44 be 08	 lea	 eax, DWORD PTR [esi+edi*4+8]
  0006f	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  00076	2b d0		 sub	 edx, eax
  00078	03 d6		 add	 edx, esi
  0007a	c1 fa 02	 sar	 edx, 2
  0007d	03 d2		 add	 edx, edx
  0007f	03 d2		 add	 edx, edx
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _memmove

; 2385 :         std::copy(inner->childid + mid+1, inner->childid + inner->slotuse+1,
; 2386 :                   newinner->childid);

  0008c	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00090	8d 84 be 88 00
	00 00		 lea	 eax, DWORD PTR [esi+edi*4+136]
  00097	8d 14 8d 88 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+136]
  0009e	2b d0		 sub	 edx, eax
  000a0	03 d6		 add	 edx, esi
  000a2	c1 fa 02	 sar	 edx, 2
  000a5	03 d2		 add	 edx, edx
  000a7	03 d2		 add	 edx, edx
  000a9	52		 push	 edx
  000aa	50		 push	 eax
  000ab	8d 83 84 00 00
	00		 lea	 eax, DWORD PTR [ebx+132]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _memmove

; 2387 : 
; 2388 :         inner->slotuse = mid;
; 2389 : 
; 2390 :         *_newkey = inner->slotkey[mid];

  000b7	8b 55 0c	 mov	 edx, DWORD PTR __newkey$[ebp]

; 2391 :         *_newinner = newinner;

  000ba	8b 45 10	 mov	 eax, DWORD PTR __newinner$[ebp]
  000bd	66 89 7e 02	 mov	 WORD PTR [esi+2], di
  000c1	8b 4c be 04	 mov	 ecx, DWORD PTR [esi+edi*4+4]
  000c5	83 c4 24	 add	 esp, 36			; 00000024H
  000c8	89 0a		 mov	 DWORD PTR [edx], ecx
  000ca	5f		 pop	 edi
  000cb	89 18		 mov	 DWORD PTR [eax], ebx
  000cd	5b		 pop	 ebx

; 2392 :     }

  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 10 00	 ret	 16			; 00000010H

; 2374 : 
; 2375 :         BTREE_PRINT("btree::split_inner: mid " << mid << " addslot " << addslot);
; 2376 : 
; 2377 :         BTREE_PRINT("btree::split_inner_node on " << inner << " into two nodes " << mid << " and " << inner->slotuse - (mid + 1) << " sized");
; 2378 : 
; 2379 :         inner_node *newinner = allocate_inner(inner->level);

$LN26@split_inne:
  000d4	8d 4d 14	 lea	 ecx, DWORD PTR $T184966[ebp]
  000d7	51		 push	 ecx
  000d8	8d 4d f4	 lea	 ecx, DWORD PTR $T185026[ebp]
  000db	c7 45 14 00 00
	00 00		 mov	 DWORD PTR $T184966[ebp], 0
  000e2	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000e7	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ec	8d 55 f4	 lea	 edx, DWORD PTR $T185026[ebp]
  000ef	52		 push	 edx
  000f0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T185026[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000f7	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN78@split_inne:
$LN77@split_inne:
  000fc	cc		 int	 3
?split_inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUinner_node@12@PAIPAPAUnode@12@I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_inner_node
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?split_leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUleaf_node@12@PAIPAPAUnode@12@@Z
_TEXT	SEGMENT
$T185233 = -12						; size = 12
$T185173 = 8						; size = 4
_this$ = 8						; size = 4
__newkey$ = 12						; size = 4
__newleaf$ = 16						; size = 4
?split_leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUleaf_node@12@PAIPAPAUnode@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_leaf_node, COMDAT
; _leaf$ = edi

; 2325 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 2326 :         BTREE_ASSERT(leaf->isfull());
; 2327 : 
; 2328 :         unsigned int mid = (leaf->slotuse >> 1);

  00007	0f b7 5f 02	 movzx	 ebx, WORD PTR [edi+2]
  0000b	56		 push	 esi

; 2329 : 
; 2330 :         BTREE_PRINT("btree::split_leaf_node on " << leaf);
; 2331 : 
; 2332 :         leaf_node *newleaf = allocate_leaf();

  0000c	68 0c 01 00 00	 push	 268			; 0000010cH
  00011	d1 eb		 shr	 ebx, 1
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00018	8b f0		 mov	 esi, eax
  0001a	83 c4 04	 add	 esp, 4
  0001d	85 f6		 test	 esi, esi
  0001f	0f 84 b6 00 00
	00		 je	 $LN24@split_leaf
  00025	68 0c 01 00 00	 push	 268			; 0000010cH
  0002a	6a 00		 push	 0
  0002c	56		 push	 esi
  0002d	e8 00 00 00 00	 call	 _memset
  00032	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	33 c0		 xor	 eax, eax
  00037	89 06		 mov	 DWORD PTR [esi], eax
  00039	33 d2		 xor	 edx, edx
  0003b	89 56 08	 mov	 DWORD PTR [esi+8], edx
  0003e	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00041	ff 41 10	 inc	 DWORD PTR [ecx+16]

; 2333 : 
; 2334 :         newleaf->slotuse = leaf->slotuse - mid;

  00044	66 8b 47 02	 mov	 ax, WORD PTR [edi+2]
  00048	66 2b c3	 sub	 ax, bx
  0004b	66 89 46 02	 mov	 WORD PTR [esi+2], ax

; 2335 : 
; 2336 :         newleaf->nextleaf = leaf->nextleaf;

  0004f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 2337 :         if (newleaf->nextleaf == NULL) {

  00058	3b c2		 cmp	 eax, edx
  0005a	75 05		 jne	 SHORT $LN5@split_leaf

; 2338 :             BTREE_ASSERT(leaf == m_tailleaf);
; 2339 :             m_tailleaf = newleaf;

  0005c	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 2340 :         }
; 2341 :         else {

  0005f	eb 03		 jmp	 SHORT $LN1@split_leaf
$LN5@split_leaf:

; 2342 :             newleaf->nextleaf->prevleaf = newleaf;

  00061	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN1@split_leaf:

; 2343 :         }
; 2344 : 
; 2345 :         std::copy(leaf->slotkey + mid, leaf->slotkey + leaf->slotuse,
; 2346 :                   newleaf->slotkey);

  00064	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00068	8d 44 9f 0c	 lea	 eax, DWORD PTR [edi+ebx*4+12]
  0006c	8d 14 8d 0c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+12]
  00073	2b d0		 sub	 edx, eax
  00075	03 d7		 add	 edx, edi
  00077	c1 fa 02	 sar	 edx, 2
  0007a	03 d2		 add	 edx, edx
  0007c	03 d2		 add	 edx, edx
  0007e	52		 push	 edx
  0007f	50		 push	 eax
  00080	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 _memmove

; 2347 :         data_copy(leaf->slotdata + mid, leaf->slotdata + leaf->slotuse,
; 2348 :                   newleaf->slotdata);

  00089	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  0008d	8d 84 9f 8c 00
	00 00		 lea	 eax, DWORD PTR [edi+ebx*4+140]
  00094	8d 14 8d 8c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+140]
  0009b	2b d0		 sub	 edx, eax
  0009d	03 d7		 add	 edx, edi
  0009f	c1 fa 02	 sar	 edx, 2
  000a2	03 d2		 add	 edx, edx
  000a4	03 d2		 add	 edx, edx
  000a6	52		 push	 edx
  000a7	50		 push	 eax
  000a8	8d 86 8c 00 00
	00		 lea	 eax, DWORD PTR [esi+140]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _memmove

; 2349 : 
; 2350 :         leaf->slotuse = mid;
; 2351 :         leaf->nextleaf = newleaf;
; 2352 :         newleaf->prevleaf = leaf;
; 2353 : 
; 2354 :         *_newkey = leaf->slotkey[leaf->slotuse-1];

  000b4	8b 45 0c	 mov	 eax, DWORD PTR __newkey$[ebp]
  000b7	66 89 5f 02	 mov	 WORD PTR [edi+2], bx
  000bb	89 77 08	 mov	 DWORD PTR [edi+8], esi
  000be	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  000c1	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  000c5	8b 54 8f 08	 mov	 edx, DWORD PTR [edi+ecx*4+8]

; 2355 :         *_newleaf = newleaf;

  000c9	8b 4d 10	 mov	 ecx, DWORD PTR __newleaf$[ebp]
  000cc	83 c4 18	 add	 esp, 24			; 00000018H
  000cf	89 10		 mov	 DWORD PTR [eax], edx
  000d1	89 31		 mov	 DWORD PTR [ecx], esi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 2356 :     }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 0c 00	 ret	 12			; 0000000cH

; 2329 : 
; 2330 :         BTREE_PRINT("btree::split_leaf_node on " << leaf);
; 2331 : 
; 2332 :         leaf_node *newleaf = allocate_leaf();

$LN24@split_leaf:
  000db	8d 55 08	 lea	 edx, DWORD PTR $T185173[ebp]
  000de	52		 push	 edx
  000df	8d 4d f4	 lea	 ecx, DWORD PTR $T185233[ebp]
  000e2	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T185173[ebp], 0
  000e9	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000ee	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000f3	8d 45 f4	 lea	 eax, DWORD PTR $T185233[ebp]
  000f6	50		 push	 eax
  000f7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T185233[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000fe	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN80@split_leaf:
$LN79@split_leaf:
  00103	cc		 int	 3
?split_leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUleaf_node@12@PAIPAPAUnode@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_leaf_node
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z
_TEXT	SEGMENT
tv252 = -12						; size = 8
tv244 = -12						; size = 8
tv262 = -8						; size = 4
tv254 = -8						; size = 4
tv246 = -8						; size = 4
__Cat$185438 = -8					; size = 1
tv258 = -2						; size = 2
tv249 = -2						; size = 2
?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size, COMDAT
; _this$ = esi
; _new_num_buckets$ = eax

; 752  :   void clear_to_size(size_type new_num_buckets) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 753  :     if (!table) {

  00007	8b 5e 34	 mov	 ebx, DWORD PTR [esi+52]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	85 db		 test	 ebx, ebx
  0000f	0f 85 91 00 00
	00		 jne	 $LN3@clear_to_s

; 754  :       table = val_info.allocate(new_num_buckets);

  00015	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _malloc
  00022	83 c4 04	 add	 esp, 4

; 758  :         typedef integral_constant<bool,
; 759  :             is_same<value_alloc_type,
; 760  :                     libc_allocator_with_realloc<value_type> >::value>
; 761  :             realloc_ok;
; 762  :         resize_table(num_buckets, new_num_buckets, realloc_ok());

$LN15@clear_to_s:
  00025	89 46 34	 mov	 DWORD PTR [esi+52], eax
$LN13@clear_to_s:

; 763  :       }
; 764  :     }
; 765  :     assert(table);
; 766  :     fill_range_with_empty(table, table + new_num_buckets);

  00028	8b 55 f8	 mov	 edx, DWORD PTR __Cat$185438[ebp]
  0002b	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0002e	52		 push	 edx
  0002f	8d 56 2c	 lea	 edx, DWORD PTR [esi+44]
  00032	8d 0c f8	 lea	 ecx, DWORD PTR [eax+edi*8]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >

; 767  :     num_elements = 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	83 c4 08	 add	 esp, 8

; 768  :     num_deleted = 0;
; 769  :     num_buckets = new_num_buckets;          // our new size
; 770  :     settings.reset_thresholds(bucket_count());

  00040	89 7d f8	 mov	 DWORD PTR tv262[ebp], edi
  00043	db 45 f8	 fild	 DWORD PTR tv262[ebp]
  00046	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00049	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0004c	89 7e 28	 mov	 DWORD PTR [esi+40], edi
  0004f	85 ff		 test	 edi, edi
  00051	79 06		 jns	 SHORT $LN44@clear_to_s
  00053	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN44@clear_to_s:
  00059	d9 46 08	 fld	 DWORD PTR [esi+8]
  0005c	5f		 pop	 edi
  0005d	d9 7d fe	 fnstcw	 WORD PTR tv258[ebp]
  00060	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00064	0f b7 45 fe	 movzx	 eax, WORD PTR tv258[ebp]
  00068	d8 c9		 fmul	 ST(0), ST(1)
  0006a	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0006f	89 45 f8	 mov	 DWORD PTR tv254[ebp], eax
  00072	5b		 pop	 ebx
  00073	d9 6d f8	 fldcw	 WORD PTR tv254[ebp]
  00076	df 7d f4	 fistp	 QWORD PTR tv252[ebp]
  00079	8b 45 f4	 mov	 eax, DWORD PTR tv252[ebp]
  0007c	89 06		 mov	 DWORD PTR [esi], eax
  0007e	d9 6d fe	 fldcw	 WORD PTR tv258[ebp]
  00081	d8 4e 0c	 fmul	 DWORD PTR [esi+12]
  00084	d9 7d fe	 fnstcw	 WORD PTR tv249[ebp]
  00087	0f b7 45 fe	 movzx	 eax, WORD PTR tv249[ebp]
  0008b	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00090	89 45 f8	 mov	 DWORD PTR tv246[ebp], eax
  00093	d9 6d f8	 fldcw	 WORD PTR tv246[ebp]
  00096	df 7d f4	 fistp	 QWORD PTR tv244[ebp]
  00099	8b 4d f4	 mov	 ecx, DWORD PTR tv244[ebp]
  0009c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0009f	d9 6d fe	 fldcw	 WORD PTR tv249[ebp]

; 771  :   }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN3@clear_to_s:

; 755  :     } else {
; 756  :       destroy_buckets(0, num_buckets);
; 757  :       if (new_num_buckets != num_buckets) {   // resize, if necessary

  000a6	3b 7e 28	 cmp	 edi, DWORD PTR [esi+40]
  000a9	0f 84 79 ff ff
	ff		 je	 $LN13@clear_to_s

; 758  :         typedef integral_constant<bool,
; 759  :             is_same<value_alloc_type,
; 760  :                     libc_allocator_with_realloc<value_type> >::value>
; 761  :             realloc_ok;
; 762  :         resize_table(num_buckets, new_num_buckets, realloc_ok());

  000af	8d 0c fd 00 00
	00 00		 lea	 ecx, DWORD PTR [edi*8]
  000b6	51		 push	 ecx
  000b7	53		 push	 ebx
  000b8	e8 00 00 00 00	 call	 _realloc
  000bd	83 c4 08	 add	 esp, 8
  000c0	85 c0		 test	 eax, eax
  000c2	0f 85 5d ff ff
	ff		 jne	 $LN15@clear_to_s
  000c8	53		 push	 ebx
  000c9	57		 push	 edi
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@KBAOBEKM@sparsehash?3?5FATAL?5ERROR?3?5failed?5@
  000cf	e8 00 00 00 00	 call	 ___iob_func
  000d4	83 c0 40	 add	 eax, 64			; 00000040H
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 _fprintf
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
  000e0	6a 01		 push	 1
  000e2	e8 00 00 00 00	 call	 _exit
$LN46@clear_to_s:
$LN45@clear_to_s:
  000e7	cc		 int	 3
?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z
_TEXT	SEGMENT
_r$157299 = -32						; size = 20
_slot$157293 = -12					; size = 4
_this$ = -8						; size = 4
_newkey$157291 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
tv974 = 12						; size = 4
_slot$157330 = 12					; size = 4
_newchild$157292 = 12					; size = 4
_n$ = 12						; size = 4
_key$ = 16						; size = 4
_value$ = 20						; size = 4
_splitkey$ = 24						; size = 4
_splitnode$ = 28					; size = 4
?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_descend, COMDAT
; _this$ = ecx

; 2193 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2194 :         if (!n->isleafnode())

  00008	8b 75 0c	 mov	 esi, DWORD PTR _n$[ebp]
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	33 c9		 xor	 ecx, ecx

; 2195 :         {
; 2196 :             inner_node *inner = static_cast<inner_node*>(n);
; 2197 : 
; 2198 :             key_type newkey = key_type();
; 2199 :             node *newchild = NULL;
; 2200 : 
; 2201 :             int slot = find_lower(inner, key);

  00010	33 db		 xor	 ebx, ebx
  00012	57		 push	 edi
  00013	66 39 0e	 cmp	 WORD PTR [esi], cx
  00016	0f 84 76 01 00
	00		 je	 $LN36@insert_des
  0001c	33 c0		 xor	 eax, eax
  0001e	8b fe		 mov	 edi, esi
  00020	89 4d fc	 mov	 DWORD PTR _newkey$157291[ebp], ecx
  00023	89 4d 0c	 mov	 DWORD PTR _newchild$157292[ebp], ecx
  00026	66 3b 46 02	 cmp	 ax, WORD PTR [esi+2]
  0002a	73 18		 jae	 SHORT $LN41@insert_des

; 2207 : 
; 2208 :             if (newchild)

  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _key$[ebp]
  0002f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00031	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
$LN42@insert_des:

; 2195 :         {
; 2196 :             inner_node *inner = static_cast<inner_node*>(n);
; 2197 : 
; 2198 :             key_type newkey = key_type();
; 2199 :             node *newchild = NULL;
; 2200 : 
; 2201 :             int slot = find_lower(inner, key);

  00034	39 08		 cmp	 DWORD PTR [eax], ecx
  00036	73 0c		 jae	 SHORT $LN41@insert_des
  00038	0f b7 56 02	 movzx	 edx, WORD PTR [esi+2]
  0003c	43		 inc	 ebx
  0003d	83 c0 04	 add	 eax, 4
  00040	3b da		 cmp	 ebx, edx
  00042	7c f0		 jl	 SHORT $LN42@insert_des
$LN41@insert_des:

; 2202 : 
; 2203 :             BTREE_PRINT("btree::insert_descend into " << inner->childid[slot]);
; 2204 : 
; 2205 :             std::pair<iterator, bool> r = insert_descend(inner->childid[slot],
; 2206 :                                                          key, value, &newkey, &newchild);

  00044	8b 55 14	 mov	 edx, DWORD PTR _value$[ebp]
  00047	8d 45 0c	 lea	 eax, DWORD PTR _newchild$157292[ebp]
  0004a	50		 push	 eax
  0004b	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]
  0004e	8d 4d fc	 lea	 ecx, DWORD PTR _newkey$157291[ebp]
  00051	51		 push	 ecx
  00052	8b 8c 9e 84 00
	00 00		 mov	 ecx, DWORD PTR [esi+ebx*4+132]
  00059	52		 push	 edx
  0005a	50		 push	 eax
  0005b	51		 push	 ecx
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8d 55 e0	 lea	 edx, DWORD PTR _r$157299[ebp]
  00062	52		 push	 edx
  00063	89 5d f4	 mov	 DWORD PTR _slot$157293[ebp], ebx
  00066	e8 00 00 00 00	 call	 ?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_descend

; 2207 : 
; 2208 :             if (newchild)

  0006b	83 7d 0c 00	 cmp	 DWORD PTR _newchild$157292[ebp], 0
  0006f	74 61		 je	 SHORT $LN32@insert_des

; 2209 :             {
; 2210 :                 BTREE_PRINT("btree::insert_descend newchild with key " << newkey << " node " << newchild << " at slot " << slot);
; 2211 : 
; 2212 :                 if (inner->isfull())

  00071	66 83 7e 02 20	 cmp	 WORD PTR [esi+2], 32	; 00000020H
  00076	0f 85 92 00 00
	00		 jne	 $LN289@insert_des

; 2213 :                 {
; 2214 :                     split_inner_node(inner, splitkey, splitnode, slot);

  0007c	8b 45 1c	 mov	 eax, DWORD PTR _splitnode$[ebp]
  0007f	8b 4d 18	 mov	 ecx, DWORD PTR _splitkey$[ebp]
  00082	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00085	53		 push	 ebx
  00086	50		 push	 eax
  00087	51		 push	 ecx
  00088	52		 push	 edx
  00089	e8 00 00 00 00	 call	 ?split_inner_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUinner_node@12@PAIPAPAUnode@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_inner_node

; 2215 : 
; 2216 :                     BTREE_PRINT("btree::insert_descend done split_inner: putslot: " << slot << " putkey: " << newkey << " upkey: " << *splitkey);
; 2217 : 
; 2218 : #ifdef BTREE_DEBUG
; 2219 :                     if (debug)
; 2220 :                     {
; 2221 :                         print_node(std::cout, inner);
; 2222 :                         print_node(std::cout, *splitnode);
; 2223 :                     }
; 2224 : #endif
; 2225 : 
; 2226 :                     // check if insert slot is in the split sibling node
; 2227 :                     BTREE_PRINT("btree::insert_descend switch: " << slot << " > " << inner->slotuse+1);
; 2228 : 
; 2229 :                     if (slot == inner->slotuse+1 && inner->slotuse < (*splitnode)->slotuse)

  0008e	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00092	8b c1		 mov	 eax, ecx
  00094	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00097	3b da		 cmp	 ebx, edx
  00099	75 62		 jne	 SHORT $LN21@insert_des
  0009b	8b 55 1c	 mov	 edx, DWORD PTR _splitnode$[ebp]
  0009e	8b 12		 mov	 edx, DWORD PTR [edx]
  000a0	66 3b 4a 02	 cmp	 cx, WORD PTR [edx+2]
  000a4	73 57		 jae	 SHORT $LN21@insert_des

; 2230 :                     {
; 2231 :                         // special case when the insert slot matches the split
; 2232 :                         // place between the two nodes, then the insert key
; 2233 :                         // becomes the split key.
; 2234 : 
; 2235 :                         BTREE_ASSERT(inner->slotuse + 1 < innerslotmax);
; 2236 : 
; 2237 :                         inner_node *splitinner = static_cast<inner_node*>(*splitnode);
; 2238 : 
; 2239 :                         // move the split key and it's datum into the left node
; 2240 :                         inner->slotkey[inner->slotuse] = *splitkey;

  000a6	8b 4d 18	 mov	 ecx, DWORD PTR _splitkey$[ebp]
  000a9	8b 39		 mov	 edi, DWORD PTR [ecx]
  000ab	89 7c 86 04	 mov	 DWORD PTR [esi+eax*4+4], edi

; 2241 :                         inner->childid[inner->slotuse+1] = splitinner->childid[0];

  000af	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  000b3	8b ba 84 00 00
	00		 mov	 edi, DWORD PTR [edx+132]
  000b9	89 bc 86 88 00
	00 00		 mov	 DWORD PTR [esi+eax*4+136], edi

; 2242 :                         inner->slotuse++;
; 2243 : 
; 2244 :                         // set new split key and move corresponding datum into right node
; 2245 :                         splitinner->childid[0] = newchild;

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _newchild$157292[ebp]
  000c3	66 ff 46 02	 inc	 WORD PTR [esi+2]
  000c7	89 82 84 00 00
	00		 mov	 DWORD PTR [edx+132], eax

; 2246 :                         *splitkey = newkey;

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _newkey$157291[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx
$LN32@insert_des:

; 2247 : 
; 2248 :                         return r;

  000d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _r$157299[ebp]
  000d8	66 8b 55 e4	 mov	 dx, WORD PTR _r$157299[ebp+4]
  000dc	89 08		 mov	 DWORD PTR [eax], ecx
  000de	8b 4d e8	 mov	 ecx, DWORD PTR _r$157299[ebp+8]
  000e1	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  000e5	8b 55 ec	 mov	 edx, DWORD PTR _r$157299[ebp+12]
  000e8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000eb	8a 4d f0	 mov	 cl, BYTE PTR _r$157299[ebp+16]
  000ee	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000f1	88 48 10	 mov	 BYTE PTR [eax+16], cl

; 2319 :         }
; 2320 :     }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 18 00	 ret	 24			; 00000018H
$LN21@insert_des:

; 2249 :                     }
; 2250 :                     else if (slot >= inner->slotuse+1)

  000fd	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00100	3b d9		 cmp	 ebx, ecx
  00102	7c 0a		 jl	 SHORT $LN289@insert_des

; 2251 :                     {
; 2252 :                         // in case the insert slot is in the newly create split
; 2253 :                         // node, we reuse the code below.
; 2254 : 
; 2255 :                         slot -= inner->slotuse+1;
; 2256 :                         inner = static_cast<inner_node*>(*splitnode);

  00104	8b 55 1c	 mov	 edx, DWORD PTR _splitnode$[ebp]
  00107	8b 3a		 mov	 edi, DWORD PTR [edx]
  00109	2b d8		 sub	 ebx, eax
  0010b	4b		 dec	 ebx
  0010c	eb 03		 jmp	 SHORT $LN13@insert_des
$LN289@insert_des:
  0010e	8b 5d f4	 mov	 ebx, DWORD PTR _slot$157293[ebp]
$LN13@insert_des:

; 2257 :                         BTREE_PRINT("btree::insert_descend switching to splitted node " << inner << " slot " << slot);
; 2258 :                     }
; 2259 :                 }
; 2260 : 
; 2261 :                 // move items and put pointer to child node into correct slot
; 2262 :                 BTREE_ASSERT(slot >= 0 && slot <= inner->slotuse);
; 2263 : 
; 2264 :                 std::copy_backward(inner->slotkey + slot, inner->slotkey + inner->slotuse,
; 2265 :                                    inner->slotkey + inner->slotuse+1);

  00111	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00115	8d 04 8d 04 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+4]
  0011c	8d 74 9f 04	 lea	 esi, DWORD PTR [edi+ebx*4+4]
  00120	2b c6		 sub	 eax, esi
  00122	03 c7		 add	 eax, edi
  00124	c1 f8 02	 sar	 eax, 2
  00127	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0012e	52		 push	 edx
  0012f	2b c8		 sub	 ecx, eax
  00131	8d 44 8f 08	 lea	 eax, DWORD PTR [edi+ecx*4+8]
  00135	56		 push	 esi
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _memmove

; 2266 :                 std::copy_backward(inner->childid + slot, inner->childid + inner->slotuse+1,
; 2267 :                                    inner->childid + inner->slotuse+2);

  0013c	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  00140	8d 04 8d 88 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+136]
  00147	8d 94 9f 84 00
	00 00		 lea	 edx, DWORD PTR [edi+ebx*4+132]
  0014e	2b c2		 sub	 eax, edx
  00150	03 c7		 add	 eax, edi
  00152	c1 f8 02	 sar	 eax, 2
  00155	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0015c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015f	52		 push	 edx
  00160	8d 94 9f 84 00
	00 00		 lea	 edx, DWORD PTR [edi+ebx*4+132]
  00167	2b c8		 sub	 ecx, eax
  00169	52		 push	 edx
  0016a	8d 84 8f 8c 00
	00 00		 lea	 eax, DWORD PTR [edi+ecx*4+140]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _memmove

; 2268 : 
; 2269 :                 inner->slotkey[slot] = newkey;

  00177	8b 4d fc	 mov	 ecx, DWORD PTR _newkey$157291[ebp]
  0017a	89 0e		 mov	 DWORD PTR [esi], ecx

; 2270 :                 inner->childid[slot + 1] = newchild;

  0017c	8b 55 0c	 mov	 edx, DWORD PTR _newchild$157292[ebp]
  0017f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00182	89 94 9f 88 00
	00 00		 mov	 DWORD PTR [edi+ebx*4+136], edx

; 2271 :                 inner->slotuse++;

  00189	66 ff 47 02	 inc	 WORD PTR [edi+2]

; 2272 :             }
; 2273 : 
; 2274 :             return r;

  0018d	e9 40 ff ff ff	 jmp	 $LN32@insert_des
$LN36@insert_des:

; 2275 :         }
; 2276 :         else // n->isleafnode() == true
; 2277 :         {
; 2278 :             leaf_node *leaf = static_cast<leaf_node*>(n);
; 2279 : 
; 2280 :             int slot = find_lower(leaf, key);

  00192	0f b7 7e 02	 movzx	 edi, WORD PTR [esi+2]
  00196	8b d7		 mov	 edx, edi
  00198	3b d1		 cmp	 edx, ecx
  0019a	7e 20		 jle	 SHORT $LN146@insert_des

; 2281 : 
; 2282 :             if (!allow_duplicates && slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot])) {

  0019c	8b 45 10	 mov	 eax, DWORD PTR _key$[ebp]

; 2316 :             }
; 2317 : 
; 2318 :             return std::pair<iterator, bool>(iterator(leaf, slot), true);

  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	89 4d 0c	 mov	 DWORD PTR tv974[ebp], ecx
  001a4	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
$LN147@insert_des:

; 2275 :         }
; 2276 :         else // n->isleafnode() == true
; 2277 :         {
; 2278 :             leaf_node *leaf = static_cast<leaf_node*>(n);
; 2279 : 
; 2280 :             int slot = find_lower(leaf, key);

  001a7	8b 4d 0c	 mov	 ecx, DWORD PTR tv974[ebp]
  001aa	39 08		 cmp	 DWORD PTR [eax], ecx
  001ac	73 0c		 jae	 SHORT $LN296@insert_des
  001ae	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  001b2	43		 inc	 ebx
  001b3	83 c0 04	 add	 eax, 4
  001b6	3b d9		 cmp	 ebx, ecx
  001b8	7c ed		 jl	 SHORT $LN147@insert_des
$LN296@insert_des:
  001ba	33 c9		 xor	 ecx, ecx
$LN146@insert_des:
  001bc	89 5d 0c	 mov	 DWORD PTR _slot$157330[ebp], ebx

; 2281 : 
; 2282 :             if (!allow_duplicates && slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot])) {

  001bf	3b da		 cmp	 ebx, edx
  001c1	7d 2b		 jge	 SHORT $LN8@insert_des
  001c3	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  001c6	8b 02		 mov	 eax, DWORD PTR [edx]
  001c8	8b 54 9e 0c	 mov	 edx, DWORD PTR [esi+ebx*4+12]
  001cc	3b d0		 cmp	 edx, eax
  001ce	77 1e		 ja	 SHORT $LN8@insert_des
  001d0	72 1c		 jb	 SHORT $LN8@insert_des

; 2283 :                 return std::pair<iterator, bool>(iterator(leaf, slot), false);

  001d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001d5	89 30		 mov	 DWORD PTR [eax], esi
  001d7	66 89 58 04	 mov	 WORD PTR [eax+4], bx
  001db	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001de	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  001e1	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 2319 :         }
; 2320 :     }

  001e5	5f		 pop	 edi
  001e6	5e		 pop	 esi
  001e7	5b		 pop	 ebx
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c2 18 00	 ret	 24			; 00000018H
$LN8@insert_des:

; 2284 :             }
; 2285 : 
; 2286 :             if (leaf->isfull())

  001ee	83 ff 20	 cmp	 edi, 32			; 00000020H
  001f1	75 25		 jne	 SHORT $LN5@insert_des

; 2287 :             {
; 2288 :                 split_leaf_node(leaf, splitkey, splitnode);

  001f3	8b 45 1c	 mov	 eax, DWORD PTR _splitnode$[ebp]
  001f6	8b 4d 18	 mov	 ecx, DWORD PTR _splitkey$[ebp]
  001f9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  001fc	50		 push	 eax
  001fd	51		 push	 ecx
  001fe	52		 push	 edx
  001ff	8b fe		 mov	 edi, esi
  00201	e8 00 00 00 00	 call	 ?split_leaf_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUleaf_node@12@PAIPAPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::split_leaf_node

; 2289 : 
; 2290 :                 // check if insert slot is in the split sibling node
; 2291 :                 if (slot >= leaf->slotuse)

  00206	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  0020a	3b d8		 cmp	 ebx, eax
  0020c	7c 0a		 jl	 SHORT $LN5@insert_des

; 2292 :                 {
; 2293 :                     slot -= leaf->slotuse;

  0020e	2b d8		 sub	 ebx, eax

; 2294 :                     leaf = static_cast<leaf_node*>(*splitnode);

  00210	8b 45 1c	 mov	 eax, DWORD PTR _splitnode$[ebp]
  00213	8b 30		 mov	 esi, DWORD PTR [eax]
  00215	89 5d 0c	 mov	 DWORD PTR _slot$157330[ebp], ebx
$LN5@insert_des:

; 2295 :                 }
; 2296 :             }
; 2297 : 
; 2298 :             // move items and put data item into correct data slot
; 2299 :             BTREE_ASSERT(slot >= 0 && slot <= leaf->slotuse);
; 2300 : 
; 2301 :             std::copy_backward(leaf->slotkey + slot, leaf->slotkey + leaf->slotuse,
; 2302 :                                leaf->slotkey + leaf->slotuse+1);

  00218	8b 4d 0c	 mov	 ecx, DWORD PTR _slot$157330[ebp]
  0021b	8d 7c 8e 0c	 lea	 edi, DWORD PTR [esi+ecx*4+12]
  0021f	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00223	8d 04 8d 0c 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+12]
  0022a	2b c7		 sub	 eax, edi
  0022c	03 c6		 add	 eax, esi
  0022e	c1 f8 02	 sar	 eax, 2
  00231	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  00238	52		 push	 edx
  00239	2b c8		 sub	 ecx, eax
  0023b	8d 44 8e 10	 lea	 eax, DWORD PTR [esi+ecx*4+16]
  0023f	57		 push	 edi
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 _memmove

; 2303 :             data_copy_backward(leaf->slotdata + slot, leaf->slotdata + leaf->slotuse,
; 2304 :                                leaf->slotdata + leaf->slotuse+1);

  00246	8b 4d 0c	 mov	 ecx, DWORD PTR _slot$157330[ebp]
  00249	8d 9c 8e 8c 00
	00 00		 lea	 ebx, DWORD PTR [esi+ecx*4+140]
  00250	0f b7 4e 02	 movzx	 ecx, WORD PTR [esi+2]
  00254	8d 04 8d 8c 00
	00 00		 lea	 eax, DWORD PTR [ecx*4+140]
  0025b	2b c3		 sub	 eax, ebx
  0025d	03 c6		 add	 eax, esi
  0025f	c1 f8 02	 sar	 eax, 2
  00262	83 c4 0c	 add	 esp, 12			; 0000000cH
  00265	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]
  0026c	52		 push	 edx
  0026d	2b c8		 sub	 ecx, eax
  0026f	8d 84 8e 90 00
	00 00		 lea	 eax, DWORD PTR [esi+ecx*4+144]
  00276	53		 push	 ebx
  00277	50		 push	 eax
  00278	e8 00 00 00 00	 call	 _memmove

; 2305 : 
; 2306 :             leaf->slotkey[slot] = key;

  0027d	8b 55 10	 mov	 edx, DWORD PTR _key$[ebp]
  00280	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 2307 :             if (!used_as_set) leaf->slotdata[slot] = value;

  00282	8b 45 14	 mov	 eax, DWORD PTR _value$[ebp]
  00285	89 0f		 mov	 DWORD PTR [edi], ecx
  00287	8b 08		 mov	 ecx, DWORD PTR [eax]
  00289	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2308 :             leaf->slotuse++;

  0028b	66 ff 46 02	 inc	 WORD PTR [esi+2]

; 2309 : 
; 2310 :             if (splitnode && leaf != *splitnode && slot == leaf->slotuse-1)

  0028f	8b 4d 1c	 mov	 ecx, DWORD PTR _splitnode$[ebp]
  00292	66 8b 46 02	 mov	 ax, WORD PTR [esi+2]
  00296	33 ff		 xor	 edi, edi
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH
  0029b	3b cf		 cmp	 ecx, edi
  0029d	74 14		 je	 SHORT $LN1@insert_des
  0029f	3b 31		 cmp	 esi, DWORD PTR [ecx]
  002a1	74 10		 je	 SHORT $LN1@insert_des
  002a3	0f b7 c0	 movzx	 eax, ax
  002a6	48		 dec	 eax
  002a7	39 45 0c	 cmp	 DWORD PTR _slot$157330[ebp], eax
  002aa	75 07		 jne	 SHORT $LN1@insert_des

; 2311 :             {
; 2312 :                 // special case: the node was split, and the insert is at the
; 2313 :                 // last slot of the old node. then the splitkey must be
; 2314 :                 // updated.
; 2315 :                 *splitkey = key;

  002ac	8b 0a		 mov	 ecx, DWORD PTR [edx]
  002ae	8b 55 18	 mov	 edx, DWORD PTR _splitkey$[ebp]
  002b1	89 0a		 mov	 DWORD PTR [edx], ecx
$LN1@insert_des:

; 2316 :             }
; 2317 : 
; 2318 :             return std::pair<iterator, bool>(iterator(leaf, slot), true);

  002b3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002b6	66 8b 4d 0c	 mov	 cx, WORD PTR _slot$157330[ebp]
  002ba	89 30		 mov	 DWORD PTR [eax], esi
  002bc	66 89 48 04	 mov	 WORD PTR [eax+4], cx
  002c0	89 78 08	 mov	 DWORD PTR [eax+8], edi
  002c3	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 2319 :         }
; 2320 :     }

  002c6	5f		 pop	 edi
  002c7	5e		 pop	 esi
  002c8	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1
  002cc	5b		 pop	 ebx
  002cd	8b e5		 mov	 esp, ebp
  002cf	5d		 pop	 ebp
  002d0	c2 18 00	 ret	 24			; 00000018H
?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_descend
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo, COMDAT
; _this$ = eax
; _v$ = ecx

; 1167 :         : alloc_impl<value_alloc_type>(v), emptyval(v.emptyval) { }

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	89 10		 mov	 DWORD PTR [eax], edx
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0000a	c3		 ret	 0
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV012@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z
_TEXT	SEGMENT
?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash, COMDAT
; _v$ = eax

; 65   :     return hasher::operator()(v);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 66   :   }

  00035	c3		 ret	 0
?hash@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEIABI@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::hash
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty, COMDAT
; _this$ = edx
; _it$ = eax

; 465  :     assert(settings.use_empty());  // we always need to know what's empty!
; 466  :     return equals(get_key(val_info.emptyval), get_key(*it));

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00006	33 d2		 xor	 edx, edx
  00008	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000a	0f 94 c0	 sete	 al

; 467  :   }

  0000d	c3		 ret	 0
?test_empty@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_empty
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z
_TEXT	SEGMENT
?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key, COMDAT
; _this$ = eax
; _key$ = ecx

; 378  :     // The num_deleted test is crucial for read(): after read(), the ht values
; 379  :     // are garbage, and we don't want to think some of them are deleted.
; 380  :     // Invariant: !use_deleted implies num_deleted is 0.
; 381  :     assert(settings.use_deleted() || num_deleted == 0);
; 382  :     return num_deleted > 0 && equals(key_info.delkey, key);

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 0d		 jbe	 SHORT $LN3@test_delet
  00006	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00009	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000b	75 06		 jne	 SHORT $LN3@test_delet
  0000d	b8 01 00 00 00	 mov	 eax, 1

; 383  :   }

  00012	c3		 ret	 0
$LN3@test_delet:

; 378  :     // The num_deleted test is crucial for read(): after read(), the ht values
; 379  :     // are garbage, and we don't want to think some of them are deleted.
; 380  :     // Invariant: !use_deleted implies num_deleted is 0.
; 381  :     assert(settings.use_deleted() || num_deleted == 0);
; 382  :     return num_deleted > 0 && equals(key_info.delkey, key);

  00013	33 c0		 xor	 eax, eax

; 383  :   }

  00015	c3		 ret	 0
?test_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE_NABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted_key
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z
_TEXT	SEGMENT
$T186544 = -20						; size = 12
$T186447 = -20						; size = 12
_newkey$ = -8						; size = 4
_newchild$ = -4						; size = 4
$T186486 = 8						; size = 4
$T186395 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
_value$ = 16						; size = 4
?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start, COMDAT
; _this$ = esi

; 2145 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 2146 :         node *newchild = NULL;

  00007	33 db		 xor	 ebx, ebx
  00009	57		 push	 edi
  0000a	89 5d fc	 mov	 DWORD PTR _newchild$[ebp], ebx

; 2147 :         key_type newkey = key_type();

  0000d	89 5d f8	 mov	 DWORD PTR _newkey$[ebp], ebx

; 2148 : 
; 2149 :         if (m_root == NULL) {

  00010	39 1e		 cmp	 DWORD PTR [esi], ebx
  00012	75 3b		 jne	 SHORT $LN7@insert_sta

; 2150 :             m_root = m_headleaf = m_tailleaf = allocate_leaf();

  00014	68 0c 01 00 00	 push	 268			; 0000010cH
  00019	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001e	8b f8		 mov	 edi, eax
  00020	83 c4 04	 add	 esp, 4
  00023	3b fb		 cmp	 edi, ebx
  00025	0f 84 b8 00 00
	00		 je	 $LN20@insert_sta
  0002b	68 0c 01 00 00	 push	 268			; 0000010cH
  00030	53		 push	 ebx
  00031	57		 push	 edi
  00032	e8 00 00 00 00	 call	 _memset
  00037	33 c0		 xor	 eax, eax
  00039	89 07		 mov	 DWORD PTR [edi], eax
  0003b	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  0003e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH
  00044	ff 46 10	 inc	 DWORD PTR [esi+16]
  00047	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004a	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0004d	89 3e		 mov	 DWORD PTR [esi], edi
$LN7@insert_sta:

; 2151 :         }
; 2152 : 
; 2153 :         std::pair<iterator, bool> r = insert_descend(m_root, key, value, &newkey, &newchild);

  0004f	8b 45 10	 mov	 eax, DWORD PTR _value$[ebp]
  00052	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00055	8d 4d fc	 lea	 ecx, DWORD PTR _newchild$[ebp]
  00058	51		 push	 ecx
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  0005c	8d 55 f8	 lea	 edx, DWORD PTR _newkey$[ebp]
  0005f	52		 push	 edx
  00060	8b 16		 mov	 edx, DWORD PTR [esi]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	52		 push	 edx
  00065	57		 push	 edi
  00066	8b ce		 mov	 ecx, esi
  00068	e8 00 00 00 00	 call	 ?insert_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@PAUnode@12@ABIABQAUstx_object@@PAIPAPAU512@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_descend

; 2154 : 
; 2155 :         if (newchild)

  0006d	39 5d fc	 cmp	 DWORD PTR _newchild$[ebp], ebx
  00070	74 5e		 je	 SHORT $LN6@insert_sta

; 2156 :         {
; 2157 :             inner_node *newroot = allocate_inner(m_root->level + 1);

  00072	8b 06		 mov	 eax, DWORD PTR [esi]
  00074	66 8b 08	 mov	 cx, WORD PTR [eax]
  00077	66 41		 inc	 cx
  00079	68 08 01 00 00	 push	 264			; 00000108H
  0007e	0f b7 d9	 movzx	 ebx, cx
  00081	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00086	8b f8		 mov	 edi, eax
  00088	83 c4 04	 add	 esp, 4
  0008b	85 ff		 test	 edi, edi
  0008d	74 78		 je	 SHORT $LN47@insert_sta
  0008f	68 08 01 00 00	 push	 264			; 00000108H
  00094	6a 00		 push	 0
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 _memset

; 2158 :             newroot->slotkey[0] = newkey;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _newkey$[ebp]
  0009f	33 d2		 xor	 edx, edx
  000a1	66 89 57 02	 mov	 WORD PTR [edi+2], dx

; 2159 : 
; 2160 :             newroot->childid[0] = m_root;
; 2161 :             newroot->childid[1] = newchild;

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _newchild$[ebp]
  000a8	66 89 1f	 mov	 WORD PTR [edi], bx
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	ff 46 14	 inc	 DWORD PTR [esi+20]
  000b1	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000b4	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 2162 : 
; 2163 :             newroot->slotuse = 1;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	89 8f 84 00 00
	00		 mov	 DWORD PTR [edi+132], ecx
  000c1	89 97 88 00 00
	00		 mov	 DWORD PTR [edi+136], edx
  000c7	66 89 47 02	 mov	 WORD PTR [edi+2], ax

; 2164 : 
; 2165 :             m_root = newroot;

  000cb	89 3e		 mov	 DWORD PTR [esi], edi
  000cd	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@insert_sta:

; 2166 :         }
; 2167 : 
; 2168 :         // increment itemcount if the item was inserted
; 2169 :         if (r.second) ++m_stats.itemcount;

  000d0	80 7f 10 00	 cmp	 BYTE PTR [edi+16], 0
  000d4	74 03		 je	 SHORT $LN1@insert_sta
  000d6	ff 46 0c	 inc	 DWORD PTR [esi+12]
$LN1@insert_sta:

; 2170 : 
; 2171 : #ifdef BTREE_DEBUG
; 2172 :         if (debug) print(std::cout);
; 2173 : #endif
; 2174 : 
; 2175 :         if (selfverify) {
; 2176 :             verify();
; 2177 :             BTREE_ASSERT(exists(key));
; 2178 :         }
; 2179 : 
; 2180 :         return r;

  000d9	8b c7		 mov	 eax, edi

; 2181 :     }

  000db	5f		 pop	 edi
  000dc	5b		 pop	 ebx
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c2 0c 00	 ret	 12			; 0000000cH

; 2150 :             m_root = m_headleaf = m_tailleaf = allocate_leaf();

$LN20@insert_sta:
  000e3	8d 55 08	 lea	 edx, DWORD PTR $T186395[ebp]
  000e6	52		 push	 edx
  000e7	8d 4d ec	 lea	 ecx, DWORD PTR $T186447[ebp]
  000ea	89 5d 08	 mov	 DWORD PTR $T186395[ebp], ebx
  000ed	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000f2	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000f7	8d 45 ec	 lea	 eax, DWORD PTR $T186447[ebp]
  000fa	50		 push	 eax
  000fb	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T186447[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00102	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN74@insert_sta:

; 2156 :         {
; 2157 :             inner_node *newroot = allocate_inner(m_root->level + 1);

$LN47@insert_sta:
  00107	8d 4d 08	 lea	 ecx, DWORD PTR $T186486[ebp]
  0010a	51		 push	 ecx
  0010b	8d 4d ec	 lea	 ecx, DWORD PTR $T186544[ebp]
  0010e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T186486[ebp], 0
  00115	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0011a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0011f	8d 55 ec	 lea	 edx, DWORD PTR $T186544[ebp]
  00122	52		 push	 edx
  00123	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T186544[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0012a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN75@insert_sta:
$LN73@insert_sta:
  0012f	cc		 int	 3
?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z
_TEXT	SEGMENT
_slot$156761 = 8					; size = 2
_n$ = 8							; size = 4
?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive, COMDAT
; _this$ = ecx

; 1546 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1547 :         if (n->isleafnode())

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _n$[ebp]
  00007	56		 push	 esi
  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	66 39 33	 cmp	 WORD PTR [ebx], si
  00010	74 56		 je	 SHORT $LN1@clear_recu

; 1548 :         {
; 1549 :             leaf_node *leafnode = static_cast<leaf_node*>(n);
; 1550 : 
; 1551 :             for (unsigned int slot = 0; slot < leafnode->slotuse; ++slot)
; 1552 :             {
; 1553 :                 // data objects are deleted by leaf_node's destructor
; 1554 :             }
; 1555 :         }
; 1556 :         else
; 1557 :         {
; 1558 :             inner_node *innernode = static_cast<inner_node*>(n);
; 1559 : 
; 1560 :             for (unsigned short slot = 0; slot < innernode->slotuse + 1; ++slot)

  00012	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  00016	40		 inc	 eax
  00017	89 75 08	 mov	 DWORD PTR _slot$156761[ebp], esi
  0001a	85 c0		 test	 eax, eax
  0001c	7e 4a		 jle	 SHORT $LN1@clear_recu
  0001e	8b ff		 npad	 2
$LL3@clear_recu:

; 1561 :             {
; 1562 :                 clear_recursive(innernode->childid[slot]);

  00020	8b 8c b3 84 00
	00 00		 mov	 ecx, DWORD PTR [ebx+esi*4+132]
  00027	51		 push	 ecx
  00028	8b cf		 mov	 ecx, edi
  0002a	e8 00 00 00 00	 call	 ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive

; 1563 :                 free_node(innernode->childid[slot]);

  0002f	8b b4 b3 84 00
	00 00		 mov	 esi, DWORD PTR [ebx+esi*4+132]
  00036	66 83 3e 00	 cmp	 WORD PTR [esi], 0
  0003a	56		 push	 esi
  0003b	75 0d		 jne	 SHORT $LN14@clear_recu
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00042	83 c4 04	 add	 esp, 4
  00045	ff 4f 10	 dec	 DWORD PTR [edi+16]
  00048	eb 0b		 jmp	 SHORT $LN2@clear_recu
$LN14@clear_recu:
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004f	83 c4 04	 add	 esp, 4
  00052	ff 4f 14	 dec	 DWORD PTR [edi+20]
$LN2@clear_recu:

; 1548 :         {
; 1549 :             leaf_node *leafnode = static_cast<leaf_node*>(n);
; 1550 : 
; 1551 :             for (unsigned int slot = 0; slot < leafnode->slotuse; ++slot)
; 1552 :             {
; 1553 :                 // data objects are deleted by leaf_node's destructor
; 1554 :             }
; 1555 :         }
; 1556 :         else
; 1557 :         {
; 1558 :             inner_node *innernode = static_cast<inner_node*>(n);
; 1559 : 
; 1560 :             for (unsigned short slot = 0; slot < innernode->slotuse + 1; ++slot)

  00055	8b 45 08	 mov	 eax, DWORD PTR _slot$156761[ebp]
  00058	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  0005c	40		 inc	 eax
  0005d	0f b7 f0	 movzx	 esi, ax
  00060	42		 inc	 edx
  00061	89 45 08	 mov	 DWORD PTR _slot$156761[ebp], eax
  00064	3b f2		 cmp	 esi, edx
  00066	7c b8		 jl	 SHORT $LL3@clear_recu
$LN1@clear_recu:
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx

; 1564 :             }
; 1565 :         }
; 1566 :     }

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 50   :   btree_container(const key_compare &comp, const allocator_type &alloc)

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 51   :       : tree_(comp, alloc) {
; 52   :   }

  00006	c3		 ret	 0
??0?$btree_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z
_TEXT	SEGMENT
?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash, COMDAT
; _v$ = eax

; 1209 :     return settings.hash(v);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 1210 :   }

  00035	c3		 ret	 0
?hash@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABEIABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::hash
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z
_TEXT	SEGMENT
tv446 = -16						; size = 8
tv438 = -16						; size = 8
tv426 = -16						; size = 8
tv418 = -16						; size = 8
_tmp$156523 = -16					; size = 8
tv455 = -12						; size = 4
tv448 = -12						; size = 4
tv440 = -12						; size = 4
tv435 = -12						; size = 4
tv428 = -12						; size = 4
tv420 = -12						; size = 4
tv451 = -2						; size = 2
tv443 = -2						; size = 2
tv431 = -2						; size = 2
tv423 = -2						; size = 2
?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap, COMDAT
; _this$ = ecx
; _ht$ = edx

; 734  :   void swap(dense_hashtable& ht) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 735  :     STL_NAMESPACE::swap(settings, ht.settings);

  00006	f3 0f 7e 1a	 movq	 xmm3, QWORD PTR [edx]
  0000a	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  0000e	f3 0f 7e 49 08	 movq	 xmm1, QWORD PTR [ecx+8]
  00013	f3 0f 7e 51 10	 movq	 xmm2, QWORD PTR [ecx+16]
  00018	66 0f d6 19	 movq	 QWORD PTR [ecx], xmm3
  0001c	f3 0f 7e 5a 08	 movq	 xmm3, QWORD PTR [edx+8]
  00021	66 0f d6 59 08	 movq	 QWORD PTR [ecx+8], xmm3
  00026	f3 0f 7e 5a 10	 movq	 xmm3, QWORD PTR [edx+16]
  0002b	66 0f d6 59 10	 movq	 QWORD PTR [ecx+16], xmm3
  00030	66 0f d6 02	 movq	 QWORD PTR [edx], xmm0
  00034	66 0f d6 4a 08	 movq	 QWORD PTR [edx+8], xmm1
  00039	66 0f d6 52 10	 movq	 QWORD PTR [edx+16], xmm2

; 736  :     STL_NAMESPACE::swap(key_info, ht.key_info);

  0003e	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00041	53		 push	 ebx
  00042	56		 push	 esi
  00043	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  00046	57		 push	 edi
  00047	8b 7a 18	 mov	 edi, DWORD PTR [edx+24]
  0004a	89 79 18	 mov	 DWORD PTR [ecx+24], edi
  0004d	8b 7a 1c	 mov	 edi, DWORD PTR [edx+28]
  00050	89 79 1c	 mov	 DWORD PTR [ecx+28], edi
  00053	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00056	89 72 1c	 mov	 DWORD PTR [edx+28], esi

; 737  :     STL_NAMESPACE::swap(num_deleted, ht.num_deleted);

  00059	8b 72 20	 mov	 esi, DWORD PTR [edx+32]
  0005c	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0005f	89 71 20	 mov	 DWORD PTR [ecx+32], esi
  00062	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 738  :     STL_NAMESPACE::swap(num_elements, ht.num_elements);

  00065	8b 72 24	 mov	 esi, DWORD PTR [edx+36]
  00068	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0006b	89 71 24	 mov	 DWORD PTR [ecx+36], esi
  0006e	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 739  :     STL_NAMESPACE::swap(num_buckets, ht.num_buckets);

  00071	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  00074	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00077	89 71 28	 mov	 DWORD PTR [ecx+40], esi
  0007a	89 42 28	 mov	 DWORD PTR [edx+40], eax

; 740  :     { value_type tmp;     // for annoying reasons, swap() doesn't work
; 741  :       set_value(&tmp, val_info.emptyval);

  0007d	8b 71 30	 mov	 esi, DWORD PTR [ecx+48]
  00080	8b 79 2c	 mov	 edi, DWORD PTR [ecx+44]
  00083	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]
  00086	89 75 f4	 mov	 DWORD PTR _tmp$156523[ebp+4], esi

; 742  :       set_value(&val_info.emptyval, ht.val_info.emptyval);

  00089	8d 72 2c	 lea	 esi, DWORD PTR [edx+44]
  0008c	85 c0		 test	 eax, eax
  0008e	74 0a		 je	 SHORT $LN59@swap@2
  00090	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00092	89 18		 mov	 DWORD PTR [eax], ebx
  00094	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00097	89 58 04	 mov	 DWORD PTR [eax+4], ebx
$LN59@swap@2:

; 743  :       set_value(&ht.val_info.emptyval, tmp);

  0009a	33 db		 xor	 ebx, ebx
  0009c	3b f3		 cmp	 esi, ebx
  0009e	74 08		 je	 SHORT $LN69@swap@2
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _tmp$156523[ebp+4]
  000a3	89 3e		 mov	 DWORD PTR [esi], edi
  000a5	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN69@swap@2:

; 744  :     }
; 745  :     STL_NAMESPACE::swap(table, ht.table);

  000a8	8b 72 34	 mov	 esi, DWORD PTR [edx+52]
  000ab	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  000ae	89 71 34	 mov	 DWORD PTR [ecx+52], esi
  000b1	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 746  :     settings.reset_thresholds(bucket_count());  // this also resets consider_shrink

  000b4	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  000b7	8b c6		 mov	 eax, esi
  000b9	89 45 f4	 mov	 DWORD PTR tv455[ebp], eax
  000bc	db 45 f4	 fild	 DWORD PTR tv455[ebp]
  000bf	85 c0		 test	 eax, eax
  000c1	79 06		 jns	 SHORT $LN113@swap@2
  000c3	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN113@swap@2:
  000c9	d9 41 08	 fld	 DWORD PTR [ecx+8]
  000cc	88 59 10	 mov	 BYTE PTR [ecx+16], bl
  000cf	d9 7d fe	 fnstcw	 WORD PTR tv451[ebp]
  000d2	0f b7 45 fe	 movzx	 eax, WORD PTR tv451[ebp]
  000d6	d8 c9		 fmul	 ST(0), ST(1)
  000d8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000dd	89 45 f4	 mov	 DWORD PTR tv448[ebp], eax
  000e0	d9 6d f4	 fldcw	 WORD PTR tv448[ebp]
  000e3	df 7d f0	 fistp	 QWORD PTR tv446[ebp]
  000e6	8b 45 f0	 mov	 eax, DWORD PTR tv446[ebp]
  000e9	89 01		 mov	 DWORD PTR [ecx], eax
  000eb	d9 6d fe	 fldcw	 WORD PTR tv451[ebp]
  000ee	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  000f1	d9 7d fe	 fnstcw	 WORD PTR tv443[ebp]
  000f4	0f b7 45 fe	 movzx	 eax, WORD PTR tv443[ebp]
  000f8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000fd	89 45 f4	 mov	 DWORD PTR tv440[ebp], eax
  00100	d9 6d f4	 fldcw	 WORD PTR tv440[ebp]
  00103	df 7d f0	 fistp	 QWORD PTR tv438[ebp]
  00106	8b 45 f0	 mov	 eax, DWORD PTR tv438[ebp]

; 747  :     ht.settings.reset_thresholds(bucket_count());

  00109	89 75 f4	 mov	 DWORD PTR tv435[ebp], esi
  0010c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0010f	d9 6d fe	 fldcw	 WORD PTR tv443[ebp]
  00112	db 45 f4	 fild	 DWORD PTR tv435[ebp]
  00115	85 f6		 test	 esi, esi
  00117	79 06		 jns	 SHORT $LN114@swap@2
  00119	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN114@swap@2:
  0011f	d9 42 08	 fld	 DWORD PTR [edx+8]

; 748  :     // we purposefully don't swap the allocator, which may not be swap-able
; 749  :   }

  00122	5f		 pop	 edi
  00123	d9 7d fe	 fnstcw	 WORD PTR tv431[ebp]
  00126	5e		 pop	 esi
  00127	0f b7 45 fe	 movzx	 eax, WORD PTR tv431[ebp]
  0012b	d8 c9		 fmul	 ST(0), ST(1)
  0012d	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00132	89 45 f4	 mov	 DWORD PTR tv428[ebp], eax
  00135	88 5a 10	 mov	 BYTE PTR [edx+16], bl
  00138	d9 6d f4	 fldcw	 WORD PTR tv428[ebp]
  0013b	5b		 pop	 ebx
  0013c	df 7d f0	 fistp	 QWORD PTR tv426[ebp]
  0013f	8b 4d f0	 mov	 ecx, DWORD PTR tv426[ebp]
  00142	89 0a		 mov	 DWORD PTR [edx], ecx
  00144	d9 6d fe	 fldcw	 WORD PTR tv431[ebp]
  00147	d8 4a 0c	 fmul	 DWORD PTR [edx+12]
  0014a	d9 7d fe	 fnstcw	 WORD PTR tv423[ebp]
  0014d	0f b7 45 fe	 movzx	 eax, WORD PTR tv423[ebp]
  00151	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00156	89 45 f4	 mov	 DWORD PTR tv420[ebp], eax
  00159	d9 6d f4	 fldcw	 WORD PTR tv420[ebp]
  0015c	df 7d f0	 fistp	 QWORD PTR tv418[ebp]
  0015f	8b 45 f0	 mov	 eax, DWORD PTR tv418[ebp]
  00162	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00165	d9 6d fe	 fldcw	 WORD PTR tv423[ebp]
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 412  :     return test_deleted_key(get_key(*it));

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN13@test_delet@2
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN13@test_delet@2
  00010	b8 01 00 00 00	 mov	 eax, 1

; 413  :   }

  00015	c3		 ret	 0

; 412  :     return test_deleted_key(get_key(*it));

$LN13@test_delet@2:
  00016	33 c0		 xor	 eax, eax

; 413  :   }

  00018	c3		 ret	 0
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z
_TEXT	SEGMENT
_bucknum$ = 8						; size = 4
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax

; 408  :   bool test_deleted(size_type bucknum) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 409  :     return test_deleted_key(get_key(table[bucknum]));

  00003	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00007	76 17		 jbe	 SHORT $LN11@test_delet@3
  00009	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0000c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0000f	8b 45 08	 mov	 eax, DWORD PTR _bucknum$[ebp]
  00012	3b 14 c1	 cmp	 edx, DWORD PTR [ecx+eax*8]
  00015	75 09		 jne	 SHORT $LN11@test_delet@3
  00017	b8 01 00 00 00	 mov	 eax, 1

; 410  :   }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4

; 409  :     return test_deleted_key(get_key(table[bucknum]));

$LN11@test_delet@3:
  00020	33 c0		 xor	 eax, eax

; 410  :   }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = eax

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 42		 jne	 SHORT $LN3@operator@12

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000f	75 1c		 jne	 SHORT $LN34@operator@12

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00017	75 11		 jne	 SHORT $LN17@operator@12
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL18@operator@12:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL18@operator@12
$LN17@operator@12:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@12:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN1@operator@12
$LL2@operator@12:
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@12

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL2@operator@12
$LN1@operator@12:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator@12:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z
_TEXT	SEGMENT
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z PROC ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator(), COMDAT
; __Keyval$ = eax

; 154  : 		return ((size_t)_Hashobj(_Keyval));

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b c1		 mov	 eax, ecx
  00029	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002c	33 c8		 xor	 ecx, eax
  0002e	8b c1		 mov	 eax, ecx
  00030	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00033	33 c1		 xor	 eax, ecx

; 155  : 		}

  00035	c3		 ret	 0
??R?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@QBEIABI@Z ENDP ; std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >::operator()
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Tmp$187529 = -4					; size = 4
__Buckets$ = 8						; size = 4
?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init, COMDAT
; _this$ = edi

; 842  : 		{	// initialize hash table with _Buckets buckets, leave list alone

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 843  : 		_Vec.assign(2 * _Buckets, end());

  00004	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR __Buckets$[ebp]
  0000b	8d 57 10	 lea	 edx, DWORD PTR [edi+16]
  0000e	56		 push	 esi
  0000f	8b 32		 mov	 esi, DWORD PTR [edx]
  00011	89 45 fc	 mov	 DWORD PTR __Tmp$187529[ebp], eax
  00014	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00017	3b f0		 cmp	 esi, eax
  00019	74 1a		 je	 SHORT $LN35@Init
  0001b	8b c8		 mov	 ecx, eax
  0001d	3b c0		 cmp	 eax, eax
  0001f	74 11		 je	 SHORT $LN64@Init
$LL66@Init:
  00021	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00023	89 1e		 mov	 DWORD PTR [esi], ebx
  00025	83 c1 04	 add	 ecx, 4
  00028	83 c6 04	 add	 esi, 4
  0002b	3b c8		 cmp	 ecx, eax
  0002d	75 f2		 jne	 SHORT $LL66@Init
  0002f	8b 5d 08	 mov	 ebx, DWORD PTR __Buckets$[ebp]
$LN64@Init:
  00032	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN35@Init:
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$187529[ebp]
  0003a	51		 push	 ecx
  0003b	8d 0c 1b	 lea	 ecx, DWORD PTR [ebx+ebx]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 844  : 		_Mask = _Buckets - 1;

  00044	8d 53 ff	 lea	 edx, DWORD PTR [ebx-1]
  00047	5e		 pop	 esi

; 845  : 		_Maxidx = _Buckets;

  00048	89 5f 24	 mov	 DWORD PTR [edi+36], ebx
  0004b	89 57 20	 mov	 DWORD PTR [edi+32], edx
  0004e	5b		 pop	 ebx

; 846  : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
?_Init@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Init
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax
; __Bucket$ = esi

; 728  : 		if (_Vec_lo(_Bucket) == end())

  00000	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00003	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00006	39 14 f1	 cmp	 DWORD PTR [ecx+esi*8], edx
  00009	8d 0c f1	 lea	 ecx, DWORD PTR [ecx+esi*8]
  0000c	75 03		 jne	 SHORT $LN2@End

; 729  : 			return (end());

  0000e	89 10		 mov	 DWORD PTR [eax], edx

; 734  : 			}
; 735  : 		}

  00010	c3		 ret	 0
$LN2@End:

; 730  : 		else
; 731  : 			{	// point past last element
; 732  : 			iterator _Ans = _Vec_hi(_Bucket);

  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 733  : 			return (++_Ans);

  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	89 08		 mov	 DWORD PTR [eax], ecx

; 734  : 			}
; 735  : 		}

  00018	c3		 ret	 0
?_End@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_End
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 807  : 		return (iterator(_Lmost(), this));

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00005	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  00007	c3		 ret	 0
?begin@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
_TEXT	ENDS
;	COMDAT ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z
_TEXT	SEGMENT
$T187793 = -28						; size = 8
$T187792 = -28						; size = 8
$T187790 = -28						; size = 8
_myres$156193 = -20					; size = 8
_result$156171 = -20					; size = 8
_myres$156102 = -20					; size = 8
$T187785 = -12						; size = 8
$T187783 = -12						; size = 8
$T187782 = -12						; size = 8
$T187781 = -12						; size = 8
$T187780 = -12						; size = 8
$T187779 = -12						; size = 8
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_iter$ = 12						; size = 4
tv1770 = 16						; size = 4
_curr$ = 16						; size = 4
_left$ = 20						; size = 4
_right$ = 24						; size = 4
_leftparent$ = 28					; size = 4
_rightparent$ = 32					; size = 4
_parent$ = 36						; size = 4
_parentslot$ = 40					; size = 4
?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend, COMDAT
; _this$ = ecx

; 2967 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx

; 2968 :         if (curr->isleafnode())

  00007	8b 5d 10	 mov	 ebx, DWORD PTR _curr$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00011	66 39 3b	 cmp	 WORD PTR [ebx], di
  00014	0f 85 f3 02 00
	00		 jne	 $LN123@erase_iter

; 2969 :         {
; 2970 :             leaf_node *leaf = static_cast<leaf_node*>(curr);
; 2971 :             leaf_node *leftleaf = static_cast<leaf_node*>(left);
; 2972 :             leaf_node *rightleaf = static_cast<leaf_node*>(right);
; 2973 : 
; 2974 :             // if this is not the correct leaf, get next step in recursive
; 2975 :             // search
; 2976 :             if (leaf != iter.currnode)

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _iter$[ebp]
  0001d	3b 18		 cmp	 ebx, DWORD PTR [eax]
  0001f	74 15		 je	 SHORT $LN122@erase_iter
$LN404@erase_iter:

; 2977 :             {
; 2978 :                 return btree_not_found;

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0002a	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 3256 :         }
; 3257 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 24 00	 ret	 36			; 00000024H
$LN122@erase_iter:

; 2979 :             }
; 2980 : 
; 2981 :             if (iter.currslot >= leaf->slotuse)

  00036	0f b7 40 04	 movzx	 eax, WORD PTR [eax+4]
  0003a	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  0003e	66 3b c1	 cmp	 ax, cx

; 2982 :             {
; 2983 :                 BTREE_PRINT("Could not find iterator (" << iter.currnode << "," << iter.currslot << ") to erase. Invalid leaf node?");
; 2984 : 
; 2985 :                 return btree_not_found;

  00041	73 de		 jae	 SHORT $LN404@erase_iter

; 2986 :             }
; 2987 : 
; 2988 :             int slot = iter.currslot;

  00043	8b f8		 mov	 edi, eax

; 2989 : 
; 2990 :             BTREE_PRINT("Found iterator in leaf " << curr << " at slot " << slot);
; 2991 : 
; 2992 :             std::copy(leaf->slotkey + slot+1, leaf->slotkey + leaf->slotuse,
; 2993 :                       leaf->slotkey + slot);

  00045	8d 44 bb 10	 lea	 eax, DWORD PTR [ebx+edi*4+16]
  00049	8d 14 8d 0c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+12]
  00050	2b d0		 sub	 edx, eax
  00052	03 d3		 add	 edx, ebx
  00054	c1 fa 02	 sar	 edx, 2
  00057	03 d2		 add	 edx, edx
  00059	03 d2		 add	 edx, edx
  0005b	52		 push	 edx
  0005c	50		 push	 eax
  0005d	8d 44 bb 0c	 lea	 eax, DWORD PTR [ebx+edi*4+12]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 _memmove

; 2994 :             data_copy(leaf->slotdata + slot+1, leaf->slotdata + leaf->slotuse,
; 2995 :                       leaf->slotdata + slot);

  00067	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  0006b	8d 84 bb 90 00
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+144]
  00072	8d 14 8d 8c 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+140]
  00079	2b d0		 sub	 edx, eax
  0007b	03 d3		 add	 edx, ebx
  0007d	c1 fa 02	 sar	 edx, 2
  00080	03 d2		 add	 edx, edx
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	03 d2		 add	 edx, edx
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	8d 84 bb 8c 00
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+140]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _memmove

; 2996 : 
; 2997 :             leaf->slotuse--;

  00096	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0009b	66 01 4b 02	 add	 WORD PTR [ebx+2], cx
  0009f	66 8b 4b 02	 mov	 cx, WORD PTR [ebx+2]

; 2998 : 
; 2999 :             result_t myres = btree_ok;
; 3000 : 
; 3001 :             // if the last key of the leaf was changed, the parent is notified
; 3002 :             // and updates the key of this leaf
; 3003 :             if (slot == leaf->slotuse)

  000a3	0f b7 c1	 movzx	 eax, cx
  000a6	33 f6		 xor	 esi, esi
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	3b f8		 cmp	 edi, eax
  000ad	8b 7d 28	 mov	 edi, DWORD PTR _parentslot$[ebp]
  000b0	89 75 ec	 mov	 DWORD PTR _myres$156102[ebp], esi
  000b3	89 75 f0	 mov	 DWORD PTR _myres$156102[ebp+4], esi
  000b6	75 30		 jne	 SHORT $LN101@erase_iter

; 3004 :             {
; 3005 :                 if (parent && parentslot < parent->slotuse)

  000b8	8b 55 24	 mov	 edx, DWORD PTR _parent$[ebp]
  000bb	3b d6		 cmp	 edx, esi
  000bd	74 15		 je	 SHORT $LN113@erase_iter
  000bf	0f b7 52 02	 movzx	 edx, WORD PTR [edx+2]
  000c3	3b fa		 cmp	 edi, edx
  000c5	73 0d		 jae	 SHORT $LN113@erase_iter

; 3006 :                 {
; 3007 :                     BTREE_ASSERT(parent->childid[parentslot] == curr);
; 3008 :                     parent->slotkey[parentslot] = leaf->slotkey[leaf->slotuse - 1];

  000c7	8b 44 83 08	 mov	 eax, DWORD PTR [ebx+eax*4+8]
  000cb	8b 4d 24	 mov	 ecx, DWORD PTR _parent$[ebp]
  000ce	89 44 b9 04	 mov	 DWORD PTR [ecx+edi*4+4], eax

; 3009 :                 }
; 3010 :                 else

  000d2	eb 14		 jmp	 SHORT $LN101@erase_iter
$LN113@erase_iter:

; 3011 :                 {
; 3012 :                     if (leaf->slotuse >= 1)

  000d4	66 83 f9 01	 cmp	 cx, 1
  000d8	72 0e		 jb	 SHORT $LN101@erase_iter

; 3013 :                     {
; 3014 :                         BTREE_PRINT("Scheduling lastkeyupdate: key " << leaf->slotkey[leaf->slotuse - 1]);
; 3015 :                         myres |= result_t(btree_update_lastkey, leaf->slotkey[leaf->slotuse - 1]);

  000da	8b 44 83 08	 mov	 eax, DWORD PTR [ebx+eax*4+8]
  000de	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _myres$156102[ebp], 2
  000e5	89 45 f0	 mov	 DWORD PTR _myres$156102[ebp+4], eax
$LN101@erase_iter:

; 3016 :                     }
; 3017 :                     else
; 3018 :                     {
; 3019 :                         BTREE_ASSERT(leaf == m_root);
; 3020 :                     }
; 3021 :                 }
; 3022 :             }
; 3023 : 
; 3024 :             if (leaf->isunderflow() && !(leaf == m_root && leaf->slotuse >= 1))

  000e8	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  000ec	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000ef	0f 83 01 02 00
	00		 jae	 $LN194@erase_iter
  000f5	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000f8	8b 02		 mov	 eax, DWORD PTR [edx]
  000fa	3b d8		 cmp	 ebx, eax
  000fc	75 09		 jne	 SHORT $LN99@erase_iter
  000fe	83 f9 01	 cmp	 ecx, 1
  00101	0f 83 ef 01 00
	00		 jae	 $LN194@erase_iter
$LN99@erase_iter:

; 3025 :             {
; 3026 :                 // determine what to do about the underflow
; 3027 : 
; 3028 :                 // case : if this empty leaf is the root, then delete all nodes
; 3029 :                 // and set root to NULL.
; 3030 :                 if (leftleaf == NULL && rightleaf == NULL)

  00107	8b 55 14	 mov	 edx, DWORD PTR _left$[ebp]
  0010a	8b 4d 18	 mov	 ecx, DWORD PTR _right$[ebp]
  0010d	3b d6		 cmp	 edx, esi
  0010f	75 27		 jne	 SHORT $LN381@erase_iter
  00111	3b ce		 cmp	 ecx, esi
  00113	75 32		 jne	 SHORT $LN382@erase_iter

; 3031 :                 {
; 3032 :                     BTREE_ASSERT(leaf == m_root);
; 3033 :                     BTREE_ASSERT(leaf->slotuse == 0);
; 3034 : 
; 3035 :                     free_node(m_root);

  00115	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00118	e8 00 00 00 00	 call	 ?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::free_node

; 3036 : 
; 3037 :                     m_root = leaf = NULL;
; 3038 :                     m_headleaf = m_tailleaf = NULL;
; 3039 : 
; 3040 :                     // will be decremented soon by insert_start()
; 3041 :                     BTREE_ASSERT(m_stats.itemcount == 1);
; 3042 :                     BTREE_ASSERT(m_stats.leaves == 0);
; 3043 :                     BTREE_ASSERT(m_stats.innernodes == 0);
; 3044 : 
; 3045 :                     return btree_ok;

  0011d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00120	33 c9		 xor	 ecx, ecx
  00122	89 0e		 mov	 DWORD PTR [esi], ecx
  00124	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00127	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0012a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3251 :                         shift_left_inner(inner, rightinner, rightparent, parentslot);
; 3252 :                 }
; 3253 :             }
; 3254 : 
; 3255 :             return myres;

  0012d	89 08		 mov	 DWORD PTR [eax], ecx

; 3256 :         }
; 3257 :     }

  0012f	5f		 pop	 edi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 24 00	 ret	 36			; 00000024H
$LN381@erase_iter:

; 3046 :                 }
; 3047 :                 // case : if both left and right leaves would underflow in case of
; 3048 :                 // a shift, then merging is necessary. choose the more local merger
; 3049 :                 // with our parent
; 3050 :                 else if ( (leftleaf == NULL || leftleaf->isfew()) && (rightleaf == NULL || rightleaf->isfew()) )

  00138	66 83 7a 02 10	 cmp	 WORD PTR [edx+2], 16	; 00000010H
  0013d	77 13		 ja	 SHORT $LN81@erase_iter
  0013f	3b ce		 cmp	 ecx, esi
  00141	0f 84 7a 01 00
	00		 je	 $LN79@erase_iter
$LN382@erase_iter:
  00147	66 83 79 02 10	 cmp	 WORD PTR [ecx+2], 16	; 00000010H
  0014c	0f 86 6f 01 00
	00		 jbe	 $LN79@erase_iter
$LN81@erase_iter:

; 3056 :                 }
; 3057 :                 // case : the right leaf has extra data, so balance right with current
; 3058 :                 else if ( (leftleaf != NULL && leftleaf->isfew()) && (rightleaf != NULL && !rightleaf->isfew()) )

  00152	3b d6		 cmp	 edx, esi
  00154	0f 84 c1 00 00
	00		 je	 $LN71@erase_iter
  0015a	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0015e	83 f8 10	 cmp	 eax, 16			; 00000010H
  00161	77 6c		 ja	 SHORT $LN395@erase_iter
  00163	3b ce		 cmp	 ecx, esi
  00165	74 63		 je	 SHORT $LN75@erase_iter
  00167	66 83 79 02 10	 cmp	 WORD PTR [ecx+2], 16	; 00000010H
  0016c	76 5c		 jbe	 SHORT $LN75@erase_iter

; 3059 :                 {
; 3060 :                     if (rightparent == parent)

  0016e	8b 45 20	 mov	 eax, DWORD PTR _rightparent$[ebp]
  00171	3b 45 24	 cmp	 eax, DWORD PTR _parent$[ebp]
  00174	75 16		 jne	 SHORT $LN74@erase_iter

; 3061 :                         myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);

  00176	57		 push	 edi
  00177	50		 push	 eax
  00178	8d 45 f4	 lea	 eax, DWORD PTR $T187781[ebp]
  0017b	53		 push	 ebx
  0017c	50		 push	 eax
  0017d	8b f1		 mov	 esi, ecx
  0017f	e8 00 00 00 00	 call	 ?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_leaf
  00184	83 c4 10	 add	 esp, 16			; 00000010H

; 3062 :                     else

  00187	e9 58 01 00 00	 jmp	 $LN397@erase_iter
$LN74@erase_iter:

; 3063 :                         myres |= merge_leaves(leftleaf, leaf, leftparent);

  0018c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	8d 45 f4	 lea	 eax, DWORD PTR $T187782[ebp]
  00192	50		 push	 eax
  00193	51		 push	 ecx
  00194	8b f3		 mov	 esi, ebx
  00196	8b fa		 mov	 edi, edx
  00198	e8 00 00 00 00	 call	 ?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	09 4d ec	 or	 DWORD PTR _myres$156102[ebp], ecx
  001a2	d1 e9		 shr	 ecx, 1
  001a4	f6 c1 01	 test	 cl, 1
  001a7	0f 84 49 01 00
	00		 je	 $LN194@erase_iter
  001ad	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  001b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001b3	89 55 f0	 mov	 DWORD PTR _myres$156102[ebp+4], edx
  001b6	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  001b9	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  001bc	89 10		 mov	 DWORD PTR [eax], edx
  001be	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  001c1	5f		 pop	 edi
  001c2	5e		 pop	 esi
  001c3	5b		 pop	 ebx
  001c4	8b e5		 mov	 esp, ebp
  001c6	5d		 pop	 ebp
  001c7	c2 24 00	 ret	 36			; 00000024H
$LN75@erase_iter:

; 3064 :                 }
; 3065 :                 // case : the left leaf has extra data, so balance left with current
; 3066 :                 else if ( (leftleaf != NULL && !leftleaf->isfew()) && (rightleaf != NULL && rightleaf->isfew()) )

  001ca	83 f8 10	 cmp	 eax, 16			; 00000010H
  001cd	76 4c		 jbe	 SHORT $LN71@erase_iter
$LN395@erase_iter:
  001cf	3b ce		 cmp	 ecx, esi
  001d1	74 48		 je	 SHORT $LN71@erase_iter
  001d3	66 83 79 02 10	 cmp	 WORD PTR [ecx+2], 16	; 00000010H
  001d8	77 41		 ja	 SHORT $LN71@erase_iter

; 3067 :                 {
; 3068 :                     if (leftparent == parent)

  001da	8b 45 1c	 mov	 eax, DWORD PTR _leftparent$[ebp]
  001dd	3b 45 24	 cmp	 eax, DWORD PTR _parent$[ebp]
  001e0	75 26		 jne	 SHORT $LN70@erase_iter

; 3069 :                         shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);

  001e2	4f		 dec	 edi
  001e3	57		 push	 edi
  001e4	50		 push	 eax
  001e5	8b fb		 mov	 edi, ebx
  001e7	8b f2		 mov	 esi, edx
  001e9	e8 00 00 00 00	 call	 ?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  001ee	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001f1	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  001f4	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  001f7	83 c4 08	 add	 esp, 8
  001fa	89 10		 mov	 DWORD PTR [eax], edx
  001fc	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  001ff	5f		 pop	 edi
  00200	5e		 pop	 esi
  00201	5b		 pop	 ebx
  00202	8b e5		 mov	 esp, ebp
  00204	5d		 pop	 ebp
  00205	c2 24 00	 ret	 36			; 00000024H
$LN70@erase_iter:

; 3070 :                     else
; 3071 :                         myres |= merge_leaves(leaf, rightleaf, rightparent);

  00208	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0020b	8d 45 f4	 lea	 eax, DWORD PTR $T187783[ebp]
  0020e	50		 push	 eax
  0020f	52		 push	 edx
  00210	8b f1		 mov	 esi, ecx
  00212	8b fb		 mov	 edi, ebx
  00214	e8 00 00 00 00	 call	 ?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves
  00219	eb 7d		 jmp	 SHORT $LN399@erase_iter
$LN71@erase_iter:

; 3072 :                 }
; 3073 :                 // case : both the leaf and right leaves have extra data and our
; 3074 :                 // parent, choose the leaf with more data
; 3075 :                 else if (leftparent == rightparent)

  0021b	8b 45 20	 mov	 eax, DWORD PTR _rightparent$[ebp]
  0021e	39 45 1c	 cmp	 DWORD PTR _leftparent$[ebp], eax
  00221	75 33		 jne	 SHORT $LN67@erase_iter

; 3076 :                 {
; 3077 :                     if (leftleaf->slotuse <= rightleaf->slotuse)

  00223	66 8b 72 02	 mov	 si, WORD PTR [edx+2]
  00227	66 3b 71 02	 cmp	 si, WORD PTR [ecx+2]

; 3078 :                         myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);
; 3079 :                     else

  0022b	76 5a		 jbe	 SHORT $LN63@erase_iter

; 3080 :                         shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);

  0022d	8b 4d 1c	 mov	 ecx, DWORD PTR _leftparent$[ebp]
  00230	4f		 dec	 edi
  00231	57		 push	 edi
  00232	51		 push	 ecx
  00233	8b fb		 mov	 edi, ebx
  00235	8b f2		 mov	 esi, edx
  00237	e8 00 00 00 00	 call	 ?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  0023c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0023f	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  00242	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  00245	83 c4 08	 add	 esp, 8
  00248	89 10		 mov	 DWORD PTR [eax], edx
  0024a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  0024d	5f		 pop	 edi
  0024e	5e		 pop	 esi
  0024f	5b		 pop	 ebx
  00250	8b e5		 mov	 esp, ebp
  00252	5d		 pop	 ebp
  00253	c2 24 00	 ret	 36			; 00000024H
$LN67@erase_iter:

; 3081 :                 }
; 3082 :                 else
; 3083 :                 {
; 3084 :                     if (leftparent == parent)

  00256	8b 75 24	 mov	 esi, DWORD PTR _parent$[ebp]
  00259	39 75 1c	 cmp	 DWORD PTR _leftparent$[ebp], esi
  0025c	75 29		 jne	 SHORT $LN63@erase_iter

; 3085 :                         shift_right_leaf(leftleaf, leaf, leftparent, parentslot - 1);

  0025e	8b 45 1c	 mov	 eax, DWORD PTR _leftparent$[ebp]
  00261	4f		 dec	 edi
  00262	57		 push	 edi
  00263	50		 push	 eax
  00264	8b fb		 mov	 edi, ebx
  00266	8b f2		 mov	 esi, edx
  00268	e8 00 00 00 00	 call	 ?shift_right_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_leaf

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  0026d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00270	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  00273	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  00276	83 c4 08	 add	 esp, 8
  00279	89 10		 mov	 DWORD PTR [eax], edx
  0027b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  0027e	5f		 pop	 edi
  0027f	5e		 pop	 esi
  00280	5b		 pop	 ebx
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 24 00	 ret	 36			; 00000024H
$LN63@erase_iter:

; 3086 :                     else
; 3087 :                         myres |= shift_left_leaf(leaf, rightleaf, rightparent, parentslot);

  00287	57		 push	 edi
  00288	50		 push	 eax
  00289	8d 55 f4	 lea	 edx, DWORD PTR $T187785[ebp]
  0028c	53		 push	 ebx
  0028d	52		 push	 edx
  0028e	8b f1		 mov	 esi, ecx
  00290	e8 00 00 00 00	 call	 ?shift_left_leaf@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_leaf
  00295	83 c4 10	 add	 esp, 16			; 00000010H
$LN399@erase_iter:
  00298	8b 08		 mov	 ecx, DWORD PTR [eax]
  0029a	09 4d ec	 or	 DWORD PTR _myres$156102[ebp], ecx
  0029d	d1 e9		 shr	 ecx, 1
  0029f	f6 c1 01	 test	 cl, 1
  002a2	74 52		 je	 SHORT $LN194@erase_iter
  002a4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  002a7	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  002aa	89 45 f0	 mov	 DWORD PTR _myres$156102[ebp+4], eax
  002ad	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002b0	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  002b3	89 10		 mov	 DWORD PTR [eax], edx
  002b5	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  002b8	5f		 pop	 edi
  002b9	5e		 pop	 esi
  002ba	5b		 pop	 ebx
  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c2 24 00	 ret	 36			; 00000024H
$LN79@erase_iter:

; 3051 :                 {
; 3052 :                     if (leftparent == parent)

  002c1	8b 45 24	 mov	 eax, DWORD PTR _parent$[ebp]
  002c4	39 45 1c	 cmp	 DWORD PTR _leftparent$[ebp], eax

; 3053 :                         myres |= merge_leaves(leftleaf, leaf, leftparent);

  002c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002ca	75 0a		 jne	 SHORT $LN78@erase_iter
  002cc	8d 4d f4	 lea	 ecx, DWORD PTR $T187779[ebp]
  002cf	51		 push	 ecx
  002d0	8b f3		 mov	 esi, ebx
  002d2	8b fa		 mov	 edi, edx

; 3054 :                     else

  002d4	eb 08		 jmp	 SHORT $LN398@erase_iter
$LN78@erase_iter:

; 3055 :                         myres |= merge_leaves(leaf, rightleaf, rightparent);

  002d6	8d 55 f4	 lea	 edx, DWORD PTR $T187780[ebp]
  002d9	52		 push	 edx
  002da	8b f1		 mov	 esi, ecx
  002dc	8b fb		 mov	 edi, ebx
$LN398@erase_iter:
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 ?merge_leaves@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@PAUleaf_node@12@0PAUinner_node@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_leaves
$LN397@erase_iter:
  002e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e6	09 4d ec	 or	 DWORD PTR _myres$156102[ebp], ecx
  002e9	d1 e9		 shr	 ecx, 1
  002eb	f6 c1 01	 test	 cl, 1
  002ee	74 06		 je	 SHORT $LN194@erase_iter
  002f0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002f3	89 4d f0	 mov	 DWORD PTR _myres$156102[ebp+4], ecx
$LN194@erase_iter:

; 3088 :                 }
; 3089 :             }
; 3090 : 
; 3091 :             return myres;

  002f6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f9	8b 55 ec	 mov	 edx, DWORD PTR _myres$156102[ebp]
  002fc	8b 4d f0	 mov	 ecx, DWORD PTR _myres$156102[ebp+4]
  002ff	89 10		 mov	 DWORD PTR [eax], edx
  00301	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3256 :         }
; 3257 :     }

  00304	5f		 pop	 edi
  00305	5e		 pop	 esi
  00306	5b		 pop	 ebx
  00307	8b e5		 mov	 esp, ebp
  00309	5d		 pop	 ebp
  0030a	c2 24 00	 ret	 36			; 00000024H
$LN123@erase_iter:

; 3092 :         }
; 3093 :         else // !curr->isleafnode()
; 3094 :         {
; 3095 :             inner_node *inner = static_cast<inner_node*>(curr);
; 3096 :             inner_node *leftinner = static_cast<inner_node*>(left);
; 3097 :             inner_node *rightinner = static_cast<inner_node*>(right);
; 3098 : 
; 3099 :             // find first slot below which the searched iterator might be
; 3100 :             // located.
; 3101 : 
; 3102 :             result_t result;
; 3103 :             int slot = find_lower(inner, iter.key());

  0030d	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  00310	0f b7 72 04	 movzx	 esi, WORD PTR [edx+4]
  00314	8b 12		 mov	 edx, DWORD PTR [edx]
  00316	8d 74 b2 0c	 lea	 esi, DWORD PTR [edx+esi*4+12]
  0031a	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  0031e	33 c9		 xor	 ecx, ecx
  00320	33 c0		 xor	 eax, eax
  00322	85 d2		 test	 edx, edx
  00324	7e 1b		 jle	 SHORT $LN236@erase_iter
  00326	8b 16		 mov	 edx, DWORD PTR [esi]
  00328	89 55 10	 mov	 DWORD PTR tv1770[ebp], edx
  0032b	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN237@erase_iter:
  0032e	8b 75 10	 mov	 esi, DWORD PTR tv1770[ebp]
  00331	39 32		 cmp	 DWORD PTR [edx], esi
  00333	73 0c		 jae	 SHORT $LN236@erase_iter
  00335	0f b7 73 02	 movzx	 esi, WORD PTR [ebx+2]
  00339	47		 inc	 edi
  0033a	83 c2 04	 add	 edx, 4
  0033d	3b fe		 cmp	 edi, esi
  0033f	7c ed		 jl	 SHORT $LN237@erase_iter
$LN236@erase_iter:

; 3104 : 
; 3105 :             while (slot <= inner->slotuse)

  00341	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  00345	3b fa		 cmp	 edi, edx
  00347	0f 8f a9 00 00
	00		 jg	 $LN59@erase_iter
  0034d	8d 49 00	 npad	 3
$LL60@erase_iter:

; 3106 :             {
; 3107 :                 node *myleft, *myright;
; 3108 :                 inner_node *myleftparent, *myrightparent;
; 3109 : 
; 3110 :                 if (slot == 0) {

  00350	85 ff		 test	 edi, edi
  00352	75 1e		 jne	 SHORT $LN58@erase_iter

; 3111 :                     myleft = (left == NULL) ? NULL : (static_cast<inner_node*>(left))->childid[left->slotuse - 1];

  00354	8b 45 14	 mov	 eax, DWORD PTR _left$[ebp]
  00357	85 c0		 test	 eax, eax
  00359	75 07		 jne	 SHORT $LN126@erase_iter

; 3112 :                     myleftparent = leftparent;

  0035b	8b 75 1c	 mov	 esi, DWORD PTR _leftparent$[ebp]
  0035e	33 d2		 xor	 edx, edx

; 3113 :                 }
; 3114 :                 else {

  00360	eb 19		 jmp	 SHORT $LN57@erase_iter
$LN126@erase_iter:

; 3111 :                     myleft = (left == NULL) ? NULL : (static_cast<inner_node*>(left))->childid[left->slotuse - 1];

  00362	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00366	8b 94 88 80 00
	00 00		 mov	 edx, DWORD PTR [eax+ecx*4+128]

; 3112 :                     myleftparent = leftparent;

  0036d	8b 75 1c	 mov	 esi, DWORD PTR _leftparent$[ebp]

; 3113 :                 }
; 3114 :                 else {

  00370	eb 09		 jmp	 SHORT $LN57@erase_iter
$LN58@erase_iter:

; 3115 :                     myleft = inner->childid[slot - 1];

  00372	8b 94 bb 80 00
	00 00		 mov	 edx, DWORD PTR [ebx+edi*4+128]

; 3116 :                     myleftparent = inner;

  00379	8b f3		 mov	 esi, ebx
$LN57@erase_iter:

; 3117 :                 }
; 3118 : 
; 3119 :                 if (slot == inner->slotuse) {

  0037b	0f b7 43 02	 movzx	 eax, WORD PTR [ebx+2]
  0037f	3b f8		 cmp	 edi, eax
  00381	75 17		 jne	 SHORT $LN56@erase_iter

; 3120 :                     myright = (right == NULL) ? NULL : (static_cast<inner_node*>(right))->childid[0];

  00383	8b 45 18	 mov	 eax, DWORD PTR _right$[ebp]
  00386	85 c0		 test	 eax, eax
  00388	75 05		 jne	 SHORT $LN128@erase_iter

; 3121 :                     myrightparent = rightparent;

  0038a	8b 4d 20	 mov	 ecx, DWORD PTR _rightparent$[ebp]

; 3122 :                 }
; 3123 :                 else {

  0038d	eb 14		 jmp	 SHORT $LN54@erase_iter
$LN128@erase_iter:

; 3120 :                     myright = (right == NULL) ? NULL : (static_cast<inner_node*>(right))->childid[0];

  0038f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]

; 3121 :                     myrightparent = rightparent;

  00395	8b 4d 20	 mov	 ecx, DWORD PTR _rightparent$[ebp]

; 3122 :                 }
; 3123 :                 else {

  00398	eb 09		 jmp	 SHORT $LN54@erase_iter
$LN56@erase_iter:

; 3124 :                     myright = inner->childid[slot + 1];

  0039a	8b 84 bb 88 00
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+136]

; 3125 :                     myrightparent = inner;

  003a1	8b cb		 mov	 ecx, ebx
$LN54@erase_iter:

; 3126 :                 }
; 3127 : 
; 3128 :                 BTREE_PRINT("erase_iter_descend into " << inner->childid[slot]);
; 3129 : 
; 3130 :                 result = erase_iter_descend(iter,
; 3131 :                                             inner->childid[slot],
; 3132 :                                             myleft, myright,
; 3133 :                                             myleftparent, myrightparent,
; 3134 :                                             inner, slot);

  003a3	57		 push	 edi
  003a4	53		 push	 ebx
  003a5	51		 push	 ecx
  003a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a9	56		 push	 esi
  003aa	8b 75 0c	 mov	 esi, DWORD PTR _iter$[ebp]
  003ad	50		 push	 eax
  003ae	52		 push	 edx
  003af	8b 94 bb 84 00
	00 00		 mov	 edx, DWORD PTR [ebx+edi*4+132]
  003b6	52		 push	 edx
  003b7	56		 push	 esi
  003b8	8d 45 e4	 lea	 eax, DWORD PTR $T187790[ebp]
  003bb	50		 push	 eax
  003bc	e8 00 00 00 00	 call	 ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
  003c1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003c3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003c6	89 45 f0	 mov	 DWORD PTR _result$156171[ebp+4], eax

; 3135 : 
; 3136 :                 if (!result.has(btree_not_found))

  003c9	f6 c1 01	 test	 cl, 1
  003cc	74 28		 je	 SHORT $LN59@erase_iter

; 3137 :                     break;
; 3138 : 
; 3139 :                 // continue recursive search for leaf on next slot
; 3140 : 
; 3141 :                 if (slot < inner->slotuse && key_less(inner->slotkey[slot],iter.key()))

  003ce	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  003d2	3b fa		 cmp	 edi, edx
  003d4	7d 13		 jge	 SHORT $LN50@erase_iter
  003d6	0f b7 56 04	 movzx	 edx, WORD PTR [esi+4]
  003da	8b 06		 mov	 eax, DWORD PTR [esi]
  003dc	8b 74 bb 04	 mov	 esi, DWORD PTR [ebx+edi*4+4]
  003e0	3b 74 90 0c	 cmp	 esi, DWORD PTR [eax+edx*4+12]
  003e4	72 44		 jb	 SHORT $LN377@erase_iter
  003e6	8b 45 f0	 mov	 eax, DWORD PTR _result$156171[ebp+4]
$LN50@erase_iter:

; 3104 : 
; 3105 :             while (slot <= inner->slotuse)

  003e9	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]

; 3143 : 
; 3144 :                 ++slot;

  003ed	47		 inc	 edi
  003ee	3b fa		 cmp	 edi, edx
  003f0	0f 8e 5a ff ff
	ff		 jle	 $LL60@erase_iter
$LN59@erase_iter:

; 3145 :             }
; 3146 : 
; 3147 :             if (slot > inner->slotuse)

  003f6	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  003fa	3b fa		 cmp	 edi, edx

; 3148 :                 return btree_not_found;

  003fc	7f 2c		 jg	 SHORT $LN377@erase_iter

; 3149 : 
; 3150 :             result_t myres = btree_ok;
; 3151 : 
; 3152 :             if (result.has(btree_update_lastkey))

  003fe	8b 75 28	 mov	 esi, DWORD PTR _parentslot$[ebp]
  00401	33 d2		 xor	 edx, edx
  00403	89 55 ec	 mov	 DWORD PTR _myres$156193[ebp], edx
  00406	89 55 f0	 mov	 DWORD PTR _myres$156193[ebp+4], edx
  00409	8b d1		 mov	 edx, ecx
  0040b	d1 ea		 shr	 edx, 1
  0040d	f6 c2 01	 test	 dl, 1
  00410	74 3b		 je	 SHORT $LN386@erase_iter

; 3153 :             {
; 3154 :                 if (parent && parentslot < parent->slotuse)

  00412	8b 55 24	 mov	 edx, DWORD PTR _parent$[ebp]
  00415	85 d2		 test	 edx, edx
  00417	74 2a		 je	 SHORT $LN39@erase_iter
  00419	0f b7 52 02	 movzx	 edx, WORD PTR [edx+2]
  0041d	3b f2		 cmp	 esi, edx
  0041f	73 22		 jae	 SHORT $LN39@erase_iter

; 3155 :                 {
; 3156 :                     BTREE_PRINT("Fixing lastkeyupdate: key " << result.lastkey << " into parent " << parent << " at parentslot " << parentslot);
; 3157 : 
; 3158 :                     BTREE_ASSERT(parent->childid[parentslot] == curr);
; 3159 :                     parent->slotkey[parentslot] = result.lastkey;

  00421	8b 55 24	 mov	 edx, DWORD PTR _parent$[ebp]
  00424	89 44 b2 04	 mov	 DWORD PTR [edx+esi*4+4], eax

; 3160 :                 }
; 3161 :                 else

  00428	eb 23		 jmp	 SHORT $LN386@erase_iter
$LN377@erase_iter:

; 3142 :                     return btree_not_found;

  0042a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0042d	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00433	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3256 :         }
; 3257 :     }

  0043a	5f		 pop	 edi
  0043b	5e		 pop	 esi
  0043c	5b		 pop	 ebx
  0043d	8b e5		 mov	 esp, ebp
  0043f	5d		 pop	 ebp
  00440	c2 24 00	 ret	 36			; 00000024H
$LN39@erase_iter:

; 3162 :                 {
; 3163 :                     BTREE_PRINT("Forwarding lastkeyupdate: key " << result.lastkey);
; 3164 :                     myres |= result_t(btree_update_lastkey, result.lastkey);

  00443	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _myres$156193[ebp], 2
  0044a	89 45 f0	 mov	 DWORD PTR _myres$156193[ebp+4], eax
$LN386@erase_iter:
  0044d	8b 55 18	 mov	 edx, DWORD PTR _right$[ebp]

; 3165 :                 }
; 3166 :             }
; 3167 : 
; 3168 :             if (result.has(btree_fixmerge))

  00450	c1 e9 02	 shr	 ecx, 2
  00453	f6 c1 01	 test	 cl, 1
  00456	0f 84 b5 00 00
	00		 je	 $LN31@erase_iter

; 3169 :             {
; 3170 :                 // either the current node or the next is empty and should be removed
; 3171 :                 if (inner->childid[slot]->slotuse != 0)

  0045c	8b 84 bb 84 00
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+132]
  00463	66 83 78 02 00	 cmp	 WORD PTR [eax+2], 0
  00468	74 01		 je	 SHORT $LN34@erase_iter

; 3172 :                     slot++;

  0046a	47		 inc	 edi
$LN34@erase_iter:

; 3173 : 
; 3174 :                 // this is the child slot invalidated by the merge
; 3175 :                 BTREE_ASSERT(inner->childid[slot]->slotuse == 0);
; 3176 : 
; 3177 :                 free_node(inner->childid[slot]);

  0046b	8b 84 bb 84 00
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+132]
  00472	66 83 38 00	 cmp	 WORD PTR [eax], 0
  00476	50		 push	 eax
  00477	75 10		 jne	 SHORT $LN297@erase_iter
  00479	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0047e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00481	83 c4 04	 add	 esp, 4
  00484	ff 48 10	 dec	 DWORD PTR [eax+16]
  00487	eb 0e		 jmp	 SHORT $LN296@erase_iter
$LN297@erase_iter:
  00489	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0048e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00491	83 c4 04	 add	 esp, 4
  00494	ff 48 14	 dec	 DWORD PTR [eax+20]
$LN296@erase_iter:

; 3178 : 
; 3179 :                 std::copy(inner->slotkey + slot, inner->slotkey + inner->slotuse,
; 3180 :                           inner->slotkey + slot-1);

  00497	0f b7 53 02	 movzx	 edx, WORD PTR [ebx+2]
  0049b	8d 14 95 04 00
	00 00		 lea	 edx, DWORD PTR [edx*4+4]
  004a2	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  004a5	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  004a8	2b d1		 sub	 edx, ecx
  004aa	03 d3		 add	 edx, ebx
  004ac	c1 fa 02	 sar	 edx, 2
  004af	03 d2		 add	 edx, edx
  004b1	03 d2		 add	 edx, edx
  004b3	52		 push	 edx
  004b4	51		 push	 ecx
  004b5	50		 push	 eax
  004b6	e8 00 00 00 00	 call	 _memmove

; 3181 :                 std::copy(inner->childid + slot+1, inner->childid + inner->slotuse+1,
; 3182 :                           inner->childid + slot);

  004bb	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  004bf	8d 84 bb 88 00
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+136]
  004c6	8d 14 8d 88 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+136]
  004cd	2b d0		 sub	 edx, eax
  004cf	03 d3		 add	 edx, ebx
  004d1	c1 fa 02	 sar	 edx, 2
  004d4	03 d2		 add	 edx, edx
  004d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  004d9	03 d2		 add	 edx, edx
  004db	52		 push	 edx
  004dc	50		 push	 eax
  004dd	8d 84 bb 84 00
	00 00		 lea	 eax, DWORD PTR [ebx+edi*4+132]
  004e4	50		 push	 eax
  004e5	e8 00 00 00 00	 call	 _memmove

; 3183 : 
; 3184 :                 inner->slotuse--;

  004ea	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  004ef	66 01 43 02	 add	 WORD PTR [ebx+2], ax
  004f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3185 : 
; 3186 :                 if (inner->level == 1)

  004f6	66 83 3b 01	 cmp	 WORD PTR [ebx], 1
  004fa	75 12		 jne	 SHORT $LN387@erase_iter

; 3187 :                 {
; 3188 :                     // fix split key for children leaves
; 3189 :                     slot--;
; 3190 :                     leaf_node *child = static_cast<leaf_node*>(inner->childid[slot]);

  004fc	8b 84 bb 80 00
	00 00		 mov	 eax, DWORD PTR [ebx+edi*4+128]

; 3191 :                     inner->slotkey[slot] = child->slotkey[ child->slotuse-1 ];

  00503	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00507	8b 54 88 08	 mov	 edx, DWORD PTR [eax+ecx*4+8]
  0050b	89 14 bb	 mov	 DWORD PTR [ebx+edi*4], edx
$LN387@erase_iter:
  0050e	8b 55 18	 mov	 edx, DWORD PTR _right$[ebp]
$LN31@erase_iter:

; 3192 :                 }
; 3193 :             }
; 3194 : 
; 3195 :             if (inner->isunderflow() && !(inner == m_root && inner->slotuse >= 1))

  00511	0f b7 4b 02	 movzx	 ecx, WORD PTR [ebx+2]
  00515	bf 10 00 00 00	 mov	 edi, 16			; 00000010H
  0051a	66 3b cf	 cmp	 cx, di
  0051d	0f 83 80 01 00
	00		 jae	 $LN351@erase_iter
  00523	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00526	3b 18		 cmp	 ebx, DWORD PTR [eax]
  00528	75 09		 jne	 SHORT $LN29@erase_iter
  0052a	83 f9 01	 cmp	 ecx, 1
  0052d	0f 83 70 01 00
	00		 jae	 $LN351@erase_iter
$LN29@erase_iter:

; 3196 :             {
; 3197 :                 // case: the inner node is the root and has just one
; 3198 :                 // child. that child becomes the new root
; 3199 :                 if (leftinner == NULL && rightinner == NULL)

  00533	8b 4d 14	 mov	 ecx, DWORD PTR _left$[ebp]
  00536	85 c9		 test	 ecx, ecx
  00538	75 32		 jne	 SHORT $LN380@erase_iter
  0053a	85 d2		 test	 edx, edx
  0053c	75 3c		 jne	 SHORT $LN383@erase_iter

; 3200 :                 {
; 3201 :                     BTREE_ASSERT(inner == m_root);
; 3202 :                     BTREE_ASSERT(inner->slotuse == 0);
; 3203 : 
; 3204 :                     m_root = inner->childid[0];

  0053e	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [ebx+132]
  00544	8b f0		 mov	 esi, eax
  00546	89 0e		 mov	 DWORD PTR [esi], ecx

; 3205 : 
; 3206 :                     inner->slotuse = 0;
; 3207 :                     free_node(inner);

  00548	8b c3		 mov	 eax, ebx
  0054a	66 89 53 02	 mov	 WORD PTR [ebx+2], dx
  0054e	e8 00 00 00 00	 call	 ?free_node@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::free_node

; 3208 : 
; 3209 :                     return btree_ok;

  00553	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00556	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0055c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 3256 :         }
; 3257 :     }

  00563	5f		 pop	 edi
  00564	5e		 pop	 esi
  00565	5b		 pop	 ebx
  00566	8b e5		 mov	 esp, ebp
  00568	5d		 pop	 ebp
  00569	c2 24 00	 ret	 36			; 00000024H
$LN380@erase_iter:

; 3210 :                 }
; 3211 :                 // case : if both left and right leaves would underflow in case of
; 3212 :                 // a shift, then merging is necessary. choose the more local merger
; 3213 :                 // with our parent
; 3214 :                 else if ( (leftinner == NULL || leftinner->isfew()) && (rightinner == NULL || rightinner->isfew()) )

  0056c	66 39 79 02	 cmp	 WORD PTR [ecx+2], di
  00570	77 12		 ja	 SHORT $LN20@erase_iter
  00572	85 d2		 test	 edx, edx
  00574	0f 84 ce 00 00
	00		 je	 $LN18@erase_iter
$LN383@erase_iter:
  0057a	66 39 7a 02	 cmp	 WORD PTR [edx+2], di
  0057e	0f 86 c4 00 00
	00		 jbe	 $LN18@erase_iter
$LN20@erase_iter:

; 3220 :                 }
; 3221 :                 // case : the right leaf has extra data, so balance right with current
; 3222 :                 else if ( (leftinner != NULL && leftinner->isfew()) && (rightinner != NULL && !rightinner->isfew()) )

  00584	85 c9		 test	 ecx, ecx
  00586	74 67		 je	 SHORT $LN10@erase_iter
  00588	0f b7 41 02	 movzx	 eax, WORD PTR [ecx+2]
  0058c	66 3b c7	 cmp	 ax, di
  0058f	77 32		 ja	 SHORT $LN401@erase_iter
  00591	85 d2		 test	 edx, edx
  00593	74 29		 je	 SHORT $LN14@erase_iter
  00595	66 39 7a 02	 cmp	 WORD PTR [edx+2], di
  00599	76 23		 jbe	 SHORT $LN14@erase_iter

; 3223 :                 {
; 3224 :                     if (rightparent == parent)

  0059b	8b 45 24	 mov	 eax, DWORD PTR _parent$[ebp]
  0059e	39 45 20	 cmp	 DWORD PTR _rightparent$[ebp], eax
  005a1	0f 85 a9 00 00
	00		 jne	 $LN13@erase_iter
$LN2@erase_iter:

; 3225 :                         shift_left_inner(inner, rightinner, rightparent, parentslot);

  005a7	8b 4d 20	 mov	 ecx, DWORD PTR _rightparent$[ebp]
  005aa	56		 push	 esi
  005ab	8b 75 18	 mov	 esi, DWORD PTR _right$[ebp]
  005ae	51		 push	 ecx
  005af	8b c3		 mov	 eax, ebx
  005b1	e8 00 00 00 00	 call	 ?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_inner
  005b6	83 c4 08	 add	 esp, 8

; 3226 :                     else

  005b9	e9 e5 00 00 00	 jmp	 $LN351@erase_iter
$LN14@erase_iter:

; 3227 :                         myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);
; 3228 :                 }
; 3229 :                 // case : the left leaf has extra data, so balance left with current
; 3230 :                 else if ( (leftinner != NULL && !leftinner->isfew()) && (rightinner != NULL && rightinner->isfew()) )

  005be	66 3b c7	 cmp	 ax, di
  005c1	76 2c		 jbe	 SHORT $LN10@erase_iter
$LN401@erase_iter:
  005c3	85 d2		 test	 edx, edx
  005c5	74 28		 je	 SHORT $LN10@erase_iter
  005c7	66 39 7a 02	 cmp	 WORD PTR [edx+2], di
  005cb	77 22		 ja	 SHORT $LN10@erase_iter

; 3231 :                 {
; 3232 :                     if (leftparent == parent)

  005cd	8b 55 24	 mov	 edx, DWORD PTR _parent$[ebp]
  005d0	39 55 1c	 cmp	 DWORD PTR _leftparent$[ebp], edx
  005d3	0f 85 a2 00 00
	00		 jne	 $LN17@erase_iter

; 3233 :                         shift_right_inner(leftinner, inner, leftparent, parentslot - 1);

  005d9	8b 45 1c	 mov	 eax, DWORD PTR _leftparent$[ebp]
  005dc	4e		 dec	 esi
  005dd	56		 push	 esi
  005de	50		 push	 eax
  005df	51		 push	 ecx
  005e0	8b fb		 mov	 edi, ebx
  005e2	e8 00 00 00 00	 call	 ?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner
  005e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3234 :                     else
; 3235 :                         myres |= merge_inner(inner, rightinner, rightparent, parentslot);

  005ea	e9 b4 00 00 00	 jmp	 $LN351@erase_iter
$LN10@erase_iter:

; 3236 :                 }
; 3237 :                 // case : both the leaf and right leaves have extra data and our
; 3238 :                 // parent, choose the leaf with more data
; 3239 :                 else if (leftparent == rightparent)

  005ef	8b 45 1c	 mov	 eax, DWORD PTR _leftparent$[ebp]
  005f2	3b 45 20	 cmp	 eax, DWORD PTR _rightparent$[ebp]
  005f5	75 34		 jne	 SHORT $LN6@erase_iter

; 3240 :                 {
; 3241 :                     if (leftinner->slotuse <= rightinner->slotuse)

  005f7	66 8b 49 02	 mov	 cx, WORD PTR [ecx+2]
  005fb	66 3b 4a 02	 cmp	 cx, WORD PTR [edx+2]
  005ff	77 17		 ja	 SHORT $LN5@erase_iter

; 3242 :                         shift_left_inner(inner, rightinner, rightparent, parentslot);

  00601	8b 55 20	 mov	 edx, DWORD PTR _rightparent$[ebp]
  00604	56		 push	 esi
  00605	8b 75 18	 mov	 esi, DWORD PTR _right$[ebp]
  00608	52		 push	 edx
  00609	8b c3		 mov	 eax, ebx
  0060b	e8 00 00 00 00	 call	 ?shift_left_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_left_inner
  00610	83 c4 08	 add	 esp, 8

; 3243 :                     else

  00613	e9 8b 00 00 00	 jmp	 $LN351@erase_iter
$LN5@erase_iter:

; 3244 :                         shift_right_inner(leftinner, inner, leftparent, parentslot - 1);

  00618	8b 4d 14	 mov	 ecx, DWORD PTR _left$[ebp]
  0061b	4e		 dec	 esi
  0061c	56		 push	 esi
  0061d	50		 push	 eax
  0061e	51		 push	 ecx
  0061f	8b fb		 mov	 edi, ebx
  00621	e8 00 00 00 00	 call	 ?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner
  00626	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3245 :                 }
; 3246 :                 else

  00629	eb 78		 jmp	 SHORT $LN351@erase_iter
$LN6@erase_iter:

; 3247 :                 {
; 3248 :                     if (leftparent == parent)

  0062b	3b 45 24	 cmp	 eax, DWORD PTR _parent$[ebp]
  0062e	0f 85 73 ff ff
	ff		 jne	 $LN2@erase_iter

; 3249 :                         shift_right_inner(leftinner, inner, leftparent, parentslot - 1);

  00634	4e		 dec	 esi
  00635	8b d0		 mov	 edx, eax
  00637	56		 push	 esi
  00638	52		 push	 edx
  00639	8b c1		 mov	 eax, ecx
  0063b	50		 push	 eax
  0063c	8b fb		 mov	 edi, ebx
  0063e	e8 00 00 00 00	 call	 ?shift_right_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CAXPAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::shift_right_inner
  00643	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :                     else

  00646	eb 5b		 jmp	 SHORT $LN351@erase_iter
$LN18@erase_iter:

; 3215 :                 {
; 3216 :                     if (leftparent == parent)

  00648	8b 55 24	 mov	 edx, DWORD PTR _parent$[ebp]
  0064b	39 55 1c	 cmp	 DWORD PTR _leftparent$[ebp], edx
  0064e	75 2b		 jne	 SHORT $LN17@erase_iter
$LN13@erase_iter:

; 3217 :                         myres |= merge_inner(leftinner, inner, leftparent, parentslot - 1);

  00650	8b 4d 1c	 mov	 ecx, DWORD PTR _leftparent$[ebp]
  00653	8d 45 e4	 lea	 eax, DWORD PTR $T187792[ebp]
  00656	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00659	8b 75 14	 mov	 esi, DWORD PTR _left$[ebp]
  0065c	50		 push	 eax
  0065d	8b fb		 mov	 edi, ebx
  0065f	e8 00 00 00 00	 call	 ?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_inner
  00664	8b 08		 mov	 ecx, DWORD PTR [eax]
  00666	09 4d ec	 or	 DWORD PTR _myres$156193[ebp], ecx
  00669	d1 e9		 shr	 ecx, 1
  0066b	83 c4 04	 add	 esp, 4
  0066e	f6 c1 01	 test	 cl, 1
  00671	74 30		 je	 SHORT $LN351@erase_iter
  00673	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00676	89 4d f0	 mov	 DWORD PTR _myres$156193[ebp+4], ecx

; 3218 :                     else

  00679	eb 28		 jmp	 SHORT $LN351@erase_iter
$LN17@erase_iter:

; 3219 :                         myres |= merge_inner(inner, rightinner, rightparent, parentslot);

  0067b	8b 4d 20	 mov	 ecx, DWORD PTR _rightparent$[ebp]
  0067e	8b 7d 18	 mov	 edi, DWORD PTR _right$[ebp]
  00681	8d 55 e4	 lea	 edx, DWORD PTR $T187793[ebp]
  00684	52		 push	 edx
  00685	8b d6		 mov	 edx, esi
  00687	8b f3		 mov	 esi, ebx
  00689	e8 00 00 00 00	 call	 ?merge_inner@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@CA?AUresult_t@12@PAUinner_node@12@00I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::merge_inner
  0068e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00690	09 4d ec	 or	 DWORD PTR _myres$156193[ebp], ecx
  00693	d1 e9		 shr	 ecx, 1
  00695	83 c4 04	 add	 esp, 4
  00698	f6 c1 01	 test	 cl, 1
  0069b	74 06		 je	 SHORT $LN351@erase_iter
  0069d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006a0	89 45 f0	 mov	 DWORD PTR _myres$156193[ebp+4], eax
$LN351@erase_iter:

; 3251 :                         shift_left_inner(inner, rightinner, rightparent, parentslot);
; 3252 :                 }
; 3253 :             }
; 3254 : 
; 3255 :             return myres;

  006a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  006a6	8b 4d ec	 mov	 ecx, DWORD PTR _myres$156193[ebp]
  006a9	8b 55 f0	 mov	 edx, DWORD PTR _myres$156193[ebp+4]

; 3256 :         }
; 3257 :     }

  006ac	5f		 pop	 edi
  006ad	5e		 pop	 esi
  006ae	89 50 04	 mov	 DWORD PTR [eax+4], edx
  006b1	89 08		 mov	 DWORD PTR [eax], ecx
  006b3	5b		 pop	 ebx
  006b4	8b e5		 mov	 esp, ebp
  006b6	5d		 pop	 ebp
  006b7	c2 24 00	 ret	 36			; 00000024H
?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert2@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z
_TEXT	SEGMENT
?insert2@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert2, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi
; _key$ = ecx
; _data$ = eax

; 2107 :     {

  00000	51		 push	 ecx

; 2108 :         return insert_start(key, data);

  00001	50		 push	 eax
  00002	51		 push	 ecx
  00003	57		 push	 edi
  00004	e8 00 00 00 00	 call	 ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
  00009	8b c7		 mov	 eax, edi
  0000b	59		 pop	 ecx

; 2109 :     }

  0000c	c3		 ret	 0
?insert2@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert2
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?clear@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ
_TEXT	SEGMENT
$T188402 = -12						; size = 12
?clear@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear, COMDAT
; _this$ = esi

; 1528 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1529 :         if (m_root)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b c7		 cmp	 eax, edi
  0000d	74 45		 je	 SHORT $LN3@clear@4

; 1530 :         {
; 1531 :             clear_recursive(m_root);

  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive

; 1532 :             free_node(m_root);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	50		 push	 eax
  0001a	66 39 38	 cmp	 WORD PTR [eax], di
  0001d	75 0d		 jne	 SHORT $LN8@clear@4
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
  00027	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002a	eb 0b		 jmp	 SHORT $LN7@clear@4
$LN8@clear@4:
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
  00034	ff 4e 14	 dec	 DWORD PTR [esi+20]
$LN7@clear@4:

; 1533 : 
; 1534 :             m_root = NULL;
; 1535 :             m_headleaf = m_tailleaf = NULL;
; 1536 : 
; 1537 :             m_stats = tree_stats();

  00037	89 7d f4	 mov	 DWORD PTR $T188402[ebp], edi
  0003a	89 7d f8	 mov	 DWORD PTR $T188402[ebp+4], edi
  0003d	f3 0f 7e 45 f4	 movq	 xmm0, QWORD PTR $T188402[ebp]
  00042	33 c0		 xor	 eax, eax
  00044	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00049	89 3e		 mov	 DWORD PTR [esi], edi
  0004b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004e	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00051	89 46 14	 mov	 DWORD PTR [esi+20], eax
$LN3@clear@4:
  00054	5f		 pop	 edi

; 1538 :         }
; 1539 : 
; 1540 :         BTREE_ASSERT(m_stats.itemcount == 0);
; 1541 :     }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?clear@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXXZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z
_TEXT	SEGMENT
$T188434 = -8						; size = 8
$T188435 = 8						; size = 8
_iter$ = 8						; size = 8
?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1297 :   iterator internal_end(iterator iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1298 :     return iter.node ? iter : end();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _iter$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	85 c9		 test	 ecx, ecx
  0000b	74 1c		 je	 SHORT $LN3@internal_e
  0000d	89 4d f8	 mov	 DWORD PTR $T188434[ebp], ecx
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00013	89 4d fc	 mov	 DWORD PTR $T188434[ebp+4], ecx
  00016	8d 4d f8	 lea	 ecx, DWORD PTR $T188434[ebp]
  00019	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001e	89 10		 mov	 DWORD PTR [eax], edx
  00020	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1299 :   }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
$LN3@internal_e:

; 1298 :     return iter.node ? iter : end();

  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 0d		 je	 SHORT $LN13@internal_e
  0002f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00032	75 08		 jne	 SHORT $LN13@internal_e
  00034	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  0003a	eb 02		 jmp	 SHORT $LN25@internal_e
$LN13@internal_e:
  0003c	8b d1		 mov	 edx, ecx
$LN25@internal_e:
  0003e	85 d2		 test	 edx, edx
  00040	74 1d		 je	 SHORT $LN9@internal_e
  00042	85 c9		 test	 ecx, ecx
  00044	74 11		 je	 SHORT $LN29@internal_e
  00046	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00049	75 0c		 jne	 SHORT $LN29@internal_e
  0004b	8b 91 80 01 00
	00		 mov	 edx, DWORD PTR [ecx+384]
  00051	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  00055	eb 0a		 jmp	 SHORT $LN10@internal_e
$LN29@internal_e:
  00057	8b d1		 mov	 edx, ecx
  00059	0f b6 52 03	 movzx	 edx, BYTE PTR [edx+3]
  0005d	eb 02		 jmp	 SHORT $LN10@internal_e
$LN9@internal_e:
  0005f	33 d2		 xor	 edx, edx
$LN10@internal_e:
  00061	85 c9		 test	 ecx, ecx
  00063	74 0b		 je	 SHORT $LN47@internal_e
  00065	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00068	75 06		 jne	 SHORT $LN47@internal_e
  0006a	8b 89 80 01 00
	00		 mov	 ecx, DWORD PTR [ecx+384]
$LN47@internal_e:
  00070	89 4d 08	 mov	 DWORD PTR $T188435[ebp], ecx
  00073	8d 4d 08	 lea	 ecx, DWORD PTR $T188435[ebp]
  00076	89 55 0c	 mov	 DWORD PTR $T188435[ebp+4], edx
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0007e	89 10		 mov	 DWORD PTR [eax], edx
  00080	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1299 :   }

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 08 00	 ret	 8
?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 162  :   btree_unique_container(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 163  :                          const allocator_type &alloc = allocator_type())
; 164  :       : super_type(comp, alloc) {
; 165  :   }

  00006	c3		 ret	 0
??0?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z
_TEXT	SEGMENT
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo, COMDAT
; _this$ = eax

; 1165 :         : alloc_impl<value_alloc_type>(a), emptyval() { }

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00006	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0000d	c3		 ret	 0
??0ValInfo@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV?$alloc_impl@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@12@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::ValInfo::ValInfo
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\hashtable-common.h
_TEXT	ENDS
;	COMDAT ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z
_TEXT	SEGMENT
$T188701 = -24						; size = 12
tv166 = -12						; size = 8
tv173 = -8						; size = 4
tv169 = -8						; size = 4
$T188711 = -8						; size = 4
_enlarge$ = -4						; size = 4
tv172 = -2						; size = 2
?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z PROC ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets, COMDAT
; _this$ = eax
; _num_elts$ = edx
; _min_buckets_wanted$ = esi

; 150  :   size_type min_buckets(size_type num_elts, size_type min_buckets_wanted) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 151  :     float enlarge = enlarge_factor();

  00006	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0000b	f3 0f 11 45 fc	 movss	 DWORD PTR _enlarge$[ebp], xmm0

; 152  :     size_type sz = HT_MIN_BUCKETS;             // min buckets allowed

  00010	d9 45 fc	 fld	 DWORD PTR _enlarge$[ebp]
  00013	b9 04 00 00 00	 mov	 ecx, 4
$LN4@min_bucket:

; 153  :     while ( sz < min_buckets_wanted ||
; 154  :             num_elts >= static_cast<size_type>(sz * enlarge) ) {

  00018	3b ce		 cmp	 ecx, esi
  0001a	72 33		 jb	 SHORT $LN2@min_bucket
  0001c	8b c1		 mov	 eax, ecx
  0001e	89 45 f8	 mov	 DWORD PTR tv173[ebp], eax
  00021	db 45 f8	 fild	 DWORD PTR tv173[ebp]
  00024	85 c0		 test	 eax, eax
  00026	79 06		 jns	 SHORT $LN26@min_bucket
  00028	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN26@min_bucket:
  0002e	d9 7d fe	 fnstcw	 WORD PTR tv172[ebp]
  00031	0f b7 45 fe	 movzx	 eax, WORD PTR tv172[ebp]
  00035	d8 c9		 fmul	 ST(0), ST(1)
  00037	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0003c	89 45 f8	 mov	 DWORD PTR tv169[ebp], eax
  0003f	d9 6d f8	 fldcw	 WORD PTR tv169[ebp]
  00042	df 7d f4	 fistp	 QWORD PTR tv166[ebp]
  00045	8b 45 f4	 mov	 eax, DWORD PTR tv166[ebp]
  00048	d9 6d fe	 fldcw	 WORD PTR tv172[ebp]
  0004b	3b d0		 cmp	 edx, eax
  0004d	72 0b		 jb	 SHORT $LN22@min_bucket
$LN2@min_bucket:

; 155  :       // This just prevents overflowing size_type, since sz can exceed
; 156  :       // max_size() here.
; 157  :       if (static_cast<size_type>(sz * 2) < sz) {

  0004f	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  00052	3b c1		 cmp	 eax, ecx
  00054	72 0c		 jb	 SHORT $LN24@min_bucket

; 159  :       }
; 160  :       sz *= 2;

  00056	8b c8		 mov	 ecx, eax

; 161  :     }

  00058	eb be		 jmp	 SHORT $LN4@min_bucket
$LN22@min_bucket:

; 153  :     while ( sz < min_buckets_wanted ||
; 154  :             num_elts >= static_cast<size_type>(sz * enlarge) ) {

  0005a	dd d8		 fstp	 ST(0)

; 162  :     return sz;

  0005c	8b c1		 mov	 eax, ecx

; 163  :   }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN24@min_bucket:

; 158  :         throw std::length_error("resize overflow");  // protect against overflow

  00062	8d 4d f8	 lea	 ecx, DWORD PTR $T188711[ebp]
  00065	dd d8		 fstp	 ST(0)
  00067	51		 push	 ecx
  00068	8d 4d e8	 lea	 ecx, DWORD PTR $T188701[ebp]
  0006b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T188711[ebp], OFFSET ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
  00072	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00077	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0007c	8d 55 e8	 lea	 edx, DWORD PTR $T188701[ebp]
  0007f	52		 push	 edx
  00080	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T188701[ebp], OFFSET ??_7length_error@std@@6B@
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN28@min_bucket:
$LN27@min_bucket:
  0008c	cc		 int	 3
?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ENDP ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z
_TEXT	SEGMENT
tv325 = -12						; size = 4
_num_probes$ = -8					; size = 4
_insert_pos$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position, COMDAT
; _this$ = edi
; _key$ = eax

; 807  :   pair<size_type, size_type> find_position(const key_type &key) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 808  :     size_type num_probes = 0;              // how many times we've probed
; 809  :     const size_type bucket_count_minus_one = bucket_count() - 1;
; 810  :     size_type bucknum = hash(key) & bucket_count_minus_one;

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b d1		 mov	 edx, ecx
  0000a	c1 e2 06	 shl	 edx, 6
  0000d	89 4d f4	 mov	 DWORD PTR tv325[ebp], ecx
  00010	2b ca		 sub	 ecx, edx
  00012	8b c1		 mov	 eax, ecx
  00014	c1 e8 11	 shr	 eax, 17			; 00000011H
  00017	33 c8		 xor	 ecx, eax
  00019	8b d1		 mov	 edx, ecx
  0001b	c1 e2 09	 shl	 edx, 9
  0001e	2b ca		 sub	 ecx, edx
  00020	8b c1		 mov	 eax, ecx
  00022	c1 e0 04	 shl	 eax, 4
  00025	33 c8		 xor	 ecx, eax
  00027	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  0002e	2b ca		 sub	 ecx, edx
  00030	8b c1		 mov	 eax, ecx
  00032	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00035	33 c8		 xor	 ecx, eax
  00037	53		 push	 ebx

; 811  :     size_type insert_pos = ILLEGAL_BUCKET; // where we would insert
; 812  :     while ( 1 ) {                          // probe until something happens
; 813  :       if ( test_empty(bucknum) ) {         // bucket is empty

  00038	8b 5f 34	 mov	 ebx, DWORD PTR [edi+52]
  0003b	8b d1		 mov	 edx, ecx
  0003d	56		 push	 esi
  0003e	8b 77 28	 mov	 esi, DWORD PTR [edi+40]
  00041	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00044	33 d1		 xor	 edx, ecx
  00046	4e		 dec	 esi
  00047	23 d6		 and	 edx, esi
  00049	8b 0c d3	 mov	 ecx, DWORD PTR [ebx+edx*8]
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _num_probes$[ebp], 0
  00053	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _insert_pos$[ebp], -1
  0005a	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  0005d	74 37		 je	 SHORT $LN116@find_posit
  0005f	90		 npad	 1
$LL10@find_posit:

; 818  : 
; 819  :       } else if ( test_deleted(bucknum) ) {// keep searching, but mark to insert

  00060	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00064	76 10		 jbe	 SHORT $LN4@find_posit
  00066	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00069	75 0b		 jne	 SHORT $LN4@find_posit

; 820  :         if ( insert_pos == ILLEGAL_BUCKET )

  0006b	83 7d fc ff	 cmp	 DWORD PTR _insert_pos$[ebp], -1
  0006f	75 0a		 jne	 SHORT $LN1@find_posit

; 821  :           insert_pos = bucknum;

  00071	89 55 fc	 mov	 DWORD PTR _insert_pos$[ebp], edx

; 822  : 
; 823  :       } else if ( equals(key, get_key(table[bucknum])) ) {

  00074	eb 05		 jmp	 SHORT $LN1@find_posit
$LN4@find_posit:
  00076	39 4d f4	 cmp	 DWORD PTR tv325[ebp], ecx
  00079	74 43		 je	 SHORT $LN112@find_posit
$LN1@find_posit:

; 825  :       }
; 826  :       ++num_probes;                        // we're doing another probe

  0007b	8b 45 f8	 mov	 eax, DWORD PTR _num_probes$[ebp]
  0007e	40		 inc	 eax

; 827  :       bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one;

  0007f	03 d0		 add	 edx, eax
  00081	23 d6		 and	 edx, esi
  00083	8b 0c d3	 mov	 ecx, DWORD PTR [ebx+edx*8]
  00086	89 45 f8	 mov	 DWORD PTR _num_probes$[ebp], eax
  00089	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  0008c	75 d2		 jne	 SHORT $LL10@find_posit

; 814  :         if ( insert_pos == ILLEGAL_BUCKET )   // found no prior place to insert

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _insert_pos$[ebp]
  00091	83 f9 ff	 cmp	 ecx, -1
  00094	75 14		 jne	 SHORT $LN7@find_posit
$LN116@find_posit:

; 815  :           return pair<size_type,size_type>(ILLEGAL_BUCKET, bucknum);

  00096	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00099	5e		 pop	 esi
  0009a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000a0	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a3	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 04 00	 ret	 4
$LN7@find_posit:

; 816  :         else
; 817  :           return pair<size_type,size_type>(ILLEGAL_BUCKET, insert_pos);

  000aa	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ad	5e		 pop	 esi
  000ae	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1
  000b4	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000b7	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
$LN112@find_posit:

; 824  :         return pair<size_type,size_type>(bucknum, ILLEGAL_BUCKET);

  000be	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c1	5e		 pop	 esi
  000c2	89 10		 mov	 DWORD PTR [eax], edx
  000c4	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [eax+4], -1
  000cb	5b		 pop	 ebx

; 828  :       assert(num_probes < bucket_count()
; 829  :              && "Hashtable is full: an error in key_equal<> or hash<>");
; 830  :     }
; 831  :   }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted, COMDAT
; _this$ = ecx
; _it$ = eax

; 421  :     assert(settings.use_deleted());
; 422  :     bool retval = !test_deleted(it);

  00000	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00004	76 13		 jbe	 SHORT $LN15@set_delete
  00006	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00009	56		 push	 esi
  0000a	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0000d	3b 32		 cmp	 esi, DWORD PTR [edx]
  0000f	5e		 pop	 esi
  00010	75 07		 jne	 SHORT $LN15@set_delete
  00012	ba 01 00 00 00	 mov	 edx, 1
  00017	eb 02		 jmp	 SHORT $LN16@set_delete
$LN15@set_delete:
  00019	33 d2		 xor	 edx, edx
$LN16@set_delete:

; 423  :     // &* converts from iterator to value-type.
; 424  :     set_key(&(*it), key_info.delkey);

  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00021	84 d2		 test	 dl, dl
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002c	0f 94 c0	 sete	 al

; 425  :     return retval;
; 426  :   }

  0002f	c3		 ret	 0
?set_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++, COMDAT
; _this$ = eax

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	75 42		 jne	 SHORT $LN5@operator@13
  00008	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000b	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  0000f	75 1c		 jne	 SHORT $LN36@operator@13
  00011	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00013	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00017	75 11		 jne	 SHORT $LN19@operator@13
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL20@operator@13:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL20@operator@13
$LN19@operator@13:
  0002a	89 10		 mov	 DWORD PTR [eax], edx

; 266  : 		return (*this);
; 267  : 		}

  0002c	c3		 ret	 0
$LN36@operator@13:

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN3@operator@13
$LL4@operator@13:
  00036	8b 10		 mov	 edx, DWORD PTR [eax]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN3@operator@13
  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL4@operator@13
$LN3@operator@13:
  00048	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator@13:

; 266  : 		return (*this);
; 267  : 		}

  0004a	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 1054 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1056 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1057 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1058 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1059 : 		_Orphan_ptr(*this, _Pnode);
; 1060 : 
; 1061 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1062 : 		_Nodeptr _Pnode = (_Where++)._Mynode();

  00003	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	89 4d 08	 mov	 DWORD PTR __Where$[ebp], ecx

; 1063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1064 : 
; 1065 : 		if (_Pnode != this->_Myhead)

  0000b	3b 06		 cmp	 eax, DWORD PTR [esi]
  0000d	74 26		 je	 SHORT $LN36@erase@2

; 1066 : 			{	// not list head, safe to erase
; 1067 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1068 : 				this->_Nextnode(_Pnode);

  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx

; 1069 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1070 : 				this->_Prevnode(_Pnode);

  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1071 : 
; 1072 : 			_Dest_val(this->_Alnod, _Pnode);
; 1073 : 			this->_Alnod.deallocate(_Pnode, 1);

  0001b	50		 push	 eax
  0001c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1074 : 
; 1075 : 			--this->_Mysize;
; 1076 : 			}
; 1077 : 		return (_Make_iter(_Where));

  00024	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00027	83 c4 04	 add	 esp, 4
  0002a	ff 4e 04	 dec	 DWORD PTR [esi+4]
  0002d	89 07		 mov	 DWORD PTR [edi], eax
  0002f	8b c7		 mov	 eax, edi

; 1078 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN36@erase@2:

; 1074 : 
; 1075 : 			--this->_Mysize;
; 1076 : 			}
; 1077 : 		return (_Make_iter(_Where));

  00035	89 0f		 mov	 DWORD PTR [edi], ecx
  00037	8b c7		 mov	 eax, edi

; 1078 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?erase@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z
_TEXT	SEGMENT
?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval, COMDAT
; _this$ = esi
; __Keyval$ = eax

; 835  : 		size_type _Num = this->comp(_Keyval) & _Mask;

  00000	8b 08		 mov	 ecx, DWORD PTR [eax]
  00002	8b d1		 mov	 edx, ecx
  00004	c1 e2 06	 shl	 edx, 6
  00007	2b ca		 sub	 ecx, edx
  00009	8b c1		 mov	 eax, ecx
  0000b	c1 e8 11	 shr	 eax, 17			; 00000011H
  0000e	33 c8		 xor	 ecx, eax
  00010	8b d1		 mov	 edx, ecx
  00012	c1 e2 09	 shl	 edx, 9
  00015	2b ca		 sub	 ecx, edx
  00017	8b c1		 mov	 eax, ecx
  00019	c1 e0 04	 shl	 eax, 4
  0001c	33 c8		 xor	 ecx, eax
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00025	2b ca		 sub	 ecx, edx
  00027	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0002a	8b c1		 mov	 eax, ecx
  0002c	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0002f	33 c8		 xor	 ecx, eax
  00031	8b c1		 mov	 eax, ecx
  00033	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00036	33 c1		 xor	 eax, ecx
  00038	23 c2		 and	 eax, edx

; 836  : 		if (_Maxidx <= _Num)

  0003a	39 46 24	 cmp	 DWORD PTR [esi+36], eax
  0003d	77 09		 ja	 SHORT $LN1@Hashval

; 837  : 			_Num -= (_Mask >> 1) + 1;

  0003f	d1 ea		 shr	 edx, 1
  00041	83 c9 ff	 or	 ecx, -1
  00044	2b ca		 sub	 ecx, edx
  00046	03 c1		 add	 eax, ecx
$LN1@Hashval:

; 838  : 		return (_Num);
; 839  : 		}

  00048	c3		 ret	 0
?_Hashval@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IBEIABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hashval
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket, COMDAT
; _this$ = ecx
; __Bucket$ = esi

; 749  : 		{	// fix iterators before erasing _Plist before _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 750  : 		if (_Vec_hi(_Bucket) == _Plist)

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	8b 55 08	 mov	 edx, DWORD PTR __Plist$[ebp]
  00009	39 54 f0 04	 cmp	 DWORD PTR [eax+esi*8+4], edx
  0000d	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  00010	75 21		 jne	 SHORT $LN5@Erase_buck

; 751  : 			if (_Vec_lo(_Bucket) == _Plist)

  00012	39 10		 cmp	 DWORD PTR [eax], edx
  00014	75 13		 jne	 SHORT $LN4@Erase_buck

; 752  : 				{	// make bucket empty
; 753  : 				_Vec_lo(_Bucket) = end();

  00016	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00019	89 10		 mov	 DWORD PTR [eax], edx

; 754  : 				_Vec_hi(_Bucket) = end();

  0001b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00021	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx

; 760  : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN4@Erase_buck:

; 755  : 				}
; 756  : 			else
; 757  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

  00029	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0002c	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 760  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN5@Erase_buck:

; 758  : 		else if (_Vec_lo(_Bucket) == _Plist)

  00033	39 10		 cmp	 DWORD PTR [eax], edx
  00035	75 04		 jne	 SHORT $LN1@Erase_buck

; 759  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

  00037	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00039	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Erase_buck:

; 760  : 		}

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Erase_bucket@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@I@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Erase_bucket
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z
_TEXT	SEGMENT
$T189515 = -8						; size = 4
__Where$155570 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound, COMDAT
; _this$ = ecx
; __Keyval$ = eax

; 603  : 		{	// find leftmost not less than _Keyval in mutable hash table

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 604  : 		size_type _Bucket = _Hashval(_Keyval);

  00003	8b 00		 mov	 eax, DWORD PTR [eax]
  00005	83 ec 08	 sub	 esp, 8
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b c8		 mov	 ecx, eax
  0000e	8b d1		 mov	 edx, ecx
  00010	c1 e2 06	 shl	 edx, 6
  00013	2b ca		 sub	 ecx, edx
  00015	8b d1		 mov	 edx, ecx
  00017	c1 ea 11	 shr	 edx, 17			; 00000011H
  0001a	33 ca		 xor	 ecx, edx
  0001c	8b d1		 mov	 edx, ecx
  0001e	c1 e2 09	 shl	 edx, 9
  00021	2b ca		 sub	 ecx, edx
  00023	8b d1		 mov	 edx, ecx
  00025	c1 e2 04	 shl	 edx, 4
  00028	33 ca		 xor	 ecx, edx
  0002a	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  00031	2b ca		 sub	 ecx, edx
  00033	8b d1		 mov	 edx, ecx
  00035	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00038	33 ca		 xor	 ecx, edx
  0003a	8b d1		 mov	 edx, ecx
  0003c	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0003f	57		 push	 edi
  00040	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00043	33 d1		 xor	 edx, ecx
  00045	23 d7		 and	 edx, edi
  00047	39 56 24	 cmp	 DWORD PTR [esi+36], edx
  0004a	77 09		 ja	 SHORT $LN9@lower_boun@4
  0004c	d1 ef		 shr	 edi, 1
  0004e	83 c9 ff	 or	 ecx, -1
  00051	2b cf		 sub	 ecx, edi
  00053	03 d1		 add	 edx, ecx
$LN9@lower_boun@4:

; 605  : 		for (iterator _Where = _Begin(_Bucket);

  00055	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00058	8b 1c d1	 mov	 ebx, DWORD PTR [ecx+edx*8]
  0005b	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0005e	8d 3c d1	 lea	 edi, DWORD PTR [ecx+edx*8]
  00061	8b cb		 mov	 ecx, ebx
  00063	89 4d fc	 mov	 DWORD PTR __Where$155570[ebp], ecx

; 606  : 			_Where != _End(_Bucket); ++_Where)

$LL26@lower_boun@4:
  00066	3b de		 cmp	 ebx, esi
  00068	75 04		 jne	 SHORT $LN31@lower_boun@4
  0006a	8b d6		 mov	 edx, esi
  0006c	eb 05		 jmp	 SHORT $LN30@lower_boun@4
$LN31@lower_boun@4:
  0006e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00071	8b 12		 mov	 edx, DWORD PTR [edx]
$LN30@lower_boun@4:
  00073	3b ca		 cmp	 ecx, edx
  00075	74 3a		 je	 SHORT $LN2@lower_boun@4

; 607  : 			if (!this->comp(this->_Kfn(*_Where), _Keyval))

  00077	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  0007a	74 04		 je	 SHORT $LN127@lower_boun@4

; 606  : 			_Where != _End(_Bucket); ++_Where)

  0007c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007e	eb e6		 jmp	 SHORT $LL26@lower_boun@4
$LN127@lower_boun@4:
  00080	89 4d fc	 mov	 DWORD PTR __Where$155570[ebp], ecx

; 608  : 				return (this->comp(_Keyval,
; 609  : 					this->_Kfn(*_Where)) ? end() : _Where);

  00083	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00086	74 16		 je	 SHORT $LN7@lower_boun@4
  00088	8d 45 f8	 lea	 eax, DWORD PTR $T189515[ebp]
  0008b	89 75 f8	 mov	 DWORD PTR $T189515[ebp], esi
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5b		 pop	 ebx

; 611  : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
$LN7@lower_boun@4:

; 608  : 				return (this->comp(_Keyval,
; 609  : 					this->_Kfn(*_Where)) ? end() : _Where);

  0009e	8d 45 fc	 lea	 eax, DWORD PTR __Where$155570[ebp]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	89 08		 mov	 DWORD PTR [eax], ecx
  000aa	5b		 pop	 ebx

; 611  : 		}

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN2@lower_boun@4:

; 610  : 		return (end());

  000b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	5f		 pop	 edi
  000b5	89 30		 mov	 DWORD PTR [eax], esi
  000b7	5e		 pop	 esi
  000b8	89 4d fc	 mov	 DWORD PTR __Where$155570[ebp], ecx
  000bb	5b		 pop	 ebx

; 611  : 		}

  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
xdata$x	ENDS
;	COMDAT ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
_TEXT	SEGMENT
$T190044 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Tmp$190598 = 12					; size = 4
$T189957 = 12						; size = 4
__Parg$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT

; 220  : 		{	// construct empty hash table

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00009	6a ff		 push	 -1
  0000b	68 00 00 00 00	 push	 __ehhandler$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Parg$[ebp]
  0001b	66 8b 08	 mov	 cx, WORD PTR [eax]
  0001e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00025	57		 push	 edi
  00026	66 89 0e	 mov	 WORD PTR [esi], cx
  00029	33 ff		 xor	 edi, edi
  0002b	6a 10		 push	 16			; 00000010H
  0002d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00035	83 c4 04	 add	 esp, 4
  00038	3b c7		 cmp	 eax, edi
  0003a	0f 84 85 00 00
	00		 je	 $LN24@Hash@2
  00040	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00043	89 00		 mov	 DWORD PTR [eax], eax
  00045	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00048	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004b	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  0004e	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00051	89 3a		 mov	 DWORD PTR [edx], edi
  00053	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  00056	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  00059	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 221  : 		_Init();

  0005d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00060	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00068	f3 0f 11 46 28	 movss	 DWORD PTR [esi+40], xmm0
  0006d	8b 3a		 mov	 edi, DWORD PTR [edx]
  0006f	89 45 0c	 mov	 DWORD PTR __Tmp$190598[ebp], eax
  00072	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00075	3b f8		 cmp	 edi, eax
  00077	74 19		 je	 SHORT $LN84@Hash@2
  00079	8b c8		 mov	 ecx, eax
  0007b	3b c0		 cmp	 eax, eax
  0007d	74 10		 je	 SHORT $LN113@Hash@2
  0007f	53		 push	 ebx
$LL115@Hash@2:
  00080	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00082	89 1f		 mov	 DWORD PTR [edi], ebx
  00084	83 c1 04	 add	 ecx, 4
  00087	83 c7 04	 add	 edi, 4
  0008a	3b c8		 cmp	 ecx, eax
  0008c	75 f2		 jne	 SHORT $LL115@Hash@2
  0008e	5b		 pop	 ebx
$LN113@Hash@2:
  0008f	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN84@Hash@2:
  00092	8b 02		 mov	 eax, DWORD PTR [edx]
  00094	8d 4d 0c	 lea	 ecx, DWORD PTR __Tmp$190598[ebp]
  00097	51		 push	 ecx
  00098	50		 push	 eax
  00099	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  0009e	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 222  : 		}

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	c7 46 20 07 00
	00 00		 mov	 DWORD PTR [esi+32], 7
  000ad	c7 46 24 08 00
	00 00		 mov	 DWORD PTR [esi+36], 8
  000b4	5f		 pop	 edi
  000b5	8b c6		 mov	 eax, esi
  000b7	5e		 pop	 esi
  000b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8

; 220  : 		{	// construct empty hash table

$LN24@Hash@2:
  000c5	8d 55 0c	 lea	 edx, DWORD PTR $T189957[ebp]
  000c8	52		 push	 edx
  000c9	8d 4d e8	 lea	 ecx, DWORD PTR $T190044[ebp]
  000cc	89 7d 0c	 mov	 DWORD PTR $T189957[ebp], edi
  000cf	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000d4	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000d9	8d 45 e8	 lea	 eax, DWORD PTR $T190044[ebp]
  000dc	50		 push	 eax
  000dd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T190044[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000e4	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN143@Hash@2:
$LN142@Hash@2:
  000e9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$0:
  00000	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00003	83 c6 04	 add	 esi, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z$1:
  0000b	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000e	83 c6 10	 add	 esi, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::~vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >
__ehhandler$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree.h
;	COMDAT ?erase@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXViterator@12@@Z
_TEXT	SEGMENT
_result$ = -8						; size = 8
_iter$ = 8						; size = 16
?erase@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXViterator@12@@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase, COMDAT
; _this$ = esi

; 2634 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2635 :         BTREE_PRINT("btree::erase_iter(" << iter.currnode << "," << iter.currslot << ") on btree size " << size());
; 2636 : 
; 2637 :         if (selfverify) verify();
; 2638 : 
; 2639 :         if (!m_root) return;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 ec 08	 sub	 esp, 8
  00008	85 c0		 test	 eax, eax
  0000a	74 25		 je	 SHORT $LN2@erase@3

; 2640 : 
; 2641 :         result_t result = erase_iter_descend(iter, m_root, NULL, NULL, NULL, NULL, NULL, 0);

  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	6a 00		 push	 0
  00016	6a 00		 push	 0
  00018	50		 push	 eax
  00019	8d 45 08	 lea	 eax, DWORD PTR _iter$[ebp]
  0001c	50		 push	 eax
  0001d	8d 4d f8	 lea	 ecx, DWORD PTR _result$[ebp]
  00020	51		 push	 ecx
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend

; 2642 : 
; 2643 :         if (!result.has(btree_not_found))

  00028	f6 45 f8 01	 test	 BYTE PTR _result$[ebp], 1
  0002c	75 03		 jne	 SHORT $LN2@erase@3

; 2644 :             --m_stats.itemcount;

  0002e	ff 4e 0c	 dec	 DWORD PTR [esi+12]
$LN2@erase@3:

; 2645 : 
; 2646 : #ifdef BTREE_DEBUG
; 2647 :         if (debug) print(std::cout);
; 2648 : #endif
; 2649 :         if (selfverify) verify();
; 2650 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
?erase@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAEXViterator@12@@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
$T190720 = -16						; size = 16
$T190719 = -16						; size = 16
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find, COMDAT
; _key$ = eax

; 1779 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1780 :         node *n = m_root;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	83 ec 14	 sub	 esp, 20			; 00000014H
  0000b	53		 push	 ebx

; 1781 :         if (!n) return end();

  0000c	33 db		 xor	 ebx, ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	3b d3		 cmp	 edx, ebx
  00012	75 3d		 jne	 SHORT $LN124@find
  00014	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00017	3b cb		 cmp	 ecx, ebx
  00019	74 1c		 je	 SHORT $LN10@find
  0001b	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  0001f	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00028	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  0002b	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 1796 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8

; 1781 :         if (!n) return end();

$LN10@find:
  00037	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	33 d2		 xor	 edx, edx
  0003c	89 08		 mov	 DWORD PTR [eax], ecx
  0003e	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  00042	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  00045	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 1796 :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
$LN124@find:

; 1782 : 
; 1783 :         while(!n->isleafnode())

  00051	66 39 1a	 cmp	 WORD PTR [edx], bx
  00054	74 29		 je	 SHORT $LN1@find
$LL2@find:

; 1784 :         {
; 1785 :             const inner_node *inner = static_cast<const inner_node*>(n);
; 1786 :             int slot = find_lower(inner, key);

  00056	0f b7 7a 02	 movzx	 edi, WORD PTR [edx+2]
  0005a	33 c9		 xor	 ecx, ecx
  0005c	3b fb		 cmp	 edi, ebx
  0005e	7e 13		 jle	 SHORT $LN20@find
  00060	8b 18		 mov	 ebx, DWORD PTR [eax]
  00062	8d 72 04	 lea	 esi, DWORD PTR [edx+4]
$LL21@find:
  00065	39 1e		 cmp	 DWORD PTR [esi], ebx
  00067	73 08		 jae	 SHORT $LN131@find
  00069	41		 inc	 ecx
  0006a	83 c6 04	 add	 esi, 4
  0006d	3b cf		 cmp	 ecx, edi
  0006f	7c f4		 jl	 SHORT $LL21@find
$LN131@find:
  00071	33 db		 xor	 ebx, ebx
$LN20@find:

; 1787 : 
; 1788 :             n = inner->childid[slot];

  00073	8b 94 8a 84 00
	00 00		 mov	 edx, DWORD PTR [edx+ecx*4+132]
  0007a	66 39 1a	 cmp	 WORD PTR [edx], bx
  0007d	75 d7		 jne	 SHORT $LL2@find
$LN1@find:

; 1789 :         }
; 1790 : 
; 1791 :         leaf_node *leaf = static_cast<leaf_node*>(n);
; 1792 : 
; 1793 :         int slot = find_lower(leaf, key);

  0007f	0f b7 7a 02	 movzx	 edi, WORD PTR [edx+2]
  00083	33 c9		 xor	 ecx, ecx
  00085	3b fb		 cmp	 edi, ebx
  00087	7e 15		 jle	 SHORT $LN55@find
  00089	8b 18		 mov	 ebx, DWORD PTR [eax]
  0008b	8d 72 0c	 lea	 esi, DWORD PTR [edx+12]
  0008e	8b ff		 npad	 2
$LL56@find:
  00090	39 1e		 cmp	 DWORD PTR [esi], ebx
  00092	73 08		 jae	 SHORT $LN132@find
  00094	41		 inc	 ecx
  00095	83 c6 04	 add	 esi, 4
  00098	3b cf		 cmp	 ecx, edi
  0009a	7c f4		 jl	 SHORT $LL56@find
$LN132@find:
  0009c	33 db		 xor	 ebx, ebx
$LN55@find:

; 1794 :         return (slot < leaf->slotuse && key_equal(key, leaf->slotkey[slot]))
; 1795 :             ? iterator(leaf, slot) : end();

  0009e	3b cf		 cmp	 ecx, edi
  000a0	7d 15		 jge	 SHORT $LN6@find
  000a2	8b 74 8a 0c	 mov	 esi, DWORD PTR [edx+ecx*4+12]
  000a6	8b 38		 mov	 edi, DWORD PTR [eax]
  000a8	3b f7		 cmp	 esi, edi
  000aa	77 0b		 ja	 SHORT $LN6@find
  000ac	72 09		 jb	 SHORT $LN6@find
  000ae	89 55 f0	 mov	 DWORD PTR $T190719[ebp], edx
  000b1	66 89 4d f4	 mov	 WORD PTR $T190719[ebp+4], cx
  000b5	eb 19		 jmp	 SHORT $LN134@find
$LN6@find:
  000b7	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000bd	3b cb		 cmp	 ecx, ebx
  000bf	74 06		 je	 SHORT $LN106@find
  000c1	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  000c5	eb 02		 jmp	 SHORT $LN107@find
$LN106@find:
  000c7	33 d2		 xor	 edx, edx
$LN107@find:
  000c9	89 4d f0	 mov	 DWORD PTR $T190720[ebp], ecx
  000cc	66 89 55 f4	 mov	 WORD PTR $T190720[ebp+4], dx
$LN134@find:
  000d0	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d3	8d 4d f0	 lea	 ecx, DWORD PTR $T190720[ebp]
  000d6	89 5d fc	 mov	 DWORD PTR $T190720[ebp+12], ebx
  000d9	89 5d f8	 mov	 DWORD PTR $T190720[ebp+8], ebx
  000dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000de	89 10		 mov	 DWORD PTR [eax], edx
  000e0	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  000e4	66 89 50 04	 mov	 WORD PTR [eax+4], dx
  000e8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000eb	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]

; 1796 :     }

  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	89 50 08	 mov	 DWORD PTR [eax+8], edx
  000f3	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 08 00	 ret	 8
?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ
_TEXT	SEGMENT
$T191043 = -12						; size = 12
??1?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ PROC ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::~btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>, COMDAT
; _this$ = esi

; 1352 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :         clear();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b c7		 cmp	 eax, edi
  0000d	74 45		 je	 SHORT $LN5@btree@2
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	50		 push	 eax
  0001a	66 39 38	 cmp	 WORD PTR [eax], di
  0001d	75 0d		 jne	 SHORT $LN10@btree@2
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
  00027	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002a	eb 0b		 jmp	 SHORT $LN9@btree@2
$LN10@btree@2:
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
  00034	ff 4e 14	 dec	 DWORD PTR [esi+20]
$LN9@btree@2:
  00037	89 7d f4	 mov	 DWORD PTR $T191043[ebp], edi
  0003a	89 7d f8	 mov	 DWORD PTR $T191043[ebp+4], edi
  0003d	f3 0f 7e 45 f4	 movq	 xmm0, QWORD PTR $T191043[ebp]
  00042	33 c0		 xor	 eax, eax
  00044	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00049	89 3e		 mov	 DWORD PTR [esi], edi
  0004b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004e	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00051	89 46 14	 mov	 DWORD PTR [esi+20], eax
$LN5@btree@2:
  00054	5f		 pop	 edi

; 1354 :     }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??1?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE@XZ ENDP ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::~btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree_map.h
_TEXT	ENDS
;	COMDAT ?insert@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABU?$pair@IPAUstx_object@@@4@@Z
_TEXT	SEGMENT
?insert@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABU?$pair@IPAUstx_object@@@4@@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::insert, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi
; _x$ = eax

; 474  :     {

  00000	51		 push	 ecx

; 475  : 	return tree.insert2(x.first, x.second);

  00001	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00004	51		 push	 ecx
  00005	50		 push	 eax
  00006	57		 push	 edi
  00007	e8 00 00 00 00	 call	 ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
  0000c	8b c7		 mov	 eax, edi
  0000e	59		 pop	 ecx

; 476  :     }

  0000f	c3		 ret	 0
?insert@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABU?$pair@IPAUstx_object@@@4@@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::insert
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique, COMDAT
; _key$ = edi

; 1065 :   iterator find_unique(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1066 :     return internal_end(
; 1067 :         internal_find_unique(key, iterator(root(), 0)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 11		 mov	 edx, DWORD PTR [ecx]
  00008	53		 push	 ebx
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	56		 push	 esi
  0000d	83 ec 08	 sub	 esp, 8
  00010	8b f4		 mov	 esi, esp
  00012	83 ec 08	 sub	 esp, 8
  00015	8b c4		 mov	 eax, esp
  00017	89 10		 mov	 DWORD PTR [eax], edx
  00019	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00020	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  00025	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00028	8b c3		 mov	 eax, ebx
  0002a	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end

; 1068 :   }

  0002f	5e		 pop	 esi
  00030	8b c3		 mov	 eax, ebx
  00032	5b		 pop	 ebx
  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?find_unique@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::find_unique
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >, COMDAT
; _this$ = eax

; 249  :   btree_map_container(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 250  :                       const allocator_type &alloc = allocator_type())
; 251  :       : super_type(comp, alloc) {
; 252  :   }

  00006	c3		 ret	 0
??0?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
tv237 = -12						; size = 8
tv229 = -12						; size = 8
tv246 = -8						; size = 4
tv239 = -8						; size = 4
tv231 = -8						; size = 4
tv242 = -2						; size = 2
tv234 = -2						; size = 2
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = ecx

; 681  :         table(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0000b	33 d2		 xor	 edx, edx
  0000d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00012	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0001a	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  00021	66 89 51 11	 mov	 WORD PTR [ecx+17], dx
  00025	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00028	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002d	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00030	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00033	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00036	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 682  :     // table is NULL until emptyval is set.  However, we set num_buckets
; 683  :     // here so we know how much space to allocate once emptyval is set
; 684  :     settings.reset_thresholds(bucket_count());

  00039	db 41 28	 fild	 DWORD PTR [ecx+40]
  0003c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0003f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00042	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00045	85 c0		 test	 eax, eax
  00047	79 06		 jns	 SHORT $LN37@dense_hash@3
  00049	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN37@dense_hash@3:
  0004f	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00052	88 51 10	 mov	 BYTE PTR [ecx+16], dl
  00055	d9 7d fe	 fnstcw	 WORD PTR tv242[ebp]
  00058	0f b7 45 fe	 movzx	 eax, WORD PTR tv242[ebp]
  0005c	d8 c9		 fmul	 ST(0), ST(1)
  0005e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00063	89 45 f8	 mov	 DWORD PTR tv239[ebp], eax
  00066	d9 6d f8	 fldcw	 WORD PTR tv239[ebp]
  00069	df 7d f4	 fistp	 QWORD PTR tv237[ebp]
  0006c	8b 45 f4	 mov	 eax, DWORD PTR tv237[ebp]
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	d9 6d fe	 fldcw	 WORD PTR tv242[ebp]
  00074	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00077	d9 7d fe	 fnstcw	 WORD PTR tv234[ebp]
  0007a	0f b7 45 fe	 movzx	 eax, WORD PTR tv234[ebp]
  0007e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00083	89 45 f8	 mov	 DWORD PTR tv231[ebp], eax
  00086	d9 6d f8	 fldcw	 WORD PTR tv231[ebp]
  00089	df 7d f4	 fistp	 QWORD PTR tv229[ebp]
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv229[ebp]
  0008f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 685  :   }

  00092	8b c1		 mov	 eax, ecx
  00094	d9 6d fe	 fldcw	 WORD PTR tv234[ebp]
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABUSelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@1@ABUSetKey@61@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z
_TEXT	SEGMENT
?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find, COMDAT
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 586  : 		return (lower_bound(_Keyval));

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00006	56		 push	 esi
  00007	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
  0000c	8b c6		 mov	 eax, esi

; 587  : 		}

  0000e	c3		 ret	 0
?find@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Plist$ = 12						; size = 4
?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT

; 538  : 		{	// erase element at _Plist

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 539  : 		size_type _Bucket = _Hashval(this->_Kfn(*_Plist));

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Plist$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	8b c8		 mov	 ecx, eax
  0000b	c1 e1 06	 shl	 ecx, 6
  0000e	2b c1		 sub	 eax, ecx
  00010	8b c8		 mov	 ecx, eax
  00012	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00015	33 c1		 xor	 eax, ecx
  00017	8b c8		 mov	 ecx, eax
  00019	c1 e1 09	 shl	 ecx, 9
  0001c	2b c1		 sub	 eax, ecx
  0001e	8b c8		 mov	 ecx, eax
  00020	c1 e1 04	 shl	 ecx, 4
  00023	33 c1		 xor	 eax, ecx
  00025	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002c	2b c1		 sub	 eax, ecx
  0002e	8b c8		 mov	 ecx, eax
  00030	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00033	33 c1		 xor	 eax, ecx
  00035	53		 push	 ebx
  00036	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	56		 push	 esi
  0003a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  00040	8b c8		 mov	 ecx, eax
  00042	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00045	57		 push	 edi
  00046	8b 7e 20	 mov	 edi, DWORD PTR [esi+32]
  00049	33 c8		 xor	 ecx, eax
  0004b	23 cf		 and	 ecx, edi
  0004d	39 4e 24	 cmp	 DWORD PTR [esi+36], ecx
  00050	77 09		 ja	 SHORT $LN9@erase@4
  00052	d1 ef		 shr	 edi, 1
  00054	83 c8 ff	 or	 eax, -1
  00057	2b c7		 sub	 eax, edi
  00059	03 c8		 add	 ecx, eax
$LN9@erase@4:

; 540  : 
; 541  : 		_Erase_bucket(_List._Make_iter(_Plist), _Bucket);

  0005b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0005e	39 54 c8 04	 cmp	 DWORD PTR [eax+ecx*8+4], edx
  00062	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]
  00065	75 1d		 jne	 SHORT $LN32@erase@4
  00067	39 10		 cmp	 DWORD PTR [eax], edx
  00069	75 11		 jne	 SHORT $LN31@erase@4
  0006b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006e	89 10		 mov	 DWORD PTR [eax], edx
  00070	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00073	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00076	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
  0007a	eb 10		 jmp	 SHORT $LN141@erase@4
$LN31@erase@4:
  0007c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0007f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00082	eb 08		 jmp	 SHORT $LN141@erase@4
$LN32@erase@4:
  00084	39 10		 cmp	 DWORD PTR [eax], edx
  00086	75 07		 jne	 SHORT $LN28@erase@4
  00088	8b 12		 mov	 edx, DWORD PTR [edx]
  0008a	89 10		 mov	 DWORD PTR [eax], edx
$LN141@erase@4:
  0008c	8b 55 0c	 mov	 edx, DWORD PTR __Plist$[ebp]
$LN28@erase@4:

; 542  : 		return (_List.erase(_Plist));

  0008f	8b 3a		 mov	 edi, DWORD PTR [edx]
  00091	8b ca		 mov	 ecx, edx
  00093	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00096	74 1a		 je	 SHORT $LN140@erase@4
  00098	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0009b	8b 10		 mov	 edx, DWORD PTR [eax]
  0009d	89 3a		 mov	 DWORD PTR [edx], edi
  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	51		 push	 ecx
  000a4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000ac	83 c4 04	 add	 esp, 4
  000af	ff 4e 08	 dec	 DWORD PTR [esi+8]
$LN140@erase@4:
  000b2	89 3b		 mov	 DWORD PTR [ebx], edi
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	8b c3		 mov	 eax, ebx
  000b8	5b		 pop	 ebx

; 543  : 		}

  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ
_TEXT	SEGMENT
$T191705 = -2						; size = 2
??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 118  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8d 45 fe	 lea	 eax, DWORD PTR $T191705[ebp]
  00007	50		 push	 eax
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >

; 119  : 		}

  0000e	8b c6		 mov	 eax, esi
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??0?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAE@XZ ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z
_TEXT	SEGMENT
$T191718 = -4						; size = 4
__Where$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find, COMDAT
; ___$ReturnUdt$ = eax

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Keyval$[ebp]
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  0000f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00012	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	75 1a		 jne	 SHORT $LN9@find@2
  0001b	57		 push	 edi
  0001c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0001e	8b ff		 npad	 2
$LL10@find@2:
  00020	39 79 0c	 cmp	 DWORD PTR [ecx+12], edi
  00023	73 05		 jae	 SHORT $LN8@find@2
  00025	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00028	eb 04		 jmp	 SHORT $LN7@find@2
$LN8@find@2:
  0002a	8b d1		 mov	 edx, ecx
  0002c	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN7@find@2:
  0002e	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00032	74 ec		 je	 SHORT $LL10@find@2
  00034	5f		 pop	 edi
$LN9@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  00035	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00038	89 55 08	 mov	 DWORD PTR __Where$[ebp], edx
  0003b	3b d6		 cmp	 edx, esi
  0003d	74 16		 je	 SHORT $LN3@find@2
  0003f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00041	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00044	72 0f		 jb	 SHORT $LN3@find@2
  00046	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	5e		 pop	 esi
  0004c	89 10		 mov	 DWORD PTR [eax], edx
  0004e	5b		 pop	 ebx

; 1429 : 		}

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN3@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  00055	89 75 fc	 mov	 DWORD PTR $T191718[ebp], esi
  00058	8d 4d fc	 lea	 ecx, DWORD PTR $T191718[ebp]
  0005b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005d	5e		 pop	 esi
  0005e	89 10		 mov	 DWORD PTR [eax], edx
  00060	5b		 pop	 ebx

; 1429 : 		}

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv820 = -8						; size = 4
__Erasednode$ = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00003	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000d	74 0a		 je	 SHORT $LN40@erase@5

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00014	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN305@erase@5:
$LN40@erase@5:
  00019	53		 push	 ebx
  0001a	56		 push	 esi

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

  0001b	8b d8		 mov	 ebx, eax
  0001d	57		 push	 edi

; 1207 : 		++_Where;	// save successor iterator for return

  0001e	8d 45 10	 lea	 eax, DWORD PTR __Where$[ebp]
  00021	89 5d fc	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00024	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00029	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002b	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0002f	74 05		 je	 SHORT $LN39@erase@5

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00031	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00034	eb 17		 jmp	 SHORT $LN301@erase@5
$LN39@erase@5:
  00036	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00039	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003d	74 04		 je	 SHORT $LN37@erase@5

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0003f	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00041	eb 0a		 jmp	 SHORT $LN301@erase@5
$LN37@erase@5:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00043	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00046	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  00049	3b c3		 cmp	 eax, ebx
  0004b	75 7c		 jne	 SHORT $LN35@erase@5
$LN301@erase@5:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004d	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00051	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00054	75 03		 jne	 SHORT $LN34@erase@5

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00056	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@5:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  00059	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00062	75 05		 jne	 SHORT $LN33@erase@5

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00064	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00067	eb 0b		 jmp	 SHORT $LN30@erase@5
$LN33@erase@5:
  00069	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006b	75 04		 jne	 SHORT $LN31@erase@5

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006d	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  0006f	eb 03		 jmp	 SHORT $LN30@erase@5
$LN31@erase@5:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00071	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@5:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00074	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00077	39 18		 cmp	 DWORD PTR [eax], ebx
  00079	75 24		 jne	 SHORT $LN29@erase@5

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007b	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0007f	74 04		 je	 SHORT $LN43@erase@5
  00081	8b ce		 mov	 ecx, esi
  00083	eb 15		 jmp	 SHORT $LN95@erase@5
$LN43@erase@5:
  00085	8b 07		 mov	 eax, DWORD PTR [edi]
  00087	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0008b	8b cf		 mov	 ecx, edi
  0008d	75 0b		 jne	 SHORT $LN95@erase@5
  0008f	90		 npad	 1
$LL96@erase@5:
  00090	8b c8		 mov	 ecx, eax
  00092	8b 01		 mov	 eax, DWORD PTR [ecx]
  00094	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00098	74 f6		 je	 SHORT $LL96@erase@5
$LN95@erase@5:
  0009a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@erase@5:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  0009f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a2	89 4d f8	 mov	 DWORD PTR tv820[ebp], ecx
  000a5	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a8	75 7c		 jne	 SHORT $LN173@erase@5

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000aa	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000ae	74 07		 je	 SHORT $LN45@erase@5
  000b0	8b c6		 mov	 eax, esi
  000b2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000b5	eb 6f		 jmp	 SHORT $LN173@erase@5
$LN45@erase@5:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000b7	8b c7		 mov	 eax, edi
  000b9	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Max
  000be	8b 4d f8	 mov	 ecx, DWORD PTR tv820[ebp]
  000c1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000c7	eb 5d		 jmp	 SHORT $LN173@erase@5
$LN35@erase@5:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000cc	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ce	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000d0	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000d3	75 04		 jne	 SHORT $LN26@erase@5

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000d5	8b f0		 mov	 esi, eax

; 1257 : 			else

  000d7	eb 1a		 jmp	 SHORT $LN25@erase@5
$LN26@erase@5:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d9	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000dd	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e0	75 03		 jne	 SHORT $LN24@erase@5

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000e2	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@5:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000e5	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000e7	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000ea	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000ed	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000f0	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@5:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000f3	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f9	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000fc	75 05		 jne	 SHORT $LN23@erase@5

; 1271 : 				_Root() = _Pnode;	// link down from root

  000fe	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00101	eb 0e		 jmp	 SHORT $LN20@erase@5
$LN23@erase@5:
  00103	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00106	39 19		 cmp	 DWORD PTR [ecx], ebx
  00108	75 04		 jne	 SHORT $LN21@erase@5

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  0010a	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  0010c	eb 03		 jmp	 SHORT $LN20@erase@5
$LN21@erase@5:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  0010e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@5:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00111	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00114	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  00117	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  0011a	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  0011d	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00120	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00123	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$LN173@erase@5:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  00126	8b 45 fc	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00129	b3 01		 mov	 bl, 1
  0012b	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  0012e	0f 85 ff 00 00
	00		 jne	 $LN19@erase@5

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00134	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00137	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  0013a	0f 84 f0 00 00
	00		 je	 $LN16@erase@5
$LL18@erase@5:
  00140	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  00143	0f 85 e7 00 00
	00		 jne	 $LN16@erase@5

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00149	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0014b	3b f9		 cmp	 edi, ecx
  0014d	75 69		 jne	 SHORT $LN15@erase@5

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  0014f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00152	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  00156	75 15		 jne	 SHORT $LN14@erase@5

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  00158	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  0015b	52		 push	 edx
  0015c	8b ce		 mov	 ecx, esi
  0015e	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00162	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  00167	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0016a	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN14@erase@5:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  0016d	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00171	75 78		 jne	 SHORT $LN303@erase@5

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00173	8b 01		 mov	 eax, DWORD PTR [ecx]
  00175	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00178	75 08		 jne	 SHORT $LN11@erase@5
  0017a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0017d	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00180	74 65		 je	 SHORT $LN304@erase@5
$LN11@erase@5:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00182	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00185	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00188	75 15		 jne	 SHORT $LN9@erase@5

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0018a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0018c	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  0018f	52		 push	 edx
  00190	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  00194	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  00199	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0019c	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN9@erase@5:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0019f	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  001a2	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  001a5	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  001a8	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001ab	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1323 : 						_Lrotate(_Fixnodeparent);

  001ae	52		 push	 edx
  001af	8b ce		 mov	 ecx, esi
  001b1	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001b6	eb 78		 jmp	 SHORT $LN16@erase@5
$LN15@erase@5:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001b8	80 79 14 00	 cmp	 BYTE PTR [ecx+20], 0
  001bc	75 14		 jne	 SHORT $LN7@erase@5

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001be	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001c1	52		 push	 edx
  001c2	8b ce		 mov	 ecx, esi
  001c4	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001c8	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001cd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001cf	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN7@erase@5:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001d2	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001d6	75 13		 jne	 SHORT $LN303@erase@5

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001d8	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001db	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  001de	75 1e		 jne	 SHORT $LN4@erase@5
  001e0	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e2	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  001e5	75 17		 jne	 SHORT $LN4@erase@5
$LN304@erase@5:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001e7	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
$LN303@erase@5:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001eb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001ee	8b fe		 mov	 edi, esi
  001f0	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001f3	3b 79 04	 cmp	 edi, DWORD PTR [ecx+4]
  001f6	0f 85 44 ff ff
	ff		 jne	 $LL18@erase@5

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001fc	eb 32		 jmp	 SHORT $LN16@erase@5
$LN4@erase@5:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001fe	8b 01		 mov	 eax, DWORD PTR [ecx]
  00200	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00203	75 15		 jne	 SHORT $LN2@erase@5

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  00205	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00208	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  0020b	52		 push	 edx
  0020c	c6 41 14 00	 mov	 BYTE PTR [ecx+20], 0
  00210	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00215	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00217	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN2@erase@5:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0021a	8a 46 14	 mov	 al, BYTE PTR [esi+20]
  0021d	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00220	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00223	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00225	88 59 14	 mov	 BYTE PTR [ecx+20], bl

; 1359 : 						_Rrotate(_Fixnodeparent);

  00228	52		 push	 edx
  00229	8b ce		 mov	 ecx, esi
  0022b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Rrotate
$LN16@erase@5:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  00230	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$LN19@erase@5:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00233	8b 55 fc	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00236	52		 push	 edx
  00237	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0023c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00242	83 c4 04	 add	 esp, 4
  00245	5f		 pop	 edi
  00246	5e		 pop	 esi
  00247	5b		 pop	 ebx
  00248	85 c0		 test	 eax, eax
  0024a	74 04		 je	 SHORT $LN1@erase@5

; 1373 : 			--this->_Mysize;

  0024c	48		 dec	 eax
  0024d	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@5:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00250	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp]
  00253	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00256	89 08		 mov	 DWORD PTR [eax], ecx

; 1376 : 		}

  00258	8b e5		 mov	 esp, ebp
  0025a	5d		 pop	 ebp
  0025b	c2 0c 00	 ret	 12			; 0000000cH
$LN302@erase@5:
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\stx\btree_map.h
_TEXT	ENDS
;	COMDAT ?erase@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEXViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@@Z
_TEXT	SEGMENT
$T192471 = -24						; size = 16
_result$192449 = -8					; size = 8
_iter$ = 8						; size = 16
?erase@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEXViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::erase, COMDAT

; 554  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 555  : 	return tree.erase(iter);

  00006	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00009	66 8b 4d 0c	 mov	 cx, WORD PTR _iter$[ebp+4]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _iter$[ebp+8]
  00010	89 45 e8	 mov	 DWORD PTR $T192471[ebp], eax
  00013	8b 45 14	 mov	 eax, DWORD PTR _iter$[ebp+12]
  00016	56		 push	 esi
  00017	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  0001d	89 45 f4	 mov	 DWORD PTR $T192471[ebp+12], eax
  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	66 89 4d ec	 mov	 WORD PTR $T192471[ebp+4], cx
  00026	89 55 f0	 mov	 DWORD PTR $T192471[ebp+8], edx
  00029	85 c0		 test	 eax, eax
  0002b	74 25		 je	 SHORT $LN14@erase@6
  0002d	6a 00		 push	 0
  0002f	6a 00		 push	 0
  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	6a 00		 push	 0
  00039	50		 push	 eax
  0003a	8d 4d e8	 lea	 ecx, DWORD PTR $T192471[ebp]
  0003d	51		 push	 ecx
  0003e	8d 55 f8	 lea	 edx, DWORD PTR _result$192449[ebp]
  00041	52		 push	 edx
  00042	8b ce		 mov	 ecx, esi
  00044	e8 00 00 00 00	 call	 ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
  00049	f6 45 f8 01	 test	 BYTE PTR _result$192449[ebp], 1
  0004d	75 03		 jne	 SHORT $LN14@erase@6
  0004f	ff 4e 0c	 dec	 DWORD PTR [esi+12]
$LN14@erase@6:

; 556  :     }

  00052	5e		 pop	 esi
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 10 00	 ret	 16			; 00000010H
?erase@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEXViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEAAPAUstx_object@@ABI@Z
_TEXT	SEGMENT
$T192476 = -28						; size = 20
$T192474 = -8						; size = 8
??A?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEAAPAUstx_object@@ABI@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::operator[], COMDAT
; _key$ = eax

; 513  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 514  : 	iterator i = insert( value_type(key, data_type()) ).first;

  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	56		 push	 esi
  00009	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  0000f	8d 55 fc	 lea	 edx, DWORD PTR $T192474[ebp+4]
  00012	52		 push	 edx
  00013	8d 45 f8	 lea	 eax, DWORD PTR $T192474[ebp]
  00016	89 4d f8	 mov	 DWORD PTR $T192474[ebp], ecx
  00019	50		 push	 eax
  0001a	8d 4d e4	 lea	 ecx, DWORD PTR $T192476[ebp]
  0001d	51		 push	 ecx
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T192474[ebp+4], 0
  00025	e8 00 00 00 00	 call	 ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start

; 515  : 	return i.data();

  0002a	0f b7 55 e8	 movzx	 edx, WORD PTR $T192476[ebp+4]
  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T192476[ebp]
  00031	8d 84 90 8c 00
	00 00		 lea	 eax, DWORD PTR [eax+edx*4+140]

; 516  :     }

  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??A?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEAAPAUstx_object@@ABI@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@ABI@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?find@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@ABI@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::find, COMDAT
; ___$ReturnUdt$ = esi

; 345  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 346  : 	return tree.find(key);

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  00009	56		 push	 esi
  0000a	50		 push	 eax
  0000b	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0000e	e8 00 00 00 00	 call	 ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find
  00013	8b c6		 mov	 eax, esi
  00015	59		 pop	 ecx

; 347  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?find@?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE?AViterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@2@ABI@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??1?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@XZ
_TEXT	SEGMENT
$T192608 = -12						; size = 12
??1?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@XZ PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::~btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >, COMDAT
; _this$ = esi

; 202  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  :     }

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b c7		 cmp	 eax, edi
  0000d	74 45		 je	 SHORT $LN8@btree_map@2
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	50		 push	 eax
  0001a	66 39 38	 cmp	 WORD PTR [eax], di
  0001d	75 0d		 jne	 SHORT $LN13@btree_map@2
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
  00027	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002a	eb 0b		 jmp	 SHORT $LN12@btree_map@2
$LN13@btree_map@2:
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
  00034	ff 4e 14	 dec	 DWORD PTR [esi+20]
$LN12@btree_map@2:
  00037	89 7d f4	 mov	 DWORD PTR $T192608[ebp], edi
  0003a	89 7d f8	 mov	 DWORD PTR $T192608[ebp+4], edi
  0003d	f3 0f 7e 45 f4	 movq	 xmm0, QWORD PTR $T192608[ebp]
  00042	33 c0		 xor	 eax, eax
  00044	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00049	89 3e		 mov	 DWORD PTR [esi], edi
  0004b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004e	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00051	89 46 14	 mov	 DWORD PTR [esi+20], eax
$LN8@btree_map@2:
  00054	5f		 pop	 edi
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??1?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@XZ ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::~btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >, COMDAT
; _this$ = eax

; 172  :     {

  00000	33 c9		 xor	 ecx, ecx
  00002	89 08		 mov	 DWORD PTR [eax], ecx
  00004	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00007	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00010	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 173  :     }

  00013	c3		 ret	 0
??0?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAE@ABV?$allocator@U?$pair@IPAUstx_object@@@std@@@std@@@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find, COMDAT
; _key$ = edi

; 182  :   iterator find(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree

; 183  :     return this->tree_.find_unique(key);

  0000b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0000d	56		 push	 esi
  0000e	83 ec 08	 sub	 esp, 8
  00011	8b f4		 mov	 esi, esp
  00013	83 ec 08	 sub	 esp, 8
  00016	8b c4		 mov	 eax, esp
  00018	89 08		 mov	 DWORD PTR [eax], ecx
  0001a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00021	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  00026	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00029	8b c6		 mov	 eax, esi
  0002b	8b d3		 mov	 edx, ebx
  0002d	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end
  00032	8b c6		 mov	 eax, esi

; 184  :   }

  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	59		 pop	 ecx
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?find@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABI@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::find
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_map.h
_TEXT	ENDS
;	COMDAT ??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z
_TEXT	SEGMENT
??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z PROC ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>, COMDAT
; _this$ = eax

; 56   :   btree_map(const key_compare &comp = key_compare(),

  00000	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 57   :             const allocator_type &alloc = allocator_type())
; 58   :       : super_type(comp, alloc) {
; 59   :   }

  00006	c3		 ret	 0
??0?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@QAE@ABU?$btree_key_compare_to_adapter@U?$less@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@std@@@Z ENDP ; btree::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>::btree_map<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z
_TEXT	SEGMENT
tv269 = -12						; size = 8
tv261 = -12						; size = 8
tv278 = -8						; size = 4
tv271 = -8						; size = 4
tv263 = -8						; size = 4
tv274 = -2						; size = 2
tv266 = -2						; size = 2
??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = ecx

; 190  :   explicit dense_hash_map(size_type expected_max_items_in_table = 0,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0000b	33 d2		 xor	 edx, edx
  0000d	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  00012	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  0001a	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  00021	66 89 51 11	 mov	 WORD PTR [ecx+17], dx
  00025	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00028	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  0002d	89 51 20	 mov	 DWORD PTR [ecx+32], edx
  00030	89 51 24	 mov	 DWORD PTR [ecx+36], edx
  00033	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00036	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00039	db 41 28	 fild	 DWORD PTR [ecx+40]
  0003c	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  0003f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00042	89 51 34	 mov	 DWORD PTR [ecx+52], edx
  00045	85 c0		 test	 eax, eax
  00047	79 06		 jns	 SHORT $LN40@dense_hash@4
  00049	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN40@dense_hash@4:
  0004f	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00052	88 51 10	 mov	 BYTE PTR [ecx+16], dl
  00055	d9 7d fe	 fnstcw	 WORD PTR tv274[ebp]
  00058	0f b7 45 fe	 movzx	 eax, WORD PTR tv274[ebp]
  0005c	d8 c9		 fmul	 ST(0), ST(1)
  0005e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00063	89 45 f8	 mov	 DWORD PTR tv271[ebp], eax
  00066	d9 6d f8	 fldcw	 WORD PTR tv271[ebp]
  00069	df 7d f4	 fistp	 QWORD PTR tv269[ebp]
  0006c	8b 45 f4	 mov	 eax, DWORD PTR tv269[ebp]
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	d9 6d fe	 fldcw	 WORD PTR tv274[ebp]
  00074	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  00077	d9 7d fe	 fnstcw	 WORD PTR tv266[ebp]
  0007a	0f b7 45 fe	 movzx	 eax, WORD PTR tv266[ebp]
  0007e	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00083	89 45 f8	 mov	 DWORD PTR tv263[ebp], eax
  00086	d9 6d f8	 fldcw	 WORD PTR tv263[ebp]
  00089	df 7d f4	 fistp	 QWORD PTR tv261[ebp]
  0008c	8b 45 f4	 mov	 eax, DWORD PTR tv261[ebp]
  0008f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 191  :                           const hasher& hf = hasher(),
; 192  :                           const key_equal& eql = key_equal(),
; 193  :                           const allocator_type& alloc = allocator_type())
; 194  :     : rep(expected_max_items_in_table, hf, eql, SelectKey(), SetKey(), alloc) {
; 195  :   }

  00092	8b c1		 mov	 eax, ecx
  00094	d9 6d fe	 fldcw	 WORD PTR tv266[ebp]
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
??0?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE@IABVcpp_tommy_inthash_u32@@ABU?$equal_to@I@std@@ABV?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@1@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
_TEXT	ENDS
PUBLIC	?test_size@@YAXXZ				; test_size
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
;	COMDAT ?test_size@@YAXXZ
_TEXT	SEGMENT
_stats$193032 = -8					; size = 8
?test_size@@YAXXZ PROC					; test_size, COMDAT

; 2112 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2113 : #ifdef USE_JUDY
; 2114 : 	Word_t w;
; 2115 : #endif
; 2116 : 
; 2117 : 	MEM(DATA_TREE, rbt_size(&tree, the_max));

  00006	b8 05 00 00 00	 mov	 eax, 5
  0000b	56		 push	 esi
  0000c	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00012	75 11		 jne	 SHORT $LN14@test_size
  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0001a	03 f6		 add	 esi, esi
  0001c	03 f6		 add	 esi, esi
  0001e	03 f6		 add	 esi, esi
  00020	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN14@test_size:

; 2118 : 	MEM(DATA_HASHTABLE, tommy_hashtable_memory_usage(&hashtable));

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  0002c	75 19		 jne	 SHORT $LN13@test_size
  0002e	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00033	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+4
  00039	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  0003c	03 f6		 add	 esi, esi
  0003e	03 f6		 add	 esi, esi
  00040	33 c0		 xor	 eax, eax
  00042	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN13@test_size:

; 2119 : 	MEM(DATA_HASHDYN, tommy_hashdyn_memory_usage(&hashdyn));

  00047	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?the_data@@3IA, 1 ; the_data
  0004e	75 1c		 jne	 SHORT $LN12@test_size
  00050	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00055	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  0005b	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
  0005e	03 f6		 add	 esi, esi
  00060	03 f6		 add	 esi, esi
  00062	b8 01 00 00 00	 mov	 eax, 1
  00067	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN12@test_size:

; 2120 : 	MEM(DATA_HASHLIN, tommy_hashlin_memory_usage(&hashlin));

  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00077	75 18		 jne	 SHORT $LN11@test_size
  00079	8b 0d a0 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  0007f	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  00085	8d 34 8a	 lea	 esi, DWORD PTR [edx+ecx*4]
  00088	03 f6		 add	 esi, esi
  0008a	03 f6		 add	 esi, esi
  0008c	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN11@test_size:

; 2121 : 	MEM(DATA_TRIE, tommy_trie_memory_usage(&trie));

  00091	b8 03 00 00 00	 mov	 eax, 3
  00096	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0009c	75 17		 jne	 SHORT $LN10@test_size
  0009e	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  000a4	8b 15 44 00 00
	00		 mov	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+68
  000aa	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
  000ad	c1 e6 04	 shl	 esi, 4
  000b0	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN10@test_size:

; 2122 : 	MEM(DATA_TRIE_INPLACE, tommy_trie_inplace_memory_usage(&trie_inplace));

  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000c0	75 0e		 jne	 SHORT $LN9@test_size
  000c2	8b 35 00 01 00
	00		 mov	 esi, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  000c8	c1 e6 05	 shl	 esi, 5
  000cb	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN9@test_size:

; 2123 : 	MEM(DATA_KHASH, khash_size(khash));

  000d0	83 3d 00 00 00
	00 07		 cmp	 DWORD PTR ?the_data@@3IA, 7 ; the_data
  000d7	75 1d		 jne	 SHORT $LN8@test_size
  000d9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  000de	8b 00		 mov	 eax, DWORD PTR [eax]
  000e0	8b c8		 mov	 ecx, eax
  000e2	c1 e9 04	 shr	 ecx, 4
  000e5	8d 34 41	 lea	 esi, DWORD PTR [ecx+eax*2]
  000e8	03 f6		 add	 esi, esi
  000ea	03 f6		 add	 esi, esi
  000ec	b8 07 00 00 00	 mov	 eax, 7
  000f1	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN8@test_size:

; 2124 : #ifdef USE_GOOGLEDENSEHASH
; 2125 : 	MEM(DATA_GOOGLEDENSEHASH, googledensehash_size(googledensehash));

  000f6	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000fb	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00101	75 14		 jne	 SHORT $LN7@test_size
  00103	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00109	8b 72 28	 mov	 esi, DWORD PTR [edx+40]
  0010c	03 f6		 add	 esi, esi
  0010e	03 f6		 add	 esi, esi
  00110	03 f6		 add	 esi, esi
  00112	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN7@test_size:

; 2126 : #endif
; 2127 : #ifdef USE_GOOGLEBTREE
; 2128 : 	MEM(DATA_GOOGLEBTREE, googlebtree_size(googlebtree));

  00117	83 3d 00 00 00
	00 0c		 cmp	 DWORD PTR ?the_data@@3IA, 12 ; the_data, 0000000cH
  0011e	75 45		 jne	 SHORT $LN6@test_size
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00126	8b 31		 mov	 esi, DWORD PTR [ecx]
  00128	56		 push	 esi
  00129	8d 45 f8	 lea	 eax, DWORD PTR _stats$193032[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?internal_stats@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AUnode_stats@12@PBV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_stats
  00132	8b 45 f8	 mov	 eax, DWORD PTR _stats$193032[ebp]
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _stats$193032[ebp+4]
  00138	83 f8 01	 cmp	 eax, 1
  0013b	75 11		 jne	 SHORT $LN72@test_size
  0013d	85 c9		 test	 ecx, ecx
  0013f	75 0d		 jne	 SHORT $LN72@test_size
  00141	0f b6 76 02	 movzx	 esi, BYTE PTR [esi+2]
  00145	8d 34 f5 0c 00
	00 00		 lea	 esi, DWORD PTR [esi*8+12]
  0014c	eb 0d		 jmp	 SHORT $LN71@test_size
$LN72@test_size:
  0014e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00151	c1 e1 07	 shl	 ecx, 7
  00154	c1 e0 08	 shl	 eax, 8
  00157	8d 74 01 0c	 lea	 esi, DWORD PTR [ecx+eax+12]
$LN71@test_size:
  0015b	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00160	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN6@test_size:

; 2129 : #endif
; 2130 : #ifdef USE_STXBTREE
; 2131 : 	MEM(DATA_STXBTREE, stxbtree_size(stxbtree));

  00165	83 3d 00 00 00
	00 0d		 cmp	 DWORD PTR ?the_data@@3IA, 13 ; the_data, 0000000dH
  0016c	75 23		 jne	 SHORT $LN5@test_size
  0016e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  00173	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  00176	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00179	69 f6 0c 01 00
	00		 imul	 esi, 268		; 0000010cH
  0017f	69 d2 08 01 00
	00		 imul	 edx, 264		; 00000108H
  00185	03 f2		 add	 esi, edx
  00187	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0018c	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN5@test_size:

; 2132 : #endif
; 2133 : 	MEM(DATA_UTHASH, uthash_size(uthash));

  00191	83 3d 00 00 00
	00 08		 cmp	 DWORD PTR ?the_data@@3IA, 8 ; the_data
  00198	75 30		 jne	 SHORT $LN4@test_size
  0019a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  0019f	85 c0		 test	 eax, eax
  001a1	75 04		 jne	 SHORT $LN96@test_size
  001a3	33 f6		 xor	 esi, esi
  001a5	eb 19		 jmp	 SHORT $LN97@test_size
$LN96@test_size:
  001a7	8b 00		 mov	 eax, DWORD PTR [eax]
  001a9	85 c0		 test	 eax, eax
  001ab	75 04		 jne	 SHORT $LN95@test_size
  001ad	33 f6		 xor	 esi, esi
  001af	eb 0f		 jmp	 SHORT $LN97@test_size
$LN95@test_size:
  001b1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b7	c1 e1 05	 shl	 ecx, 5
  001ba	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  001bd	8d 34 91	 lea	 esi, DWORD PTR [ecx+edx*4]
$LN97@test_size:
  001c0	b8 08 00 00 00	 mov	 eax, 8
  001c5	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN4@test_size:

; 2134 : 	MEM(DATA_NEDTRIE, nedtrie_size(&nedtrie));

  001ca	83 3d 00 00 00
	00 06		 cmp	 DWORD PTR ?the_data@@3IA, 6 ; the_data
  001d1	75 16		 jne	 SHORT $LN3@test_size
  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A
  001d8	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  001db	03 f6		 add	 esi, esi
  001dd	03 f6		 add	 esi, esi
  001df	b8 06 00 00 00	 mov	 eax, 6
  001e4	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN3@test_size:

; 2135 : #ifdef USE_JUDY
; 2136 : 	JLMU(w, judy);

  001e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judy@@3PAXA ; judy
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 _JudyLMemUsed
  001f4	83 c4 04	 add	 esp, 4

; 2137 : 	MEM(DATA_JUDY, w);

  001f7	83 3d 00 00 00
	00 09		 cmp	 DWORD PTR ?the_data@@3IA, 9 ; the_data
  001fe	75 0c		 jne	 SHORT $LN2@test_size
  00200	8b f0		 mov	 esi, eax
  00202	b8 09 00 00 00	 mov	 eax, 9
  00207	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN2@test_size:

; 2138 : #endif
; 2139 : #ifdef USE_JUDYARRAY
; 2140 : 	MEM(DATA_JUDYARRAY,judy_size(judyarray));

  0020c	83 3d 00 00 00
	00 0a		 cmp	 DWORD PTR ?the_data@@3IA, 10 ; the_data, 0000000aH
  00213	75 29		 jne	 SHORT $LN1@test_size
  00215	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  0021b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0021e	33 f6		 xor	 esi, esi
  00220	85 c0		 test	 eax, eax
  00222	74 10		 je	 SHORT $LN107@test_size
$LL108@test_size:
  00224	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00229	2b 50 04	 sub	 edx, DWORD PTR [eax+4]
  0022c	8b 00		 mov	 eax, DWORD PTR [eax]
  0022e	03 f2		 add	 esi, edx
  00230	85 c0		 test	 eax, eax
  00232	75 f0		 jne	 SHORT $LL108@test_size
$LN107@test_size:
  00234	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00239	e8 00 00 00 00	 call	 ?mem@@YAXII@Z		; mem
$LN1@test_size:

; 2141 : #endif
; 2142 : }

  0023e	5e		 pop	 esi
  0023f	8b e5		 mov	 esp, ebp
  00241	5d		 pop	 ebp
  00242	c3		 ret	 0
?test_size@@YAXXZ ENDP					; test_size
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_G?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEPAXI@Z
_TEXT	SEGMENT
$T193192 = -12						; size = 12
??_G?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEPAXI@Z PROC ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	3b c7		 cmp	 eax, edi
  0000d	74 45		 je	 SHORT $LN11@scalar@7
  0000f	50		 push	 eax
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ?clear_recursive@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAEXPAUnode@12@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::clear_recursive
  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	50		 push	 eax
  0001a	66 39 38	 cmp	 WORD PTR [eax], di
  0001d	75 0d		 jne	 SHORT $LN16@scalar@7
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00024	83 c4 04	 add	 esp, 4
  00027	ff 4e 10	 dec	 DWORD PTR [esi+16]
  0002a	eb 0b		 jmp	 SHORT $LN15@scalar@7
$LN16@scalar@7:
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00031	83 c4 04	 add	 esp, 4
  00034	ff 4e 14	 dec	 DWORD PTR [esi+20]
$LN15@scalar@7:
  00037	89 7d f4	 mov	 DWORD PTR $T193192[ebp], edi
  0003a	89 7d f8	 mov	 DWORD PTR $T193192[ebp+4], edi
  0003d	f3 0f 7e 45 f4	 movq	 xmm0, QWORD PTR $T193192[ebp]
  00042	33 c0		 xor	 eax, eax
  00044	66 0f d6 46 0c	 movq	 QWORD PTR [esi+12], xmm0
  00049	89 3e		 mov	 DWORD PTR [esi], edi
  0004b	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0004e	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00051	89 46 14	 mov	 DWORD PTR [esi+20], eax
$LN11@scalar@7:
  00054	56		 push	 esi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0005a	83 c4 04	 add	 esp, 4
  0005d	8b c6		 mov	 eax, esi
  0005f	5f		 pop	 edi
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??_G?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEPAXI@Z ENDP ; stx::btree_map<unsigned int,stx_object *,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,std::allocator<std::pair<unsigned int,stx_object *> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?judy_del@@YAPAIPAUJudy@@@Z			; judy_del
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_del@@YAPAIPAUJudy@@@Z
_TEXT	SEGMENT
tv334 = -28						; size = 4
_cnt$ = -24						; size = 4
tv659 = -20						; size = 4
tv347 = -16						; size = 4
_node$ = -12						; size = 4
_size$ = -12						; size = 4
tv568 = -8						; size = 4
tv587 = -4						; size = 4
?judy_del@@YAPAIPAUJudy@@@Z PROC			; judy_del, COMDAT

; 1154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00009	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 1155 : int slot, off, size, type, high;
; 1156 : JudySlot *table, *inner;
; 1157 : JudySlot next, *node;
; 1158 : int keysize, cnt;
; 1159 : uchar *base;
; 1160 : 
; 1161 : 	while( judy->level ) {

  0000c	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	0f 84 9a 01 00
	00		 je	 $LN15@judy_del
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL16@judy_del:

; 1162 : 		next = judy->stack[judy->level].next;

  00020	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00023	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00026	8d 1c 8a	 lea	 ebx, DWORD PTR [edx+ecx*4]
  00029	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]

; 1163 : 		slot = judy->stack[judy->level].slot;

  0002c	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]
  00030	8b 34 82	 mov	 esi, DWORD PTR [edx+eax*4]

; 1165 : 		size = JudySize[next & 0x07];

  00033	8b f9		 mov	 edi, ecx
  00035	83 e7 07	 and	 edi, 7
  00038	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[edi*4]
  0003f	89 7d e4	 mov	 DWORD PTR tv334[ebp], edi
  00042	89 45 f4	 mov	 DWORD PTR _size$[ebp], eax

; 1166 : 
; 1167 : 		switch( type = next & 0x07 ) {

  00045	83 ff 07	 cmp	 edi, 7
  00048	0f 87 55 01 00
	00		 ja	 $LN49@judy_del
  0004e	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN50@judy_del[edi*4]
$LN12@judy_del:

; 1168 : 		case JUDY_1:
; 1169 : 		case JUDY_2:
; 1170 : 		case JUDY_4:
; 1171 : 		case JUDY_8:
; 1172 : 		case JUDY_16:
; 1173 : 		case JUDY_32:
; 1174 : #ifdef ASKITIS
; 1175 : 		case JUDY_64:
; 1176 : #endif
; 1177 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);

  00055	8b 53 38	 mov	 edx, DWORD PTR [ebx+56]
  00058	83 e2 03	 and	 edx, 3
  0005b	bf 04 00 00 00	 mov	 edi, 4
  00060	2b fa		 sub	 edi, edx

; 1178 : 			cnt = size / (sizeof(JudySlot) + keysize);

  00062	8d 5f 04	 lea	 ebx, DWORD PTR [edi+4]
  00065	33 d2		 xor	 edx, edx
  00067	f7 f3		 div	 ebx

; 1179 : 			node = (JudySlot *)((next & JUDY_mask) + size);

  00069	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0006c	89 4d f0	 mov	 DWORD PTR tv347[ebp], ecx
  0006f	89 45 e8	 mov	 DWORD PTR _cnt$[ebp], eax
  00072	8b 45 f4	 mov	 eax, DWORD PTR _size$[ebp]
  00075	8d 1c 01	 lea	 ebx, DWORD PTR [ecx+eax]
  00078	89 5d f4	 mov	 DWORD PTR _node$[ebp], ebx

; 1180 : 			base = (uchar *)(next & JUDY_mask);
; 1181 : 
; 1182 : 			//	move deleted slot to first slot
; 1183 : 
; 1184 : 			while( slot ) {

  0007b	85 f6		 test	 esi, esi
  0007d	74 52		 je	 SHORT $LN10@judy_del

; 1164 : 		off = judy->stack[judy->level].off;

  0007f	8b c7		 mov	 eax, edi
  00081	f7 d8		 neg	 eax
  00083	89 45 ec	 mov	 DWORD PTR tv659[ebp], eax
  00086	8b d7		 mov	 edx, edi
  00088	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0008b	0f af d6	 imul	 edx, esi
  0008e	0f af c7	 imul	 eax, edi
  00091	03 d1		 add	 edx, ecx
  00093	03 c1		 add	 eax, ecx
  00095	8d 0c b5 00 00
	00 00		 lea	 ecx, DWORD PTR [esi*4]
  0009c	89 55 f8	 mov	 DWORD PTR tv568[ebp], edx
  0009f	89 45 fc	 mov	 DWORD PTR tv587[ebp], eax
  000a2	2b d9		 sub	 ebx, ecx
  000a4	eb 06		 jmp	 SHORT $LN11@judy_del
$LL48@judy_del:
  000a6	8b 55 f8	 mov	 edx, DWORD PTR tv568[ebp]
  000a9	8b 45 fc	 mov	 eax, DWORD PTR tv587[ebp]
$LN11@judy_del:

; 1185 : 				node[-slot-1] = node[-slot];

  000ac	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 1186 : 				memcpy (base + slot * keysize, base + (slot - 1) * keysize, keysize);

  000ae	57		 push	 edi
  000af	50		 push	 eax
  000b0	52		 push	 edx
  000b1	89 4b fc	 mov	 DWORD PTR [ebx-4], ecx
  000b4	e8 00 00 00 00	 call	 _memcpy

; 1187 : 				slot--;

  000b9	8b 45 ec	 mov	 eax, DWORD PTR tv659[ebp]
  000bc	01 45 fc	 add	 DWORD PTR tv587[ebp], eax
  000bf	01 45 f8	 add	 DWORD PTR tv568[ebp], eax
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	83 c3 04	 add	 ebx, 4
  000c8	4e		 dec	 esi
  000c9	75 db		 jne	 SHORT $LL48@judy_del

; 1180 : 			base = (uchar *)(next & JUDY_mask);
; 1181 : 
; 1182 : 			//	move deleted slot to first slot
; 1183 : 
; 1184 : 			while( slot ) {

  000cb	8b 5d f4	 mov	 ebx, DWORD PTR _node$[ebp]
  000ce	8b 4d f0	 mov	 ecx, DWORD PTR tv347[ebp]
$LN10@judy_del:

; 1188 : 			}
; 1189 : 
; 1190 : 			//	zero out first slot
; 1191 : 
; 1192 : 			node[-1] = 0;
; 1193 : 			memset (base, 0, keysize);

  000d1	57		 push	 edi
  000d2	6a 00		 push	 0
  000d4	51		 push	 ecx
  000d5	c7 43 fc 00 00
	00 00		 mov	 DWORD PTR [ebx-4], 0
  000dc	e8 00 00 00 00	 call	 _memset

; 1194 : 
; 1195 : 			if( node[-cnt] ) {	// does node have any slots left?

  000e1	8b 55 e8	 mov	 edx, DWORD PTR _cnt$[ebp]
  000e4	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  000e7	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  000ee	2b c1		 sub	 eax, ecx
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f3	83 38 00	 cmp	 DWORD PTR [eax], 0
  000f6	0f 85 c6 00 00
	00		 jne	 $LN44@judy_del

; 1198 : 			}
; 1199 : 
; 1200 : 			judy_free (judy, base, type);

  000fc	8b 4d e4	 mov	 ecx, DWORD PTR tv334[ebp]
  000ff	85 c9		 test	 ecx, ecx
  00101	75 07		 jne	 SHORT $LN20@judy_del
  00103	b9 04 00 00 00	 mov	 ecx, 4
  00108	eb 0a		 jmp	 SHORT $LN19@judy_del
$LN20@judy_del:
  0010a	83 f9 07	 cmp	 ecx, 7
  0010d	75 05		 jne	 SHORT $LN19@judy_del
  0010f	b9 03 00 00 00	 mov	 ecx, 3
$LN19@judy_del:
  00114	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00119	8b 74 88 04	 mov	 esi, DWORD PTR [eax+ecx*4+4]
  0011d	8b 55 f0	 mov	 edx, DWORD PTR tv347[ebp]
  00120	89 32		 mov	 DWORD PTR [edx], esi
  00122	89 54 88 04	 mov	 DWORD PTR [eax+ecx*4+4], edx

; 1201 : 			judy->level--;

  00126	ff 48 28	 dec	 DWORD PTR [eax+40]

; 1202 : 			continue;

  00129	eb 78		 jmp	 SHORT $LN49@judy_del
$LN8@judy_del:

; 1203 : 
; 1204 : 		case JUDY_radix:
; 1205 : 			table = (JudySlot  *)(next & JUDY_mask);
; 1206 : 			inner = (JudySlot *)(table[slot >> 4] & JUDY_mask);

  0012b	8b d6		 mov	 edx, esi
  0012d	c1 fa 04	 sar	 edx, 4
  00130	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00133	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00136	8d 3c 91	 lea	 edi, DWORD PTR [ecx+edx*4]
  00139	83 e0 f8	 and	 eax, -8			; fffffff8H

; 1207 : 			inner[slot & 0x0F] = 0;

  0013c	83 e6 0f	 and	 esi, 15			; 0000000fH
  0013f	c7 04 b0 00 00
	00 00		 mov	 DWORD PTR [eax+esi*4], 0

; 1208 : 			high = slot & 0xF0;
; 1209 : 
; 1210 : 			for( cnt = 16; cnt--; )

  00146	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0014b	eb 03 8d 49 00	 npad	 5
$LL7@judy_del:
  00150	4a		 dec	 edx

; 1211 : 				if( inner[cnt] )

  00151	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  00155	0f 85 86 00 00
	00		 jne	 $LN42@judy_del

; 1208 : 			high = slot & 0xF0;
; 1209 : 
; 1210 : 			for( cnt = 16; cnt--; )

  0015b	85 d2		 test	 edx, edx
  0015d	75 f1		 jne	 SHORT $LL7@judy_del

; 1213 : 
; 1214 : 			judy_free (judy, inner, JUDY_radix);

  0015f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00165	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00168	89 30		 mov	 DWORD PTR [eax], esi
  0016a	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1215 : 			table[slot >> 4] = 0;

  0016d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0

; 1216 : 
; 1217 : 			for( cnt = 16; cnt--; )

  00173	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
$LL4@judy_del:
  00178	48		 dec	 eax

; 1218 : 				if( table[cnt] )

  00179	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0017d	75 62		 jne	 SHORT $LN42@judy_del

; 1216 : 
; 1217 : 			for( cnt = 16; cnt--; )

  0017f	85 c0		 test	 eax, eax
  00181	75 f5		 jne	 SHORT $LL4@judy_del

; 1219 : 					return judy_prv (judy);
; 1220 : 
; 1221 : 			judy_free (judy, table, JUDY_radix);

  00183	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00188	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0018b	89 11		 mov	 DWORD PTR [ecx], edx
  0018d	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1222 : 			judy->level--;

  00190	ff 48 28	 dec	 DWORD PTR [eax+40]

; 1223 : 			continue;

  00193	eb 0e		 jmp	 SHORT $LN49@judy_del
$LN1@judy_del:

; 1224 : 
; 1225 : #ifndef ASKITIS
; 1226 : 		case JUDY_span:
; 1227 : 			base = (uchar *)(next & JUDY_mask);
; 1228 : 			judy_free (judy, base, type);

  00195	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00198	83 e1 f8	 and	 ecx, -8			; fffffff8H
  0019b	89 01		 mov	 DWORD PTR [ecx], eax
  0019d	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1229 : 			judy->level--;

  001a0	ff 4a 28	 dec	 DWORD PTR [edx+40]
$LN49@judy_del:

; 1155 : int slot, off, size, type, high;
; 1156 : JudySlot *table, *inner;
; 1157 : JudySlot next, *node;
; 1158 : int keysize, cnt;
; 1159 : uchar *base;
; 1160 : 
; 1161 : 	while( judy->level ) {

  001a3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001a9	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  001ad	0f 85 6d fe ff
	ff		 jne	 $LL16@judy_del
$LN15@judy_del:
  001b3	5f		 pop	 edi
  001b4	5e		 pop	 esi

; 1230 : 			continue;
; 1231 : #endif
; 1232 : 		}
; 1233 : 	}
; 1234 : 
; 1235 : 	//	tree is now empty
; 1236 : 
; 1237 : 	*judy->root = 0;

  001b5	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1238 : 	return NULL;

  001bb	33 c0		 xor	 eax, eax
  001bd	5b		 pop	 ebx

; 1239 : }

  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
$LN44@judy_del:

; 1196 : 				judy->stack[judy->level].slot++;

  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001c8	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  001cb	8d 54 40 0f	 lea	 edx, DWORD PTR [eax+eax*2+15]
  001cf	ff 04 91	 inc	 DWORD PTR [ecx+edx*4]
  001d2	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1197 : 				return judy_prv (judy);

  001d5	e8 00 00 00 00	 call	 ?judy_prv@@YAPAIPAUJudy@@@Z ; judy_prv
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx

; 1239 : }

  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c3		 ret	 0
$LN42@judy_del:

; 1212 : 					return judy_prv (judy);

  001e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  001e7	e8 00 00 00 00	 call	 ?judy_prv@@YAPAIPAUJudy@@@Z ; judy_prv
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx

; 1239 : }

  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
  001f3	90		 npad	 1
$LN50@judy_del:
  001f4	00 00 00 00	 DD	 $LN8@judy_del
  001f8	00 00 00 00	 DD	 $LN12@judy_del
  001fc	00 00 00 00	 DD	 $LN12@judy_del
  00200	00 00 00 00	 DD	 $LN12@judy_del
  00204	00 00 00 00	 DD	 $LN12@judy_del
  00208	00 00 00 00	 DD	 $LN12@judy_del
  0020c	00 00 00 00	 DD	 $LN12@judy_del
  00210	00 00 00 00	 DD	 $LN1@judy_del
?judy_del@@YAPAIPAUJudy@@@Z ENDP			; judy_del
_TEXT	ENDS
PUBLIC	?judy_splitnode@@YAXPAUJudy@@PAIIII@Z		; judy_splitnode
; Function compile flags: /Ogtp
;	COMDAT ?judy_splitnode@@YAXPAUJudy@@PAIIII@Z
_TEXT	SEGMENT
_newradix$ = -12					; size = 4
_nxt$ = -8						; size = 4
_start$ = -4						; size = 4
_judy$ = 8						; size = 4
tv293 = 12						; size = 4
_next$ = 12						; size = 4
_cnt$ = 16						; size = 4
_size$ = 16						; size = 4
_keysize$ = 20						; size = 4
_depth$ = 24						; size = 4
?judy_splitnode@@YAXPAUJudy@@PAIIII@Z PROC		; judy_splitnode, COMDAT

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 782  : uint key = 0x0100, nxt;
; 783  : JudySlot *newradix;
; 784  : uchar *base;
; 785  : 
; 786  : 	base = (uchar  *)(*next & JUDY_mask);
; 787  : 	cnt = size / (sizeof(JudySlot) + keysize);

  00006	8b 4d 14	 mov	 ecx, DWORD PTR _keysize$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  0000c	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 f1		 div	 ecx

; 788  : 
; 789  : 	//	allocate outer judy_radix node
; 790  : 
; 791  : 	newradix = (JudySlot*)judy_alloc (judy, JUDY_radix);

  00013	8b 55 08	 mov	 edx, DWORD PTR _judy$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _next$[ebp]
  0001a	56		 push	 esi
  0001b	8b 33		 mov	 esi, DWORD PTR [ebx]
  0001d	57		 push	 edi
  0001e	52		 push	 edx
  0001f	33 c9		 xor	 ecx, ecx
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _start$[ebp], 0
  00028	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  0002d	83 e6 f8	 and	 esi, -8			; fffffff8H
  00030	89 45 10	 mov	 DWORD PTR _cnt$[ebp], eax
  00033	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc
  00038	8b d0		 mov	 edx, eax
  0003a	8b 45 14	 mov	 eax, DWORD PTR _keysize$[ebp]

; 792  : 	*next = (JudySlot)newradix | JUDY_radix;

  0003d	89 13		 mov	 DWORD PTR [ebx], edx

; 793  : 
; 794  : 	for( slot = 0; slot < cnt; slot++ ) {

  0003f	33 db		 xor	 ebx, ebx
  00041	83 c4 04	 add	 esp, 4
  00044	89 55 f4	 mov	 DWORD PTR _newradix$[ebp], edx
  00047	39 5d 10	 cmp	 DWORD PTR _cnt$[ebp], ebx
  0004a	7e 50		 jle	 SHORT $LN3@judy_split@2

; 781  : int cnt, slot, start = 0;

  0004c	8d 4c 06 ff	 lea	 ecx, DWORD PTR [esi+eax-1]
  00050	89 4d 0c	 mov	 DWORD PTR tv293[ebp], ecx
$LL15@judy_split@2:

; 795  : #if BYTE_ORDER != BIG_ENDIAN
; 796  : 		nxt = base[slot * keysize + keysize - 1];

  00053	8b 4d 0c	 mov	 ecx, DWORD PTR tv293[ebp]
  00056	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00059	89 4d f8	 mov	 DWORD PTR _nxt$[ebp], ecx

; 797  : #else
; 798  : 		nxt = base[slot * keysize];
; 799  : #endif
; 800  : 
; 801  : 		if( key > 0xFF )

  0005c	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00062	76 04		 jbe	 SHORT $LN2@judy_split@2

; 802  : 			key = nxt;

  00064	8b f9		 mov	 edi, ecx

; 803  : 		if( nxt == key )

  00066	eb 2b		 jmp	 SHORT $LN4@judy_split@2
$LN2@judy_split@2:
  00068	3b cf		 cmp	 ecx, edi
  0006a	74 27		 je	 SHORT $LN4@judy_split@2

; 804  : 			continue;
; 805  : 
; 806  : 		//	decompose portion of old node into radix nodes
; 807  : 
; 808  : 		judy_radix (judy, newradix, base, start, slot, keysize - 1, (uchar)key, depth);

  0006c	8b 4d 18	 mov	 ecx, DWORD PTR _depth$[ebp]
  0006f	51		 push	 ecx
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  00073	57		 push	 edi
  00074	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  00077	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	51		 push	 ecx
  0007d	8b c3		 mov	 eax, ebx
  0007f	e8 00 00 00 00	 call	 ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ; judy_radix

; 809  : 		start = slot;
; 810  : 		key = nxt;

  00084	8b 7d f8	 mov	 edi, DWORD PTR _nxt$[ebp]
  00087	8b 55 f4	 mov	 edx, DWORD PTR _newradix$[ebp]
  0008a	8b 45 14	 mov	 eax, DWORD PTR _keysize$[ebp]
  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	89 5d fc	 mov	 DWORD PTR _start$[ebp], ebx
$LN4@judy_split@2:

; 793  : 
; 794  : 	for( slot = 0; slot < cnt; slot++ ) {

  00093	01 45 0c	 add	 DWORD PTR tv293[ebp], eax
  00096	43		 inc	 ebx
  00097	3b 5d 10	 cmp	 ebx, DWORD PTR _cnt$[ebp]
  0009a	7c b7		 jl	 SHORT $LL15@judy_split@2
$LN3@judy_split@2:

; 811  : 	}
; 812  : 
; 813  : 	judy_radix (judy, newradix, base, start, slot, keysize - 1, (uchar)key, depth);

  0009c	8b 4d 18	 mov	 ecx, DWORD PTR _depth$[ebp]
  0009f	51		 push	 ecx
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _judy$[ebp]
  000a3	57		 push	 edi
  000a4	8d 78 ff	 lea	 edi, DWORD PTR [eax-1]
  000a7	8b 45 fc	 mov	 eax, DWORD PTR _start$[ebp]
  000aa	50		 push	 eax
  000ab	56		 push	 esi
  000ac	51		 push	 ecx
  000ad	8b c3		 mov	 eax, ebx
  000af	e8 00 00 00 00	 call	 ?judy_radix@@YAXPAUJudy@@PAIPAEHHHEI@Z ; judy_radix

; 814  : 	judy_free (judy, (void **)base, JUDY_max);

  000b4	8b 45 08	 mov	 eax, DWORD PTR _judy$[ebp]
  000b7	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
  000bd	89 16		 mov	 DWORD PTR [esi], edx
  000bf	5f		 pop	 edi
  000c0	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 815  : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?judy_splitnode@@YAXPAUJudy@@PAIIII@Z ENDP		; judy_splitnode
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.c
_TEXT	ENDS
;	COMDAT ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z
_TEXT	SEGMENT
_split$69032 = -12					; size = 8
_count$193278 = -4					; size = 4
?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z PROC	; hashlin_grow_step, COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 119  : 	/* grow if more than 50% full */
; 120  : 	if (hashlin->state != TOMMY_HASHLIN_STATE_GROW
; 121  : 		&& hashlin->count > hashlin->bucket_max / 2
; 122  : 	) {

  00003	a1 9c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156
  00008	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 90 00 00
	00		 je	 $LN28@hashlin_gr
  00014	8b 15 84 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0001a	8b ca		 mov	 ecx, edx
  0001c	d1 e9		 shr	 ecx, 1
  0001e	39 0d a0 00 00
	00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, ecx
  00024	0f 86 71 01 00
	00		 jbe	 $LN6@hashlin_gr

; 123  : 		/* if we are stable, setup a new grow state */
; 124  : 		/* otherwise continue with the already setup shrink one */
; 125  : 		/* but in backward direction */
; 126  : 		if (hashlin->state == TOMMY_HASHLIN_STATE_STABLE) {

  0002a	85 c0		 test	 eax, eax
  0002c	75 65		 jne	 SHORT $LN27@hashlin_gr

; 127  : 			/* set the lower size */
; 128  : 			hashlin->low_max = hashlin->bucket_max;
; 129  : 			hashlin->low_mask = hashlin->bucket_mask;

  0002e	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136

; 130  : 
; 131  : 			/* grow the hash size and allocate */
; 132  : 			++hashlin->bucket_bit;

  00033	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128
  00039	a3 94 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148, eax
  0003e	41		 inc	 ecx

; 133  : 			hashlin->bucket_max = 1 << hashlin->bucket_bit;

  0003f	b8 01 00 00 00	 mov	 eax, 1
  00044	d3 e0		 shl	 eax, cl
  00046	89 0d 80 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, ecx

; 134  : 			hashlin->bucket_mask = hashlin->bucket_max - 1;
; 135  : 			hashlin->bucket[hashlin->bucket_mac] = tommy_cast(tommy_hashlin_node**, tommy_malloc(hashlin->low_max * sizeof(tommy_hashlin_node*)));

  0004c	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*4]
  00053	51		 push	 ecx
  00054	a3 84 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, eax
  00059	48		 dec	 eax
  0005a	89 15 90 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144, edx
  00060	a3 88 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, eax
  00065	e8 00 00 00 00	 call	 _malloc
  0006a	8b 15 8c 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  00070	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[edx*4], eax

; 136  : 			++hashlin->bucket_mac;

  00077	ff 05 8c 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  0007d	83 c4 04	 add	 esp, 4

; 137  : 
; 138  : 			/* start from the beginning going forward */
; 139  : 			hashlin->split = 0;

  00080	33 c0		 xor	 eax, eax
  00082	a3 98 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, eax

; 140  : 		}
; 141  : 
; 142  : 		/* grow state */
; 143  : 		hashlin->state = TOMMY_HASHLIN_STATE_GROW;

  00087	c7 05 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 1
  00091	eb 16		 jmp	 SHORT $LN26@hashlin_gr
$LN27@hashlin_gr:

; 137  : 
; 138  : 			/* start from the beginning going forward */
; 139  : 			hashlin->split = 0;

  00093	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 140  : 		}
; 141  : 
; 142  : 		/* grow state */
; 143  : 		hashlin->state = TOMMY_HASHLIN_STATE_GROW;

  00098	c7 05 9c 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 1
  000a2	eb 05		 jmp	 SHORT $LN26@hashlin_gr
$LN28@hashlin_gr:
  000a4	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN26@hashlin_gr:

; 144  : 	}
; 145  : 
; 146  : 	/* if we are growing */
; 147  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_GROW) {
; 148  : 		/* compute the split target required to finish the reallocation before the next resize */
; 149  : 		unsigned split_target = 2 * hashlin->count;
; 150  : 
; 151  : 		/* reallocate buckets until the split target */
; 152  : 		while (hashlin->split + hashlin->low_max < split_target) {

  000a9	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  000af	57		 push	 edi
  000b0	8b 3d a0 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  000b6	03 ff		 add	 edi, edi
  000b8	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  000bb	3b d7		 cmp	 edx, edi
  000bd	0f 83 d7 00 00
	00		 jae	 $LN30@hashlin_gr
  000c3	53		 push	 ebx
  000c4	56		 push	 esi
$LL7@hashlin_gr:

; 153  : 			tommy_hashlin_node** split[2];
; 154  : 			tommy_hashlin_node* j;
; 155  : 			unsigned mask;
; 156  : 
; 157  : 			/* get the low bucket */
; 158  : 			split[0] = tommy_hashlin_pos(hashlin, hashlin->split);

  000c5	83 f8 40	 cmp	 eax, 64			; 00000040H
  000c8	73 0b		 jae	 SHORT $LN13@hashlin_gr
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  000d0	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  000d3	eb 1e		 jmp	 SHORT $LN14@hashlin_gr
$LN13@hashlin_gr:
  000d5	0f bd d0	 bsr	 edx, eax
  000d8	89 55 fc	 mov	 DWORD PTR _count$193278[ebp], edx
  000db	8b 4d fc	 mov	 ecx, DWORD PTR _count$193278[ebp]
  000de	ba 01 00 00 00	 mov	 edx, 1
  000e3	d3 e2		 shl	 edx, cl
  000e5	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  000ec	8b f0		 mov	 esi, eax
  000ee	2b f2		 sub	 esi, edx
  000f0	8d 0c b1	 lea	 ecx, DWORD PTR [ecx+esi*4]
$LN14@hashlin_gr:

; 159  : 
; 160  : 			/* get the high bucket */
; 161  : 			/* it's always in the second half, so we can index it directly */
; 162  : 			/* without calling tommy_hashlin_pos() */
; 163  : 			split[1] = &hashlin->bucket[hashlin->bucket_mac-1][hashlin->split];

  000f3	8b 15 8c 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  000f9	8b 14 95 fc ff
	ff ff		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[edx*4-4]
  00100	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]

; 164  : 
; 165  : 			/* save the low bucket */
; 166  : 			j = *split[0];

  00103	8b 01		 mov	 eax, DWORD PTR [ecx]

; 167  : 
; 168  : 			/* reinitialize the buckets */
; 169  : 			*split[0] = 0;

  00105	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0010b	89 55 f8	 mov	 DWORD PTR _split$69032[ebp+4], edx

; 170  : 			*split[1] = 0;

  0010e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 171  : 
; 172  : 			/* compute the bit to identify the bucket */
; 173  : 			mask = hashlin->bucket_mask & ~hashlin->low_mask;

  00114	8b 15 94 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  0011a	f7 d2		 not	 edx
  0011c	23 15 88 00 00
	00		 and	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00122	89 4d f4	 mov	 DWORD PTR _split$69032[ebp], ecx

; 174  : 
; 175  : 			/* flush the bucket */
; 176  : 			while (j) {

  00125	85 c0		 test	 eax, eax
  00127	74 3e		 je	 SHORT $LN4@hashlin_gr
  00129	8d a4 24 00 00
	00 00		 npad	 7
$LL5@hashlin_gr:

; 177  : 				tommy_hashlin_node* j_next = j->next;
; 178  : 				unsigned index = (j->key & mask) != 0;

  00130	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00133	8b 30		 mov	 esi, DWORD PTR [eax]
  00135	23 ca		 and	 ecx, edx
  00137	f7 d9		 neg	 ecx
  00139	1b c9		 sbb	 ecx, ecx
  0013b	f7 d9		 neg	 ecx

; 179  : 				if (*split[index])

  0013d	8b 4c 8d f4	 mov	 ecx, DWORD PTR _split$69032[ebp+ecx*4]
  00141	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00144	74 10		 je	 SHORT $LN3@hashlin_gr

; 180  : 					tommy_list_insert_tail_not_empty(*split[index], j);

  00146	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00148	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  0014b	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0014e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00151	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 181  : 				else

  00154	eb 03		 jmp	 SHORT $LN33@hashlin_gr
$LN3@hashlin_gr:

; 182  : 					tommy_list_insert_first(split[index], j);

  00156	89 40 04	 mov	 DWORD PTR [eax+4], eax
$LN33@hashlin_gr:
  00159	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0015f	89 01		 mov	 DWORD PTR [ecx], eax

; 183  : 				j = j_next;

  00161	8b c6		 mov	 eax, esi
  00163	85 f6		 test	 esi, esi
  00165	75 c9		 jne	 SHORT $LL5@hashlin_gr
$LN4@hashlin_gr:

; 184  : 			}
; 185  : 
; 186  : 			/* go forward */
; 187  : 			++hashlin->split;

  00167	a1 98 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 188  : 
; 189  : 			/* if we have finished, change the state */
; 190  : 			if (hashlin->split == hashlin->low_max) {

  0016c	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  00172	40		 inc	 eax
  00173	a3 98 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, eax
  00178	3b c1		 cmp	 eax, ecx
  0017a	74 12		 je	 SHORT $LN24@hashlin_gr

; 144  : 	}
; 145  : 
; 146  : 	/* if we are growing */
; 147  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_GROW) {
; 148  : 		/* compute the split target required to finish the reallocation before the next resize */
; 149  : 		unsigned split_target = 2 * hashlin->count;
; 150  : 
; 151  : 		/* reallocate buckets until the split target */
; 152  : 		while (hashlin->split + hashlin->low_max < split_target) {

  0017c	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  0017f	3b d7		 cmp	 edx, edi
  00181	0f 82 3e ff ff
	ff		 jb	 $LL7@hashlin_gr
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx
  00189	5f		 pop	 edi

; 192  : 				break;
; 193  : 			}
; 194  : 		}
; 195  : 	}
; 196  : }

  0018a	8b e5		 mov	 esp, ebp
  0018c	5d		 pop	 ebp
  0018d	c3		 ret	 0
$LN24@hashlin_gr:
  0018e	5e		 pop	 esi

; 191  : 				hashlin->state = TOMMY_HASHLIN_STATE_STABLE;

  0018f	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00199	5b		 pop	 ebx
$LN30@hashlin_gr:
  0019a	5f		 pop	 edi
$LN6@hashlin_gr:

; 192  : 				break;
; 193  : 			}
; 194  : 		}
; 195  : 	}
; 196  : }

  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ENDP	; hashlin_grow_step
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z
_TEXT	SEGMENT
_count$193328 = -4					; size = 4
_count$193314 = -4					; size = 4
?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z PROC ; tommy_hashlin_bucket_ptr, COMDAT
; _hash$ = ecx

; 92   : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 93   : 	unsigned pos;
; 94   : 
; 95   : 	/* if we are reallocating */
; 96   : 	if (hashlin->state != TOMMY_HASHLIN_STATE_STABLE) {

  00004	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0000b	74 29		 je	 SHORT $LN1@tommy_hash@6

; 97   : 		/* compute the old position */
; 98   : 		pos = hash & hashlin->low_mask;

  0000d	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00012	23 c1		 and	 eax, ecx

; 99   : 
; 100  : 		/* if we have not reallocated this position yet */ 
; 101  : 		if (pos >= hashlin->split) {

  00014	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  0001a	72 1a		 jb	 SHORT $LN1@tommy_hash@6

; 102  : 
; 103  : 			/* use it as it was before */
; 104  : 			return tommy_hashlin_pos(hashlin, pos);

  0001c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0001f	73 0d		 jae	 SHORT $LN5@tommy_hash@6
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A

; 110  : 
; 111  : 	return tommy_hashlin_pos(hashlin, pos);

  00027	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 112  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0

; 102  : 
; 103  : 			/* use it as it was before */
; 104  : 			return tommy_hashlin_pos(hashlin, pos);

$LN5@tommy_hash@6:
  0002e	0f bd d0	 bsr	 edx, eax
  00031	89 55 fc	 mov	 DWORD PTR _count$193314[ebp], edx
  00034	eb 1f		 jmp	 SHORT $LN16@tommy_hash@6
$LN1@tommy_hash@6:

; 105  : 		}
; 106  : 	}
; 107  : 
; 108  : 	/* otherwise operates normally */
; 109  : 	pos = hash & hashlin->bucket_mask;

  00036	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  0003b	23 c1		 and	 eax, ecx

; 110  : 
; 111  : 	return tommy_hashlin_pos(hashlin, pos);

  0003d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00040	73 0d		 jae	 SHORT $LN10@tommy_hash@6
  00042	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00048	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 112  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0

; 110  : 
; 111  : 	return tommy_hashlin_pos(hashlin, pos);

$LN10@tommy_hash@6:
  0004f	0f bd c8	 bsr	 ecx, eax
  00052	89 4d fc	 mov	 DWORD PTR _count$193328[ebp], ecx
$LN16@tommy_hash@6:
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _count$193328[ebp]
  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	d3 e2		 shl	 edx, cl
  0005f	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00066	2b c2		 sub	 eax, edx
  00068	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 112  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ENDP ; tommy_hashlin_bucket_ptr
_TEXT	ENDS
PUBLIC	_tommy_hashtable_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashtbl.c
;	COMDAT _tommy_hashtable_remove
_TEXT	SEGMENT
_tommy_hashtable_remove PROC				; COMDAT
; _cmp_arg$ = eax
; _hash$ = ecx

; 81   : 	unsigned pos = hash & hashtable->bucket_mask;
; 82   : 	tommy_hashtable_node* i = hashtable->bucket[pos];

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  0000f	23 c1		 and	 eax, ecx
  00011	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	57		 push	 edi

; 83   : 
; 84   : 	while (i) {

  00017	85 c0		 test	 eax, eax
  00019	74 1a		 je	 SHORT $LN2@tommy_hash@7
  0001b	eb 03 8d 49 00	 npad	 5
$LL3@tommy_hash@7:

; 85   : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 86   : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00020	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00023	75 0a		 jne	 SHORT $LN1@tommy_hash@7
  00025	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  00028	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0002a	3b 5f 10	 cmp	 ebx, DWORD PTR [edi+16]
  0002d	74 0c		 je	 SHORT $LN18@tommy_hash@7
$LN1@tommy_hash@7:

; 92   : 		}
; 93   : 		/* we assume that i->next is still valid also after removing */
; 94   : 		i = i->next;

  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	85 c0		 test	 eax, eax
  00033	75 eb		 jne	 SHORT $LL3@tommy_hash@7
$LN2@tommy_hash@7:
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi

; 95   : 	}
; 96   : 
; 97   : 	return 0;

  00037	33 c0		 xor	 eax, eax
  00039	5b		 pop	 ebx

; 98   : }

  0003a	c3		 ret	 0
$LN18@tommy_hash@7:

; 87   : 			tommy_list_remove_existing(&hashtable->bucket[pos], i);

  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b 32		 mov	 esi, DWORD PTR [edx]
  0003f	85 c9		 test	 ecx, ecx
  00041	74 08		 je	 SHORT $LN12@tommy_hash@7
  00043	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00046	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00049	eb 06		 jmp	 SHORT $LN11@tommy_hash@7
$LN12@tommy_hash@7:
  0004b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN11@tommy_hash@7:
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	3b f0		 cmp	 esi, eax
  00055	74 03		 je	 SHORT $LN22@tommy_hash@7
  00057	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
$LN22@tommy_hash@7:
  0005a	5f		 pop	 edi
  0005b	89 0a		 mov	 DWORD PTR [edx], ecx

; 88   : 
; 89   : 			--hashtable->count;

  0005d	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 90   : 
; 91   : 			return i->data;

  00063	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx

; 98   : }

  00068	c3		 ret	 0
_tommy_hashtable_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashtable_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashtable_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashtable_insert PROC				; COMDAT
; _node$ = eax
; _hash$ = esi

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 59   : 	unsigned pos = hash & hashtable->bucket_mask;

  00003	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8

; 60   : 
; 61   : 	tommy_list_insert_tail(&hashtable->bucket[pos], node, data);

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0000f	23 ce		 and	 ecx, esi
  00011	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	85 c9		 test	 ecx, ecx
  00018	74 25		 je	 SHORT $LN4@tommy_hash@8
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00020	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002f	89 01		 mov	 DWORD PTR [ecx], eax
  00031	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 62   : 
; 63   : 	node->key = hash;

  00034	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 64   : 
; 65   : 	++hashtable->count;

  00037	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 66   : }

  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0

; 60   : 
; 61   : 	tommy_list_insert_tail(&hashtable->bucket[pos], node, data);

$LN4@tommy_hash@8:
  0003f	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00048	89 02		 mov	 DWORD PTR [edx], eax
  0004a	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 62   : 
; 63   : 	node->key = hash;

  00050	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 64   : 
; 65   : 	++hashtable->count;

  00053	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12

; 66   : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_tommy_hashtable_insert ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrieinp.c
;	COMDAT _tommy_trie_inplace_remove
_TEXT	SEGMENT
_tommy_trie_inplace_remove PROC				; COMDAT
; _key$ = edx

; 219  : 	tommy_trie_inplace_node* ret;
; 220  : 	tommy_trie_inplace_node** let_ptr;
; 221  : 
; 222  : 	let_ptr = &trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00000	8b c2		 mov	 eax, edx
  00002	c1 e8 1a	 shr	 eax, 26			; 0000001aH
  00005	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[eax*4]

; 223  : 
; 224  : 	ret = trie_inplace_bucket_remove(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, 0, key);

  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  00012	83 c4 04	 add	 esp, 4

; 225  : 
; 226  : 	if (!ret)

  00015	85 c0		 test	 eax, eax
  00017	75 01		 jne	 SHORT $LN1@tommy_trie@6

; 232  : }

  00019	c3		 ret	 0
$LN1@tommy_trie@6:

; 227  : 		return 0;
; 228  : 
; 229  : 	--trie_inplace->count;

  0001a	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256

; 230  : 
; 231  : 	return ret->data;

  00020	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 232  : }

  00023	c3		 ret	 0
_tommy_trie_inplace_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_trie_inplace_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_inplace_insert
_TEXT	SEGMENT
_tommy_trie_inplace_insert PROC				; COMDAT
; _node$ = eax
; _data$ = ecx
; _key$ = edi

; 131  : 	tommy_trie_inplace_node** let_ptr;
; 132  : 	unsigned i;
; 133  : 
; 134  : 	node->data = data;

  00000	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00003	53		 push	 ebx

; 135  : 	node->key = key;
; 136  : 	/* clear the child pointers */
; 137  : 	for(i=0;i<TOMMY_TRIE_INPLACE_TREE_MAX;++i)
; 138  : 		node->map[i] = 0;

  00004	33 db		 xor	 ebx, ebx
  00006	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 139  : 
; 140  : 	let_ptr = &trie_inplace->bucket[key >> TOMMY_TRIE_INPLACE_BUCKET_SHIFT];

  00009	8b d7		 mov	 edx, edi
  0000b	c1 ea 1a	 shr	 edx, 26			; 0000001aH
  0000e	56		 push	 esi
  0000f	8d 34 95 00 00
	00 00		 lea	 esi, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[edx*4]
  00016	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  00019	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  0001c	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  0001f	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 141  : 
; 142  : 	trie_inplace_bucket_insert(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, node, key);

  00022	8b 16		 mov	 edx, DWORD PTR [esi]
  00024	8d 4b 1a	 lea	 ecx, DWORD PTR [ebx+26]
  00027	3b d3		 cmp	 edx, ebx
  00029	74 1e		 je	 SHORT $LN25@tommy_trie@7
  0002b	eb 03 8d 49 00	 npad	 5
$LL9@tommy_trie@7:
  00030	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  00033	74 24		 je	 SHORT $LN7@tommy_trie@7
  00035	8b f7		 mov	 esi, edi
  00037	d3 ee		 shr	 esi, cl
  00039	83 e9 02	 sub	 ecx, 2
  0003c	83 e6 03	 and	 esi, 3
  0003f	8d 74 b2 10	 lea	 esi, DWORD PTR [edx+esi*4+16]
  00043	8b 16		 mov	 edx, DWORD PTR [esi]
  00045	3b d3		 cmp	 edx, ebx
  00047	75 e7		 jne	 SHORT $LL9@tommy_trie@7
$LN25@tommy_trie@7:
  00049	89 18		 mov	 DWORD PTR [eax], ebx
  0004b	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0004e	89 06		 mov	 DWORD PTR [esi], eax

; 143  : 
; 144  : 	++trie_inplace->count;

  00050	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx

; 145  : }

  00058	c3		 ret	 0

; 141  : 
; 142  : 	trie_inplace_bucket_insert(TOMMY_TRIE_INPLACE_BUCKET_SHIFT, let_ptr, node, key);

$LN7@tommy_trie@7:
  00059	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0005c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0005f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00062	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00065	89 18		 mov	 DWORD PTR [eax], ebx
  00067	5e		 pop	 esi
  00068	89 02		 mov	 DWORD PTR [edx], eax

; 143  : 
; 144  : 	++trie_inplace->count;

  0006a	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00070	5b		 pop	 ebx

; 145  : }

  00071	c3		 ret	 0
_tommy_trie_inplace_insert ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrie.c
_TEXT	ENDS
;	COMDAT ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z
_TEXT	SEGMENT
_let_back$ = -40					; size = 32
tv239 = -8						; size = 4
_count$ = -4						; size = 4
?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z PROC ; trie_bucket_remove_existing, COMDAT
; _let_ptr$ = edx
; _key$ = eax

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax

; 169  : 	tommy_trie_node* node;
; 170  : 	tommy_trie_tree* tree;
; 171  : 	void* ptr;
; 172  : 	tommy_trie_node** let_back[TOMMY_TRIE_LEVEL_MAX+1];
; 173  : 	unsigned level;
; 174  : 	unsigned i;
; 175  : 	unsigned count;
; 176  : 	unsigned last;
; 177  : 
; 178  : 	level = 0;
; 179  : recurse:
; 180  : 	ptr = *let_ptr;

  0000a	8b 02		 mov	 eax, DWORD PTR [edx]
  0000c	33 f6		 xor	 esi, esi
  0000e	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH

; 181  : 
; 182  : 	if (!ptr)

  00013	85 c0		 test	 eax, eax
  00015	74 1d		 je	 SHORT $LN29@trie_bucke@2
$recurse$68559:

; 184  : 
; 185  : 	if (trie_get_type(ptr) == TOMMY_TRIE_TYPE_TREE) {

  00017	a8 01		 test	 al, 1
  00019	74 21		 je	 SHORT $LN34@trie_bucke@2

; 186  : 		tree = trie_get_tree(ptr);
; 187  : 
; 188  : 		/* save the path */
; 189  : 		let_back[level++] = let_ptr;

  0001b	89 54 b5 d8	 mov	 DWORD PTR _let_back$[ebp+esi*4], edx

; 190  : 
; 191  : 		/* go down one level */
; 192  : 		let_ptr = &tree->map[(key >> shift) & TOMMY_TRIE_TREE_MASK];

  0001f	8b d7		 mov	 edx, edi
  00021	d3 ea		 shr	 edx, cl
  00023	46		 inc	 esi

; 193  : 		shift -= TOMMY_TRIE_TREE_BIT;

  00024	83 e9 04	 sub	 ecx, 4
  00027	83 e2 0f	 and	 edx, 15			; 0000000fH
  0002a	8d 54 90 ff	 lea	 edx, DWORD PTR [eax+edx*4-1]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	85 c0		 test	 eax, eax
  00032	75 e3		 jne	 SHORT $recurse$68559
$LN29@trie_bucke@2:
  00034	5f		 pop	 edi

; 183  : 		return 0;

  00035	33 c0		 xor	 eax, eax
  00037	5e		 pop	 esi

; 247  : 		goto reduce;
; 248  : 
; 249  : 	return remove;
; 250  : }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
$LN34@trie_bucke@2:

; 194  : 
; 195  : 		goto recurse;
; 196  : 	}
; 197  : 
; 198  : 	node = tommy_cast(tommy_trie_node*, ptr);
; 199  : 
; 200  : 	/* if the node to remove is not specified */
; 201  : 	if (!remove) {
; 202  : 		/* remove the first */
; 203  : 		remove = node;
; 204  : 
; 205  : 		/* check if it's really the element to remove */
; 206  : 		if (remove->key != key)

  0003c	39 78 0c	 cmp	 DWORD PTR [eax+12], edi

; 207  : 			return 0;

  0003f	75 f3		 jne	 SHORT $LN29@trie_bucke@2

; 208  : 	}
; 209  : 
; 210  : 	tommy_list_remove_existing(let_ptr, remove);

  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 3a		 mov	 edi, DWORD PTR [edx]
  00045	53		 push	 ebx
  00046	85 c9		 test	 ecx, ecx
  00048	74 08		 je	 SHORT $LN19@trie_bucke@2
  0004a	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0004d	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  00050	eb 06		 jmp	 SHORT $LN18@trie_bucke@2
$LN19@trie_bucke@2:
  00052	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00055	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN18@trie_bucke@2:
  00058	3b f8		 cmp	 edi, eax
  0005a	75 06		 jne	 SHORT $LN17@trie_bucke@2
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	89 0a		 mov	 DWORD PTR [edx], ecx
  00060	eb 07		 jmp	 SHORT $LN16@trie_bucke@2
$LN17@trie_bucke@2:
  00062	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00065	8b 38		 mov	 edi, DWORD PTR [eax]
  00067	89 39		 mov	 DWORD PTR [ecx], edi
$LN16@trie_bucke@2:

; 211  : 
; 212  : 	/* if the list is not empty, try to reduce */
; 213  : 	if (*let_ptr || !level)

  00069	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0006c	75 5c		 jne	 SHORT $LN36@trie_bucke@2
  0006e	85 f6		 test	 esi, esi
  00070	74 58		 je	 SHORT $LN36@trie_bucke@2
$reduce$68579:

; 214  : 		return remove;
; 215  : 
; 216  : reduce:
; 217  : 	/* go one level up */
; 218  : 	let_ptr = let_back[--level];

  00072	8b 4c b5 d4	 mov	 ecx, DWORD PTR _let_back$[ebp+esi*4-4]

; 219  : 
; 220  : 	tree = trie_get_tree(*let_ptr);

  00076	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00078	4e		 dec	 esi
  00079	49		 dec	 ecx

; 221  : 
; 222  : 	/* check if there is only one child node */
; 223  : 	count = 0;
; 224  : 	last = 0;

  0007a	33 ff		 xor	 edi, edi
  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0

; 225  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {

  00083	33 d2		 xor	 edx, edx
$LL7@trie_bucke@2:

; 226  : 		if (tree->map[i]) {

  00085	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]
  00088	89 5d f8	 mov	 DWORD PTR tv239[ebp], ebx
  0008b	85 db		 test	 ebx, ebx
  0008d	74 13		 je	 SHORT $LN6@trie_bucke@2

; 227  : 			/* if we have a sub tree, we cannot reduce */
; 228  : 			if (trie_get_type(tree->map[i]) != TOMMY_TRIE_TYPE_NODE)

  0008f	f6 c3 01	 test	 bl, 1
  00092	75 36		 jne	 SHORT $LN36@trie_bucke@2

; 229  : 				return remove;
; 230  : 			/* if more than one node, we cannot reduce */
; 231  : 			if (++count > 1)

  00094	8b 7d fc	 mov	 edi, DWORD PTR _count$[ebp]
  00097	47		 inc	 edi
  00098	89 7d fc	 mov	 DWORD PTR _count$[ebp], edi
  0009b	83 ff 01	 cmp	 edi, 1
  0009e	77 2a		 ja	 SHORT $LN36@trie_bucke@2

; 232  : 				return remove;
; 233  : 			last = i;

  000a0	8b fa		 mov	 edi, edx
$LN6@trie_bucke@2:

; 225  : 	for(i=0;i<TOMMY_TRIE_TREE_MAX;++i) {

  000a2	42		 inc	 edx
  000a3	83 fa 10	 cmp	 edx, 16			; 00000010H
  000a6	72 dd		 jb	 SHORT $LL7@trie_bucke@2

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	/* here count is never 0, as we cannot have a tree with only one sub node */
; 238  : 	assert(count == 1);
; 239  : 
; 240  : 	*let_ptr = tree->map[last];

  000a8	8b 3c b9	 mov	 edi, DWORD PTR [ecx+edi*4]
  000ab	8b 54 b5 d8	 mov	 edx, DWORD PTR _let_back$[ebp+esi*4]
  000af	89 3a		 mov	 DWORD PTR [edx], edi

; 241  : 
; 242  : 	tommy_allocator_free(trie->alloc, tree);

  000b1	8b 15 48 00 00
	00		 mov	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A+72
  000b7	8b 3a		 mov	 edi, DWORD PTR [edx]
  000b9	89 39		 mov	 DWORD PTR [ecx], edi
  000bb	ff 4a 10	 dec	 DWORD PTR [edx+16]
  000be	89 0a		 mov	 DWORD PTR [edx], ecx

; 243  : 	--trie->node_count;

  000c0	ff 0d 44 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+68

; 244  : 
; 245  : 	/* repeat until more level */
; 246  : 	if (level)

  000c6	85 f6		 test	 esi, esi
  000c8	75 a8		 jne	 SHORT $reduce$68579
$LN36@trie_bucke@2:
  000ca	5b		 pop	 ebx
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 247  : 		goto reduce;
; 248  : 
; 249  : 	return remove;
; 250  : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ENDP ; trie_bucket_remove_existing
_TEXT	ENDS
PUBLIC	_tommy_trie_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_trie_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_trie_insert PROC					; COMDAT
; _node$ = ecx
; _key$ = eax

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 155  : 	tommy_trie_node** let_ptr;
; 156  : 
; 157  : 	node->data = data;

  00003	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]

; 158  : 	node->key = key;
; 159  : 
; 160  : 	let_ptr = &trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];
; 161  : 
; 162  : 	trie_bucket_insert(trie, TOMMY_TRIE_BUCKET_SHIFT, let_ptr, node, key);

  00006	50		 push	 eax
  00007	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0000a	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  0000d	51		 push	 ecx
  0000e	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  00015	50		 push	 eax
  00016	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00019	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 
; 164  : 	++trie->count;

  00021	ff 05 40 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64

; 165  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
_tommy_trie_insert ENDP
_TEXT	ENDS
PUBLIC	_tommy_list_concat
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommylist.c
;	COMDAT _tommy_list_concat
_TEXT	SEGMENT
_tommy_list_concat PROC					; COMDAT
; _first$ = edx
; _second$ = eax

; 33   : 	tommy_node* first_head;
; 34   : 	tommy_node* first_tail;
; 35   : 	tommy_node* second_head;
; 36   : 
; 37   : 	if (tommy_list_empty(second)) {

  00000	8b 00		 mov	 eax, DWORD PTR [eax]
  00002	85 c0		 test	 eax, eax
  00004	74 16		 je	 SHORT $LN3@tommy_list@4

; 38   : 		return;
; 39   : 	}
; 40   : 
; 41   : 	if (tommy_list_empty(first)) {

  00006	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00008	85 c9		 test	 ecx, ecx

; 42   : 		*first = *second;
; 43   : 		return;

  0000a	74 0e		 je	 SHORT $LN22@tommy_list@4

; 44   : 	}
; 45   : 
; 46   : 	first_head = tommy_list_head(first);
; 47   : 	second_head = tommy_list_head(second);
; 48   : 	first_tail = tommy_list_tail(first);

  0000c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000f	56		 push	 esi

; 49   : 
; 50   : 	/* set the "circular" prev list */
; 51   : 	first_head->prev = second_head->prev;

  00010	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00013	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 52   : 	second_head->prev = first_tail;

  00016	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00019	5e		 pop	 esi
$LN22@tommy_list@4:

; 53   : 
; 54   : 	/* set the "0 terminated" next list */
; 55   : 	first_tail->next = second_head;

  0001a	89 02		 mov	 DWORD PTR [edx], eax
$LN3@tommy_list@4:

; 56   : }

  0001c	c3		 ret	 0
_tommy_list_concat ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z
_TEXT	SEGMENT
__Tmp$193831 = 8					; size = 4
__Tmp$193820 = 8					; size = 4
_src$ = 8						; size = 4
?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge, COMDAT
; _this$ = ecx

; 1592 : void btree_node<P>::merge(btree_node *src) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1593 :   assert(parent() == src->parent());
; 1594 :   assert(position() + 1 == src->position());
; 1595 : 
; 1596 :   // Move the delimiting value to the left node.
; 1597 :   value_init(count());

  00003	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00007	53		 push	 ebx
  00008	8b 5d 08	 mov	 ebx, DWORD PTR _src$[ebp]
  0000b	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	85 c0		 test	 eax, eax
  00013	74 0d		 je	 SHORT $LN14@merge
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0001b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN14@merge:

; 1598 :   value_swap(count(), parent(), position());

  00022	0f b6 51 01	 movzx	 edx, BYTE PTR [ecx+1]
  00026	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00029	8b 7c d0 08	 mov	 edi, DWORD PTR [eax+edx*8+8]
  0002d	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  00031	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  00035	8b 74 d1 08	 mov	 esi, DWORD PTR [ecx+edx*8+8]
  00039	8d 54 d1 08	 lea	 edx, DWORD PTR [ecx+edx*8+8]
  0003d	89 3a		 mov	 DWORD PTR [edx], edi
  0003f	89 30		 mov	 DWORD PTR [eax], esi
  00041	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00044	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00047	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  0004a	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1599 : 
; 1600 :   // Move the values from the right to the left node.
; 1601 :   for (int i = 0; i < src->count(); ++i) {

  0004d	33 f6		 xor	 esi, esi
  0004f	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  00053	76 5e		 jbe	 SHORT $LN5@merge

; 1598 :   value_swap(count(), parent(), position());

  00055	8d 53 08	 lea	 edx, DWORD PTR [ebx+8]
  00058	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL132@merge:

; 1602 :     value_init(1 + count() + i);

  00060	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  00064	03 c6		 add	 eax, esi
  00066	8d 44 c1 10	 lea	 eax, DWORD PTR [ecx+eax*8+16]
  0006a	85 c0		 test	 eax, eax
  0006c	74 0d		 je	 SHORT $LN62@merge
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00074	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN62@merge:

; 1603 :     value_swap(1 + count() + i, src, i);

  0007b	0f b6 41 03	 movzx	 eax, BYTE PTR [ecx+3]
  0007f	03 c6		 add	 eax, esi
  00081	8b 7c c1 10	 mov	 edi, DWORD PTR [ecx+eax*8+16]
  00085	8d 44 c1 10	 lea	 eax, DWORD PTR [ecx+eax*8+16]
  00089	89 7d 08	 mov	 DWORD PTR __Tmp$193820[ebp], edi
  0008c	8b 3a		 mov	 edi, DWORD PTR [edx]
  0008e	89 38		 mov	 DWORD PTR [eax], edi
  00090	8b 7d 08	 mov	 edi, DWORD PTR __Tmp$193820[ebp]
  00093	89 3a		 mov	 DWORD PTR [edx], edi
  00095	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00098	89 7d 08	 mov	 DWORD PTR __Tmp$193831[ebp], edi
  0009b	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0009e	89 78 04	 mov	 DWORD PTR [eax+4], edi
  000a1	8b 45 08	 mov	 eax, DWORD PTR __Tmp$193831[ebp]
  000a4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  000a7	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  000ab	46		 inc	 esi
  000ac	83 c2 08	 add	 edx, 8
  000af	3b f0		 cmp	 esi, eax
  000b1	7c ad		 jl	 SHORT $LL132@merge
$LN5@merge:

; 1604 :     src->value_destroy(i);
; 1605 :   }
; 1606 : 
; 1607 :   if (!leaf()) {

  000b3	80 39 00	 cmp	 BYTE PTR [ecx], 0
  000b6	75 37		 jne	 SHORT $LN1@merge

; 1608 :     // Move the child pointers from the right to the left node.
; 1609 :     for (int i = 0; i <= src->count(); ++i) {

  000b8	33 f6		 xor	 esi, esi
  000ba	80 7b 03 00	 cmp	 BYTE PTR [ebx+3], 0
  000be	72 2f		 jb	 SHORT $LN1@merge
  000c0	8d bb 00 01 00
	00		 lea	 edi, DWORD PTR [ebx+256]
$LL3@merge:

; 1610 :       set_child(1 + count() + i, src->child(i));

  000c6	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  000ca	8b 07		 mov	 eax, DWORD PTR [edi]
  000cc	8d 54 32 01	 lea	 edx, DWORD PTR [edx+esi+1]
  000d0	89 84 91 00 01
	00 00		 mov	 DWORD PTR [ecx+edx*4+256], eax
  000d7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000da	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 1611 :       *src->mutable_child(i) = NULL;

  000dd	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  000e3	0f b6 43 03	 movzx	 eax, BYTE PTR [ebx+3]
  000e7	46		 inc	 esi
  000e8	83 c7 04	 add	 edi, 4
  000eb	3b f0		 cmp	 esi, eax
  000ed	7e d7		 jle	 SHORT $LL3@merge
$LN1@merge:

; 1612 :     }
; 1613 :   }
; 1614 : 
; 1615 :   // Fixup the counts on the src and dest nodes.
; 1616 :   set_count(1 + count() + src->count());

  000ef	8a 53 03	 mov	 dl, BYTE PTR [ebx+3]
  000f2	fe c2		 inc	 dl
  000f4	00 51 03	 add	 BYTE PTR [ecx+3], dl

; 1617 :   src->set_count(0);

  000f7	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0

; 1618 : 
; 1619 :   // Remove the value on the parent node.
; 1620 :   parent()->remove_value(position());

  000fb	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  000ff	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00102	e8 00 00 00 00	 call	 ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx

; 1621 : }

  0010a	5d		 pop	 ebp
  0010b	c2 04 00	 ret	 4
?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z
_TEXT	SEGMENT
$T193892 = -12						; size = 8
__Tmp$194083 = 8					; size = 4
__Tmp$194072 = 8					; size = 4
_dest$ = 8						; size = 4
?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z PROC ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split, COMDAT
; _this$ = edi
; _insert_position$ = eax

; 1551 : void btree_node<P>::split(btree_node *dest, int insert_position) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _dest$[ebp]
  0000a	56		 push	 esi

; 1552 :   assert(dest->count() == 0);
; 1553 : 
; 1554 :   // We bias the split based on the position being inserted. If we're
; 1555 :   // inserting at the beginning of the left node then bias the split to put
; 1556 :   // more values on the right node. If we're inserting at the end of the
; 1557 :   // right node then bias the split to put more values on the left node.
; 1558 :   if (insert_position == 0) {

  0000b	85 c0		 test	 eax, eax
  0000d	75 0a		 jne	 SHORT $LN11@split

; 1559 :     dest->set_count(count() - 1);

  0000f	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00012	fe c8		 dec	 al
  00014	88 43 03	 mov	 BYTE PTR [ebx+3], al

; 1560 :   } else if (insert_position == max_count()) {

  00017	eb 16		 jmp	 SHORT $LN24@split
$LN11@split:
  00019	0f b6 4f 02	 movzx	 ecx, BYTE PTR [edi+2]
  0001d	3b c1		 cmp	 eax, ecx
  0001f	75 06		 jne	 SHORT $LN9@split

; 1561 :     dest->set_count(0);

  00021	c6 43 03 00	 mov	 BYTE PTR [ebx+3], 0

; 1562 :   } else {

  00025	eb 08		 jmp	 SHORT $LN24@split
$LN9@split:

; 1563 :     dest->set_count(count() / 2);

  00027	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  0002a	d0 ea		 shr	 dl, 1
  0002c	88 53 03	 mov	 BYTE PTR [ebx+3], dl
$LN24@split:

; 1564 :   }
; 1565 :   set_count(count() - dest->count());

  0002f	8a 43 03	 mov	 al, BYTE PTR [ebx+3]
  00032	28 47 03	 sub	 BYTE PTR [edi+3], al

; 1566 :   assert(count() >= 1);
; 1567 : 
; 1568 :   // Move values from the left sibling to the right sibling.
; 1569 :   for (int i = 0; i < dest->count(); ++i) {

  00035	33 d2		 xor	 edx, edx
  00037	38 53 03	 cmp	 BYTE PTR [ebx+3], dl
  0003a	76 4c		 jbe	 SHORT $LN5@split

; 1564 :   }
; 1565 :   set_count(count() - dest->count());

  0003c	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
$LN7@split:

; 1570 :     dest->value_init(i);

  0003f	85 c0		 test	 eax, eax
  00041	74 0d		 je	 SHORT $LN36@split
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00049	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN36@split:

; 1571 :     value_swap(count() + i, dest, i);

  00050	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00054	03 ca		 add	 ecx, edx
  00056	8b 74 cf 08	 mov	 esi, DWORD PTR [edi+ecx*8+8]
  0005a	8d 4c cf 08	 lea	 ecx, DWORD PTR [edi+ecx*8+8]
  0005e	89 75 08	 mov	 DWORD PTR __Tmp$194072[ebp], esi
  00061	8b 30		 mov	 esi, DWORD PTR [eax]
  00063	89 31		 mov	 DWORD PTR [ecx], esi
  00065	8b 75 08	 mov	 esi, DWORD PTR __Tmp$194072[ebp]
  00068	89 30		 mov	 DWORD PTR [eax], esi
  0006a	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0006d	89 75 08	 mov	 DWORD PTR __Tmp$194083[ebp], esi
  00070	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00073	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Tmp$194083[ebp]
  00079	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0007c	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00080	42		 inc	 edx
  00081	83 c0 08	 add	 eax, 8
  00084	3b d1		 cmp	 edx, ecx
  00086	7c b7		 jl	 SHORT $LN7@split
$LN5@split:

; 1572 :     value_destroy(count() + i);
; 1573 :   }
; 1574 : 
; 1575 :   // The split key is the largest value in the left sibling.
; 1576 :   set_count(count() - 1);
; 1577 :   parent()->insert_value(position(), value_type());

  00088	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  0008b	fe 4f 03	 dec	 BYTE PTR [edi+3]
  0008e	33 c0		 xor	 eax, eax
  00090	89 45 f4	 mov	 DWORD PTR $T193892[ebp], eax
  00093	89 45 f8	 mov	 DWORD PTR $T193892[ebp+4], eax
  00096	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0009a	8d 4d f4	 lea	 ecx, DWORD PTR $T193892[ebp]
  0009d	e8 00 00 00 00	 call	 ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value

; 1578 :   value_swap(count(), parent(), position());

  000a2	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  000a6	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  000aa	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ad	8b 74 d0 08	 mov	 esi, DWORD PTR [eax+edx*8+8]
  000b1	8d 44 d0 08	 lea	 eax, DWORD PTR [eax+edx*8+8]
  000b5	8b 54 cf 08	 mov	 edx, DWORD PTR [edi+ecx*8+8]
  000b9	89 74 cf 08	 mov	 DWORD PTR [edi+ecx*8+8], esi
  000bd	89 10		 mov	 DWORD PTR [eax], edx
  000bf	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000c2	8b 54 cf 0c	 mov	 edx, DWORD PTR [edi+ecx*8+12]
  000c6	8d 4c cf 08	 lea	 ecx, DWORD PTR [edi+ecx*8+8]
  000ca	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000cd	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1579 :   value_destroy(count());
; 1580 :   parent()->set_child(position() + 1, dest);

  000d0	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  000d4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000d7	40		 inc	 eax
  000d8	89 9c 81 00 01
	00 00		 mov	 DWORD PTR [ecx+eax*4+256], ebx
  000df	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  000e2	88 43 01	 mov	 BYTE PTR [ebx+1], al

; 1581 : 
; 1582 :   if (!leaf()) {

  000e5	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000e8	75 44		 jne	 SHORT $LN1@split

; 1583 :     for (int i = 0; i <= dest->count(); ++i) {

  000ea	33 c0		 xor	 eax, eax
  000ec	33 f6		 xor	 esi, esi
  000ee	38 43 03	 cmp	 BYTE PTR [ebx+3], al
  000f1	72 3b		 jb	 SHORT $LN1@split
  000f3	8d 93 00 01 00
	00		 lea	 edx, DWORD PTR [ebx+256]
  000f9	8d a4 24 00 00
	00 00		 npad	 7
$LL3@split:

; 1584 :       assert(child(count() + i + 1) != NULL);
; 1585 :       dest->set_child(i, child(count() + i + 1));

  00100	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00104	03 c8		 add	 ecx, eax
  00106	8b 8c 8f 04 01
	00 00		 mov	 ecx, DWORD PTR [edi+ecx*4+260]
  0010d	89 0a		 mov	 DWORD PTR [edx], ecx
  0010f	88 41 01	 mov	 BYTE PTR [ecx+1], al
  00112	89 59 04	 mov	 DWORD PTR [ecx+4], ebx

; 1586 :       *mutable_child(count() + i + 1) = NULL;

  00115	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00119	03 c8		 add	 ecx, eax
  0011b	89 b4 8f 04 01
	00 00		 mov	 DWORD PTR [edi+ecx*4+260], esi
  00122	0f b6 4b 03	 movzx	 ecx, BYTE PTR [ebx+3]
  00126	40		 inc	 eax
  00127	83 c2 04	 add	 edx, 4
  0012a	3b c1		 cmp	 eax, ecx
  0012c	7e d2		 jle	 SHORT $LL3@split
$LN1@split:

; 1587 :     }
; 1588 :   }
; 1589 : }

  0012e	5e		 pop	 esi
  0012f	5b		 pop	 ebx
  00130	8b e5		 mov	 esp, ebp
  00132	5d		 pop	 ebp
  00133	c2 04 00	 ret	 4
?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ENDP ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes, COMDAT
; _left$ = edi
; _right$ = esi

; 2096 : void btree<P>::merge_nodes(node_type *left, node_type *right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2097 :   left->merge(right);

  00003	56		 push	 esi
  00004	8b cf		 mov	 ecx, edi
  00006	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge

; 2098 :   if (right->leaf()) {

  0000b	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0000e	74 22		 je	 SHORT $LN3@merge_node

; 2099 :     if (rightmost() == right) {

  00010	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	85 c0		 test	 eax, eax
  00017	74 0d		 je	 SHORT $LN10@merge_node
  00019	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001c	75 08		 jne	 SHORT $LN10@merge_node
  0001e	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00024	eb 02		 jmp	 SHORT $LN22@merge_node
$LN10@merge_node:
  00026	8b c8		 mov	 ecx, eax
$LN22@merge_node:
  00028	3b ce		 cmp	 ecx, esi
  0002a	75 06		 jne	 SHORT $LN3@merge_node

; 2100 :       *mutable_rightmost() = left;

  0002c	89 b8 80 01 00
	00		 mov	 DWORD PTR [eax+384], edi
$LN3@merge_node:

; 2101 :     }
; 2102 :     delete_leaf_node(right);
; 2103 :   } else {
; 2104 :     delete_internal_node(right);

  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	83 c4 04	 add	 esp, 4

; 2105 :   }
; 2106 : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?merge_nodes@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@0@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge_nodes
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z
_TEXT	SEGMENT
$T194802 = -36						; size = 12
$T194718 = -36						; size = 12
$T194609 = -36						; size = 12
_parent_iter$162173 = -32				; size = 8
tv928 = -28						; size = 4
tv927 = -24						; size = 4
tv1350 = -20						; size = 4
_to_move$162166 = -20					; size = 4
$T194406 = -20						; size = 4
tv897 = -16						; size = 4
$T194407 = -16						; size = 4
_right$162164 = -12					; size = 4
_to_move$162151 = -12					; size = 4
_this$ = -8						; size = 4
$T194759 = 8						; size = 4
$T194666 = 8						; size = 4
$T194540 = 8						; size = 4
_parent$ = 8						; size = 4
_iter$ = 8						; size = 4
?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split, COMDAT
; _this$ = ecx

; 1987 : void btree<P>::rebalance_or_split(iterator *iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx

; 1988 :   node_type *&node = iter->node;
; 1989 :   int &insert_position = iter->position;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _iter$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx

; 1990 :   assert(node->count() == node->max_count());
; 1991 : 
; 1992 :   // First try to make room on the node by rebalancing.
; 1993 :   node_type *parent = node->parent();
; 1994 :   if (node != root()) {

  0000d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000f	57		 push	 edi
  00010	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00012	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00015	89 75 f8	 mov	 DWORD PTR _this$[ebp], esi
  00018	89 45 08	 mov	 DWORD PTR _parent$[ebp], eax
  0001b	3b f9		 cmp	 edi, ecx
  0001d	0f 84 65 01 00
	00		 je	 $LN19@rebalance_@3

; 1995 :     if (node->position() > 0) {

  00023	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00026	84 c9		 test	 cl, cl
  00028	0f 84 87 00 00
	00		 je	 $LN16@rebalance_@3

; 1996 :       // Try rebalancing with our left sibling.
; 1997 :       node_type *left = parent->child(node->position() - 1);

  0002e	0f b6 c9	 movzx	 ecx, cl
  00031	8b b4 88 fc 00
	00 00		 mov	 esi, DWORD PTR [eax+ecx*4+252]

; 1998 :       if (left->count() < left->max_count()) {

  00038	8a 4e 03	 mov	 cl, BYTE PTR [esi+3]
  0003b	3a 4e 02	 cmp	 cl, BYTE PTR [esi+2]
  0003e	73 72		 jae	 SHORT $LN239@rebalance_@3

; 1999 :         // We bias rebalancing based on the position being inserted. If we're
; 2000 :         // inserting at the end of the right node then we bias rebalancing to
; 2001 :         // fill up the left node.
; 2002 :         int to_move = (left->max_count() - left->count()) /
; 2003 :             (1 + (insert_position < left->max_count()));

  00040	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00044	0f b6 d1	 movzx	 edx, cl
  00047	33 c9		 xor	 ecx, ecx
  00049	39 43 04	 cmp	 DWORD PTR [ebx+4], eax
  0004c	89 55 f0	 mov	 DWORD PTR tv897[ebp], edx
  0004f	0f 9c c1	 setl	 cl
  00052	2b c2		 sub	 eax, edx
  00054	99		 cdq

; 2004 :         to_move = std::max(1, to_move);

  00055	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T194406[ebp], 1
  0005c	41		 inc	 ecx
  0005d	f7 f9		 idiv	 ecx
  0005f	89 45 f4	 mov	 DWORD PTR _to_move$162151[ebp], eax
  00062	83 f8 01	 cmp	 eax, 1
  00065	8d 45 f4	 lea	 eax, DWORD PTR _to_move$162151[ebp]
  00068	7f 03		 jg	 SHORT $LN45@rebalance_@3
  0006a	8d 45 ec	 lea	 eax, DWORD PTR $T194406[ebp]
$LN45@rebalance_@3:
  0006d	8b 10		 mov	 edx, DWORD PTR [eax]

; 2005 : 
; 2006 :         if (((insert_position - to_move) >= 0) ||
; 2007 :             ((left->count() + to_move) < left->max_count())) {

  0006f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00072	2b c2		 sub	 eax, edx
  00074	89 55 f4	 mov	 DWORD PTR _to_move$162151[ebp], edx
  00077	79 0d		 jns	 SHORT $LN15@rebalance_@3
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv897[ebp]
  0007c	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00080	03 ca		 add	 ecx, edx
  00082	3b c8		 cmp	 ecx, eax
  00084	7d 29		 jge	 SHORT $LN240@rebalance_@3
$LN15@rebalance_@3:

; 2008 :           left->rebalance_right_to_left(node, to_move);

  00086	56		 push	 esi
  00087	8b c7		 mov	 eax, edi
  00089	e8 00 00 00 00	 call	 ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left

; 2009 : 
; 2010 :           assert(node->max_count() - node->count() == to_move);
; 2011 :           insert_position = insert_position - to_move;

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR _to_move$162151[ebp]
  00091	29 4b 04	 sub	 DWORD PTR [ebx+4], ecx
  00094	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 2012 :           if (insert_position < 0) {

  00097	79 0d		 jns	 SHORT $LN1@rebalance_@3

; 2013 :             insert_position = insert_position + left->count() + 1;

  00099	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  0009d	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]

; 2090 :     insert_position = insert_position - node->count() - 1;

  000a1	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2091 :     node = split_node;

  000a4	89 33		 mov	 DWORD PTR [ebx], esi
$LN1@rebalance_@3:

; 2092 :   }
; 2093 : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5b		 pop	 ebx
  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c2 04 00	 ret	 4
$LN240@rebalance_@3:

; 2005 : 
; 2006 :         if (((insert_position - to_move) >= 0) ||
; 2007 :             ((left->count() + to_move) < left->max_count())) {

  000af	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
$LN239@rebalance_@3:
  000b2	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
$LN16@rebalance_@3:

; 2014 :             node = left;
; 2015 :           }
; 2016 : 
; 2017 :           assert(node->count() < node->max_count());
; 2018 :           return;
; 2019 :         }
; 2020 :       }
; 2021 :     }
; 2022 : 
; 2023 :     if (node->position() < parent->count()) {

  000b5	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  000b8	3a 48 03	 cmp	 cl, BYTE PTR [eax+3]
  000bb	0f 83 9e 00 00
	00		 jae	 $LN11@rebalance_@3

; 2024 :       // Try rebalancing with our right sibling.
; 2025 :       node_type *right = parent->child(node->position() + 1);

  000c1	0f b6 c9	 movzx	 ecx, cl
  000c4	8b 8c 88 04 01
	00 00		 mov	 ecx, DWORD PTR [eax+ecx*4+260]
  000cb	89 4d f4	 mov	 DWORD PTR _right$162164[ebp], ecx

; 2026 :       if (right->count() < right->max_count()) {

  000ce	8b 55 f4	 mov	 edx, DWORD PTR _right$162164[ebp]
  000d1	8a 49 03	 mov	 cl, BYTE PTR [ecx+3]
  000d4	8a 52 02	 mov	 dl, BYTE PTR [edx+2]
  000d7	3a ca		 cmp	 cl, dl
  000d9	0f 83 80 00 00
	00		 jae	 $LN11@rebalance_@3

; 2027 :         // We bias rebalancing based on the position being inserted. If we're
; 2028 :         // inserting at the beginning of the left node then we bias rebalancing
; 2029 :         // to fill up the right node.
; 2030 :         int to_move = (right->max_count() - right->count()) /
; 2031 :             (1 + (insert_position > 0));

  000df	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  000e2	0f b6 c2	 movzx	 eax, dl
  000e5	33 d2		 xor	 edx, edx
  000e7	85 f6		 test	 esi, esi
  000e9	0f 9f c2	 setg	 dl
  000ec	0f b6 c9	 movzx	 ecx, cl
  000ef	89 45 e4	 mov	 DWORD PTR tv928[ebp], eax
  000f2	2b c1		 sub	 eax, ecx
  000f4	89 4d e8	 mov	 DWORD PTR tv927[ebp], ecx
  000f7	42		 inc	 edx
  000f8	89 55 ec	 mov	 DWORD PTR tv1350[ebp], edx
  000fb	99		 cdq
  000fc	f7 7d ec	 idiv	 DWORD PTR tv1350[ebp]

; 2032 :         to_move = std::max(1, to_move);

  000ff	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T194407[ebp], 1
  00106	89 45 ec	 mov	 DWORD PTR _to_move$162166[ebp], eax
  00109	83 f8 01	 cmp	 eax, 1
  0010c	8d 45 ec	 lea	 eax, DWORD PTR _to_move$162166[ebp]
  0010f	7f 03		 jg	 SHORT $LN71@rebalance_@3
  00111	8d 45 f0	 lea	 eax, DWORD PTR $T194407[ebp]
$LN71@rebalance_@3:
  00114	8b 08		 mov	 ecx, DWORD PTR [eax]

; 2033 : 
; 2034 :         if ((insert_position <= (node->count() - to_move)) ||
; 2035 :             ((right->count() + to_move) < right->max_count())) {

  00116	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  0011a	2b c1		 sub	 eax, ecx
  0011c	3b f0		 cmp	 esi, eax
  0011e	7e 0a		 jle	 SHORT $LN10@rebalance_@3
  00120	8b 55 e8	 mov	 edx, DWORD PTR tv927[ebp]
  00123	03 d1		 add	 edx, ecx
  00125	3b 55 e4	 cmp	 edx, DWORD PTR tv928[ebp]
  00128	7d 2f		 jge	 SHORT $LN237@rebalance_@3
$LN10@rebalance_@3:

; 2036 :           node->rebalance_left_to_right(right, to_move);

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _right$162164[ebp]
  0012d	8b f7		 mov	 esi, edi
  0012f	e8 00 00 00 00	 call	 ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right

; 2037 : 
; 2038 :           if (insert_position > node->count()) {

  00134	8b 03		 mov	 eax, DWORD PTR [ebx]
  00136	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0013a	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0013d	3b c1		 cmp	 eax, ecx
  0013f	0f 8e 61 ff ff
	ff		 jle	 $LN1@rebalance_@3

; 2039 :             insert_position = insert_position - node->count() - 1;

  00145	2b c1		 sub	 eax, ecx

; 2040 :             node = right;

  00147	8b 4d f4	 mov	 ecx, DWORD PTR _right$162164[ebp]
  0014a	48		 dec	 eax
  0014b	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  0014e	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2092 :   }
; 2093 : }

  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	5b		 pop	 ebx
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 04 00	 ret	 4
$LN237@rebalance_@3:

; 2041 :           }
; 2042 : 
; 2043 :           assert(node->count() < node->max_count());
; 2044 :           return;

  00159	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0015c	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
$LN11@rebalance_@3:

; 2045 :         }
; 2046 :       }
; 2047 :     }
; 2048 : 
; 2049 :     // Rebalancing failed, make sure there is room on the parent node for a new
; 2050 :     // value.
; 2051 :     if (parent->count() == parent->max_count()) {

  0015f	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  00162	3a 48 02	 cmp	 cl, BYTE PTR [eax+2]
  00165	0f 85 d8 00 00
	00		 jne	 $LN5@rebalance_@3

; 2052 :       iterator parent_iter(node->parent(), node->position());

  0016b	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0016f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00172	89 45 e4	 mov	 DWORD PTR _parent_iter$162173[ebp+4], eax

; 2053 :       rebalance_or_split(&parent_iter);

  00175	8d 45 e0	 lea	 eax, DWORD PTR _parent_iter$162173[ebp]
  00178	50		 push	 eax
  00179	8b ce		 mov	 ecx, esi
  0017b	89 55 e0	 mov	 DWORD PTR _parent_iter$162173[ebp], edx
  0017e	e8 00 00 00 00	 call	 ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split

; 2054 :     }
; 2055 :   } else {

  00183	e9 bb 00 00 00	 jmp	 $LN5@rebalance_@3
$LN19@rebalance_@3:

; 2056 :     // Rebalancing not possible because this is the root node.
; 2057 :     if (root()->leaf()) {

  00188	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0018b	74 74		 je	 SHORT $LN6@rebalance_@3

; 2058 :       // The root node is currently a leaf node: create a new root node and set
; 2059 :       // the current root node as the child of the new root.
; 2060 :       parent = new_internal_root_node();

  0018d	68 88 01 00 00	 push	 392			; 00000188H
  00192	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00197	83 c4 04	 add	 esp, 4
  0019a	85 c0		 test	 eax, eax
  0019c	74 3b		 je	 SHORT $LN102@rebalance_@3
  0019e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001a0	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  001a3	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  001a9	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  001ad	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001b0	c6 00 00	 mov	 BYTE PTR [eax], 0
  001b3	89 88 80 01 00
	00		 mov	 DWORD PTR [eax+384], ecx
  001b9	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  001bd	89 90 84 01 00
	00		 mov	 DWORD PTR [eax+388], edx

; 2061 :       parent->set_child(0, root());

  001c3	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001c5	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx
  001cb	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  001ce	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
  001d2	89 45 08	 mov	 DWORD PTR _parent$[ebp], eax

; 2062 :       *mutable_root() = parent;

  001d5	89 06		 mov	 DWORD PTR [esi], eax

; 2063 :       assert(*mutable_rightmost() == parent->child(0));
; 2064 :     } else {

  001d7	eb 6a		 jmp	 SHORT $LN5@rebalance_@3

; 2058 :       // The root node is currently a leaf node: create a new root node and set
; 2059 :       // the current root node as the child of the new root.
; 2060 :       parent = new_internal_root_node();

$LN102@rebalance_@3:
  001d9	8d 45 08	 lea	 eax, DWORD PTR $T194540[ebp]
  001dc	50		 push	 eax
  001dd	8d 4d dc	 lea	 ecx, DWORD PTR $T194609[ebp]
  001e0	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194540[ebp], 0
  001e7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  001ec	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  001f1	8d 4d dc	 lea	 ecx, DWORD PTR $T194609[ebp]
  001f4	51		 push	 ecx
  001f5	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T194609[ebp], OFFSET ??_7bad_alloc@std@@6B@
  001fc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN243@rebalance_@3:
$LN6@rebalance_@3:

; 2065 :       // The root node is an internal node. We do not want to create a new root
; 2066 :       // node because the root node is special and holds the size of the tree
; 2067 :       // and a pointer to the rightmost node. So we create a new internal node
; 2068 :       // and move all of the items on the current root into the new node.
; 2069 :       parent = new_internal_node(parent);

  00201	68 80 01 00 00	 push	 384			; 00000180H
  00206	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0020b	8b f0		 mov	 esi, eax
  0020d	83 c4 04	 add	 esp, 4
  00210	85 f6		 test	 esi, esi
  00212	0f 84 ff 00 00
	00		 je	 $LN141@rebalance_@3

; 2070 :       parent->set_child(0, parent);
; 2071 :       parent->swap(root());

  00218	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021b	66 c7 46 01 00
	1f		 mov	 WORD PTR [esi+1], 7936	; 00001f00H
  00221	c6 46 03 00	 mov	 BYTE PTR [esi+3], 0
  00225	c6 06 00	 mov	 BYTE PTR [esi], 0
  00228	89 b6 00 01 00
	00		 mov	 DWORD PTR [esi+256], esi
  0022e	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00231	c6 46 01 00	 mov	 BYTE PTR [esi+1], 0
  00235	8b 38		 mov	 edi, DWORD PTR [eax]
  00237	8b d6		 mov	 edx, esi
  00239	89 75 08	 mov	 DWORD PTR _parent$[ebp], esi
  0023c	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2072 :       node = parent;

  00241	89 33		 mov	 DWORD PTR [ebx], esi
$LN5@rebalance_@3:

; 2073 :     }
; 2074 :   }
; 2075 : 
; 2076 :   // Split the node.
; 2077 :   node_type *split_node;
; 2078 :   if (node->leaf()) {

  00243	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00245	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00248	74 76		 je	 SHORT $LN4@rebalance_@3

; 2079 :     split_node = new_leaf_node(parent);

  0024a	68 00 01 00 00	 push	 256			; 00000100H
  0024f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00254	8b f0		 mov	 esi, eax
  00256	83 c4 04	 add	 esp, 4
  00259	85 f6		 test	 esi, esi
  0025b	74 3b		 je	 SHORT $LN171@rebalance_@3
  0025d	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  00260	c7 06 01 00 1f
	00		 mov	 DWORD PTR [esi], 2031617 ; 001f0001H
  00266	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 2080 :     node->split(split_node, insert_position);

  00269	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0026c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0026e	56		 push	 esi
  0026f	e8 00 00 00 00	 call	 ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split

; 2081 :     if (rightmost() == node) {

  00274	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00277	8b 00		 mov	 eax, DWORD PTR [eax]
  00279	85 c0		 test	 eax, eax
  0027b	74 0d		 je	 SHORT $LN186@rebalance_@3
  0027d	80 38 00	 cmp	 BYTE PTR [eax], 0
  00280	75 08		 jne	 SHORT $LN186@rebalance_@3
  00282	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00288	eb 02		 jmp	 SHORT $LN198@rebalance_@3
$LN186@rebalance_@3:
  0028a	8b c8		 mov	 ecx, eax
$LN198@rebalance_@3:
  0028c	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  0028e	75 65		 jne	 SHORT $LN2@rebalance_@3

; 2082 :       *mutable_rightmost() = split_node;

  00290	89 b0 80 01 00
	00		 mov	 DWORD PTR [eax+384], esi

; 2083 :     }
; 2084 :   } else {

  00296	eb 5d		 jmp	 SHORT $LN2@rebalance_@3

; 2079 :     split_node = new_leaf_node(parent);

$LN171@rebalance_@3:
  00298	8d 4d 08	 lea	 ecx, DWORD PTR $T194759[ebp]
  0029b	51		 push	 ecx
  0029c	8d 4d dc	 lea	 ecx, DWORD PTR $T194802[ebp]
  0029f	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194759[ebp], 0
  002a6	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  002ab	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  002b0	8d 55 dc	 lea	 edx, DWORD PTR $T194802[ebp]
  002b3	52		 push	 edx
  002b4	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T194802[ebp], OFFSET ??_7bad_alloc@std@@6B@
  002bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN244@rebalance_@3:
$LN4@rebalance_@3:

; 2085 :     split_node = new_internal_node(parent);

  002c0	68 80 01 00 00	 push	 384			; 00000180H
  002c5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ca	83 c4 04	 add	 esp, 4
  002cd	85 c0		 test	 eax, eax
  002cf	0f 84 04 ff ff
	ff		 je	 $LN102@rebalance_@3
  002d5	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  002d8	66 c7 40 01 00
	1f		 mov	 WORD PTR [eax+1], 7936	; 00001f00H
  002de	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  002e2	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  002e5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2086 :     node->split(split_node, insert_position);

  002e8	8b 3b		 mov	 edi, DWORD PTR [ebx]
  002ea	8b f0		 mov	 esi, eax
  002ec	50		 push	 eax
  002ed	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002f0	e8 00 00 00 00	 call	 ?split@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::split
$LN2@rebalance_@3:

; 2087 :   }
; 2088 : 
; 2089 :   if (insert_position > node->count()) {

  002f5	8b 13		 mov	 edx, DWORD PTR [ebx]
  002f7	0f b6 4a 03	 movzx	 ecx, BYTE PTR [edx+3]
  002fb	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  002fe	3b c1		 cmp	 eax, ecx
  00300	0f 8e a0 fd ff
	ff		 jle	 $LN1@rebalance_@3

; 2090 :     insert_position = insert_position - node->count() - 1;

  00306	2b c1		 sub	 eax, ecx
  00308	48		 dec	 eax
  00309	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2092 :   }
; 2093 : }

  0030c	5f		 pop	 edi
  0030d	89 33		 mov	 DWORD PTR [ebx], esi
  0030f	5e		 pop	 esi
  00310	5b		 pop	 ebx
  00311	8b e5		 mov	 esp, ebp
  00313	5d		 pop	 ebp
  00314	c2 04 00	 ret	 4

; 2065 :       // The root node is an internal node. We do not want to create a new root
; 2066 :       // node because the root node is special and holds the size of the tree
; 2067 :       // and a pointer to the rightmost node. So we create a new internal node
; 2068 :       // and move all of the items on the current root into the new node.
; 2069 :       parent = new_internal_node(parent);

$LN141@rebalance_@3:
  00317	8d 55 08	 lea	 edx, DWORD PTR $T194666[ebp]
  0031a	52		 push	 edx
  0031b	8d 4d dc	 lea	 ecx, DWORD PTR $T194718[ebp]
  0031e	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194666[ebp], 0
  00325	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0032a	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0032f	8d 45 dc	 lea	 eax, DWORD PTR $T194718[ebp]
  00332	50		 push	 eax
  00333	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T194718[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0033a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN245@rebalance_@3:
$LN241@rebalance_@3:
  0033f	cc		 int	 3
?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\list
_TEXT	ENDS
;	COMDAT ??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; __Val$ = esi

; 721  : 		void emplace_front(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 722  : 		{	// insert element at beginning
; 723  : 		_Insert_rv(begin(), _STD forward<_Valty>(_Val));

  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]
  0000c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0000f	51		 push	 ecx
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00016	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00019	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0001e	2b d1		 sub	 edx, ecx
  00020	83 fa 01	 cmp	 edx, 1
  00023	73 0a		 jae	 SHORT $LN25@emplace_fr
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN43@emplace_fr:
$LN25@emplace_fr:
  0002f	41		 inc	 ecx
  00030	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00033	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	5f		 pop	 edi
  0003a	89 01		 mov	 DWORD PTR [ecx], eax
  0003c	5b		 pop	 ebx

; 724  : 		}

  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
$LN42@emplace_fr:
??$emplace_front@U?$pair@$$CBIPAUcpp_object@@@std@@@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEX$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::emplace_front<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z
_TEXT	SEGMENT
$T195194 = -20						; size = 12
$T195095 = -8						; size = 4
$T195094 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
$T195149 = 12						; size = 4
_v$ = 12						; size = 4
_iter$ = 16						; size = 8
?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert, COMDAT
; _this$ = eax

; 2201 : btree<P>::internal_insert(iterator iter, const value_type &v) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax

; 2202 :   if (!iter.node->leaf()) {

  0000a	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  0000d	80 38 00	 cmp	 BYTE PTR [eax], 0
  00010	57		 push	 edi
  00011	75 12		 jne	 SHORT $LN82@internal_i

; 2203 :     // We can't insert on an internal node. Instead, we'll insert after the
; 2204 :     // previous value which is guaranteed to be on a leaf node.
; 2205 :     --iter;

  00013	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  00016	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow

; 2206 :     ++iter.position;

  0001b	bf 01 00 00 00	 mov	 edi, 1
  00020	01 7d 14	 add	 DWORD PTR _iter$[ebp+4], edi
  00023	eb 05		 jmp	 SHORT $LN6@internal_i
$LN82@internal_i:
  00025	bf 01 00 00 00	 mov	 edi, 1
$LN6@internal_i:

; 2207 :   }
; 2208 :   if (iter.node->count() == iter.node->max_count()) {

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  0002d	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00030	38 41 03	 cmp	 BYTE PTR [ecx+3], al
  00033	0f 85 a7 00 00
	00		 jne	 $LN5@internal_i

; 2209 :     // Make room in the leaf for the new item.
; 2210 :     if (iter.node->max_count() < kNodeValues) {

  00039	3c 1f		 cmp	 al, 31			; 0000001fH
  0003b	0f 83 90 00 00
	00		 jae	 $LN4@internal_i

; 2211 :       // Insertion into the root where the root is smaller that the full node
; 2212 :       // size. Simply grow the size of the root node.
; 2213 :       assert(iter.node == root());
; 2214 :       iter.node = new_leaf_root_node(
; 2215 :           std::min<int>(kNodeValues, 2 * iter.node->max_count()));

  00041	0f b6 c0	 movzx	 eax, al
  00044	03 c0		 add	 eax, eax
  00046	89 45 fc	 mov	 DWORD PTR $T195094[ebp], eax
  00049	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004c	c7 45 f8 1f 00
	00 00		 mov	 DWORD PTR $T195095[ebp], 31 ; 0000001fH
  00053	8d 45 fc	 lea	 eax, DWORD PTR $T195094[ebp]
  00056	7c 03		 jl	 SHORT $LN29@internal_i
  00058	8d 45 f8	 lea	 eax, DWORD PTR $T195095[ebp]
$LN29@internal_i:
  0005b	8b 18		 mov	 ebx, DWORD PTR [eax]
  0005d	8d 0c dd 08 00
	00 00		 lea	 ecx, DWORD PTR [ebx*8+8]
  00064	33 c0		 xor	 eax, eax
  00066	85 c9		 test	 ecx, ecx
  00068	74 12		 je	 SHORT $LN37@internal_i
  0006a	83 f9 ff	 cmp	 ecx, -1
  0006d	77 3a		 ja	 SHORT $LN36@internal_i
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00075	83 c4 04	 add	 esp, 4
  00078	85 c0		 test	 eax, eax
  0007a	74 2d		 je	 SHORT $LN36@internal_i
$LN37@internal_i:
  0007c	66 c7 00 01 00	 mov	 WORD PTR [eax], 1
  00081	88 58 02	 mov	 BYTE PTR [eax+2], bl
  00084	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00088	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 2216 :       iter.node->swap(root());

  0008b	8b 3e		 mov	 edi, DWORD PTR [esi]
  0008d	8b d0		 mov	 edx, eax
  0008f	89 45 10	 mov	 DWORD PTR _iter$[ebp], eax
  00092	e8 00 00 00 00	 call	 ?swap@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::swap

; 2217 :       delete_leaf_node(root());

  00097	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 2218 :       *mutable_root() = iter.node;

  0009f	8b 55 10	 mov	 edx, DWORD PTR _iter$[ebp]
  000a2	83 c4 04	 add	 esp, 4
  000a5	89 16		 mov	 DWORD PTR [esi], edx

; 2219 :     } else {

  000a7	eb 44		 jmp	 SHORT $LN1@internal_i

; 2211 :       // Insertion into the root where the root is smaller that the full node
; 2212 :       // size. Simply grow the size of the root node.
; 2213 :       assert(iter.node == root());
; 2214 :       iter.node = new_leaf_root_node(
; 2215 :           std::min<int>(kNodeValues, 2 * iter.node->max_count()));

$LN36@internal_i:
  000a9	8d 45 0c	 lea	 eax, DWORD PTR $T195149[ebp]
  000ac	50		 push	 eax
  000ad	8d 4d ec	 lea	 ecx, DWORD PTR $T195194[ebp]
  000b0	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR $T195149[ebp], 0
  000b7	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000bc	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000c1	8d 4d ec	 lea	 ecx, DWORD PTR $T195194[ebp]
  000c4	51		 push	 ecx
  000c5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T195194[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000cc	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN85@internal_i:
$LN4@internal_i:

; 2220 :       rebalance_or_split(&iter);

  000d1	8d 55 10	 lea	 edx, DWORD PTR _iter$[ebp]
  000d4	52		 push	 edx
  000d5	8b ce		 mov	 ecx, esi
  000d7	e8 00 00 00 00	 call	 ?rebalance_or_split@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_or_split

; 2221 :       ++*mutable_size();

  000dc	8b 36		 mov	 esi, DWORD PTR [esi]

; 2222 :     }

  000de	eb 07		 jmp	 SHORT $LN84@internal_i
$LN5@internal_i:

; 2223 :   } else if (!root()->leaf()) {

  000e0	8b 36		 mov	 esi, DWORD PTR [esi]
  000e2	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000e5	75 06		 jne	 SHORT $LN1@internal_i
$LN84@internal_i:

; 2224 :     ++*mutable_size();

  000e7	01 be 84 01 00
	00		 add	 DWORD PTR [esi+388], edi
$LN1@internal_i:

; 2225 :   }
; 2226 :   iter.node->insert_value(iter.position, v);

  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR _v$[ebp]
  000f0	8b 45 14	 mov	 eax, DWORD PTR _iter$[ebp+4]
  000f3	8b 75 10	 mov	 esi, DWORD PTR _iter$[ebp]
  000f6	e8 00 00 00 00	 call	 ?insert_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXHABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_value

; 2227 :   return iter;

  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000fe	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00101	8b 55 14	 mov	 edx, DWORD PTR _iter$[ebp+4]

; 2228 : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	89 08		 mov	 DWORD PTR [eax], ecx
  00108	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0010b	5b		 pop	 ebx
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 10 00	 ret	 16			; 00000010H
$LN83@internal_i:
?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z
_TEXT	SEGMENT
tv562 = -4						; size = 4
_to_move$161048 = -4					; size = 4
$T195281 = 8						; size = 4
_to_move$161037 = 8					; size = 4
_this$ = 8						; size = 4
$T195280 = 12						; size = 4
_iter$ = 12						; size = 4
?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance, COMDAT

; 2109 : bool btree<P>::try_merge_or_rebalance(iterator *iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2110 :   node_type *parent = iter->node->parent();

  00004	8b 45 0c	 mov	 eax, DWORD PTR _iter$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 38		 mov	 edi, DWORD PTR [eax]

; 2111 :   if (iter->node->position() > 0) {

  0000c	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0000f	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00012	84 c0		 test	 al, al
  00014	74 6e		 je	 SHORT $LN165@try_merge_

; 2112 :     // Try merging with our left sibling.
; 2113 :     node_type *left = parent->child(iter->node->position() - 1);
; 2114 :     if ((1 + left->count() + iter->node->count()) <= left->max_count()) {

  00016	0f b6 5f 03	 movzx	 ebx, BYTE PTR [edi+3]
  0001a	0f b6 d0	 movzx	 edx, al
  0001d	8b b4 91 fc 00
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+252]
  00024	0f b6 56 03	 movzx	 edx, BYTE PTR [esi+3]
  00028	8d 54 13 01	 lea	 edx, DWORD PTR [ebx+edx+1]
  0002c	0f b6 5e 02	 movzx	 ebx, BYTE PTR [esi+2]
  00030	3b d3		 cmp	 edx, ebx
  00032	7f 50		 jg	 SHORT $LN165@try_merge_

; 2115 :       iter->position += 1 + left->count();

  00034	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00038	8b 5d 0c	 mov	 ebx, DWORD PTR _iter$[ebp]
  0003b	40		 inc	 eax
  0003c	01 43 04	 add	 DWORD PTR [ebx+4], eax

; 2116 :       merge_nodes(left, iter->node);

  0003f	57		 push	 edi
  00040	8b ce		 mov	 ecx, esi
  00042	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
  00047	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0004a	74 22		 je	 SHORT $LN30@try_merge_
  0004c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	85 c0		 test	 eax, eax
  00053	74 0d		 je	 SHORT $LN37@try_merge_
  00055	80 38 00	 cmp	 BYTE PTR [eax], 0
  00058	75 08		 jne	 SHORT $LN37@try_merge_
  0005a	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  00060	eb 02		 jmp	 SHORT $LN49@try_merge_
$LN37@try_merge_:
  00062	8b c8		 mov	 ecx, eax
$LN49@try_merge_:
  00064	3b cf		 cmp	 ecx, edi
  00066	75 06		 jne	 SHORT $LN30@try_merge_
  00068	89 b0 80 01 00
	00		 mov	 DWORD PTR [eax+384], esi
$LN30@try_merge_:
  0006e	57		 push	 edi
  0006f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00074	83 c4 04	 add	 esp, 4
  00077	5f		 pop	 edi

; 2117 :       iter->node = left;

  00078	89 33		 mov	 DWORD PTR [ebx], esi
  0007a	5e		 pop	 esi

; 2118 :       return true;

  0007b	b0 01		 mov	 al, 1
  0007d	5b		 pop	 ebx

; 2158 : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 08 00	 ret	 8
$LN165@try_merge_:

; 2119 :     }
; 2120 :   }
; 2121 :   if (iter->node->position() < parent->count()) {

  00084	3a 41 03	 cmp	 al, BYTE PTR [ecx+3]
  00087	0f 83 ae 00 00
	00		 jae	 $LN164@try_merge_

; 2122 :     // Try merging with our right sibling.
; 2123 :     node_type *right = parent->child(iter->node->position() + 1);

  0008d	0f b6 d0	 movzx	 edx, al
  00090	8b b4 91 04 01
	00 00		 mov	 esi, DWORD PTR [ecx+edx*4+260]

; 2124 :     if ((1 + iter->node->count() + right->count()) <= right->max_count()) {

  00097	0f b6 57 03	 movzx	 edx, BYTE PTR [edi+3]
  0009b	0f b6 5e 03	 movzx	 ebx, BYTE PTR [esi+3]
  0009f	89 55 fc	 mov	 DWORD PTR tv562[ebp], edx
  000a2	8d 54 13 01	 lea	 edx, DWORD PTR [ebx+edx+1]
  000a6	0f b6 5e 02	 movzx	 ebx, BYTE PTR [esi+2]
  000aa	3b d3		 cmp	 edx, ebx
  000ac	7f 43		 jg	 SHORT $LN6@try_merge_

; 2125 :       merge_nodes(iter->node, right);

  000ae	56		 push	 esi
  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 ?merge@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::merge
  000b6	80 3e 00	 cmp	 BYTE PTR [esi], 0
  000b9	74 22		 je	 SHORT $LN87@try_merge_
  000bb	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 00		 mov	 eax, DWORD PTR [eax]
  000c0	85 c0		 test	 eax, eax
  000c2	74 0d		 je	 SHORT $LN94@try_merge_
  000c4	80 38 00	 cmp	 BYTE PTR [eax], 0
  000c7	75 08		 jne	 SHORT $LN94@try_merge_
  000c9	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  000cf	eb 02		 jmp	 SHORT $LN106@try_merge_
$LN94@try_merge_:
  000d1	8b c8		 mov	 ecx, eax
$LN106@try_merge_:
  000d3	3b ce		 cmp	 ecx, esi
  000d5	75 06		 jne	 SHORT $LN87@try_merge_
  000d7	89 b8 80 01 00
	00		 mov	 DWORD PTR [eax+384], edi
$LN87@try_merge_:
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e3	83 c4 04	 add	 esp, 4
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi

; 2126 :       return true;

  000e8	b0 01		 mov	 al, 1
  000ea	5b		 pop	 ebx

; 2158 : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 08 00	 ret	 8
$LN6@try_merge_:

; 2127 :     }
; 2128 :     // Try rebalancing with our right sibling. We don't perform rebalancing if
; 2129 :     // we deleted the first element from iter->node and the node is not
; 2130 :     // empty. This is a small optimization for the common pattern of deleting
; 2131 :     // from the front of the tree.
; 2132 :     if ((right->count() > kMinNodeValues) &&
; 2133 :         ((iter->node->count() == 0) ||
; 2134 :          (iter->position > 0))) {

  000f1	80 7e 03 0f	 cmp	 BYTE PTR [esi+3], 15	; 0000000fH
  000f5	76 44		 jbe	 SHORT $LN164@try_merge_
  000f7	8a 57 03	 mov	 dl, BYTE PTR [edi+3]
  000fa	84 d2		 test	 dl, dl
  000fc	74 09		 je	 SHORT $LN4@try_merge_
  000fe	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  00101	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00105	7e 34		 jle	 SHORT $LN164@try_merge_
$LN4@try_merge_:

; 2135 :       int to_move = (right->count() - iter->node->count()) / 2;

  00107	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  0010b	8b c1		 mov	 eax, ecx
  0010d	2b 45 fc	 sub	 eax, DWORD PTR tv562[ebp]

; 2136 :       to_move = std::min(to_move, right->count() - 1);

  00110	49		 dec	 ecx
  00111	99		 cdq
  00112	2b c2		 sub	 eax, edx
  00114	d1 f8		 sar	 eax, 1
  00116	89 45 08	 mov	 DWORD PTR _to_move$161037[ebp], eax
  00119	3b c8		 cmp	 ecx, eax
  0011b	89 4d 0c	 mov	 DWORD PTR $T195280[ebp], ecx
  0011e	8d 45 0c	 lea	 eax, DWORD PTR $T195280[ebp]
  00121	7c 03		 jl	 SHORT $LN141@try_merge_
  00123	8d 45 08	 lea	 eax, DWORD PTR _to_move$161037[ebp]
$LN141@try_merge_:
  00126	8b 10		 mov	 edx, DWORD PTR [eax]

; 2137 :       iter->node->rebalance_right_to_left(right, to_move);

  00128	57		 push	 edi
  00129	8b c6		 mov	 eax, esi
  0012b	e8 00 00 00 00	 call	 ?rebalance_right_to_left@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_right_to_left
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi

; 2154 :       return false;
; 2155 :     }
; 2156 :   }
; 2157 :   return false;

  00132	32 c0		 xor	 al, al
  00134	5b		 pop	 ebx

; 2158 : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c2 08 00	 ret	 8
$LN164@try_merge_:

; 2138 :       return false;
; 2139 :     }
; 2140 :   }
; 2141 :   if (iter->node->position() > 0) {

  0013b	84 c0		 test	 al, al
  0013d	74 54		 je	 SHORT $LN2@try_merge_

; 2142 :     // Try rebalancing with our left sibling. We don't perform rebalancing if
; 2143 :     // we deleted the last element from iter->node and the node is not
; 2144 :     // empty. This is a small optimization for the common pattern of deleting
; 2145 :     // from the back of the tree.
; 2146 :     node_type *left = parent->child(iter->node->position() - 1);

  0013f	0f b6 c0	 movzx	 eax, al
  00142	8b b4 81 fc 00
	00 00		 mov	 esi, DWORD PTR [ecx+eax*4+252]

; 2147 :     if ((left->count() > kMinNodeValues) &&
; 2148 :         ((iter->node->count() == 0) ||
; 2149 :          (iter->position < iter->node->count()))) {

  00149	80 7e 03 0f	 cmp	 BYTE PTR [esi+3], 15	; 0000000fH
  0014d	76 44		 jbe	 SHORT $LN2@try_merge_
  0014f	8a 47 03	 mov	 al, BYTE PTR [edi+3]
  00152	84 c0		 test	 al, al
  00154	74 0b		 je	 SHORT $LN1@try_merge_
  00156	8b 55 0c	 mov	 edx, DWORD PTR _iter$[ebp]
  00159	0f b6 c8	 movzx	 ecx, al
  0015c	39 4a 04	 cmp	 DWORD PTR [edx+4], ecx
  0015f	7d 32		 jge	 SHORT $LN2@try_merge_
$LN1@try_merge_:

; 2150 :       int to_move = (left->count() - iter->node->count()) / 2;

  00161	0f b6 4e 03	 movzx	 ecx, BYTE PTR [esi+3]
  00165	0f b6 d0	 movzx	 edx, al
  00168	8b c1		 mov	 eax, ecx
  0016a	2b c2		 sub	 eax, edx
  0016c	99		 cdq
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1

; 2151 :       to_move = std::min(to_move, left->count() - 1);

  00171	49		 dec	 ecx
  00172	89 45 fc	 mov	 DWORD PTR _to_move$161048[ebp], eax
  00175	3b c8		 cmp	 ecx, eax
  00177	89 4d 08	 mov	 DWORD PTR $T195281[ebp], ecx
  0017a	8d 45 08	 lea	 eax, DWORD PTR $T195281[ebp]
  0017d	7c 03		 jl	 SHORT $LN163@try_merge_
  0017f	8d 45 fc	 lea	 eax, DWORD PTR _to_move$161048[ebp]
$LN163@try_merge_:
  00182	8b 18		 mov	 ebx, DWORD PTR [eax]

; 2152 :       left->rebalance_left_to_right(iter->node, to_move);

  00184	8b cb		 mov	 ecx, ebx
  00186	8b c7		 mov	 eax, edi
  00188	e8 00 00 00 00	 call	 ?rebalance_left_to_right@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXPAV12@H@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::rebalance_left_to_right

; 2153 :       iter->position += to_move;

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _iter$[ebp]
  00190	01 58 04	 add	 DWORD PTR [eax+4], ebx
$LN2@try_merge_:

; 2154 :       return false;
; 2155 :     }
; 2156 :   }
; 2157 :   return false;

  00193	5f		 pop	 edi
  00194	5e		 pop	 esi
  00195	32 c0		 xor	 al, al
  00197	5b		 pop	 ebx

; 2158 : }

  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 08 00	 ret	 8
?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--, COMDAT
; _this$ = esi

; 419  : 		--(*(_Mybase *)this);

  00000	8b c6		 mov	 eax, esi
  00002	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00007	8b c6		 mov	 eax, esi

; 421  : 		}

  00009	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ
_TEXT	SEGMENT
tv503 = -4						; size = 4
tv501 = -4						; size = 4
__Tmp$196307 = -4					; size = 4
_this$ = 8						; size = 4
?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size, COMDAT

; 879  : 		{	// grow table as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 880  : 		if (max_load_factor() < load_factor())

  00008	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000b	db 43 08	 fild	 DWORD PTR [ebx+8]
  0000e	56		 push	 esi
  0000f	8b 73 24	 mov	 esi, DWORD PTR [ebx+36]
  00012	85 c0		 test	 eax, eax
  00014	79 06		 jns	 SHORT $LN129@Check_size
  00016	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN129@Check_size:
  0001c	8b ce		 mov	 ecx, esi
  0001e	89 4d fc	 mov	 DWORD PTR tv501[ebp], ecx
  00021	db 45 fc	 fild	 DWORD PTR tv501[ebp]
  00024	85 c9		 test	 ecx, ecx
  00026	79 06		 jns	 SHORT $LN130@Check_size
  00028	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN130@Check_size:
  0002e	de f9		 fdivp	 ST(1), ST(0)
  00030	d9 43 28	 fld	 DWORD PTR [ebx+40]
  00033	d9 c9		 fxch	 ST(1)
  00035	df f1		 fcomip	 ST(1)
  00037	dd d8		 fstp	 ST(0)
  00039	76 6d		 jbe	 SHORT $LN4@Check_size

; 881  : 
; 882  :  #if _HAS_INCREMENTAL_HASH
; 883  : 			_Grow();	// too dense, need to grow hash table
; 884  : 
; 885  :  #else /* _HAS_INCREMENTAL_HASH */
; 886  : 			{	// rehash to bigger table
; 887  : 			size_type _Maxsize = _Vec.max_size() / 2;
; 888  : 			size_type _Newsize = bucket_count();
; 889  : 
; 890  : 			for (int _Idx = 0; _Idx < 3 && _Newsize < _Maxsize; ++_Idx)

  0003b	33 c0		 xor	 eax, eax
  0003d	8d 49 00	 npad	 3
$LL3@Check_size:
  00040	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00046	73 08		 jae	 SHORT $LN1@Check_size
  00048	40		 inc	 eax

; 891  : 				_Newsize *= 2;	// multiply safely by 8

  00049	03 f6		 add	 esi, esi
  0004b	83 f8 03	 cmp	 eax, 3
  0004e	7c f0		 jl	 SHORT $LL3@Check_size
$LN1@Check_size:

; 892  : 			_Init(_Newsize);

  00050	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00053	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00056	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  00059	57		 push	 edi
  0005a	8b 3a		 mov	 edi, DWORD PTR [edx]
  0005c	89 45 fc	 mov	 DWORD PTR __Tmp$196307[ebp], eax
  0005f	3b f9		 cmp	 edi, ecx
  00061	74 21		 je	 SHORT $LN59@Check_size
  00063	8b c1		 mov	 eax, ecx
  00065	3b c9		 cmp	 ecx, ecx
  00067	74 18		 je	 SHORT $LN88@Check_size
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL90@Check_size:
  00070	8b 18		 mov	 ebx, DWORD PTR [eax]
  00072	89 1f		 mov	 DWORD PTR [edi], ebx
  00074	83 c0 04	 add	 eax, 4
  00077	83 c7 04	 add	 edi, 4
  0007a	3b c1		 cmp	 eax, ecx
  0007c	75 f2		 jne	 SHORT $LL90@Check_size
  0007e	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
$LN88@Check_size:
  00081	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN59@Check_size:
  00084	8b 02		 mov	 eax, DWORD PTR [edx]
  00086	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$196307[ebp]
  00089	51		 push	 ecx
  0008a	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@IAEXV?$_Vector_const_iterator@V?$_Vector_val@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@V?$allocator@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@@2@@std@@@2@IABV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::vector<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > >,std::allocator<std::_List_iterator<std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > > > > >::_Insert_n

; 893  : 			_Reinsert(end());

  00093	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00096	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00099	50		 push	 eax
  0009a	8b cb		 mov	 ecx, ebx
  0009c	89 53 20	 mov	 DWORD PTR [ebx+32], edx
  0009f	89 73 24	 mov	 DWORD PTR [ebx+36], esi
  000a2	e8 00 00 00 00	 call	 ?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
  000a7	5f		 pop	 edi
$LN4@Check_size:
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 894  : 			}
; 895  :  #endif /* _HAS_INCREMENTAL_HASH */
; 896  : 		}

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c2 04 00	 ret	 4
?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -8						; size = 1
__Where$160816 = -4					; size = 4
_this$ = 8						; size = 4
$T196374 = 12						; size = 4
$T196372 = 12						; size = 4
__Node$ = 12						; size = 4
?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert, COMDAT
; ___$ReturnUdt$ = esi

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00009	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  0000c	53		 push	 ebx
  0000d	57		 push	 edi
  0000e	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  00011	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00014	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00018	b1 01		 mov	 cl, 1
  0001a	88 4d f8	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 1f		 jne	 SHORT $LN11@Linsert
  0001f	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)
; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,
; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else
; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00022	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  00025	8b f8		 mov	 edi, eax
  00027	0f 92 c1	 setb	 cl
  0002a	88 4d f8	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0002d	84 c9		 test	 cl, cl
  0002f	74 04		 je	 SHORT $LN15@Linsert
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00035	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00038	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003c	74 e4		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0003e	8b df		 mov	 ebx, edi
  00040	89 5d fc	 mov	 DWORD PTR __Where$160816[ebp], ebx

; 970  : 			if (!_Addleft)

  00043	84 c9		 test	 cl, cl
  00045	74 39		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00047	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004d	3b 39		 cmp	 edi, DWORD PTR [ecx]
  0004f	75 21		 jne	 SHORT $LN4@Linsert

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00051	52		 push	 edx
  00052	6a 01		 push	 1
  00054	8d 55 0c	 lea	 edx, DWORD PTR $T196372[ebp]
  00057	52		 push	 edx
  00058	50		 push	 eax
  00059	8b cf		 mov	 ecx, edi
  0005b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	5f		 pop	 edi
  00063	89 06		 mov	 DWORD PTR [esi], eax
  00065	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  00069	8b c6		 mov	 eax, esi
  0006b	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  00072	8d 45 fc	 lea	 eax, DWORD PTR __Where$160816[ebp]
  00075	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
  0007a	8b 5d fc	 mov	 ebx, DWORD PTR __Where$160816[ebp]
  0007d	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  00080	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  00083	52		 push	 edx
  00084	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  00087	73 25		 jae	 SHORT $LN2@Linsert
  00089	8b 55 f8	 mov	 edx, DWORD PTR __Addleft$[ebp]
  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	52		 push	 edx
  00090	8d 45 0c	 lea	 eax, DWORD PTR $T196374[ebp]
  00093	50		 push	 eax
  00094	51		 push	 ecx
  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0009c	8b 10		 mov	 edx, DWORD PTR [eax]
  0009e	5f		 pop	 edi
  0009f	89 16		 mov	 DWORD PTR [esi], edx
  000a1	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000a5	8b c6		 mov	 eax, esi
  000a7	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 08 00	 ret	 8
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000ae	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000b3	83 c4 04	 add	 esp, 4
  000b6	5f		 pop	 edi

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000b7	89 1e		 mov	 DWORD PTR [esi], ebx
  000b9	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  000bd	8b c6		 mov	 eax, esi
  000bf	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
tv929 = -4						; size = 4
$T197410 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Plist$ = 16						; size = 4
?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; __Val$ = eax

; 849  : 		{	// try to insert existing node with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 850  : 		size_type _Bucket = _Hashval(this->_Kfn(_Val));

  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 00		 mov	 eax, DWORD PTR [eax]
  00009	8b c8		 mov	 ecx, eax
  0000b	c1 e1 06	 shl	 ecx, 6
  0000e	89 45 fc	 mov	 DWORD PTR tv929[ebp], eax
  00011	2b c1		 sub	 eax, ecx
  00013	8b d0		 mov	 edx, eax
  00015	c1 ea 11	 shr	 edx, 17			; 00000011H
  00018	33 c2		 xor	 eax, edx
  0001a	8b c8		 mov	 ecx, eax
  0001c	c1 e1 09	 shl	 ecx, 9
  0001f	2b c1		 sub	 eax, ecx
  00021	8b d0		 mov	 edx, eax
  00023	c1 e2 04	 shl	 edx, 4
  00026	33 c2		 xor	 eax, edx
  00028	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002f	2b c1		 sub	 eax, ecx
  00031	8b d0		 mov	 edx, eax
  00033	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00036	33 c2		 xor	 eax, edx
  00038	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	8b 4a 20	 mov	 ecx, DWORD PTR [edx+32]
  0003e	8b f0		 mov	 esi, eax
  00040	c1 ee 0f	 shr	 esi, 15			; 0000000fH
  00043	33 f0		 xor	 esi, eax
  00045	23 f1		 and	 esi, ecx
  00047	39 72 24	 cmp	 DWORD PTR [edx+36], esi
  0004a	77 09		 ja	 SHORT $LN13@Insert@2
  0004c	d1 e9		 shr	 ecx, 1
  0004e	83 c8 ff	 or	 eax, -1
  00051	2b c1		 sub	 eax, ecx
  00053	03 f0		 add	 esi, eax
$LN13@Insert@2:

; 851  : 		iterator _Where = _End(_Bucket);

  00055	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00058	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  0005b	8d 04 f1	 lea	 eax, DWORD PTR [ecx+esi*8]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8d 7a 04	 lea	 edi, DWORD PTR [edx+4]
  00063	3b d9		 cmp	 ebx, ecx
  00065	74 18		 je	 SHORT $LN7@Insert@2
  00067	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006a	8b 18		 mov	 ebx, DWORD PTR [eax]

; 852  : 
; 853  : 		for (; _Where != _Begin(_Bucket); )

  0006c	3b d9		 cmp	 ebx, ecx
  0006e	74 0f		 je	 SHORT $LN7@Insert@2
$LL8@Insert@2:

; 854  : 			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Where)))

  00070	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  00073	8b 45 fc	 mov	 eax, DWORD PTR tv929[ebp]
  00076	39 43 08	 cmp	 DWORD PTR [ebx+8], eax
  00079	74 40		 je	 SHORT $LN4@Insert@2

; 852  : 
; 853  : 		for (; _Where != _Begin(_Bucket); )

  0007b	3b d9		 cmp	 ebx, ecx
  0007d	75 f1		 jne	 SHORT $LL8@Insert@2
$LN7@Insert@2:

; 866  : 				}
; 867  : 
; 868  : 		iterator _Next = _Plist;
; 869  : 		if (_Where != ++_Next)

  0007f	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  00082	8b 08		 mov	 ecx, DWORD PTR [eax]
  00084	3b d9		 cmp	 ebx, ecx
  00086	74 12		 je	 SHORT $LN1@Insert@2

; 870  : 			_List._Splice_same(_Where, _List,
; 871  : 				_Plist, _Next, 1);	// move element into place

  00088	51		 push	 ecx
  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	8b cf		 mov	 ecx, edi
  0008d	8b d7		 mov	 edx, edi
  0008f	e8 00 00 00 00	 call	 ?_Splice_same@?$list@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEXV?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@AAV12@00I@Z ; std::list<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Splice_same
  00094	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  00097	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
$LN1@Insert@2:

; 872  : 
; 873  : 		_Insert_bucket(_Plist, _Where, _Bucket);

  0009a	89 45 08	 mov	 DWORD PTR $T197410[ebp], eax
  0009d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a0	8b 0c f0	 mov	 ecx, DWORD PTR [eax+esi*8]
  000a3	8d 04 f0	 lea	 eax, DWORD PTR [eax+esi*8]
  000a6	3b 0f		 cmp	 ecx, DWORD PTR [edi]
  000a8	75 45		 jne	 SHORT $LN177@Insert@2
  000aa	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  000ad	89 08		 mov	 DWORD PTR [eax], ecx
  000af	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR $T197410[ebp]
  000b5	89 4c f0 04	 mov	 DWORD PTR [eax+esi*8+4], ecx
  000b9	eb 5c		 jmp	 SHORT $LN236@Insert@2
$LN4@Insert@2:

; 855  : 				;	// still too high in bucket list
; 856  : 			else if (_Multi
; 857  : 				|| this->comp(this->_Kfn(*_Where), this->_Kfn(_Val)))
; 858  : 				{	// found insertion point, back up to it
; 859  : 				++_Where;
; 860  : 				break;
; 861  : 				}
; 862  : 			else
; 863  : 				{	// discard new list element and return existing
; 864  : 				_List.erase(_Plist);

  000bb	8b 45 10	 mov	 eax, DWORD PTR __Plist$[ebp]
  000be	3b 07		 cmp	 eax, DWORD PTR [edi]
  000c0	74 1b		 je	 SHORT $LN116@Insert@2
  000c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000c5	8b 30		 mov	 esi, DWORD PTR [eax]
  000c7	89 32		 mov	 DWORD PTR [edx], esi
  000c9	8b 10		 mov	 edx, DWORD PTR [eax]
  000cb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ce	50		 push	 eax
  000cf	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000d2	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000d7	83 c4 04	 add	 esp, 4
  000da	ff 4f 04	 dec	 DWORD PTR [edi+4]
$LN116@Insert@2:

; 865  : 				return (_Pairib(_Where, false));

  000dd	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	89 18		 mov	 DWORD PTR [eax], ebx
  000e4	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000e8	5b		 pop	 ebx

; 876  : 		}

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 0c 00	 ret	 12			; 0000000cH

; 872  : 
; 873  : 		_Insert_bucket(_Plist, _Where, _Bucket);

$LN177@Insert@2:
  000ef	3b cb		 cmp	 ecx, ebx
  000f1	75 07		 jne	 SHORT $LN175@Insert@2
  000f3	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  000f6	89 08		 mov	 DWORD PTR [eax], ecx
  000f8	eb 1d		 jmp	 SHORT $LN236@Insert@2
$LN175@Insert@2:
  000fa	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fd	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ff	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00102	3b 4d 08	 cmp	 ecx, DWORD PTR $T197410[ebp]
  00105	74 10		 je	 SHORT $LN236@Insert@2
  00107	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0010a	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  0010e	8d 74 f0 04	 lea	 esi, DWORD PTR [eax+esi*8+4]
  00112	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00115	89 06		 mov	 DWORD PTR [esi], eax
$LN236@Insert@2:

; 874  : 		_Check_size();

  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 ?_Check_size@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXXZ ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Check_size

; 875  : 		return (_Pairib(_Plist, true));	// return iterator for new element

  0011d	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00120	8b 4d 10	 mov	 ecx, DWORD PTR __Plist$[ebp]
  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	89 08		 mov	 DWORD PTR [eax], ecx
  00127	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  0012b	5b		 pop	 ebx

; 876  : 		}

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
$T197455 = -8						; size = 8
_this$ = 8						; size = 4
__Where$ = 12						; size = 4
__Next$ = 16						; size = 4
__Node$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert, COMDAT
; ___$ReturnUdt$ = edi

; 1089 : 		{	// try to insert node at _Node using _Where as a hint

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1090 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1091 : 		if (_Where._Getcont() != this)
; 1092 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1093 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1094 : 
; 1095 : 		const value_type& _Val = this->_Myval(_Node);
; 1096 : 
; 1097 : 		const_iterator _Next;
; 1098 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1099 : 
; 1100 : 		if (size() == 0)

  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0000d	53		 push	 ebx
  0000e	8b 5d 10	 mov	 ebx, DWORD PTR __Node$[ebp]
  00011	c7 45 10 00 00
	00 00		 mov	 DWORD PTR __Next$[ebp], 0
  00018	75 16		 jne	 SHORT $LN33@Insert@3

; 1101 : 			return (_Insert(true, this->_Myhead, _Node));	// empty tree

  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	53		 push	 ebx
  0001e	6a 01		 push	 1
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00027	8b c7		 mov	 eax, edi
  00029	5b		 pop	 ebx

; 1181 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN33@Insert@3:

; 1102 : 		else if (this->_Multi)
; 1103 : 			{	// insert even if duplicate
; 1104 : 			if (_Where == begin())
; 1105 : 				{	// insert at beginning if before first element
; 1106 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1107 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1108 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1109 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1110 : 				}
; 1111 : 			else if (_Where == end())
; 1112 : 				{	// insert at end if after last element
; 1113 : 				if (!_DEBUG_LT_PRED(this->comp,
; 1114 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1115 : 					return (_Insert(false, _Rmost(), _Node));
; 1116 : 				}
; 1117 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1118 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1119 : 				&& !_DEBUG_LT_PRED(this->comp,
; 1120 : 					this->_Kfn(_Val),
; 1121 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1122 : 				{	// insert before _Where
; 1123 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1124 : 					return (_Insert(false, _Next._Mynode(), _Node));
; 1125 : 				else
; 1126 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1127 : 				}
; 1128 : 			else if (!_DEBUG_LT_PRED(this->comp,
; 1129 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1130 : 				&& (++(_Next = _Where) == end()
; 1131 : 					|| !_DEBUG_LT_PRED(this->comp,
; 1132 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1133 : 				{	// insert after _Where
; 1134 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1135 : 					return (_Insert(false, _Where._Mynode(), _Node));
; 1136 : 				else
; 1137 : 					return (_Insert(true, _Next._Mynode(), _Node));
; 1138 : 				}
; 1139 : 			else
; 1140 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1141 : 			}
; 1142 : 		else
; 1143 : 			{	// insert only if unique
; 1144 : 			if (_Where == begin())

  00030	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00033	56		 push	 esi
  00034	8b 75 0c	 mov	 esi, DWORD PTR __Where$[ebp]
  00037	3b 30		 cmp	 esi, DWORD PTR [eax]
  00039	75 25		 jne	 SHORT $LN14@Insert@3

; 1145 : 				{	// insert at beginning if before first element
; 1146 : 				if (_DEBUG_LT_PRED(this->comp,

  0003b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0003e	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00041	0f 83 dd 00 00
	00		 jae	 $LN1@Insert@3

; 1147 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1148 : 					return (_Insert(true, _Where._Mynode(), _Node));

  00047	53		 push	 ebx
$LN7@Insert@3:
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	6a 01		 push	 1
  0004d	57		 push	 edi
  0004e	51		 push	 ecx
  0004f	8b ce		 mov	 ecx, esi
  00051	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00056	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00057	8b c7		 mov	 eax, edi
  00059	5b		 pop	 ebx

; 1181 : 		}

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
$LN14@Insert@3:

; 1149 : 				}
; 1150 : 			else if (_Where == end())

  00060	3b f0		 cmp	 esi, eax
  00062	75 26		 jne	 SHORT $LN11@Insert@3

; 1151 : 				{	// insert at end if after last element
; 1152 : 				if (_DEBUG_LT_PRED(this->comp,

  00064	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00067	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0006a	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  0006d	0f 83 b1 00 00
	00		 jae	 $LN1@Insert@3

; 1153 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1154 : 					return (_Insert(false, _Rmost(), _Node));

  00073	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00076	53		 push	 ebx
  00077	6a 00		 push	 0
  00079	57		 push	 edi
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00080	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00081	8b c7		 mov	 eax, edi
  00083	5b		 pop	 ebx

; 1181 : 		}

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c2 0c 00	 ret	 12			; 0000000cH
$LN11@Insert@3:

; 1155 : 				}
; 1156 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1157 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1158 : 				&& _DEBUG_LT_PRED(this->comp,

  0008a	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0008d	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  00090	73 36		 jae	 SHORT $LN8@Insert@3
  00092	8d 45 10	 lea	 eax, DWORD PTR __Next$[ebp]
  00095	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  00098	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >,std::_Iterator_base0>::operator--
  0009d	8b 4d 10	 mov	 ecx, DWORD PTR __Next$[ebp]
  000a0	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000a3	39 41 0c	 cmp	 DWORD PTR [ecx+12], eax
  000a6	73 20		 jae	 SHORT $LN8@Insert@3

; 1159 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1160 : 					this->_Kfn(_Val)))
; 1161 : 				{	// insert before _Where
; 1162 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  000a8	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ab	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0

; 1163 : 					return (_Insert(false, _Next._Mynode(), _Node));

  000af	53		 push	 ebx
  000b0	74 96		 je	 SHORT $LN7@Insert@3
  000b2	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	6a 00		 push	 0
  000b7	57		 push	 edi
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  000be	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  000bf	8b c7		 mov	 eax, edi
  000c1	5b		 pop	 ebx

; 1181 : 		}

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
$LN8@Insert@3:

; 1164 : 				else
; 1165 : 					return (_Insert(true, _Where._Mynode(), _Node));
; 1166 : 				}
; 1167 : 			else if (_DEBUG_LT_PRED(this->comp,
; 1168 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1169 : 				&& (++(_Next = _Where) == end()
; 1170 : 					|| _DEBUG_LT_PRED(this->comp,

  000c8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000cb	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  000ce	73 54		 jae	 SHORT $LN1@Insert@3
  000d0	8d 45 10	 lea	 eax, DWORD PTR __Next$[ebp]
  000d3	89 75 10	 mov	 DWORD PTR __Next$[ebp], esi
  000d6	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
  000db	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000de	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e1	39 08		 cmp	 DWORD PTR [eax], ecx
  000e3	8b 4d 10	 mov	 ecx, DWORD PTR __Next$[ebp]
  000e6	74 08		 je	 SHORT $LN3@Insert@3
  000e8	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  000eb	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000ee	73 34		 jae	 SHORT $LN1@Insert@3
$LN3@Insert@3:

; 1171 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1172 : 				{	// insert after _Where
; 1173 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  000f0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000f3	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 1174 : 					return (_Insert(false, _Where._Mynode(), _Node));

  000f7	53		 push	 ebx
  000f8	74 17		 je	 SHORT $LN2@Insert@3
  000fa	6a 00		 push	 0
  000fc	8b ca		 mov	 ecx, edx
  000fe	57		 push	 edi
  000ff	51		 push	 ecx
  00100	8b ce		 mov	 ecx, esi
  00102	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  00107	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00108	8b c7		 mov	 eax, edi
  0010a	5b		 pop	 ebx

; 1181 : 		}

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Insert@3:

; 1175 : 				else
; 1176 : 					return (_Insert(true, _Next._Mynode(), _Node));

  00111	6a 01		 push	 1
  00113	57		 push	 edi
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0011a	5e		 pop	 esi

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  0011b	8b c7		 mov	 eax, edi
  0011d	5b		 pop	 ebx

; 1181 : 		}

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 0c 00	 ret	 12			; 0000000cH
$LN1@Insert@3:

; 1177 : 				}
; 1178 : 			}
; 1179 : 
; 1180 : 		return (_Linsert(_Node, _Leftish).first);	// try usual insert

  00124	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00127	53		 push	 ebx
  00128	50		 push	 eax
  00129	8d 75 f8	 lea	 esi, DWORD PTR $T197455[ebp]
  0012c	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Linsert
  00131	8b 08		 mov	 ecx, DWORD PTR [eax]
  00133	5e		 pop	 esi
  00134	89 0f		 mov	 DWORD PTR [edi], ecx
  00136	8b c7		 mov	 eax, edi
  00138	5b		 pop	 ebx

; 1181 : 		}

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 0c 00	 ret	 12			; 0000000cH
?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = edi
; __Val$ = edx

; 278  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 279  : 		{	// try to insert node with value _Val
; 280  : 		_List.emplace_front(_STD forward<_Valty>(_Val));

  00003	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00006	53		 push	 ebx
  00007	8b 18		 mov	 ebx, DWORD PTR [eax]
  00009	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	53		 push	 ebx
  0000f	8b f2		 mov	 esi, edx
  00011	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00016	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00019	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0001e	2b d1		 sub	 edx, ecx
  00020	83 fa 01	 cmp	 edx, 1
  00023	73 0a		 jae	 SHORT $LN29@insert
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN82@insert:
$LN29@insert:

; 281  : 		return (_Insert(_List.front(), begin()));

  0002f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00032	41		 inc	 ecx
  00033	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00036	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	50		 push	 eax
  00044	56		 push	 esi
  00045	83 c0 08	 add	 eax, 8
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0004e	8b c6		 mov	 eax, esi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 282  : 		}

  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
$LN81@insert:
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >, COMDAT
; _this$ = eax
; __Val$ = ecx

; 760  : 		typename _STD tr1::enable_if<!_STD tr1::is_same<const_iterator,

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 08	 mov	 ebx, DWORD PTR ___$ReturnUdt$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f0		 mov	 esi, eax

; 761  : 			typename _STD tr1::remove_reference<_Valty>::type>::value,
; 762  : 				iterator>::type
; 763  : 		insert(const_iterator _Where,
; 764  : 			_Valty&& _Val)
; 765  : 		{	// try to insert node with value _Val using _Where as a hint
; 766  : 		return (_Insert(_Where,
; 767  : 			this->_Buynode(_STD forward<_Valty>(_Val))));

  0000b	8b f9		 mov	 edi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00012	50		 push	 eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00016	50		 push	 eax
  00017	56		 push	 esi
  00018	8b fb		 mov	 edi, ebx
  0001a	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	8b c3		 mov	 eax, ebx
  00023	5b		 pop	 ebx

; 768  : 		}

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
??$insert@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::insert<std::pair<unsigned int const ,cpp_object *> >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree.h
_TEXT	ENDS
;	COMDAT ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z
_TEXT	SEGMENT
$T198494 = -24						; size = 12
$T198429 = -20						; size = 8
_res$ = -12						; size = 12
$T198427 = -8						; size = 8
$T198449 = 8						; size = 4
_key$ = 8						; size = 4
_value$ = 12						; size = 4
??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 1744 : btree<P>::insert_unique(const key_type &key, ValuePointer value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx

; 1745 :   if (empty()) {

  00007	33 db		 xor	 ebx, ebx
  00009	39 1f		 cmp	 DWORD PTR [edi], ebx
  0000b	75 19		 jne	 SHORT $LN5@insert_uni

; 1746 :     *mutable_root() = new_leaf_root_node(1);

  0000d	6a 10		 push	 16			; 00000010H
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	3b c3		 cmp	 eax, ebx
  00019	74 5d		 je	 SHORT $LN18@insert_uni
  0001b	c7 00 01 00 01
	00		 mov	 DWORD PTR [eax], 65537	; 00010001H
  00021	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00024	89 07		 mov	 DWORD PTR [edi], eax
$LN5@insert_uni:

; 1747 :   }
; 1748 : 
; 1749 :   std::pair<iterator, int> res = internal_locate(key, iterator(root(), 0));

  00026	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00028	8b 55 08	 mov	 edx, DWORD PTR _key$[ebp]
  0002b	83 ec 08	 sub	 esp, 8
  0002e	8b c4		 mov	 eax, esp
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00035	52		 push	 edx
  00036	8d 45 f4	 lea	 eax, DWORD PTR _res$[ebp]
  00039	e8 00 00 00 00	 call	 ??$internal_locate_plain_compare@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@H@std@@ABIU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_locate_plain_compare<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >

; 1750 :   iterator &iter = res.first;
; 1751 :   if (res.second == kExactMatch) {

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _res$[ebp+8]
  00041	3d 00 00 00 40	 cmp	 eax, 1073741824		; 40000000H
  00046	75 54		 jne	 SHORT $LN4@insert_uni

; 1752 :     // The key already exists in the tree, do nothing.
; 1753 :     return std::make_pair(internal_last(iter), false);

  00048	8b 45 f4	 mov	 eax, DWORD PTR _res$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  0004e	3b c3		 cmp	 eax, ebx
  00050	74 15		 je	 SHORT $LN49@insert_uni
$LL50@insert_uni:
  00052	0f b6 50 03	 movzx	 edx, BYTE PTR [eax+3]
  00056	3b ca		 cmp	 ecx, edx
  00058	75 0d		 jne	 SHORT $LN49@insert_uni
  0005a	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	38 18		 cmp	 BYTE PTR [eax], bl
  00063	74 ed		 je	 SHORT $LL50@insert_uni
  00065	33 c0		 xor	 eax, eax
$LN49@insert_uni:
  00067	89 06		 mov	 DWORD PTR [esi], eax
  00069	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0006c	88 5e 08	 mov	 BYTE PTR [esi+8], bl

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  0006f	8b c6		 mov	 eax, esi

; 1763 : }

  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8

; 1746 :     *mutable_root() = new_leaf_root_node(1);

$LN18@insert_uni:
  00078	8d 45 08	 lea	 eax, DWORD PTR $T198449[ebp]
  0007b	50		 push	 eax
  0007c	8d 4d e8	 lea	 ecx, DWORD PTR $T198494[ebp]
  0007f	89 5d 08	 mov	 DWORD PTR $T198449[ebp], ebx
  00082	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00087	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0008c	8d 4d e8	 lea	 ecx, DWORD PTR $T198494[ebp]
  0008f	51		 push	 ecx
  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T198494[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00097	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN198@insert_uni:
$LN4@insert_uni:

; 1754 :   } else if (!res.second) {

  0009c	8b 55 f4	 mov	 edx, DWORD PTR _res$[ebp]
  0009f	3b c3		 cmp	 eax, ebx
  000a1	75 49		 jne	 SHORT $LN1@insert_uni

; 1755 :     iterator last = internal_last(iter);

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  000a6	8b c2		 mov	 eax, edx
  000a8	3b d3		 cmp	 edx, ebx
  000aa	74 40		 je	 SHORT $LN1@insert_uni
  000ac	8d 64 24 00	 npad	 4
$LL87@insert_uni:
  000b0	0f b6 58 03	 movzx	 ebx, BYTE PTR [eax+3]
  000b4	3b cb		 cmp	 ecx, ebx
  000b6	75 0f		 jne	 SHORT $LN86@insert_uni
  000b8	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  000bc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000bf	33 db		 xor	 ebx, ebx
  000c1	38 18		 cmp	 BYTE PTR [eax], bl
  000c3	74 eb		 je	 SHORT $LL87@insert_uni

; 1756 :     if (last.node && !compare_keys(key, last.key())) {

  000c5	eb 25		 jmp	 SHORT $LN1@insert_uni

; 1755 :     iterator last = internal_last(iter);

$LN86@insert_uni:

; 1756 :     if (last.node && !compare_keys(key, last.key())) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	3b c3		 cmp	 eax, ebx
  000cb	74 1f		 je	 SHORT $LN1@insert_uni
  000cd	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
  000d0	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  000d2	3b 5c c8 08	 cmp	 ebx, DWORD PTR [eax+ecx*8+8]
  000d6	72 12		 jb	 SHORT $LN194@insert_uni

; 1757 :       // The key already exists in the tree, do nothing.
; 1758 :       return std::make_pair(last, false);

  000d8	89 06		 mov	 DWORD PTR [esi], eax
  000da	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  000dd	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  000e1	8b c6		 mov	 eax, esi

; 1763 : }

  000e3	5b		 pop	 ebx
  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c2 08 00	 ret	 8
$LN194@insert_uni:

; 1757 :       // The key already exists in the tree, do nothing.
; 1758 :       return std::make_pair(last, false);

  000ea	33 db		 xor	 ebx, ebx
$LN1@insert_uni:

; 1759 :     }
; 1760 :   }
; 1761 : 
; 1762 :   return std::make_pair(internal_insert(iter, *value), true);

  000ec	8b 4d f8	 mov	 ecx, DWORD PTR _res$[ebp+4]
  000ef	83 ec 08	 sub	 esp, 8
  000f2	8b c4		 mov	 eax, esp
  000f4	89 10		 mov	 DWORD PTR [eax], edx
  000f6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000f9	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  000fc	8b 02		 mov	 eax, DWORD PTR [edx]
  000fe	8d 4d f8	 lea	 ecx, DWORD PTR $T198427[ebp]
  00101	51		 push	 ecx
  00102	8d 55 ec	 lea	 edx, DWORD PTR $T198429[ebp]
  00105	89 45 f8	 mov	 DWORD PTR $T198427[ebp], eax
  00108	52		 push	 edx
  00109	8b c7		 mov	 eax, edi
  0010b	89 5d fc	 mov	 DWORD PTR $T198427[ebp+4], ebx
  0010e	e8 00 00 00 00	 call	 ?internal_insert@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@ABU?$pair@$$CBIPAUgoogle_object@@@std@@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_insert
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00118	89 0e		 mov	 DWORD PTR [esi], ecx
  0011a	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0011d	c6 46 08 01	 mov	 BYTE PTR [esi+8], 1
  00121	8b c6		 mov	 eax, esi

; 1763 : }

  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 08 00	 ret	 8
$LN196@insert_uni:
??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z
_TEXT	SEGMENT
_res$ = -8						; size = 8
_this$ = 8						; size = 4
_internal_delete$ = 11					; size = 1
___$ReturnUdt$ = 12					; size = 4
_iter$ = 16						; size = 8
?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z PROC ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase, COMDAT

; 1863 : typename btree<P>::iterator btree<P>::erase(iterator iter) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi

; 1864 :   bool internal_delete = false;
; 1865 :   if (!iter.node->leaf()) {

  0000b	8b 75 10	 mov	 esi, DWORD PTR _iter$[ebp]
  0000e	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00011	57		 push	 edi
  00012	c6 45 0b 00	 mov	 BYTE PTR _internal_delete$[ebp], 0
  00016	75 37		 jne	 SHORT $LN12@erase@7

; 1866 :     // Deletion of a value on an internal node. Swap the key with the largest
; 1867 :     // value of our left child. This is easy, we just decrement iter.
; 1868 :     iterator tmp_iter(iter--);

  00018	8b 7d 14	 mov	 edi, DWORD PTR _iter$[ebp+4]
  0001b	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  0001e	e8 00 00 00 00	 call	 ?decrement_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::decrement_slow

; 1869 :     assert(iter.node->leaf());
; 1870 :     assert(!compare_keys(tmp_iter.key(), iter.key()));
; 1871 :     iter.node->value_swap(iter.position, tmp_iter.node, tmp_iter.position);

  00023	8b 4d 14	 mov	 ecx, DWORD PTR _iter$[ebp+4]
  00026	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  00029	8b 54 fe 08	 mov	 edx, DWORD PTR [esi+edi*8+8]
  0002d	8d 44 c8 08	 lea	 eax, DWORD PTR [eax+ecx*8+8]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	89 10		 mov	 DWORD PTR [eax], edx
  00035	89 4c fe 08	 mov	 DWORD PTR [esi+edi*8+8], ecx
  00039	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003c	8d 4c fe 0c	 lea	 ecx, DWORD PTR [esi+edi*8+12]
  00040	8b 31		 mov	 esi, DWORD PTR [ecx]
  00042	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00045	89 11		 mov	 DWORD PTR [ecx], edx

; 1872 :     internal_delete = true;
; 1873 :     --*mutable_size();

  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	c6 45 0b 01	 mov	 BYTE PTR _internal_delete$[ebp], 1
  0004d	eb 07		 jmp	 SHORT $LN120@erase@7
$LN12@erase@7:

; 1874 :   } else if (!root()->leaf()) {

  0004f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00051	80 38 00	 cmp	 BYTE PTR [eax], 0
  00054	75 06		 jne	 SHORT $LN10@erase@7
$LN120@erase@7:

; 1875 :     --*mutable_size();

  00056	ff 88 84 01 00
	00		 dec	 DWORD PTR [eax+388]
$LN10@erase@7:

; 1876 :   }
; 1877 : 
; 1878 :   // Delete the key from the leaf.
; 1879 :   iter.node->remove_value(iter.position);

  0005c	8b 45 14	 mov	 eax, DWORD PTR _iter$[ebp+4]
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00062	e8 00 00 00 00	 call	 ?remove_value@?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@QAEXH@Z ; btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::remove_value

; 1880 : 
; 1881 :   // We want to return the next value after the one we just erased. If we
; 1882 :   // erased from an internal node (internal_delete == true), then the next
; 1883 :   // value is ++(++iter). If we erased from a leaf node (internal_delete ==
; 1884 :   // false) then the next value is ++iter. Note that ++iter may point to an
; 1885 :   // internal node and the value in the internal node may move to a leaf node
; 1886 :   // (iter.node) when rebalancing is performed at the leaf level.
; 1887 : 
; 1888 :   // Merge/rebalance as we walk back up the tree.
; 1889 :   iterator res(iter);

  00067	8b 45 10	 mov	 eax, DWORD PTR _iter$[ebp]
  0006a	8b 75 14	 mov	 esi, DWORD PTR _iter$[ebp+4]
  0006d	8b f8		 mov	 edi, eax
  0006f	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
  00072	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi

; 1890 :   for (;;) {
; 1891 :     if (iter.node == root()) {

  00075	3b 03		 cmp	 eax, DWORD PTR [ebx]
  00077	74 38		 je	 SHORT $LN112@erase@7
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL9@erase@7:

; 1895 :       }
; 1896 :       break;
; 1897 :     }
; 1898 :     if (iter.node->count() >= kMinNodeValues) {

  00080	80 78 03 0f	 cmp	 BYTE PTR [eax+3], 15	; 0000000fH
  00084	73 4d		 jae	 SHORT $LN119@erase@7

; 1899 :       break;
; 1900 :     }
; 1901 :     bool merged = try_merge_or_rebalance(&iter);

  00086	8d 45 10	 lea	 eax, DWORD PTR _iter$[ebp]
  00089	50		 push	 eax
  0008a	53		 push	 ebx
  0008b	e8 00 00 00 00	 call	 ?try_merge_or_rebalance@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE_NPAU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_merge_or_rebalance

; 1902 :     if (iter.node->leaf()) {

  00090	8b 4d 10	 mov	 ecx, DWORD PTR _iter$[ebp]
  00093	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00096	74 05		 je	 SHORT $LN4@erase@7

; 1903 :       res = iter;

  00098	8b 75 14	 mov	 esi, DWORD PTR _iter$[ebp+4]
  0009b	8b f9		 mov	 edi, ecx
$LN4@erase@7:

; 1904 :     }
; 1905 :     if (!merged) {

  0009d	84 c0		 test	 al, al
  0009f	74 32		 je	 SHORT $LN119@erase@7

; 1906 :       break;
; 1907 :     }
; 1908 :     iter.node = iter.node->parent();

  000a1	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a4	89 45 10	 mov	 DWORD PTR _iter$[ebp], eax
  000a7	3b 03		 cmp	 eax, DWORD PTR [ebx]
  000a9	75 d5		 jne	 SHORT $LL9@erase@7

; 1903 :       res = iter;

  000ab	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000ae	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
$LN112@erase@7:

; 1892 :       try_shrink();

  000b1	53		 push	 ebx
  000b2	e8 00 00 00 00	 call	 ?try_shrink@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXXZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::try_shrink

; 1893 :       if (empty()) {

  000b7	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  000ba	75 1d		 jne	 SHORT $LN6@erase@7

; 1894 :         return end();

  000bc	8b 75 0c	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	8b c6		 mov	 eax, esi
  000c1	8b cb		 mov	 ecx, ebx
  000c3	e8 00 00 00 00	 call	 ?end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@XZ ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::end
  000c8	8b c6		 mov	 eax, esi

; 1922 : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 10 00	 ret	 16			; 00000010H
$LN119@erase@7:

; 1903 :       res = iter;

  000d3	89 7d f8	 mov	 DWORD PTR _res$[ebp], edi
  000d6	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
$LN6@erase@7:

; 1909 :   }
; 1910 : 
; 1911 :   // Adjust our return value. If we're pointing at the end of a node, advance
; 1912 :   // the iterator.
; 1913 :   if (res.position == res.node->count()) {

  000d9	0f b6 47 03	 movzx	 eax, BYTE PTR [edi+3]
  000dd	3b f0		 cmp	 esi, eax
  000df	75 21		 jne	 SHORT $LN93@erase@7

; 1914 :     res.position = res.node->count() - 1;
; 1915 :     ++res;

  000e1	80 3f 00	 cmp	 BYTE PTR [edi], 0
  000e4	8d 70 ff	 lea	 esi, DWORD PTR [eax-1]
  000e7	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000ea	74 08		 je	 SHORT $LN92@erase@7
  000ec	46		 inc	 esi
  000ed	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  000f0	3b f0		 cmp	 esi, eax
  000f2	7c 0e		 jl	 SHORT $LN93@erase@7
$LN92@erase@7:
  000f4	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  000f7	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
  000fc	8b 75 fc	 mov	 esi, DWORD PTR _res$[ebp+4]
  000ff	8b 7d f8	 mov	 edi, DWORD PTR _res$[ebp]
$LN93@erase@7:

; 1916 :   }
; 1917 :   // If we erased from an internal node, advance the iterator.
; 1918 :   if (internal_delete) {

  00102	80 7d 0b 00	 cmp	 BYTE PTR _internal_delete$[ebp], 0
  00106	74 1f		 je	 SHORT $LN102@erase@7

; 1919 :     ++res;

  00108	80 3f 00	 cmp	 BYTE PTR [edi], 0
  0010b	74 0c		 je	 SHORT $LN101@erase@7
  0010d	0f b6 4f 03	 movzx	 ecx, BYTE PTR [edi+3]
  00111	46		 inc	 esi
  00112	89 75 fc	 mov	 DWORD PTR _res$[ebp+4], esi
  00115	3b f1		 cmp	 esi, ecx
  00117	7c 0e		 jl	 SHORT $LN102@erase@7
$LN101@erase@7:
  00119	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  0011c	e8 00 00 00 00	 call	 ?increment_slow@?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@QAEXXZ ; btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *>::increment_slow
  00121	8b 75 fc	 mov	 esi, DWORD PTR _res$[ebp+4]
  00124	8b 7d f8	 mov	 edi, DWORD PTR _res$[ebp]
$LN102@erase@7:

; 1920 :   }
; 1921 :   return res;

  00127	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0012a	89 38		 mov	 DWORD PTR [eax], edi

; 1922 : }

  0012c	5f		 pop	 edi
  0012d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 10 00	 ret	 16			; 00000010H
?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ENDP ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 415  :     return test_deleted_key(get_key(*it));

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN13@test_delet@4
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN13@test_delet@4
  00010	b8 01 00 00 00	 mov	 eax, 1

; 416  :   }

  00015	c3		 ret	 0

; 415  :     return test_deleted_key(get_key(*it));

$LN13@test_delet@4:
  00016	33 c0		 xor	 eax, eax

; 416  :   }

  00018	c3		 ret	 0
?test_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE_NABU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::test_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ
_TEXT	SEGMENT
?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted, COMDAT
; _this$ = eax

; 236  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN40@advance_pa@2
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@advance_pa@2:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN1@advance_pa@2
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN50@advance_pa@2
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN50@advance_pa@2
$LN1@advance_pa@2:

; 237  :       ++pos;

  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL3@advance_pa@2
$LN50@advance_pa@2:
  00030	5e		 pop	 esi

; 236  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

$LN40@advance_pa@2:

; 238  :   }

  00031	c3		 ret	 0
?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z
_TEXT	SEGMENT
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 219  :     if (advance)  advance_past_empty_and_deleted();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN46@dense_hash@5
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@dense_hash@5:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN7@dense_hash@5
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN59@dense_hash@5
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN59@dense_hash@5
$LN7@dense_hash@5:
  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL9@dense_hash@5
$LN59@dense_hash@5:
  00030	5e		 pop	 esi
$LN46@dense_hash@5:

; 220  :   }

  00031	c3		 ret	 0
??0?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PBU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ
_TEXT	SEGMENT
??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ PROC ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++, COMDAT
; _this$ = eax

; 240  :     assert(pos != end); ++pos; advance_past_empty_and_deleted(); return *this;

  00000	83 40 04 08	 add	 DWORD PTR [eax+4], 8
  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0000a	74 22		 je	 SHORT $LN42@operator@14
  0000c	56		 push	 esi
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	90		 npad	 1
$LL5@operator@14:
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	39 56 2c	 cmp	 DWORD PTR [esi+44], edx
  00015	74 0b		 je	 SHORT $LN3@operator@14
  00017	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001b	76 10		 jbe	 SHORT $LN55@operator@14
  0001d	39 56 1c	 cmp	 DWORD PTR [esi+28], edx
  00020	75 0b		 jne	 SHORT $LN55@operator@14
$LN3@operator@14:
  00022	83 c1 08	 add	 ecx, 8
  00025	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00028	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0002b	75 e3		 jne	 SHORT $LL5@operator@14
$LN55@operator@14:
  0002d	5e		 pop	 esi
$LN42@operator@14:

; 241  :   }

  0002e	c3		 ret	 0
??E?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU01@XZ ENDP ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator++
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 314  :                                                        table+num_buckets,true);}

  00000	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00003	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00006	89 06		 mov	 DWORD PTR [esi], eax
  00008	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00011	8b c6		 mov	 eax, esi
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 312  :                                                        table+num_buckets,true);}

  00000	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00003	89 06		 mov	 DWORD PTR [esi], eax
  00005	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00008	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0000b	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  0000e	8b c6		 mov	 eax, esi
  00010	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_const_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?begin@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QBE?AU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::begin
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z
_TEXT	SEGMENT
_it$157222 = -16					; size = 12
tv647 = -4						; size = 4
_this$ = 8						; size = 4
_ht$ = 12						; size = 4
?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from, COMDAT
; _min_buckets_wanted$ = eax

; 614  :   void copy_from(const dense_hashtable &ht, size_type min_buckets_wanted) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _ht$[ebp]

; 615  :     clear_to_size(settings.min_buckets(ht.size(), min_buckets_wanted));

  0000f	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  00012	2b 57 20	 sub	 edx, DWORD PTR [edi+32]
  00015	8b f0		 mov	 esi, eax
  00017	8b c3		 mov	 eax, ebx
  00019	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
  0001e	8b f3		 mov	 esi, ebx
  00020	e8 00 00 00 00	 call	 ?clear_to_size@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_to_size

; 616  : 
; 617  :     // We use a normal iterator to get non-deleted bcks from ht
; 618  :     // We could use insert() here, but since we know there are
; 619  :     // no duplicates and no deleted items, we can be more efficient
; 620  :     assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
; 621  :     for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {

  00025	8b 77 34	 mov	 esi, DWORD PTR [edi+52]
  00028	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0002b	8d 0c c6	 lea	 ecx, DWORD PTR [esi+eax*8]
  0002e	89 4d f8	 mov	 DWORD PTR _it$157222[ebp+8], ecx
  00031	3b f1		 cmp	 esi, ecx
  00033	74 1b		 je	 SHORT $LL257@copy_from
  00035	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL18@copy_from:
  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	3b d0		 cmp	 edx, eax
  0003c	74 0b		 je	 SHORT $LN254@copy_from
  0003e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00042	76 0c		 jbe	 SHORT $LL257@copy_from
  00044	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00047	75 07		 jne	 SHORT $LL257@copy_from
$LN254@copy_from:
  00049	83 c6 08	 add	 esi, 8
  0004c	3b f1		 cmp	 esi, ecx
  0004e	75 e8		 jne	 SHORT $LL18@copy_from
$LL257@copy_from:
  00050	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00053	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00056	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00059	89 45 fc	 mov	 DWORD PTR tv647[ebp], eax
  0005c	3b c0		 cmp	 eax, eax
  0005e	74 1c		 je	 SHORT $LN253@copy_from
  00060	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
$LL119@copy_from:
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	3b d1		 cmp	 edx, ecx
  00067	74 0b		 je	 SHORT $LN252@copy_from
  00069	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0006d	76 0d		 jbe	 SHORT $LN253@copy_from
  0006f	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00072	75 08		 jne	 SHORT $LN253@copy_from
$LN252@copy_from:
  00074	83 c0 08	 add	 eax, 8
  00077	3b 45 fc	 cmp	 eax, DWORD PTR tv647[ebp]
  0007a	75 e7		 jne	 SHORT $LL119@copy_from
$LN253@copy_from:
  0007c	3b f0		 cmp	 esi, eax
  0007e	0f 84 b1 00 00
	00		 je	 $LN250@copy_from

; 622  :       size_type num_probes = 0;              // how many times we've probed
; 623  :       size_type bucknum;
; 624  :       const size_type bucket_count_minus_one = bucket_count() - 1;
; 625  :       for (bucknum = hash(get_key(*it)) & bucket_count_minus_one;

  00084	8b 06		 mov	 eax, DWORD PTR [esi]
  00086	8b c8		 mov	 ecx, eax
  00088	c1 e1 06	 shl	 ecx, 6
  0008b	2b c1		 sub	 eax, ecx
  0008d	8b c8		 mov	 ecx, eax
  0008f	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00092	33 c1		 xor	 eax, ecx
  00094	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00097	8b c8		 mov	 ecx, eax
  00099	c1 e1 09	 shl	 ecx, 9
  0009c	2b c1		 sub	 eax, ecx
  0009e	8b c8		 mov	 ecx, eax
  000a0	c1 e1 04	 shl	 ecx, 4
  000a3	33 c1		 xor	 eax, ecx
  000a5	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  000ac	2b c1		 sub	 eax, ecx
  000ae	8b c8		 mov	 ecx, eax
  000b0	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  000b3	33 c1		 xor	 eax, ecx
  000b5	8b c8		 mov	 ecx, eax
  000b7	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  000ba	33 c8		 xor	 ecx, eax

; 626  :            !test_empty(bucknum);                               // not empty
; 627  :            bucknum = (bucknum + JUMP_(key, num_probes)) & bucket_count_minus_one) {

  000bc	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000bf	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]
  000c2	4a		 dec	 edx
  000c3	23 ca		 and	 ecx, edx
  000c5	33 ff		 xor	 edi, edi
  000c7	3b 1c c8	 cmp	 ebx, DWORD PTR [eax+ecx*8]
  000ca	74 13		 je	 SHORT $LN1@copy_from
  000cc	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000cf	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000d2	8b 5b 2c	 mov	 ebx, DWORD PTR [ebx+44]
$LL3@copy_from:

; 628  :         ++num_probes;

  000d5	47		 inc	 edi
  000d6	03 cf		 add	 ecx, edi
  000d8	23 ca		 and	 ecx, edx
  000da	3b 1c c8	 cmp	 ebx, DWORD PTR [eax+ecx*8]
  000dd	75 f6		 jne	 SHORT $LL3@copy_from
$LN1@copy_from:

; 629  :         assert(num_probes < bucket_count()
; 630  :                && "Hashtable is full: an error in key_equal<> or hash<>");
; 631  :       }
; 632  :       set_value(&table[bucknum], *it);       // copies the value to here

  000df	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000e2	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000e5	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  000e8	85 c9		 test	 ecx, ecx
  000ea	74 0a		 je	 SHORT $LN208@copy_from
  000ec	8b 06		 mov	 eax, DWORD PTR [esi]
  000ee	89 01		 mov	 DWORD PTR [ecx], eax
  000f0	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000f3	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN208@copy_from:

; 633  :       num_elements++;

  000f6	8b 4d f8	 mov	 ecx, DWORD PTR _it$157222[ebp+8]
  000f9	ff 43 24	 inc	 DWORD PTR [ebx+36]
  000fc	8b 7d 0c	 mov	 edi, DWORD PTR _ht$[ebp]
  000ff	83 c6 08	 add	 esi, 8
  00102	3b f1		 cmp	 esi, ecx
  00104	0f 84 46 ff ff
	ff		 je	 $LL257@copy_from
  0010a	8b 57 2c	 mov	 edx, DWORD PTR [edi+44]
  0010d	8d 49 00	 npad	 3

; 616  : 
; 617  :     // We use a normal iterator to get non-deleted bcks from ht
; 618  :     // We could use insert() here, but since we know there are
; 619  :     // no duplicates and no deleted items, we can be more efficient
; 620  :     assert((bucket_count() & (bucket_count()-1)) == 0);      // a power of two
; 621  :     for ( const_iterator it = ht.begin(); it != ht.end(); ++it ) {

$LL67@copy_from:
  00110	8b 06		 mov	 eax, DWORD PTR [esi]
  00112	3b d0		 cmp	 edx, eax
  00114	74 13		 je	 SHORT $LN255@copy_from
  00116	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0011a	0f 86 30 ff ff
	ff		 jbe	 $LL257@copy_from
  00120	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00123	0f 85 27 ff ff
	ff		 jne	 $LL257@copy_from
$LN255@copy_from:
  00129	83 c6 08	 add	 esi, 8
  0012c	3b f1		 cmp	 esi, ecx
  0012e	75 e0		 jne	 SHORT $LL67@copy_from
  00130	e9 1b ff ff ff	 jmp	 $LL257@copy_from
$LN250@copy_from:

; 634  :     }
; 635  :     settings.inc_num_ht_copies();

  00135	ff 43 14	 inc	 DWORD PTR [ebx+20]
  00138	5f		 pop	 edi
  00139	5e		 pop	 esi
  0013a	5b		 pop	 ebx

; 636  :   }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = eax

; 271  : 		_Myiter _Tmp = *this;

  00000	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 272  : 		++*this;

  00002	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00006	89 08		 mov	 DWORD PTR [eax], ecx
  00008	75 40		 jne	 SHORT $LN7@operator@15
  0000a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0000d	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00011	75 1a		 jne	 SHORT $LN38@operator@15
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	75 0f		 jne	 SHORT $LN21@operator@15
  0001b	eb 03 8d 49 00	 npad	 5
$LL22@operator@15:
  00020	8b d1		 mov	 edx, ecx
  00022	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00024	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00028	74 f6		 je	 SHORT $LL22@operator@15
$LN21@operator@15:
  0002a	89 16		 mov	 DWORD PTR [esi], edx

; 273  : 		return (_Tmp);
; 274  : 		}

  0002c	c3		 ret	 0
$LN38@operator@15:

; 272  : 		++*this;

  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00034	75 12		 jne	 SHORT $LN5@operator@15
$LL6@operator@15:
  00036	8b 16		 mov	 edx, DWORD PTR [esi]
  00038	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003b	75 0b		 jne	 SHORT $LN5@operator@15
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00042	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00046	74 ee		 je	 SHORT $LL6@operator@15
$LN5@operator@15:
  00048	89 0e		 mov	 DWORD PTR [esi], ecx
$LN7@operator@15:

; 273  : 		return (_Tmp);
; 274  : 		}

  0004a	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ
_TEXT	SEGMENT
?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted, COMDAT
; _this$ = eax

; 178  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN40@advance_pa@3
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL3@advance_pa@3:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN1@advance_pa@3
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN50@advance_pa@3
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN50@advance_pa@3
$LN1@advance_pa@3:

; 179  :       ++pos;

  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL3@advance_pa@3
$LN50@advance_pa@3:
  00030	5e		 pop	 esi

; 178  :     while ( pos != end && (ht->test_empty(*this) || ht->test_deleted(*this)) )

$LN40@advance_pa@3:

; 180  :   }

  00031	c3		 ret	 0
?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z
_TEXT	SEGMENT
tv281 = -12						; size = 8
tv272 = -12						; size = 8
tv259 = -12						; size = 8
tv251 = -12						; size = 8
tv290 = -8						; size = 4
tv283 = -8						; size = 4
tv274 = -8						; size = 4
tv269 = -8						; size = 4
tv261 = -8						; size = 4
tv253 = -8						; size = 4
tv286 = -2						; size = 2
tv278 = -2						; size = 2
tv265 = -2						; size = 2
tv256 = -2						; size = 2
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = edi
; _ht$ = ecx
; _min_buckets_wanted$ = eax

; 697  :         table(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 01	 movq	 xmm0, QWORD PTR [ecx]
  00007	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  0000b	f3 0f 7e 41 08	 movq	 xmm0, QWORD PTR [ecx+8]
  00010	66 0f d6 47 08	 movq	 QWORD PTR [edi+8], xmm0
  00015	f3 0f 7e 41 10	 movq	 xmm0, QWORD PTR [ecx+16]
  0001a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001d	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	8b f0		 mov	 esi, eax
  00026	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00029	89 47 18	 mov	 DWORD PTR [edi+24], eax
  0002c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002f	33 db		 xor	 ebx, ebx
  00031	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  00034	89 5f 20	 mov	 DWORD PTR [edi+32], ebx
  00037	89 5f 24	 mov	 DWORD PTR [edi+36], ebx
  0003a	89 5f 28	 mov	 DWORD PTR [edi+40], ebx
  0003d	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  00040	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  00043	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00046	89 57 30	 mov	 DWORD PTR [edi+48], edx
  00049	89 5f 34	 mov	 DWORD PTR [edi+52], ebx

; 698  :     if (!ht.settings.use_empty()) {

  0004c	38 59 11	 cmp	 BYTE PTR [ecx+17], bl
  0004f	75 6e		 jne	 SHORT $LN1@dense_hash@6

; 699  :       // If use_empty isn't set, copy_from will crash, so we do our own copying.
; 700  :       assert(ht.empty());
; 701  :       num_buckets = settings.min_buckets(ht.size(), min_buckets_wanted);

  00051	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00054	2b 51 20	 sub	 edx, DWORD PTR [ecx+32]
  00057	8b c7		 mov	 eax, edi
  00059	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets

; 702  :       settings.reset_thresholds(bucket_count());

  0005e	89 45 f8	 mov	 DWORD PTR tv290[ebp], eax
  00061	db 45 f8	 fild	 DWORD PTR tv290[ebp]
  00064	89 47 28	 mov	 DWORD PTR [edi+40], eax
  00067	85 c0		 test	 eax, eax
  00069	79 06		 jns	 SHORT $LN42@dense_hash@6
  0006b	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN42@dense_hash@6:
  00071	d9 47 08	 fld	 DWORD PTR [edi+8]
  00074	5e		 pop	 esi
  00075	d9 7d fe	 fnstcw	 WORD PTR tv286[ebp]
  00078	88 5f 10	 mov	 BYTE PTR [edi+16], bl
  0007b	0f b7 45 fe	 movzx	 eax, WORD PTR tv286[ebp]
  0007f	d8 c9		 fmul	 ST(0), ST(1)
  00081	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00086	89 45 f8	 mov	 DWORD PTR tv283[ebp], eax
  00089	5b		 pop	 ebx
  0008a	d9 6d f8	 fldcw	 WORD PTR tv283[ebp]
  0008d	df 7d f4	 fistp	 QWORD PTR tv281[ebp]
  00090	8b 45 f4	 mov	 eax, DWORD PTR tv281[ebp]
  00093	89 07		 mov	 DWORD PTR [edi], eax
  00095	d9 6d fe	 fldcw	 WORD PTR tv286[ebp]
  00098	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  0009b	d9 7d fe	 fnstcw	 WORD PTR tv278[ebp]
  0009e	0f b7 45 fe	 movzx	 eax, WORD PTR tv278[ebp]
  000a2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000a7	89 45 f8	 mov	 DWORD PTR tv274[ebp], eax

; 707  :   }

  000aa	8b c7		 mov	 eax, edi
  000ac	d9 6d f8	 fldcw	 WORD PTR tv274[ebp]
  000af	df 7d f4	 fistp	 QWORD PTR tv272[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR tv272[ebp]
  000b5	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  000b8	d9 6d fe	 fldcw	 WORD PTR tv278[ebp]
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c3		 ret	 0
$LN1@dense_hash@6:

; 703  :       return;
; 704  :     }
; 705  :     settings.reset_thresholds(bucket_count());

  000bf	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  000c2	db 47 28	 fild	 DWORD PTR [edi+40]
  000c5	85 d2		 test	 edx, edx
  000c7	79 06		 jns	 SHORT $LN43@dense_hash@6
  000c9	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN43@dense_hash@6:
  000cf	d9 47 08	 fld	 DWORD PTR [edi+8]

; 706  :     copy_from(ht, min_buckets_wanted);   // copy_from() ignores deleted entries

  000d2	51		 push	 ecx
  000d3	d9 7d fe	 fnstcw	 WORD PTR tv265[ebp]
  000d6	57		 push	 edi
  000d7	0f b7 45 fe	 movzx	 eax, WORD PTR tv265[ebp]
  000db	d8 c9		 fmul	 ST(0), ST(1)
  000dd	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e2	89 45 f8	 mov	 DWORD PTR tv261[ebp], eax
  000e5	88 5f 10	 mov	 BYTE PTR [edi+16], bl
  000e8	d9 6d f8	 fldcw	 WORD PTR tv261[ebp]
  000eb	df 7d f4	 fistp	 QWORD PTR tv259[ebp]
  000ee	8b 45 f4	 mov	 eax, DWORD PTR tv259[ebp]
  000f1	89 07		 mov	 DWORD PTR [edi], eax
  000f3	d9 6d fe	 fldcw	 WORD PTR tv265[ebp]
  000f6	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  000f9	d9 7d fe	 fnstcw	 WORD PTR tv256[ebp]
  000fc	0f b7 45 fe	 movzx	 eax, WORD PTR tv256[ebp]
  00100	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00105	89 45 f8	 mov	 DWORD PTR tv253[ebp], eax
  00108	8b c6		 mov	 eax, esi
  0010a	d9 6d f8	 fldcw	 WORD PTR tv253[ebp]
  0010d	df 7d f4	 fistp	 QWORD PTR tv251[ebp]
  00110	8b 55 f4	 mov	 edx, DWORD PTR tv251[ebp]
  00113	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00116	d9 6d fe	 fldcw	 WORD PTR tv256[ebp]
  00119	e8 00 00 00 00	 call	 ?copy_from@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXABV12@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::copy_from
  0011e	5e		 pop	 esi

; 707  :   }

  0011f	8b c7		 mov	 eax, edi
  00121	5b		 pop	 ebx
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0
??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z
_TEXT	SEGMENT
??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z PROC ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >, COMDAT
; _this$ = eax

; 165  :     if (advance)  advance_past_empty_and_deleted();

  00000	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00003	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00006	74 29		 je	 SHORT $LN46@dense_hash@7
  00008	56		 push	 esi
  00009	8b 30		 mov	 esi, DWORD PTR [eax]
  0000b	eb 03 8d 49 00	 npad	 5
$LL9@dense_hash@7:
  00010	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00013	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00015	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00018	74 0b		 je	 SHORT $LN7@dense_hash@7
  0001a	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001e	76 10		 jbe	 SHORT $LN59@dense_hash@7
  00020	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00023	75 0b		 jne	 SHORT $LN59@dense_hash@7
$LN7@dense_hash@7:
  00025	83 c2 08	 add	 edx, 8
  00028	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0002b	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0002e	75 e0		 jne	 SHORT $LL9@dense_hash@7
$LN59@dense_hash@7:
  00030	5e		 pop	 esi
$LN46@dense_hash@7:

; 166  :   }

  00031	c3		 ret	 0
??0?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@PBV?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@1@PAU?$pair@$$CBIPAUgoogle_object@@@std@@1_N@Z ENDP ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T201648 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax
  0000d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 19		 jne	 SHORT $LN97@erase@8
  00014	3b d0		 cmp	 edx, eax
  00016	75 15		 jne	 SHORT $LN97@erase@8

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::clear

; 1383 : 			return (begin());

  0001d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00022	8b c6		 mov	 eax, esi
  00024	89 0e		 mov	 DWORD PTR [esi], ecx
  00026	5f		 pop	 edi

; 1390 : 			}
; 1391 : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
$LN97@erase@8:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  0002d	3b ca		 cmp	 ecx, edx
  0002f	74 60		 je	 SHORT $LN1@erase@8
$LL2@erase@8:

; 1388 : 				erase(_First++);

  00031	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00035	8b d1		 mov	 edx, ecx
  00037	75 45		 jne	 SHORT $LN59@erase@8
  00039	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003c	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00040	75 1d		 jne	 SHORT $LN99@erase@8
  00042	8b c8		 mov	 ecx, eax
  00044	8b 01		 mov	 eax, DWORD PTR [ecx]
  00046	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0004a	75 0e		 jne	 SHORT $LN73@erase@8
  0004c	8d 64 24 00	 npad	 4
$LL74@erase@8:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00058	74 f6		 je	 SHORT $LL74@erase@8
$LN73@erase@8:
  0005a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@8
$LN99@erase@8:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00066	75 13		 jne	 SHORT $LN57@erase@8
$LL58@erase@8:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@8
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00079	74 ed		 je	 SHORT $LL58@erase@8
$LN57@erase@8:
  0007b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@8:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T201648[ebp]
  00082	52		 push	 edx
  00083	57		 push	 edi
  00084	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0008c	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0008f	75 a0		 jne	 SHORT $LL2@erase@8
$LN1@erase@8:

; 1389 : 			return (iterator(_First._Ptr, this));

  00091	8b c6		 mov	 eax, esi
  00093	89 0e		 mov	 DWORD PTR [esi], ecx
  00095	5f		 pop	 edi

; 1390 : 			}
; 1391 : 		}

  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ
_TEXT	SEGMENT
_tmp$155909 = -64					; size = 56
tv209 = -8						; size = 4
tv205 = -8						; size = 4
_shrink_factor$155904 = -4				; size = 4
?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink, COMDAT
; _this$ = esi

; 524  :   bool maybe_shrink() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 525  :     assert(num_elements >= num_deleted);
; 526  :     assert((bucket_count() & (bucket_count()-1)) == 0); // is a power of two
; 527  :     assert(bucket_count() >= HT_MIN_BUCKETS);
; 528  :     bool retval = false;
; 529  : 
; 530  :     // If you construct a hashtable with < HT_DEFAULT_STARTING_BUCKETS,
; 531  :     // we'll never shrink until you get relatively big, and we'll never
; 532  :     // shrink below HT_DEFAULT_STARTING_BUCKETS.  Otherwise, something
; 533  :     // like "dense_hash_set<int> x; x.insert(4); x.erase(4);" will
; 534  :     // shrink us down to HT_MIN_BUCKETS buckets, which is too small.
; 535  :     const size_type num_remain = num_elements - num_deleted;

  00003	8b 46 24	 mov	 eax, DWORD PTR [esi+36]

; 536  :     const size_type shrink_threshold = settings.shrink_threshold();

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	2b 46 20	 sub	 eax, DWORD PTR [esi+32]
  0000c	83 ec 40	 sub	 esp, 64			; 00000040H
  0000f	53		 push	 ebx
  00010	32 db		 xor	 bl, bl
  00012	57		 push	 edi

; 537  :     if (shrink_threshold > 0 && num_remain < shrink_threshold &&
; 538  :         bucket_count() > HT_DEFAULT_STARTING_BUCKETS) {

  00013	85 c9		 test	 ecx, ecx
  00015	74 7a		 je	 SHORT $LN23@maybe_shri
  00017	3b c1		 cmp	 eax, ecx
  00019	73 76		 jae	 SHORT $LN23@maybe_shri
  0001b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00021	76 6e		 jbe	 SHORT $LN23@maybe_shri

; 539  :       const float shrink_factor = settings.shrink_factor();

  00023	f3 0f 10 46 0c	 movss	 xmm0, DWORD PTR [esi+12]

; 540  :       size_type sz = bucket_count() / 2;    // find how much we should shrink

  00028	d1 e9		 shr	 ecx, 1
  0002a	f3 0f 11 45 fc	 movss	 DWORD PTR _shrink_factor$155904[ebp], xmm0

; 541  :       while (sz > HT_DEFAULT_STARTING_BUCKETS &&
; 542  :              num_remain < sz * shrink_factor) {

  0002f	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00032	76 36		 jbe	 SHORT $LN1@maybe_shri
  00034	89 45 f8	 mov	 DWORD PTR tv209[ebp], eax
  00037	db 45 f8	 fild	 DWORD PTR tv209[ebp]
  0003a	85 c0		 test	 eax, eax
  0003c	79 06		 jns	 SHORT $LN36@maybe_shri
  0003e	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN36@maybe_shri:
  00044	d9 45 fc	 fld	 DWORD PTR _shrink_factor$155904[ebp]
$LN2@maybe_shri:
  00047	8b c1		 mov	 eax, ecx
  00049	89 45 f8	 mov	 DWORD PTR tv205[ebp], eax
  0004c	db 45 f8	 fild	 DWORD PTR tv205[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	79 06		 jns	 SHORT $LN37@maybe_shri
  00053	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN37@maybe_shri:
  00059	d8 c9		 fmul	 ST(0), ST(1)
  0005b	df f2		 fcomip	 ST(2)
  0005d	76 07		 jbe	 SHORT $LN35@maybe_shri

; 543  :         sz /= 2;                            // stay a power of 2

  0005f	d1 e9		 shr	 ecx, 1
  00061	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00064	77 e1		 ja	 SHORT $LN2@maybe_shri
$LN35@maybe_shri:

; 541  :       while (sz > HT_DEFAULT_STARTING_BUCKETS &&
; 542  :              num_remain < sz * shrink_factor) {

  00066	dd d9		 fstp	 ST(1)
  00068	dd d8		 fstp	 ST(0)
$LN1@maybe_shri:

; 544  :       }
; 545  :       dense_hashtable tmp(*this, sz);       // Do the actual resizing

  0006a	8b c1		 mov	 eax, ecx
  0006c	8b ce		 mov	 ecx, esi
  0006e	8d 7d c0	 lea	 edi, DWORD PTR _tmp$155909[ebp]
  00071	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 546  :       swap(tmp);                            // now we are tmp

  00076	8b d7		 mov	 edx, edi
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 547  :       retval = true;
; 548  :     }

  0007f	8b 45 f4	 mov	 eax, DWORD PTR _tmp$155909[ebp+52]
  00082	b3 01		 mov	 bl, 1
  00084	85 c0		 test	 eax, eax
  00086	74 09		 je	 SHORT $LN23@maybe_shri
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 _free
  0008e	83 c4 04	 add	 esp, 4
$LN23@maybe_shri:

; 549  :     settings.set_consider_shrink(false);    // because we just considered it
; 550  :     return retval;
; 551  :   }

  00091	5f		 pop	 edi
  00092	8a c3		 mov	 al, bl
  00094	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00098	5b		 pop	 ebx
  00099	8b e5		 mov	 esp, ebp
  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ
_TEXT	SEGMENT
_tmp$155878 = -56					; size = 56
?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted, COMDAT
; _this$ = esi

; 369  :   void squash_deleted() {           // gets rid of any deleted entries we have

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 370  :     if ( num_deleted ) {            // get rid of deleted before writing

  00006	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0000a	57		 push	 edi
  0000b	74 28		 je	 SHORT $LN13@squash_del

; 371  :       dense_hashtable tmp(*this);   // copying will get rid of deleted

  0000d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00012	8b ce		 mov	 ecx, esi
  00014	8d 7d c8	 lea	 edi, DWORD PTR _tmp$155878[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 372  :       swap(tmp);                    // now we are tmp

  0001c	8b d7		 mov	 edx, edi
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 373  :     }

  00025	8b 45 fc	 mov	 eax, DWORD PTR _tmp$155878[ebp+52]
  00028	85 c0		 test	 eax, eax
  0002a	74 09		 je	 SHORT $LN13@squash_del
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
$LN13@squash_del:

; 374  :     assert(num_deleted == 0);
; 375  :   }

  00035	5f		 pop	 edi
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?squash_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAEXXZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::squash_deleted
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T202067 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy, COMDAT
; _this$ = eax

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00007	8b 11		 mov	 edx, DWORD PTR [ecx]
  00009	56		 push	 esi
  0000a	51		 push	 ecx
  0000b	52		 push	 edx
  0000c	8d 75 fc	 lea	 esi, DWORD PTR $T202067[ebp]
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00014	5e		 pop	 esi

; 1867 : 		}

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z
_TEXT	SEGMENT
_tmp$202182 = -60					; size = 56
_key$ = 8						; size = 4
?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key, COMDAT
; _this$ = esi

; 386  :   void set_deleted_key(const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 387  :     // the empty indicator (if specified) and the deleted indicator
; 388  :     // must be different
; 389  :     assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
; 390  :            && "Passed the empty-key to set_deleted_key");
; 391  :     // It's only safe to change what "deleted" means if we purge deleted guys
; 392  :     squash_deleted();

  00006	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0000a	57		 push	 edi
  0000b	74 28		 je	 SHORT $LN15@set_delete@2
  0000d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00012	8b ce		 mov	 ecx, esi
  00014	8d 7d c4	 lea	 edi, DWORD PTR _tmp$202182[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  0001c	8b d7		 mov	 edx, edi
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  00025	8b 45 f8	 mov	 eax, DWORD PTR _tmp$202182[ebp+52]
  00028	85 c0		 test	 eax, eax
  0002a	74 09		 je	 SHORT $LN15@set_delete@2
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
$LN15@set_delete@2:

; 393  :     settings.set_use_deleted(true);
; 394  :     key_info.delkey = key;

  00035	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00038	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx

; 395  :   }

  00041	5f		 pop	 edi
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?set_deleted_key@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 310  :                                                  table + num_buckets, true); }

  00000	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00003	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00006	89 06		 mov	 DWORD PTR [esi], eax
  00008	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0000b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00011	8b c6		 mov	 eax, esi
  00013	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  00018	8b c6		 mov	 eax, esi
  0001a	c3		 ret	 0
?end@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\unordered_map
_TEXT	ENDS
;	COMDAT ??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z
_TEXT	SEGMENT
$T202213 = -8						; size = 8
$T202211 = -8						; size = 8
__Where$ = -4						; size = 4
??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z PROC ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[], COMDAT
; __Keyval$ = eax

; 275  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f0		 mov	 esi, eax
  0000a	57		 push	 edi
  0000b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap

; 276  : 		iterator _Where = this->lower_bound(_Keyval);

  00011	8d 45 fc	 lea	 eax, DWORD PTR __Where$[ebp]
  00014	50		 push	 eax
  00015	8b c6		 mov	 eax, esi
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 277  : 		if (_Where == this->end())

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Where$[ebp]
  00021	3b 47 04	 cmp	 eax, DWORD PTR [edi+4]
  00024	75 59		 jne	 SHORT $LN1@operator@16

; 278  : 			_Where = _Mybase::insert(
; 279  : 				value_type(_Keyval, mapped_type())).first;

  00026	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00029	8b 1a		 mov	 ebx, DWORD PTR [edx]
  0002b	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0002e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00030	50		 push	 eax
  00031	53		 push	 ebx
  00032	8d 75 f8	 lea	 esi, DWORD PTR $T202211[ebp]
  00035	89 4d f8	 mov	 DWORD PTR $T202211[ebp], ecx
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T202211[ebp+4], 0
  0003f	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00044	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00047	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  0004c	2b d1		 sub	 edx, ecx
  0004e	83 fa 01	 cmp	 edx, 1
  00051	73 0a		 jae	 SHORT $LN54@operator@16
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00058	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN114@operator@16:
$LN54@operator@16:
  0005d	41		 inc	 ecx
  0005e	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00061	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00064	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00067	89 01		 mov	 DWORD PTR [ecx], eax
  00069	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006c	8b 02		 mov	 eax, DWORD PTR [edx]
  0006e	50		 push	 eax
  0006f	8d 4d f8	 lea	 ecx, DWORD PTR $T202213[ebp]
  00072	51		 push	 ecx
  00073	83 c0 08	 add	 eax, 8
  00076	57		 push	 edi
  00077	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0007c	8b 45 f8	 mov	 eax, DWORD PTR $T202213[ebp]
$LN1@operator@16:

; 280  : 		return ((*_Where).second);
; 281  : 		}

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	83 c0 0c	 add	 eax, 12			; 0000000cH
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN113@operator@16:
??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ENDP ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T202815 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >, COMDAT

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 791  : 		_Tidy();

  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T202815[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 792  : 		}

  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	83 c4 04	 add	 esp, 4
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z
_TEXT	SEGMENT
$T202844 = -8						; size = 8
$T202847 = -4						; size = 4
??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[], COMDAT
; __Keyval$ = edx

; 210  : 		{	// find element matching _Keyval or insert with default mapped

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap

; 211  : 		iterator _Where = this->lower_bound(_Keyval);

  0000e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00011	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00014	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00018	57		 push	 edi
  00019	8b d9		 mov	 ebx, ecx
  0001b	75 17		 jne	 SHORT $LN9@operator@17
  0001d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0001f	90		 npad	 1
$LL10@operator@17:
  00020	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00023	73 05		 jae	 SHORT $LN8@operator@17
  00025	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00028	eb 04		 jmp	 SHORT $LN7@operator@17
$LN8@operator@17:
  0002a	8b d8		 mov	 ebx, eax
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@operator@17:
  0002e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00032	74 ec		 je	 SHORT $LL10@operator@17
$LN9@operator@17:

; 212  : 		if (_Where == this->end()
; 213  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

  00034	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  00037	74 07		 je	 SHORT $LN1@operator@17
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0003e	73 2c		 jae	 SHORT $LN80@operator@17
$LN1@operator@17:

; 214  : 			_Where = this->insert(_Where,
; 215  : 				value_type(_Keyval, mapped_type()));

  00040	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00042	8d 7d f8	 lea	 edi, DWORD PTR $T202844[ebp]
  00045	89 4d f8	 mov	 DWORD PTR $T202844[ebp], ecx
  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T202844[ebp+4], 0
  0004f	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  00054	50		 push	 eax
  00055	53		 push	 ebx
  00056	56		 push	 esi
  00057	8d 7d fc	 lea	 edi, DWORD PTR $T202847[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0005f	8b 45 fc	 mov	 eax, DWORD PTR $T202847[ebp]

; 216  : 		return ((*_Where).second);

  00062	83 c0 10	 add	 eax, 16			; 00000010H

; 217  : 		}

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
$LN80@operator@17:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T203217 = -16						; size = 12
$T203118 = -4						; size = 4
??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
; _this$ = esi

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	6a 18		 push	 24			; 00000018H
  00008	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 25		 je	 SHORT $LN25@map
  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001e	89 00		 mov	 DWORD PTR [eax], eax
  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00026	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00029	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0002f	b0 01		 mov	 al, 1
  00031	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00034	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00037	88 42 15	 mov	 BYTE PTR [edx+21], al

; 107  : 		}

  0003a	8b c6		 mov	 eax, esi
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00040	8d 45 fc	 lea	 eax, DWORD PTR $T203118[ebp]
  00043	50		 push	 eax
  00044	8d 4d f0	 lea	 ecx, DWORD PTR $T203217[ebp]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T203118[ebp], 0
  0004e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00053	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00058	8d 4d f0	 lea	 ecx, DWORD PTR $T203217[ebp]
  0005b	51		 push	 ecx
  0005c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T203217[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00063	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  00068	cc		 int	 3
??0?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\cpp-btree\btree_container.h
_TEXT	ENDS
;	COMDAT ?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z
_TEXT	SEGMENT
?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z PROC ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase, COMDAT
; ___$ReturnUdt$ = esi
; _iter$ = ecx

; 211  :   iterator erase(const iterator &iter) {

  00000	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  00006	57		 push	 edi

; 212  :     return this->tree_.erase(iter);

  00007	8b 39		 mov	 edi, DWORD PTR [ecx]
  00009	83 ec 08	 sub	 esp, 8
  0000c	8b c4		 mov	 eax, esp
  0000e	89 38		 mov	 DWORD PTR [eax], edi
  00010	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00013	56		 push	 esi
  00014	52		 push	 edx
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00018	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase
  0001d	8b c6		 mov	 eax, esi

; 213  :   }

  0001f	5f		 pop	 edi
  00020	c3		 ret	 0
?erase@?$btree_unique_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@ABU32@@Z ENDP ; btree::btree_unique_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z
_TEXT	SEGMENT
$T203254 = -12						; size = 12
??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z PROC ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[], COMDAT
; _key$ = eax

; 269  :   data_type& operator[](const key_type &key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree

; 270  :     return this->tree_.insert_unique(key, generate_value(key)).first->second;

  0000e	50		 push	 eax
  0000f	50		 push	 eax
  00010	8d 75 f4	 lea	 esi, DWORD PTR $T203254[ebp]
  00013	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]

; 271  :   }

  0001d	5f		 pop	 edi
  0001e	8d 44 ca 0c	 lea	 eax, DWORD PTR [edx+ecx*8+12]
  00022	5e		 pop	 esi
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??A?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@QAEAAPAUgoogle_object@@ABI@Z ENDP ; btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::operator[]
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z
_TEXT	SEGMENT
_tmp$203316 = -60					; size = 56
_key$ = 8						; size = 4
?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key, COMDAT

; 301  :   void set_deleted_key(const key_type& key)   { rep.set_deleted_key(key); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi
  00007	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000d	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00011	57		 push	 edi
  00012	74 28		 je	 SHORT $LN17@set_delete@3
  00014	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00019	8b ce		 mov	 ecx, esi
  0001b	8d 7d c4	 lea	 edi, DWORD PTR _tmp$203316[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  00023	8b d7		 mov	 edx, edi
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _tmp$203316[ebp+52]
  0002f	85 c0		 test	 eax, eax
  00031	74 09		 je	 SHORT $LN17@set_delete@3
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _free
  00039	83 c4 04	 add	 esp, 4
$LN17@set_delete@3:
  0003c	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0003f	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	5f		 pop	 edi
  00046	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
  00049	5e		 pop	 esi
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?set_deleted_key@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::set_deleted_key
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ
_TEXT	SEGMENT
?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end, COMDAT
; ___$ReturnUdt$ = esi

; 171  :   iterator end()                                 { return rep.end(); }

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00005	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00008	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00010	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00013	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00016	8b c6		 mov	 eax, esi
  00018	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  0001d	8b c6		 mov	 eax, esi
  0001f	c3		 ret	 0
?end@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@XZ ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::end
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T203489 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >, COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T203489[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	83 c4 04	 add	 esp, 4
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::~map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z$1
__ehfuncinfo$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
_TEXT	SEGMENT
$T203709 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z PROC ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	51		 push	 ecx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00025	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8d 75 f0	 lea	 esi, DWORD PTR $T203709[ebp]
  0002f	8b c7		 mov	 eax, edi
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  00036	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	83 c4 08	 add	 esp, 8
  0004b	8b c7		 mov	 eax, edi
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z$1:
  00000	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEPAXI@Z ENDP ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::`scalar deleting destructor'
PUBLIC	?test_free@@YAXXZ				; test_free
;	COMDAT xdata$x
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\judyarray\judy64na.c
xdata$x	SEGMENT
__unwindtable$?test_free@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?test_free@@YAXXZ$5
__ehfuncinfo$?test_free@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?test_free@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
xdata$x	ENDS
;	COMDAT ?test_free@@YAXXZ
_TEXT	SEGMENT
$T204242 = -20						; size = 4
$T203759 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?test_free@@YAXXZ PROC					; test_free, COMDAT

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00009	6a ff		 push	 -1
  0000b	68 00 00 00 00	 push	 __ehhandler$?test_free@@YAXXZ
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	57		 push	 edi

; 837  : 	COND(DATA_TREE) {

  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00022	83 ff 05	 cmp	 edi, 5
  00025	75 1d		 jne	 SHORT $LN21@test_free

; 838  : 		free(RBTREE);

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RBTREE@@3PAUrbt_object@@A ; RBTREE
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _free
  00032	83 c4 04	 add	 esp, 4
  00035	5f		 pop	 edi

; 940  : 	}
; 941  : #endif
; 942  : }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN21@test_free:

; 839  : 	}
; 840  : 
; 841  : 	COND(DATA_HASHTABLE) {

  00044	85 ff		 test	 edi, edi
  00046	75 2e		 jne	 SHORT $LN20@test_free

; 842  : 		if (tommy_hashtable_count(&hashtable) != 0)

  00048	39 3d 0c 00 00
	00		 cmp	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12, edi
  0004e	74 0b		 je	 SHORT $LN19@test_free

; 843  : 			abort();

  00050	e8 00 00 00 00	 call	 _abort
  00055	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN19@test_free:

; 844  : 		tommy_hashtable_done(&hashtable);

  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _free

; 845  : 		free(HASHTABLE);

  00067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A ; HASHTABLE
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _free
  00073	83 c4 08	 add	 esp, 8
$LN20@test_free:

; 846  : 	}
; 847  : 
; 848  : 	COND(DATA_HASHDYN) {

  00076	83 ff 01	 cmp	 edi, 1
  00079	75 2e		 jne	 SHORT $LN18@test_free

; 849  : 		if (tommy_hashdyn_count(&hashdyn) != 0)

  0007b	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, 0
  00082	74 0b		 je	 SHORT $LN17@test_free

; 850  : 			abort();

  00084	e8 00 00 00 00	 call	 _abort
  00089	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN17@test_free:

; 851  : 		tommy_hashdyn_done(&hashdyn);

  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _free

; 852  : 		free(HASHDYN);

  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A ; HASHDYN
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _free
  000a6	83 c4 08	 add	 esp, 8
$LN18@test_free:

; 853  : 	}
; 854  : 
; 855  : 	COND(DATA_HASHLIN) {

  000a9	56		 push	 esi
  000aa	83 ff 02	 cmp	 edi, 2
  000ad	75 48		 jne	 SHORT $LN16@test_free

; 856  : 		if (tommy_hashlin_count(&hashlin) != 0)

  000af	83 3d a0 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160, 0
  000b6	74 0b		 je	 SHORT $LN15@test_free

; 857  : 			abort();

  000b8	e8 00 00 00 00	 call	 _abort
  000bd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN15@test_free:

; 858  : 		tommy_hashlin_done(&hashlin);

  000c3	33 f6		 xor	 esi, esi
  000c5	39 35 8c 00 00
	00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, esi
  000cb	76 1c		 jbe	 SHORT $LN52@test_free
  000cd	8d 49 00	 npad	 3
$LL54@test_free:
  000d0	8b 14 b5 00 00
	00 00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[esi*4]
  000d7	52		 push	 edx
  000d8	e8 00 00 00 00	 call	 _free
  000dd	46		 inc	 esi
  000de	83 c4 04	 add	 esp, 4
  000e1	3b 35 8c 00 00
	00		 cmp	 esi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  000e7	72 e7		 jb	 SHORT $LL54@test_free
$LN52@test_free:

; 859  : 		free(HASHLIN);

  000e9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A ; HASHLIN
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _free
  000f4	83 c4 04	 add	 esp, 4
$LN16@test_free:

; 860  : 	}
; 861  : 
; 862  : 	COND(DATA_TRIE) {

  000f7	83 ff 03	 cmp	 edi, 3
  000fa	75 28		 jne	 SHORT $LN14@test_free

; 863  : 		if (tommy_trie_count(&trie) != 0)

  000fc	83 3d 40 00 00
	00 00		 cmp	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64, 0
  00103	74 05		 je	 SHORT $LN13@test_free

; 864  : 			abort();

  00105	e8 00 00 00 00	 call	 _abort
$LN13@test_free:

; 865  : 		tommy_allocator_done(&trie_allocator);

  0010a	e8 00 00 00 00	 call	 ?allocator_reset@@YAXPAUtommy_allocator_struct@@@Z ; allocator_reset

; 866  : 		free(TRIE);

  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?TRIE@@3PAUtrie_object@@A ; TRIE
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _free
  0011b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00121	83 c4 04	 add	 esp, 4
$LN14@test_free:

; 867  : 	}
; 868  : 
; 869  : 	COND(DATA_TRIE_INPLACE) {

  00124	83 ff 04	 cmp	 edi, 4
  00127	75 23		 jne	 SHORT $LN12@test_free

; 870  : 		if (tommy_trie_inplace_count(&trie_inplace) != 0)

  00129	83 3d 00 01 00
	00 00		 cmp	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, 0
  00130	74 0b		 je	 SHORT $LN11@test_free

; 871  : 			abort();

  00132	e8 00 00 00 00	 call	 _abort
  00137	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN11@test_free:

; 872  : 		free(TRIE_INPLACE);

  0013d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A ; TRIE_INPLACE
  00143	52		 push	 edx
  00144	e8 00 00 00 00	 call	 _free
  00149	83 c4 04	 add	 esp, 4
$LN12@test_free:

; 873  : 	}
; 874  : 
; 875  : 	COND(DATA_KHASH) {

  0014c	83 ff 07	 cmp	 edi, 7
  0014f	75 4c		 jne	 SHORT $LN10@test_free

; 876  : 		kh_destroy(word, khash);

  00151	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00157	85 f6		 test	 esi, esi
  00159	74 24		 je	 SHORT $LN69@test_free
  0015b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 _free
  00164	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _free
  0016d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00170	52		 push	 edx
  00171	e8 00 00 00 00	 call	 _free
  00176	56		 push	 esi
  00177	e8 00 00 00 00	 call	 _free
  0017c	83 c4 10	 add	 esp, 16			; 00000010H
$LN69@test_free:

; 877  : 		free(KHASH);

  0017f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _free
  0018a	83 c4 04	 add	 esp, 4
  0018d	5e		 pop	 esi
  0018e	5f		 pop	 edi

; 940  : 	}
; 941  : #endif
; 942  : }

  0018f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00192	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
$LN10@test_free:

; 878  : 	}
; 879  : 
; 880  : #ifdef USE_CGOOGLEDENSEHASH
; 881  : 	COND(DATA_CGOOGLE) {
; 882  : 		FreeHashTable(cgoogledensehash);
; 883  : 		free(GOOGLE);
; 884  : 	}
; 885  : #endif
; 886  : 
; 887  : #ifdef USE_GOOGLEDENSEHASH
; 888  : 	COND(DATA_GOOGLEDENSEHASH) {

  0019d	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  001a0	75 3c		 jne	 SHORT $LN74@test_free

; 889  : 		free(GOOGLE);

  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 _free

; 890  : 		delete googledensehash;

  001ae	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  001b4	83 c4 04	 add	 esp, 4
  001b7	85 f6		 test	 esi, esi
  001b9	0f 84 b4 01 00
	00		 je	 $LN182@test_free
  001bf	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  001c2	85 c0		 test	 eax, eax
  001c4	74 09		 je	 SHORT $LN87@test_free
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _free
  001cc	83 c4 04	 add	 esp, 4
$LN87@test_free:
  001cf	56		 push	 esi
  001d0	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  001d5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  001db	83 c4 04	 add	 esp, 4
$LN74@test_free:

; 891  : 	}
; 892  : #endif
; 893  : 
; 894  : #ifdef USE_GOOGLEBTREE
; 895  : 	COND(DATA_GOOGLEBTREE) {

  001de	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  001e1	75 40		 jne	 SHORT $LN91@test_free

; 896  : 		free(GOOGLE);

  001e3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  001e9	52		 push	 edx
  001ea	e8 00 00 00 00	 call	 _free

; 897  : 		delete googlebtree;

  001ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  001f5	83 c4 04	 add	 esp, 4
  001f8	8b f1		 mov	 esi, ecx
  001fa	85 c9		 test	 ecx, ecx
  001fc	0f 84 71 01 00
	00		 je	 $LN182@test_free
  00202	8b 01		 mov	 eax, DWORD PTR [ecx]
  00204	85 c0		 test	 eax, eax
  00206	74 06		 je	 SHORT $LN108@test_free
  00208	50		 push	 eax
  00209	e8 00 00 00 00	 call	 ?internal_clear@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAEXPAV?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@2@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_clear
$LN108@test_free:
  0020e	56		 push	 esi
  0020f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00215	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0021a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00220	83 c4 04	 add	 esp, 4
$LN91@test_free:

; 898  : 	}
; 899  : #endif
; 900  : 
; 901  : #ifdef USE_STXBTREE
; 902  : 	COND(DATA_STXBTREE) {

  00223	83 ff 0d	 cmp	 edi, 13			; 0000000dH
  00226	75 27		 jne	 SHORT $LN28@test_free

; 903  : 		free(STX);

  00228	a1 00 00 00 00	 mov	 eax, DWORD PTR ?STX@@3PAUstx_object@@A ; STX
  0022d	50		 push	 eax
  0022e	e8 00 00 00 00	 call	 _free

; 904  : 		delete stxbtree;

  00233	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  00239	83 c4 04	 add	 esp, 4
  0023c	85 f6		 test	 esi, esi
  0023e	0f 84 2f 01 00
	00		 je	 $LN182@test_free
  00244	e8 00 00 00 00	 call	 ??_G?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@QAEPAXI@Z
  00249	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN28@test_free:

; 905  : 	}
; 906  : #endif
; 907  : 
; 908  : #ifdef USE_CPPMAP
; 909  : 	COND(DATA_CPPMAP) {

  0024f	53		 push	 ebx
  00250	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  00253	75 51		 jne	 SHORT $LN121@test_free

; 910  : 		free(CPP);

  00255	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  0025b	51		 push	 ecx
  0025c	e8 00 00 00 00	 call	 _free

; 911  : 		delete cppmap;

  00261	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  00266	83 c4 04	 add	 esp, 4
  00269	8b d8		 mov	 ebx, eax
  0026b	89 5d f0	 mov	 DWORD PTR $T203759[ebp], ebx
  0026e	85 c0		 test	 eax, eax
  00270	0f 84 fc 00 00
	00		 je	 $LN183@test_free
  00276	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0027d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00280	8b 11		 mov	 edx, DWORD PTR [ecx]
  00282	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00285	51		 push	 ecx
  00286	52		 push	 edx
  00287	8d 75 ec	 lea	 esi, DWORD PTR $T204242[ebp]
  0028a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase
  0028f	8b 17		 mov	 edx, DWORD PTR [edi]
  00291	52		 push	 edx
  00292	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00297	53		 push	 ebx
  00298	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0029d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  002a3	83 c4 08	 add	 esp, 8
$LN121@test_free:

; 912  : 	}
; 913  : #endif
; 914  : 
; 915  : #ifdef USE_CPPUNORDEREDMAP
; 916  : 	COND(DATA_CPPUNORDEREDMAP) {

  002a6	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  002a9	75 27		 jne	 SHORT $LN180@test_free

; 917  : 		free(CPP);

  002ab	a1 00 00 00 00	 mov	 eax, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _free

; 918  : 		delete cppunorderedmap;

  002b6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  002bc	83 c4 04	 add	 esp, 4
  002bf	85 f6		 test	 esi, esi
  002c1	0f 84 ab 00 00
	00		 je	 $LN183@test_free
  002c7	e8 00 00 00 00	 call	 ??_G?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEPAXI@Z
  002cc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
$LN180@test_free:

; 919  : 	}
; 920  : #endif
; 921  : 
; 922  : 	COND(DATA_UTHASH) {

  002d2	83 ff 08	 cmp	 edi, 8
  002d5	75 20		 jne	 SHORT $LN4@test_free

; 923  : 		free(UTHASH);

  002d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?UTHASH@@3PAUuthash_object@@A ; UTHASH
  002dd	51		 push	 ecx
  002de	e8 00 00 00 00	 call	 _free
  002e3	83 c4 04	 add	 esp, 4
  002e6	5b		 pop	 ebx
  002e7	5e		 pop	 esi
  002e8	5f		 pop	 edi

; 940  : 	}
; 941  : #endif
; 942  : }

  002e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f3	8b e5		 mov	 esp, ebp
  002f5	5d		 pop	 ebp
  002f6	c3		 ret	 0
$LN4@test_free:

; 924  : 	}
; 925  : 
; 926  : 	COND(DATA_NEDTRIE) {

  002f7	83 ff 06	 cmp	 edi, 6
  002fa	75 20		 jne	 SHORT $LN3@test_free

; 927  : 		free(NEDTRIE);

  002fc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A ; NEDTRIE
  00302	52		 push	 edx
  00303	e8 00 00 00 00	 call	 _free
  00308	83 c4 04	 add	 esp, 4
  0030b	5b		 pop	 ebx
  0030c	5e		 pop	 esi
  0030d	5f		 pop	 edi

; 940  : 	}
; 941  : #endif
; 942  : }

  0030e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00311	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00318	8b e5		 mov	 esp, ebp
  0031a	5d		 pop	 ebp
  0031b	c3		 ret	 0
$LN3@test_free:

; 928  : 	}
; 929  : 
; 930  : #ifdef USE_JUDY
; 931  : 	COND(DATA_JUDY) {

  0031c	83 ff 09	 cmp	 edi, 9
  0031f	75 1f		 jne	 SHORT $LN2@test_free

; 932  : 		free(JUDY);

  00321	a1 00 00 00 00	 mov	 eax, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _free
  0032c	83 c4 04	 add	 esp, 4
  0032f	5b		 pop	 ebx
  00330	5e		 pop	 esi
  00331	5f		 pop	 edi

; 940  : 	}
; 941  : #endif
; 942  : }

  00332	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00335	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0033c	8b e5		 mov	 esp, ebp
  0033e	5d		 pop	 ebp
  0033f	c3		 ret	 0
$LN2@test_free:

; 933  : 	}
; 934  : #endif
; 935  : 
; 936  : #ifdef USE_JUDYARRAY
; 937  : 	COND(DATA_JUDYARRAY) {

  00340	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  00343	75 2d		 jne	 SHORT $LN183@test_free

; 938  : 		free(JUDYARRAY);

  00345	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  0034b	51		 push	 ecx
  0034c	e8 00 00 00 00	 call	 _free

; 939  : 		judy_close(judyarray);

  00351	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray
  00357	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0035a	83 c4 04	 add	 esp, 4
  0035d	85 c0		 test	 eax, eax
  0035f	74 11		 je	 SHORT $LN183@test_free
$LL171@test_free:
  00361	8b 30		 mov	 esi, DWORD PTR [eax]
  00363	50		 push	 eax
  00364	e8 00 00 00 00	 call	 _free
  00369	83 c4 04	 add	 esp, 4
  0036c	8b c6		 mov	 eax, esi
  0036e	85 f6		 test	 esi, esi
  00370	75 ef		 jne	 SHORT $LL171@test_free
$LN183@test_free:
  00372	5b		 pop	 ebx
$LN182@test_free:

; 940  : 	}
; 941  : #endif
; 942  : }

  00373	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00376	5e		 pop	 esi
  00377	5f		 pop	 edi
  00378	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0037f	8b e5		 mov	 esp, ebp
  00381	5d		 pop	 ebp
  00382	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?test_free@@YAXXZ$5:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T203759[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
__ehhandler$?test_free@@YAXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?test_free@@YAXXZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?test_free@@YAXXZ ENDP					; test_free
PUBLIC	?test_alloc@@YAXXZ				; test_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?test_alloc@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?test_alloc@@YAXXZ$4
__ehfuncinfo$?test_alloc@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?test_alloc@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?test_alloc@@YAXXZ
_TEXT	SEGMENT
$T204316 = -96						; size = 4
_tmp$204800 = -92					; size = 56
$T205147 = -36						; size = 12
tv1174 = -24						; size = 8
tv1166 = -24						; size = 8
tv1183 = -20						; size = 4
tv1176 = -20						; size = 4
tv1168 = -20						; size = 4
__Cat$204729 = -20					; size = 1
$T205002 = -20						; size = 4
$T204344 = -20						; size = 4
$T204340 = -20						; size = 4
$T204336 = -16						; size = 4
tv1179 = -14						; size = 2
tv1171 = -14						; size = 2
$T205186 = -14						; size = 2
__$EHRec$ = -12						; size = 12
?test_alloc@@YAXXZ PROC					; test_alloc, COMDAT

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?test_alloc@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:0, esp
  00018	83 ec 58	 sub	 esp, 88			; 00000058H
  0001b	53		 push	 ebx

; 778  : 		googledensehash = new googledensehash_t;

  0001c	33 db		 xor	 ebx, ebx
  0001e	89 5d ec	 mov	 DWORD PTR $T204344[ebp], ebx
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	83 f8 05	 cmp	 eax, 5
  0002b	75 48		 jne	 SHORT $LN19@test_alloc

; 732  : 	COND(DATA_TREE) {
; 733  : 		rbt_new(&tree);

  0002d	b8 04 00 00 00	 mov	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00032	a3 00 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A, eax
  00037	a3 04 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+4, eax
  0003c	83 e0 fe	 and	 eax, -2			; fffffffeH
  0003f	a3 08 00 00 00	 mov	 DWORD PTR ?tree@@3Urbtree_t@@A+8, eax

; 734  : 		RBTREE = (struct rbt_object*)malloc(sizeof(struct rbt_object) * the_max);

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00049	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00050	2b c8		 sub	 ecx, eax
  00052	03 c9		 add	 ecx, ecx
  00054	03 c9		 add	 ecx, ecx
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 _malloc
  0005c	83 c4 04	 add	 esp, 4
  0005f	a3 00 00 00 00	 mov	 DWORD PTR ?RBTREE@@3PAUrbt_object@@A, eax ; RBTREE

; 831  : 	}
; 832  : #endif
; 833  : }

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN19@test_alloc:

; 735  : 	}
; 736  : 
; 737  : 	COND(DATA_HASHTABLE) {

  00075	3b c3		 cmp	 eax, ebx
  00077	75 2e		 jne	 SHORT $LN289@test_alloc

; 738  : 		tommy_hashtable_init(&hashtable, 2 * the_max);

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0007e	03 c0		 add	 eax, eax
  00080	e8 00 00 00 00	 call	 _tommy_hashtable_init

; 739  : 		HASHTABLE = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  00085	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0008b	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  0008e	03 d2		 add	 edx, edx
  00090	03 d2		 add	 edx, edx
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 _malloc
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A, eax ; HASHTABLE
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  000a2	83 c4 04	 add	 esp, 4
  000a5	eb 06		 jmp	 SHORT $LN18@test_alloc
$LN289@test_alloc:
  000a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN18@test_alloc:

; 740  : 	}
; 741  : 
; 742  : 	COND(DATA_HASHDYN) {

  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 65		 jne	 SHORT $LN17@test_alloc

; 743  : 		tommy_hashdyn_init(&hashdyn);

  000b2	6a 40		 push	 64			; 00000040H
  000b4	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, 4
  000be	c7 05 08 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, 16 ; 00000010H
  000c8	c7 05 0c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, 15 ; 0000000fH
  000d2	e8 00 00 00 00	 call	 _malloc
  000d7	83 c4 04	 add	 esp, 4
  000da	6a 40		 push	 64			; 00000040H
  000dc	53		 push	 ebx
  000dd	50		 push	 eax
  000de	a3 00 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, eax
  000e3	e8 00 00 00 00	 call	 _memset

; 744  : 		HASHDYN = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  000e8	8d 04 f6	 lea	 eax, DWORD PTR [esi+esi*8]
  000eb	03 c0		 add	 eax, eax
  000ed	03 c0		 add	 eax, eax
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	50		 push	 eax
  000f3	89 1d 10 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, ebx
  000f9	e8 00 00 00 00	 call	 _malloc
  000fe	83 c4 04	 add	 esp, 4
  00101	a3 00 00 00 00	 mov	 DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A, eax ; HASHDYN

; 831  : 	}
; 832  : #endif
; 833  : }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
$LN17@test_alloc:

; 745  : 	}
; 746  : 
; 747  : 	COND(DATA_HASHLIN) {

  00117	83 f8 02	 cmp	 eax, 2
  0011a	75 25		 jne	 SHORT $LN16@test_alloc

; 748  : 		tommy_hashlin_init(&hashlin);

  0011c	e8 00 00 00 00	 call	 _tommy_hashlin_init

; 749  : 		HASHLIN = (struct hashtable_object*)malloc(sizeof(struct hashtable_object) * the_max);

  00121	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00127	8d 0c f6	 lea	 ecx, DWORD PTR [esi+esi*8]
  0012a	03 c9		 add	 ecx, ecx
  0012c	03 c9		 add	 ecx, ecx
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 _malloc
  00134	a3 00 00 00 00	 mov	 DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A, eax ; HASHLIN
  00139	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  0013e	83 c4 04	 add	 esp, 4
$LN16@test_alloc:

; 750  : 	}
; 751  : 
; 752  : 	COND(DATA_TRIE) {

  00141	83 f8 03	 cmp	 eax, 3
  00144	75 51		 jne	 SHORT $LN15@test_alloc

; 753  : 		tommy_allocator_init(&trie_allocator, TOMMY_TRIE_BLOCK_SIZE, TOMMY_TRIE_BLOCK_SIZE);

  00146	c7 05 08 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+8, 64 ; 00000040H
  00150	c7 05 0c 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+12, 64 ; 00000040H
  0015a	89 1d 10 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+16, ebx
  00160	89 1d 00 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A, ebx
  00166	89 1d 04 00 00
	00		 mov	 DWORD PTR ?trie_allocator@@3Utommy_allocator_struct@@A+4, ebx

; 754  : 		tommy_trie_init(&trie, &trie_allocator);

  0016c	e8 00 00 00 00	 call	 _tommy_trie_init

; 755  : 		TRIE = (struct trie_object*)malloc(sizeof(struct trie_object) * the_max);

  00171	8d 14 f6	 lea	 edx, DWORD PTR [esi+esi*8]
  00174	03 d2		 add	 edx, edx
  00176	03 d2		 add	 edx, edx
  00178	52		 push	 edx
  00179	e8 00 00 00 00	 call	 _malloc
  0017e	83 c4 04	 add	 esp, 4
  00181	a3 00 00 00 00	 mov	 DWORD PTR ?TRIE@@3PAUtrie_object@@A, eax ; TRIE

; 831  : 	}
; 832  : #endif
; 833  : }

  00186	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00189	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	5b		 pop	 ebx
  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c3		 ret	 0
$LN15@test_alloc:

; 756  : 	}
; 757  : 
; 758  : 	COND(DATA_TRIE_INPLACE) {

  00197	83 f8 04	 cmp	 eax, 4
  0019a	75 36		 jne	 SHORT $LN14@test_alloc

; 759  : 		tommy_trie_inplace_init(&trie_inplace);
; 760  : 		TRIE_INPLACE = (struct trie_inplace_object*)malloc(sizeof(struct trie_inplace_object) * the_max);

  0019c	6b f6 34	 imul	 esi, 52			; 00000034H
  0019f	33 c0		 xor	 eax, eax
  001a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a6	bf 00 00 00 00	 mov	 edi, OFFSET ?trie_inplace@@3Utommy_trie_inplace_struct@@A ; trie_inplace
  001ab	f3 ab		 rep stosd
  001ad	56		 push	 esi
  001ae	89 1d 00 01 00
	00		 mov	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256, ebx
  001b4	e8 00 00 00 00	 call	 _malloc
  001b9	83 c4 04	 add	 esp, 4
  001bc	a3 00 00 00 00	 mov	 DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A, eax ; TRIE_INPLACE

; 831  : 	}
; 832  : #endif
; 833  : }

  001c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	5b		 pop	 ebx
  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
$LN14@test_alloc:

; 761  : 	}
; 762  : 
; 763  : 	COND(DATA_KHASH) {

  001d2	83 f8 07	 cmp	 eax, 7
  001d5	75 37		 jne	 SHORT $LN13@test_alloc

; 764  : 		KHASH = (struct khash_object*)malloc(sizeof(struct khash_object) * the_max);

  001d7	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  001da	03 c0		 add	 eax, eax
  001dc	03 c0		 add	 eax, eax
  001de	50		 push	 eax
  001df	e8 00 00 00 00	 call	 _malloc
  001e4	83 c4 04	 add	 esp, 4

; 765  : 		khash = kh_init(word);

  001e7	6a 1c		 push	 28			; 0000001cH
  001e9	6a 01		 push	 1
  001eb	a3 00 00 00 00	 mov	 DWORD PTR ?KHASH@@3PAUkhash_object@@A, eax ; KHASH
  001f0	e8 00 00 00 00	 call	 _calloc
  001f5	83 c4 08	 add	 esp, 8
  001f8	a3 00 00 00 00	 mov	 DWORD PTR ?khash@@3PAUkh_word_t@@A, eax ; khash

; 831  : 	}
; 832  : #endif
; 833  : }

  001fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00200	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5b		 pop	 ebx
  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c3		 ret	 0
$LN13@test_alloc:

; 766  : 	}
; 767  : 
; 768  : #ifdef USE_CGOOGLEDENSEHASH
; 769  : 	COND(DATA_CGOOGLE) {
; 770  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);
; 771  : 		cgoogledensehash = AllocateHashTable(sizeof(void*), 0);
; 772  : 	}
; 773  : #endif
; 774  : 
; 775  : #ifdef USE_GOOGLEDENSEHASH
; 776  : 	COND(DATA_GOOGLEDENSEHASH) {

  0020e	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00211	0f 85 4a 01 00
	00		 jne	 $LN164@test_alloc

; 777  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);

  00217	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  0021a	03 c9		 add	 ecx, ecx
  0021c	03 c9		 add	 ecx, ecx
  0021e	51		 push	 ecx
  0021f	e8 00 00 00 00	 call	 _malloc
  00224	83 c4 04	 add	 esp, 4

; 778  : 		googledensehash = new googledensehash_t;

  00227	6a 38		 push	 56			; 00000038H
  00229	a3 00 00 00 00	 mov	 DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A, eax ; GOOGLE
  0022e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00233	83 c4 04	 add	 esp, 4
  00236	8b c8		 mov	 ecx, eax
  00238	3b cb		 cmp	 ecx, ebx
  0023a	0f 84 91 00 00
	00		 je	 $LN22@test_alloc
  00240	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00248	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0024d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e4ccccd
  00255	c7 41 28 20 00
	00 00		 mov	 DWORD PTR [ecx+40], 32	; 00000020H
  0025c	66 89 59 11	 mov	 WORD PTR [ecx+17], bx
  00260	89 59 14	 mov	 DWORD PTR [ecx+20], ebx
  00263	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  00268	89 59 20	 mov	 DWORD PTR [ecx+32], ebx
  0026b	89 59 24	 mov	 DWORD PTR [ecx+36], ebx
  0026e	89 59 2c	 mov	 DWORD PTR [ecx+44], ebx
  00271	89 59 30	 mov	 DWORD PTR [ecx+48], ebx
  00274	db 41 28	 fild	 DWORD PTR [ecx+40]
  00277	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0027a	89 59 34	 mov	 DWORD PTR [ecx+52], ebx
  0027d	85 d2		 test	 edx, edx
  0027f	79 06		 jns	 SHORT $LN293@test_alloc
  00281	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000
$LN293@test_alloc:
  00287	d9 7d f2	 fnstcw	 WORD PTR tv1179[ebp]
  0028a	0f b7 45 f2	 movzx	 eax, WORD PTR tv1179[ebp]
  0028e	d9 c0		 fld	 ST(0)
  00290	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00295	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00298	89 45 ec	 mov	 DWORD PTR tv1176[ebp], eax
  0029b	d9 6d ec	 fldcw	 WORD PTR tv1176[ebp]
  0029e	88 59 10	 mov	 BYTE PTR [ecx+16], bl
  002a1	8b f1		 mov	 esi, ecx
  002a3	df 7d e8	 fistp	 QWORD PTR tv1174[ebp]
  002a6	8b 45 e8	 mov	 eax, DWORD PTR tv1174[ebp]
  002a9	89 01		 mov	 DWORD PTR [ecx], eax
  002ab	d9 6d f2	 fldcw	 WORD PTR tv1179[ebp]
  002ae	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  002b1	d9 7d f2	 fnstcw	 WORD PTR tv1171[ebp]
  002b4	0f b7 45 f2	 movzx	 eax, WORD PTR tv1171[ebp]
  002b8	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  002bd	89 45 ec	 mov	 DWORD PTR tv1168[ebp], eax
  002c0	d9 6d ec	 fldcw	 WORD PTR tv1168[ebp]
  002c3	df 7d e8	 fistp	 QWORD PTR tv1166[ebp]
  002c6	8b 55 e8	 mov	 edx, DWORD PTR tv1166[ebp]
  002c9	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  002cc	d9 6d f2	 fldcw	 WORD PTR tv1171[ebp]
  002cf	eb 02		 jmp	 SHORT $LN23@test_alloc
$LN22@test_alloc:
  002d1	33 f6		 xor	 esi, esi
$LN23@test_alloc:

; 779  : 		googledensehash->set_empty_key(-1);

  002d3	8d 7e 2c	 lea	 edi, DWORD PTR [esi+44]
  002d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002dd	89 35 00 00 00
	00		 mov	 DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A, esi ; googledensehash
  002e3	c6 46 11 01	 mov	 BYTE PTR [esi+17], 1
  002e7	3b fb		 cmp	 edi, ebx
  002e9	74 09		 je	 SHORT $LN146@test_alloc
  002eb	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [edi], -1
  002f1	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN146@test_alloc:
  002f4	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  002f7	03 c0		 add	 eax, eax
  002f9	03 c0		 add	 eax, eax
  002fb	03 c0		 add	 eax, eax
  002fd	50		 push	 eax
  002fe	e8 00 00 00 00	 call	 _malloc
  00303	8b 55 ec	 mov	 edx, DWORD PTR __Cat$204729[ebp]
  00306	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00309	83 c4 04	 add	 esp, 4
  0030c	52		 push	 edx
  0030d	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00310	50		 push	 eax
  00311	8b d7		 mov	 edx, edi
  00313	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00316	e8 00 00 00 00	 call	 ??$_Uninit_fill@PAU?$pair@$$CBIPAUgoogle_object@@@std@@U12@@std@@YAXPAU?$pair@$$CBIPAUgoogle_object@@@0@0ABU10@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill<std::pair<unsigned int const ,google_object *> *,std::pair<unsigned int const ,google_object *> >
  0031b	83 c4 08	 add	 esp, 8

; 780  : 		googledensehash->set_deleted_key(-2);

  0031e	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00321	74 28		 je	 SHORT $LN178@test_alloc
  00323	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00328	8b ce		 mov	 ecx, esi
  0032a	8d 7d a4	 lea	 edi, DWORD PTR _tmp$204800[ebp]
  0032d	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >
  00332	8b d7		 mov	 edx, edi
  00334	8b ce		 mov	 ecx, esi
  00336	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap
  0033b	8b 45 d8	 mov	 eax, DWORD PTR _tmp$204800[ebp+52]
  0033e	3b c3		 cmp	 eax, ebx
  00340	74 09		 je	 SHORT $LN178@test_alloc
  00342	50		 push	 eax
  00343	e8 00 00 00 00	 call	 _free
  00348	83 c4 04	 add	 esp, 4
$LN178@test_alloc:
  0034b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00350	c6 46 12 01	 mov	 BYTE PTR [esi+18], 1
  00354	c7 46 1c fe ff
	ff ff		 mov	 DWORD PTR [esi+28], -2	; fffffffeH
  0035b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN164@test_alloc:

; 781  : 	}
; 782  : #endif
; 783  : 
; 784  : #ifdef USE_GOOGLEBTREE
; 785  : 	COND(DATA_GOOGLEBTREE) {

  00361	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00364	75 39		 jne	 SHORT $LN11@test_alloc

; 786  : 		GOOGLE = (struct google_object*)malloc(sizeof(struct google_object) * the_max);

  00366	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00369	03 c0		 add	 eax, eax
  0036b	03 c0		 add	 eax, eax
  0036d	50		 push	 eax
  0036e	e8 00 00 00 00	 call	 _malloc
  00373	83 c4 04	 add	 esp, 4

; 787  : 		googlebtree = new googlebtree_t;

  00376	6a 04		 push	 4
  00378	a3 00 00 00 00	 mov	 DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A, eax ; GOOGLE
  0037d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00382	83 c4 04	 add	 esp, 4
  00385	3b c3		 cmp	 eax, ebx
  00387	74 04		 je	 SHORT $LN24@test_alloc
  00389	89 18		 mov	 DWORD PTR [eax], ebx
  0038b	eb 02		 jmp	 SHORT $LN25@test_alloc
$LN24@test_alloc:
  0038d	33 c0		 xor	 eax, eax
$LN25@test_alloc:
  0038f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00395	a3 00 00 00 00	 mov	 DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A, eax ; googlebtree
  0039a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
$LN11@test_alloc:

; 788  : 	}
; 789  : #endif
; 790  : 
; 791  : #ifdef USE_STXBTREE
; 792  : 	COND(DATA_STXBTREE) {

  0039f	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  003a2	75 48		 jne	 SHORT $LN10@test_alloc

; 793  : 		STX = (struct stx_object*)malloc(sizeof(struct stx_object) * the_max);

  003a4	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  003a7	03 c9		 add	 ecx, ecx
  003a9	03 c9		 add	 ecx, ecx
  003ab	51		 push	 ecx
  003ac	e8 00 00 00 00	 call	 _malloc
  003b1	83 c4 04	 add	 esp, 4

; 794  : 		stxbtree = new stxbtree_t;

  003b4	6a 1c		 push	 28			; 0000001cH
  003b6	a3 00 00 00 00	 mov	 DWORD PTR ?STX@@3PAUstx_object@@A, eax ; STX
  003bb	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003c0	83 c4 04	 add	 esp, 4
  003c3	3b c3		 cmp	 eax, ebx
  003c5	74 13		 je	 SHORT $LN26@test_alloc
  003c7	89 18		 mov	 DWORD PTR [eax], ebx
  003c9	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  003cc	89 58 08	 mov	 DWORD PTR [eax+8], ebx
  003cf	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  003d2	89 58 10	 mov	 DWORD PTR [eax+16], ebx
  003d5	89 58 14	 mov	 DWORD PTR [eax+20], ebx
  003d8	eb 02		 jmp	 SHORT $LN27@test_alloc
$LN26@test_alloc:
  003da	33 c0		 xor	 eax, eax
$LN27@test_alloc:
  003dc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  003e2	a3 00 00 00 00	 mov	 DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A, eax ; stxbtree
  003e7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
$LN10@test_alloc:

; 795  : 	}
; 796  : #endif
; 797  : 
; 798  : #ifdef USE_CPPMAP
; 799  : 	COND(DATA_CPPMAP) {

  003ec	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  003ef	0f 85 9f 00 00
	00		 jne	 $LN9@test_alloc

; 800  : 		CPP = (struct cpp_object*)malloc(sizeof(struct cpp_object) * the_max);

  003f5	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  003f8	03 d2		 add	 edx, edx
  003fa	03 d2		 add	 edx, edx
  003fc	52		 push	 edx
  003fd	e8 00 00 00 00	 call	 _malloc
  00402	83 c4 04	 add	 esp, 4

; 801  : 		cppmap = new cppmap_t;

  00405	6a 10		 push	 16			; 00000010H
  00407	a3 00 00 00 00	 mov	 DWORD PTR ?CPP@@3PAUcpp_object@@A, eax ; CPP
  0040c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00411	8b f0		 mov	 esi, eax
  00413	83 c4 04	 add	 esp, 4
  00416	89 75 f0	 mov	 DWORD PTR $T204336[ebp], esi
  00419	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00420	3b f3		 cmp	 esi, ebx
  00422	74 56		 je	 SHORT $LN28@test_alloc
  00424	6a 18		 push	 24			; 00000018H
  00426	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00429	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0042e	83 c4 04	 add	 esp, 4
  00431	3b c3		 cmp	 eax, ebx
  00433	74 21		 je	 SHORT $LN244@test_alloc
  00435	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00438	89 00		 mov	 DWORD PTR [eax], eax
  0043a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0043d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00440	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00443	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00446	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00449	c6 40 14 01	 mov	 BYTE PTR [eax+20], 1
  0044d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00450	c6 41 15 01	 mov	 BYTE PTR [ecx+21], 1
  00454	eb 26		 jmp	 SHORT $LN29@test_alloc
$LN244@test_alloc:
  00456	8d 55 ec	 lea	 edx, DWORD PTR $T205002[ebp]
  00459	52		 push	 edx
  0045a	8d 4d dc	 lea	 ecx, DWORD PTR $T205147[ebp]
  0045d	89 5d ec	 mov	 DWORD PTR $T205002[ebp], ebx
  00460	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00465	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0046a	8d 45 dc	 lea	 eax, DWORD PTR $T205147[ebp]
  0046d	50		 push	 eax
  0046e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T205147[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00475	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN295@test_alloc:
$LN28@test_alloc:
  0047a	33 f6		 xor	 esi, esi
$LN29@test_alloc:
  0047c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00483	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00488	89 35 00 00 00
	00		 mov	 DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A, esi ; cppmap
  0048e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN9@test_alloc:

; 802  : 	}
; 803  : #endif
; 804  : 
; 805  : #ifdef USE_CPPUNORDEREDMAP
; 806  : 	COND(DATA_CPPUNORDEREDMAP) {

  00494	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00497	75 4e		 jne	 SHORT $LN8@test_alloc

; 807  : 		CPP = (struct cpp_object*)malloc(sizeof(struct cpp_object) * the_max);

  00499	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  0049c	03 c9		 add	 ecx, ecx
  0049e	03 c9		 add	 ecx, ecx
  004a0	51		 push	 ecx
  004a1	e8 00 00 00 00	 call	 _malloc
  004a6	83 c4 04	 add	 esp, 4

; 808  : 		cppunorderedmap = new cppunorderedmap_t;

  004a9	6a 2c		 push	 44			; 0000002cH
  004ab	a3 00 00 00 00	 mov	 DWORD PTR ?CPP@@3PAUcpp_object@@A, eax ; CPP
  004b0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  004b5	8b f0		 mov	 esi, eax
  004b7	83 c4 04	 add	 esp, 4
  004ba	89 75 ec	 mov	 DWORD PTR $T204340[ebp], esi
  004bd	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  004c4	3b f3		 cmp	 esi, ebx
  004c6	74 0c		 je	 SHORT $LN30@test_alloc
  004c8	8d 55 f2	 lea	 edx, DWORD PTR $T205186[ebp]
  004cb	52		 push	 edx
  004cc	56		 push	 esi
  004cd	e8 00 00 00 00	 call	 ??0?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE@ABV?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@1@ABV?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@1@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >
  004d2	eb 02		 jmp	 SHORT $LN31@test_alloc
$LN30@test_alloc:
  004d4	33 f6		 xor	 esi, esi
$LN31@test_alloc:
  004d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  004db	89 35 00 00 00
	00		 mov	 DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A, esi ; cppunorderedmap
  004e1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
$LN8@test_alloc:

; 809  : 	}
; 810  : #endif
; 811  : 
; 812  : 	COND(DATA_UTHASH) {

  004e7	83 f8 08	 cmp	 eax, 8
  004ea	75 22		 jne	 SHORT $LN7@test_alloc

; 813  : 		UTHASH = (struct uthash_object*)malloc(sizeof(struct uthash_object) * the_max);

  004ec	6b f6 34	 imul	 esi, 52			; 00000034H
  004ef	56		 push	 esi
  004f0	e8 00 00 00 00	 call	 _malloc
  004f5	83 c4 04	 add	 esp, 4
  004f8	a3 00 00 00 00	 mov	 DWORD PTR ?UTHASH@@3PAUuthash_object@@A, eax ; UTHASH

; 831  : 	}
; 832  : #endif
; 833  : }

  004fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00500	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00507	5f		 pop	 edi
  00508	5e		 pop	 esi
  00509	5b		 pop	 ebx
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c3		 ret	 0
$LN7@test_alloc:

; 814  : 	}
; 815  : 
; 816  : 	COND(DATA_NEDTRIE) {

  0050e	83 f8 06	 cmp	 eax, 6
  00511	75 3b		 jne	 SHORT $LN6@test_alloc

; 817  : 		NEDTRIE_INIT(&nedtrie);

  00513	68 88 00 00 00	 push	 136			; 00000088H
  00518	53		 push	 ebx
  00519	68 00 00 00 00	 push	 OFFSET ?nedtrie@@3Unedtrie_t@@A ; nedtrie
  0051e	e8 00 00 00 00	 call	 _memset

; 818  : 		NEDTRIE = (struct nedtrie_object*)malloc(sizeof(struct nedtrie_object) * the_max);

  00523	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00526	03 c0		 add	 eax, eax
  00528	03 c0		 add	 eax, eax
  0052a	03 c0		 add	 eax, eax
  0052c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0052f	50		 push	 eax
  00530	e8 00 00 00 00	 call	 _malloc
  00535	83 c4 04	 add	 esp, 4
  00538	a3 00 00 00 00	 mov	 DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A, eax ; NEDTRIE

; 831  : 	}
; 832  : #endif
; 833  : }

  0053d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00540	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00547	5f		 pop	 edi
  00548	5e		 pop	 esi
  00549	5b		 pop	 ebx
  0054a	8b e5		 mov	 esp, ebp
  0054c	5d		 pop	 ebp
  0054d	c3		 ret	 0
$LN6@test_alloc:

; 819  : 	}
; 820  : 
; 821  : #ifdef USE_JUDY
; 822  : 	COND(DATA_JUDY) {

  0054e	83 f8 09	 cmp	 eax, 9
  00551	75 26		 jne	 SHORT $LN2@test_alloc

; 823  : 		JUDY = (struct judy_object*)malloc(sizeof(struct judy_object) * the_max);

  00553	8d 0c b6	 lea	 ecx, DWORD PTR [esi+esi*4]
  00556	03 c9		 add	 ecx, ecx
  00558	03 c9		 add	 ecx, ecx
  0055a	51		 push	 ecx
  0055b	e8 00 00 00 00	 call	 _malloc
  00560	83 c4 04	 add	 esp, 4
  00563	a3 00 00 00 00	 mov	 DWORD PTR ?JUDY@@3PAUjudy_object@@A, eax ; JUDY

; 831  : 	}
; 832  : #endif
; 833  : }

  00568	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0056b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00572	5f		 pop	 edi
  00573	5e		 pop	 esi
  00574	5b		 pop	 ebx
  00575	8b e5		 mov	 esp, ebp
  00577	5d		 pop	 ebp
  00578	c3		 ret	 0
$LN2@test_alloc:

; 824  : 	}
; 825  : #endif
; 826  : 
; 827  : #ifdef USE_JUDYARRAY
; 828  : 	COND(DATA_JUDYARRAY) {

  00579	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0057c	75 1f		 jne	 SHORT $LN1@test_alloc

; 829  : 		JUDYARRAY = (struct judyarray_object*)malloc(sizeof(struct judyarray_object) * the_max);

  0057e	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  00581	03 d2		 add	 edx, edx
  00583	03 d2		 add	 edx, edx
  00585	52		 push	 edx
  00586	e8 00 00 00 00	 call	 _malloc
  0058b	83 c4 04	 add	 esp, 4
  0058e	a3 00 00 00 00	 mov	 DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A, eax ; JUDYARRAY

; 830  : 		judyarray = (Judy*)judy_open(1024, 1);

  00593	e8 00 00 00 00	 call	 ?judy_open@@YAPAXII@Z	; judy_open
  00598	a3 00 00 00 00	 mov	 DWORD PTR ?judyarray@@3PAUJudy@@A, eax ; judyarray
$LN1@test_alloc:

; 831  : 	}
; 832  : #endif
; 833  : }

  0059d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005a0	5f		 pop	 edi
  005a1	5e		 pop	 esi
  005a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005a9	5b		 pop	 ebx
  005aa	8b e5		 mov	 esp, ebp
  005ac	5d		 pop	 ebp
  005ad	c3		 ret	 0
$LN294@test_alloc:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?test_alloc@@YAXXZ$0:
  00000	8b 45 a0	 mov	 eax, DWORD PTR $T204316[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__unwindfunclet$?test_alloc@@YAXXZ$3:
  0000b	8b 45 f0	 mov	 eax, DWORD PTR $T204336[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
__unwindfunclet$?test_alloc@@YAXXZ$4:
  00016	8b 45 ec	 mov	 eax, DWORD PTR $T204340[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001f	59		 pop	 ecx
  00020	c3		 ret	 0
__ehhandler$?test_alloc@@YAXXZ:
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?test_alloc@@YAXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?test_alloc@@YAXXZ ENDP					; test_alloc
PUBLIC	?judy_cell@@YAPAIPAUJudy@@PAEI@Z		; judy_cell
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\judyarray\judy64na.c
;	COMDAT ?judy_cell@@YAPAIPAUJudy@@PAEI@Z
_TEXT	SEGMENT
tv1125 = -40						; size = 4
tv664 = -40						; size = 4
_table$ = -40						; size = 4
_start$ = -40						; size = 4
_size$ = -36						; size = 4
_test$ = -32						; size = 4
tv1087 = -28						; size = 4
tv697 = -28						; size = 4
tv756 = -24						; size = 4
tv666 = -24						; size = 4
_tst$ = -20						; size = 4
_slot$ = -20						; size = 4
_value$ = -16						; size = 4
_node$ = -12						; size = 4
_depth$ = -8						; size = 4
_next$ = -4						; size = 4
_buff$ = 8						; size = 4
?judy_cell@@YAPAIPAUJudy@@PAEI@Z PROC			; judy_cell, COMDAT

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?judyarray@@3PAUJudy@@A ; judyarray

; 1298 : judyvalue *src = (judyvalue *)buff;
; 1299 : int size, idx, slot, cnt, tst;
; 1300 : JudySlot *next = judy->root;
; 1301 : judyvalue test, value;
; 1302 : uint off = 0, start;

  0000e	33 db		 xor	 ebx, ebx

; 1303 : JudySlot *table;
; 1304 : JudySlot *node;
; 1305 : uint depth = 0;
; 1306 : uint keysize;
; 1307 : uchar *base;
; 1308 : 
; 1309 : 	judy->level = 0;

  00010	89 5e 28	 mov	 DWORD PTR [esi+40], ebx
  00013	57		 push	 edi
  00014	89 75 fc	 mov	 DWORD PTR _next$[ebp], esi
  00017	89 5d f8	 mov	 DWORD PTR _depth$[ebp], ebx

; 1310 : #ifdef ASKITIS
; 1311 : 	Words++;
; 1312 : #endif
; 1313 : 
; 1314 : 	while( *next ) {

  0001a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0001c	0f 84 f4 02 00
	00		 je	 $LN65@judy_cell
$LL66@judy_cell:

; 1315 : #ifndef ASKITIS
; 1316 : 		if( judy->level < judy->max )

  00022	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00025	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00028	73 04		 jae	 SHORT $LN64@judy_cell

; 1317 : 			judy->level++;

  0002a	40		 inc	 eax
  0002b	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN64@judy_cell:

; 1318 : 
; 1319 : 		judy->stack[judy->level].next = *next;

  0002e	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00039	89 54 86 34	 mov	 DWORD PTR [esi+eax*4+52], edx

; 1320 : 		judy->stack[judy->level].off = off;

  0003d	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00040	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00043	89 5c 86 38	 mov	 DWORD PTR [esi+eax*4+56], ebx

; 1321 : #endif
; 1322 : 		switch( *next & 0x07 ) {

  00047	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00049	8b c1		 mov	 eax, ecx
  0004b	83 e0 07	 and	 eax, 7
  0004e	0f 84 1d 02 00
	00		 je	 $LN35@judy_cell
  00054	83 f8 07	 cmp	 eax, 7
  00057	0f 84 9b 01 00
	00		 je	 $LN24@judy_cell

; 1323 : 		default:
; 1324 : 			size = JudySize[*next & 0x07];

  0005d	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?JudySize@@3PAHA[eax*4]

; 1325 : 			keysize = JUDY_key_size - (off & JUDY_key_mask);
; 1326 : 			cnt = size / (sizeof(JudySlot) + keysize);
; 1327 : 			base = (uchar *)(*next & JUDY_mask);

  00064	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00067	8b d3		 mov	 edx, ebx
  00069	83 e2 03	 and	 edx, 3
  0006c	89 4d e8	 mov	 DWORD PTR tv666[ebp], ecx

; 1328 : 			node = (JudySlot *)((*next & JUDY_mask) + size);

  0006f	03 c8		 add	 ecx, eax
  00071	bf 04 00 00 00	 mov	 edi, 4
  00076	2b fa		 sub	 edi, edx
  00078	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
  0007b	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0007e	33 d2		 xor	 edx, edx
  00080	89 45 dc	 mov	 DWORD PTR _size$[ebp], eax
  00083	f7 f1		 div	 ecx

; 1329 : 			start = off;
; 1330 : 			slot = cnt;
; 1331 : 			value = 0;

  00085	33 c9		 xor	 ecx, ecx
  00087	89 5d d8	 mov	 DWORD PTR _start$[ebp], ebx

; 1332 : 
; 1333 : 			if( judy->depth ) {

  0008a	39 4e 30	 cmp	 DWORD PTR [esi+48], ecx
  0008d	74 21		 je	 SHORT $LL58@judy_cell

; 1334 : 				value = src[depth++];

  0008f	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  00095	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]

; 1335 : 				off |= JUDY_key_mask;

  00098	83 cb 03	 or	 ebx, 3
  0009b	42		 inc	 edx

; 1336 : 				off++;

  0009c	43		 inc	 ebx

; 1337 : 				value &= JudyMask[keysize];

  0009d	23 0c bd 00 00
	00 00		 and	 ecx, DWORD PTR ?JudyMask@@3PAIA[edi*4]
  000a4	89 55 f8	 mov	 DWORD PTR _depth$[ebp], edx

; 1338 : 			} else

  000a7	eb 10		 jmp	 SHORT $LN126@judy_cell
  000a9	8d a4 24 00 00
	00 00		 npad	 7
$LL58@judy_cell:

; 1341 : 				if( off < max )
; 1342 : 					value |= buff[off];
; 1343 : 			  } while( ++off & JUDY_key_mask );

  000b0	43		 inc	 ebx
  000b1	c1 e1 08	 shl	 ecx, 8
  000b4	f6 c3 03	 test	 bl, 3
  000b7	75 f7		 jne	 SHORT $LL58@judy_cell
$LN126@judy_cell:

; 1339 : 			  do {
; 1340 : 				value <<= 8;

  000b9	89 4d f0	 mov	 DWORD PTR _value$[ebp], ecx

; 1344 : 
; 1345 : 			//  find slot > key
; 1346 : 
; 1347 : 			while( slot-- ) {

  000bc	85 c0		 test	 eax, eax
  000be	74 31		 je	 SHORT $LN113@judy_cell
  000c0	8b d0		 mov	 edx, eax
  000c2	0f af d7	 imul	 edx, edi
  000c5	8b cf		 mov	 ecx, edi
  000c7	f7 d9		 neg	 ecx
  000c9	03 55 e8	 add	 edx, DWORD PTR tv666[ebp]
  000cc	89 4d e4	 mov	 DWORD PTR tv1087[ebp], ecx
  000cf	eb 03		 jmp	 SHORT $LN54@judy_cell
$LL118@judy_cell:
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR tv1087[ebp]
$LN54@judy_cell:
  000d4	03 d1		 add	 edx, ecx

; 1348 : 				test = *(judyvalue *)(base + slot * keysize);
; 1349 : #if BYTE_ORDER == BIG_ENDIAN
; 1350 : 				test >>= 8 * (JUDY_key_size - keysize); 
; 1351 : #else
; 1352 : 				test &= JudyMask[keysize];

  000d6	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000d8	23 0c bd 00 00
	00 00		 and	 ecx, DWORD PTR ?JudyMask@@3PAIA[edi*4]
  000df	48		 dec	 eax
  000e0	89 45 ec	 mov	 DWORD PTR _slot$[ebp], eax
  000e3	89 4d e0	 mov	 DWORD PTR _test$[ebp], ecx

; 1353 : #endif
; 1354 : 				if( test <= value )

  000e6	3b 4d f0	 cmp	 ecx, DWORD PTR _value$[ebp]
  000e9	76 0d		 jbe	 SHORT $LN53@judy_cell

; 1344 : 
; 1345 : 			//  find slot > key
; 1346 : 
; 1347 : 			while( slot-- ) {

  000eb	85 c0		 test	 eax, eax
  000ed	75 e2		 jne	 SHORT $LL118@judy_cell
  000ef	eb 03		 jmp	 SHORT $LN119@judy_cell
$LN113@judy_cell:
  000f1	8b 4d e0	 mov	 ecx, DWORD PTR _test$[ebp]
$LN119@judy_cell:
  000f4	48		 dec	 eax
  000f5	89 45 ec	 mov	 DWORD PTR _slot$[ebp], eax
$LN53@judy_cell:

; 1355 : 					break;
; 1356 : 			}
; 1357 : #ifndef ASKITIS
; 1358 : 			judy->stack[judy->level].slot = slot;

  000f8	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  000fb	8d 54 52 0f	 lea	 edx, DWORD PTR [edx+edx*2+15]
  000ff	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 1359 : #endif
; 1360 : 			if( test == value ) {		// new key is equal to slot key

  00102	3b 4d f0	 cmp	 ecx, DWORD PTR _value$[ebp]
  00105	75 35		 jne	 SHORT $LN51@judy_cell

; 1361 : 				next = &node[-slot-1];

  00107	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  0010e	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00111	2b c1		 sub	 eax, ecx
$LN138@judy_cell:
  00113	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1362 : 
; 1363 : 				// is this a leaf?
; 1364 : 
; 1365 : 				if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {

  00116	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00119	85 c0		 test	 eax, eax
  0011b	75 11		 jne	 SHORT $LN128@judy_cell
  0011d	38 45 f0	 cmp	 BYTE PTR _value$[ebp], al
  00120	0f 84 0e 04 00
	00		 je	 $LN2@judy_cell
  00126	85 c0		 test	 eax, eax
  00128	0f 84 dc 01 00
	00		 je	 $LN27@judy_cell
$LN128@judy_cell:
  0012e	39 45 f8	 cmp	 DWORD PTR _depth$[ebp], eax
  00131	0f 84 fd 03 00
	00		 je	 $LN2@judy_cell

; 1366 : #ifdef ASKITIS
; 1367 : 				  if( *next )
; 1368 : 					Found++;
; 1369 : 				  else
; 1370 : 					Inserts++;
; 1371 : #endif
; 1372 : 				  return next;
; 1373 : 				}
; 1374 : 
; 1375 : 				continue;

  00137	e9 ce 01 00 00	 jmp	 $LN27@judy_cell
$LN51@judy_cell:

; 1376 : 			}
; 1377 : 
; 1378 : 			//	if this node is not full
; 1379 : 			//	open up cell after slot
; 1380 : 
; 1381 : 			if( !node[-1] ) {

  0013c	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0013f	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  00143	75 60		 jne	 SHORT $LN47@judy_cell

; 1382 : 		 	  memmove(base, base + keysize, slot * keysize);	// move keys less than new key down one slot

  00145	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  00148	0f af c7	 imul	 eax, edi
  0014b	50		 push	 eax
  0014c	89 45 e4	 mov	 DWORD PTR tv697[ebp], eax
  0014f	8b 45 e8	 mov	 eax, DWORD PTR tv666[ebp]
  00152	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00155	52		 push	 edx
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 _memmove

; 1383 : #if BYTE_ORDER != BIG_ENDIAN
; 1384 : 			  memcpy(base + slot * keysize, &value, keysize);	// copy new key into slot

  0015c	8b 4d e4	 mov	 ecx, DWORD PTR tv697[ebp]
  0015f	03 4d e8	 add	 ecx, DWORD PTR tv666[ebp]
  00162	57		 push	 edi
  00163	8d 45 f0	 lea	 eax, DWORD PTR _value$[ebp]
  00166	50		 push	 eax
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _memcpy
  0016d	83 c4 18	 add	 esp, 24			; 00000018H

; 1385 : #else
; 1386 : 			  test = value;
; 1387 : 			  idx = keysize;
; 1388 : 
; 1389 : 			  while( idx-- )
; 1390 : 				  base[slot * keysize + idx] = test, test >>= 8;
; 1391 : #endif
; 1392 : 			  for( idx = 0; idx < slot; idx++ )

  00170	83 7d ec 00	 cmp	 DWORD PTR _slot$[ebp], 0
  00174	7e 15		 jle	 SHORT $LN114@judy_cell

; 1382 : 		 	  memmove(base, base + keysize, slot * keysize);	// move keys less than new key down one slot

  00176	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _slot$[ebp]
  0017c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0017f	90		 npad	 1
$LL46@judy_cell:

; 1393 : 				node[-idx-1] = node[-idx-2];// copy tree ptrs/cells down one slot

  00180	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00183	89 10		 mov	 DWORD PTR [eax], edx
  00185	83 c0 fc	 add	 eax, -4			; fffffffcH
  00188	49		 dec	 ecx
  00189	75 f5		 jne	 SHORT $LL46@judy_cell
$LN114@judy_cell:

; 1394 : 
; 1395 : 			  node[-slot-1] = 0;			// set new tree ptr/cell

  0018b	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  0018e	8d 0c 85 04 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+4]
  00195	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00198	2b c1		 sub	 eax, ecx
  0019a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1396 : 			  next = &node[-slot-1];
; 1397 : 
; 1398 : 			  if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {
; 1399 : #ifdef ASKITIS
; 1400 : 				  if( *next )
; 1401 : 					Found++;
; 1402 : 				  else
; 1403 : 					Inserts++;
; 1404 : #endif
; 1405 : 			  	return next;
; 1406 : 			  }
; 1407 : 
; 1408 : 			  continue;

  001a0	e9 6e ff ff ff	 jmp	 $LN138@judy_cell
$LN47@judy_cell:

; 1409 : 			}
; 1410 : 
; 1411 : 			if( size < JudySize[JUDY_max] ) {

  001a5	8b 45 dc	 mov	 eax, DWORD PTR _size$[ebp]
  001a8	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?JudySize@@3PAHA+24
  001ae	7d 1d		 jge	 SHORT $LN40@judy_cell

; 1412 : 			  next = judy_promote (judy, next, slot+1, value, keysize);

  001b0	8b 55 f0	 mov	 edx, DWORD PTR _value$[ebp]
  001b3	8b 45 ec	 mov	 eax, DWORD PTR _slot$[ebp]
  001b6	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  001b9	52		 push	 edx
  001ba	40		 inc	 eax
  001bb	50		 push	 eax
  001bc	51		 push	 ecx
  001bd	56		 push	 esi
  001be	8b c7		 mov	 eax, edi
  001c0	e8 00 00 00 00	 call	 ?judy_promote@@YAPAIPAUJudy@@PAIHIH@Z ; judy_promote
  001c5	83 c4 10	 add	 esp, 16			; 00000010H

; 1413 : 
; 1414 : 			  if( !judy->depth && !(value & 0xFF) || judy->depth && depth == judy->depth ) {
; 1415 : #ifdef ASKITIS
; 1416 : 				if( *next )
; 1417 : 					Found++;
; 1418 : 				else
; 1419 : 					Inserts++;
; 1420 : #endif
; 1421 : 				return next;
; 1422 : 			  }
; 1423 : 
; 1424 : 			  continue;

  001c8	e9 46 ff ff ff	 jmp	 $LN138@judy_cell
$LN40@judy_cell:

; 1425 : 			}
; 1426 : 
; 1427 : 			//	split full maximal node into JUDY_radix nodes
; 1428 : 			//  loop to reprocess new insert
; 1429 : 
; 1430 : 			judy_splitnode (judy, next, size, keysize, depth);

  001cd	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  001d0	52		 push	 edx
  001d1	57		 push	 edi
  001d2	50		 push	 eax
  001d3	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  001d6	50		 push	 eax
  001d7	56		 push	 esi
  001d8	e8 00 00 00 00	 call	 ?judy_splitnode@@YAXPAUJudy@@PAIIII@Z ; judy_splitnode

; 1431 : #ifndef ASKITIS
; 1432 : 			judy->level--;

  001dd	ff 4e 28	 dec	 DWORD PTR [esi+40]

; 1433 : #endif
; 1434 : 			off = start;

  001e0	8b 5d d8	 mov	 ebx, DWORD PTR _start$[ebp]
  001e3	83 c4 14	 add	 esp, 20			; 00000014H

; 1435 : 			if( judy->depth )

  001e6	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  001ea	0f 84 1a 01 00
	00		 je	 $LN27@judy_cell

; 1436 : 				depth--;

  001f0	ff 4d f8	 dec	 DWORD PTR _depth$[ebp]

; 1437 : 			continue;

  001f3	e9 12 01 00 00	 jmp	 $LN27@judy_cell
$LN24@judy_cell:

; 1465 : #ifdef ASKITIS
; 1466 : 				if( *next )
; 1467 : 					Found++;
; 1468 : 				else
; 1469 : 					Inserts++;
; 1470 : #endif
; 1471 : 				return next;
; 1472 : 			}
; 1473 : 
; 1474 : 			continue;
; 1475 : 
; 1476 : #ifndef ASKITIS
; 1477 : 		case JUDY_span:
; 1478 : 			base = (uchar *)(*next & JUDY_mask);

  001f8	8b f9		 mov	 edi, ecx

; 1479 : 			node = (JudySlot *)((*next & JUDY_mask) + JudySize[JUDY_span]);

  001fa	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?JudySize@@3PAHA+28
  00200	83 e7 f8	 and	 edi, -8			; fffffff8H

; 1480 : 			cnt = JUDY_span_bytes;
; 1481 : 			tst = cnt;
; 1482 : 
; 1483 : 			if( tst > (int)(max - off) )

  00203	8b c3		 mov	 eax, ebx
  00205	f7 d8		 neg	 eax
  00207	8d 14 0f	 lea	 edx, DWORD PTR [edi+ecx]
  0020a	89 55 f4	 mov	 DWORD PTR _node$[ebp], edx
  0020d	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  00214	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00217	7d 03		 jge	 SHORT $LN23@judy_cell

; 1484 : 				tst = max - off;

  00219	89 45 ec	 mov	 DWORD PTR _tst$[ebp], eax
$LN23@judy_cell:

; 1485 : 
; 1486 : 			value = strncmp((const char *)base, (const char *)(buff + off), tst);

  0021c	8b 45 ec	 mov	 eax, DWORD PTR _tst$[ebp]
  0021f	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  00222	50		 push	 eax
  00223	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  00226	52		 push	 edx
  00227	57		 push	 edi
  00228	e8 00 00 00 00	 call	 _strncmp
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1487 : 
; 1488 : 			if( !value && tst < cnt && !base[tst] ) // leaf?

  00230	85 c0		 test	 eax, eax
  00232	75 28		 jne	 SHORT $LN21@judy_cell
  00234	8b 45 ec	 mov	 eax, DWORD PTR _tst$[ebp]
  00237	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  0023a	7d 0d		 jge	 SHORT $LN133@judy_cell
  0023c	80 3c 38 00	 cmp	 BYTE PTR [eax+edi], 0
  00240	0f 84 39 01 00
	00		 je	 $LN83@judy_cell

; 1490 : 
; 1491 : 			if( !value && tst == cnt ) {

  00246	83 f8 1c	 cmp	 eax, 28			; 0000001cH
$LN133@judy_cell:
  00249	75 11		 jne	 SHORT $LN21@judy_cell

; 1492 : 				next = &node[-1];

  0024b	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0024e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00251	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1493 : 				off += cnt;

  00254	83 c3 1c	 add	 ebx, 28			; 0000001cH

; 1494 : 				continue;

  00257	e9 ae 00 00 00	 jmp	 $LN27@judy_cell
$LN21@judy_cell:

; 1495 : 			}
; 1496 : 
; 1497 : 			//	bust up JUDY_span node and produce JUDY_1 nodes
; 1498 : 			//	then loop to reprocess insert
; 1499 : 
; 1500 : 			judy_splitspan (judy, next, base);

  0025c	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0025f	51		 push	 ecx
  00260	56		 push	 esi
  00261	e8 00 00 00 00	 call	 ?judy_splitspan@@YAXPAUJudy@@PAIPAE@Z ; judy_splitspan
  00266	83 c4 08	 add	 esp, 8

; 1501 : 			judy->level--;

  00269	ff 4e 28	 dec	 DWORD PTR [esi+40]

; 1502 : 			continue;

  0026c	e9 99 00 00 00	 jmp	 $LN27@judy_cell
$LN35@judy_cell:

; 1438 : 		
; 1439 : 		case JUDY_radix:
; 1440 : 			table = (JudySlot *)(*next & JUDY_mask); // outer radix
; 1441 : 
; 1442 : 			if( judy->depth )

  00271	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00274	83 e1 f8	 and	 ecx, -8			; fffffff8H
  00277	89 4d d8	 mov	 DWORD PTR _table$[ebp], ecx
  0027a	85 c0		 test	 eax, eax
  0027c	74 21		 je	 SHORT $LN32@judy_cell

; 1443 : 				slot = (src[depth] >> ((JUDY_key_size - ++off & JUDY_key_mask) * 8)) & 0xff;

  0027e	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  00281	8b 7d f8	 mov	 edi, DWORD PTR _depth$[ebp]
  00284	8b 3c ba	 mov	 edi, DWORD PTR [edx+edi*4]
  00287	43		 inc	 ebx
  00288	8b cb		 mov	 ecx, ebx
  0028a	f7 d9		 neg	 ecx
  0028c	83 e1 03	 and	 ecx, 3
  0028f	03 c9		 add	 ecx, ecx
  00291	03 c9		 add	 ecx, ecx
  00293	03 c9		 add	 ecx, ecx
  00295	d3 ef		 shr	 edi, cl
  00297	81 e7 ff 00 00
	00		 and	 edi, 255		; 000000ffH
  0029d	eb 03		 jmp	 SHORT $LN31@judy_cell
$LN32@judy_cell:

; 1444 : 			else if( off < max )
; 1445 : 				slot = buff[off++];
; 1446 : 			else
; 1447 : 				slot = 0, off++;

  0029f	33 ff		 xor	 edi, edi
  002a1	43		 inc	 ebx
$LN31@judy_cell:

; 1448 : 
; 1449 : 			if( judy->depth )

  002a2	85 c0		 test	 eax, eax
  002a4	74 08		 je	 SHORT $LN29@judy_cell

; 1450 : 				if( !(off & JUDY_key_mask) )

  002a6	f6 c3 03	 test	 bl, 3
  002a9	75 03		 jne	 SHORT $LN29@judy_cell

; 1451 : 					depth++;

  002ab	ff 45 f8	 inc	 DWORD PTR _depth$[ebp]
$LN29@judy_cell:

; 1452 : 
; 1453 : 			// allocate inner radix if empty
; 1454 : 
; 1455 : 			if( !table[slot >> 4] )

  002ae	8b 4d d8	 mov	 ecx, DWORD PTR _table$[ebp]
  002b1	8b c7		 mov	 eax, edi
  002b3	c1 f8 04	 sar	 eax, 4
  002b6	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  002ba	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002bd	89 45 e8	 mov	 DWORD PTR tv756[ebp], eax
  002c0	75 12		 jne	 SHORT $LN28@judy_cell

; 1456 : 				table[slot >> 4] = (JudySlot)judy_alloc (judy, JUDY_radix) | JUDY_radix;

  002c2	56		 push	 esi
  002c3	33 c9		 xor	 ecx, ecx
  002c5	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc
  002ca	8b 55 e8	 mov	 edx, DWORD PTR tv756[ebp]
  002cd	89 02		 mov	 DWORD PTR [edx], eax
  002cf	83 c4 04	 add	 esp, 4
  002d2	8b c2		 mov	 eax, edx
$LN28@judy_cell:

; 1457 : 
; 1458 : 			table = (JudySlot *)(table[slot >> 4] & JUDY_mask);

  002d4	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1459 : #ifndef ASKITIS
; 1460 : 			judy->stack[judy->level].slot = slot;

  002d6	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  002d9	83 e1 f8	 and	 ecx, -8			; fffffff8H
  002dc	8d 44 40 0f	 lea	 eax, DWORD PTR [eax+eax*2+15]

; 1461 : #endif
; 1462 : 			next = &table[slot & 0x0F];

  002e0	8b d7		 mov	 edx, edi
  002e2	83 e2 0f	 and	 edx, 15			; 0000000fH
  002e5	89 3c 86	 mov	 DWORD PTR [esi+eax*4], edi
  002e8	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]

; 1463 : 
; 1464 : 			if( !judy->depth && !slot || judy->depth && depth == judy->depth ) { // leaf?

  002eb	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  002ee	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  002f1	85 c9		 test	 ecx, ecx
  002f3	75 0c		 jne	 SHORT $LN135@judy_cell
  002f5	85 ff		 test	 edi, edi
  002f7	0f 84 3a 02 00
	00		 je	 $LN67@judy_cell
  002fd	85 c9		 test	 ecx, ecx
  002ff	74 09		 je	 SHORT $LN27@judy_cell
$LN135@judy_cell:
  00301	39 4d f8	 cmp	 DWORD PTR _depth$[ebp], ecx
  00304	0f 84 2d 02 00
	00		 je	 $LN67@judy_cell
$LN27@judy_cell:

; 1310 : #ifdef ASKITIS
; 1311 : 	Words++;
; 1312 : #endif
; 1313 : 
; 1314 : 	while( *next ) {

  0030a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0030d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00310	0f 85 0c fd ff
	ff		 jne	 $LL66@judy_cell
$LN65@judy_cell:

; 1503 : #endif
; 1504 : 		}
; 1505 : 	}
; 1506 : 
; 1507 : 	// place JUDY_1 node under JUDY_radix node(s)
; 1508 : 
; 1509 : #ifndef ASKITIS
; 1510 : 	if( off & JUDY_key_mask )

  00316	8b c3		 mov	 eax, ebx
  00318	83 e0 03	 and	 eax, 3
  0031b	89 45 d8	 mov	 DWORD PTR tv664[ebp], eax
  0031e	0f 84 d2 00 00
	00		 je	 $LN19@judy_cell

; 1511 : 	 if( judy->depth || off <= max ) {

  00324	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00328	75 08		 jne	 SHORT $LN18@judy_cell
  0032a	85 db		 test	 ebx, ebx
  0032c	0f 85 c4 00 00
	00		 jne	 $LN19@judy_cell
$LN18@judy_cell:

; 1512 : #else
; 1513 : 	  while( off <= max ) {
; 1514 : #endif
; 1515 : 		base = (uchar*)judy_alloc (judy, JUDY_1);

  00332	56		 push	 esi
  00333	b9 01 00 00 00	 mov	 ecx, 1
  00338	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1516 : 		keysize = JUDY_key_size - (off & JUDY_key_mask);
; 1517 : 		node = (JudySlot  *)(base + JudySize[JUDY_1]);

  0033d	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?JudySize@@3PAHA+4
  00343	8b f8		 mov	 edi, eax
  00345	03 d7		 add	 edx, edi
  00347	89 55 f4	 mov	 DWORD PTR _node$[ebp], edx

; 1518 : 		*next = (JudySlot)base | JUDY_1;

  0034a	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0034d	83 c8 01	 or	 eax, 1
  00350	b9 04 00 00 00	 mov	 ecx, 4
  00355	2b 4d d8	 sub	 ecx, DWORD PTR tv664[ebp]
  00358	83 c4 04	 add	 esp, 4
  0035b	89 02		 mov	 DWORD PTR [edx], eax

; 1519 : 
; 1520 : 		//	fill in slot 0 with bytes of key
; 1521 : 
; 1522 : 		if( judy->depth ) {

  0035d	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0
  00361	74 29		 je	 SHORT $LN79@judy_cell

; 1523 : 			value = src[depth];

  00363	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  00366	8b 45 08	 mov	 eax, DWORD PTR _buff$[ebp]
  00369	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 1524 : #if BYTE_ORDER != BIG_ENDIAN
; 1525 : 			  memcpy(base, &value, keysize);	// copy new key into slot

  0036c	51		 push	 ecx
  0036d	8d 4d f0	 lea	 ecx, DWORD PTR _value$[ebp]
  00370	51		 push	 ecx
  00371	57		 push	 edi
  00372	89 45 f0	 mov	 DWORD PTR _value$[ebp], eax
  00375	e8 00 00 00 00	 call	 _memcpy
  0037a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1526 : #else
; 1527 : 			  while( keysize-- )
; 1528 : 				  base[keysize] = value, value >>= 8;
; 1529 : #endif
; 1530 : 		} else {

  0037d	eb 34		 jmp	 SHORT $LN117@judy_cell
$LN83@judy_cell:

; 1489 : 				return &node[-1];

  0037f	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  00382	5f		 pop	 edi
  00383	5e		 pop	 esi
  00384	83 c0 fc	 add	 eax, -4			; fffffffcH
  00387	5b		 pop	 ebx

; 1612 : }

  00388	8b e5		 mov	 esp, ebp
  0038a	5d		 pop	 ebp
  0038b	c3		 ret	 0
$LN79@judy_cell:

; 1531 : #if BYTE_ORDER != BIG_ENDIAN
; 1532 : 		  while( keysize )

  0038c	85 c9		 test	 ecx, ecx
  0038e	74 23		 je	 SHORT $LN117@judy_cell
  00390	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  00393	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
$LL15@judy_cell:

; 1533 : 			if( off + keysize <= max )
; 1534 : 				*base++ = buff[off + --keysize];

  00396	49		 dec	 ecx
  00397	85 c0		 test	 eax, eax
  00399	75 12		 jne	 SHORT $LN13@judy_cell
  0039b	48		 dec	 eax
  0039c	89 45 d8	 mov	 DWORD PTR tv1125[ebp], eax
  0039f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  003a2	8a 04 10	 mov	 al, BYTE PTR [eax+edx]
  003a5	88 07		 mov	 BYTE PTR [edi], al

; 1535 : 			else

  003a7	8b 45 d8	 mov	 eax, DWORD PTR tv1125[ebp]
  003aa	47		 inc	 edi
  003ab	eb 02		 jmp	 SHORT $LN12@judy_cell
$LN13@judy_cell:

; 1536 : 				base++, --keysize;

  003ad	47		 inc	 edi
  003ae	48		 dec	 eax
$LN12@judy_cell:

; 1531 : #if BYTE_ORDER != BIG_ENDIAN
; 1532 : 		  while( keysize )

  003af	85 c9		 test	 ecx, ecx
  003b1	75 e3		 jne	 SHORT $LL15@judy_cell
$LN117@judy_cell:

; 1537 : #else
; 1538 : 		  tst = keysize;
; 1539 : 
; 1540 : 		  if( tst > (int)(max - off) )
; 1541 : 			tst = max - off;
; 1542 : 
; 1543 : 		  memcpy (base, buff + off, tst);
; 1544 : #endif
; 1545 : 		}
; 1546 : #ifndef ASKITIS
; 1547 : 		if( judy->level < judy->max )

  003b3	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003b6	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  003b9	73 04		 jae	 SHORT $LN11@judy_cell

; 1548 : 			judy->level++;

  003bb	40		 inc	 eax
  003bc	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN11@judy_cell:

; 1549 : 		judy->stack[judy->level].next = *next;

  003bf	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003c2	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]

; 1550 : 		judy->stack[judy->level].slot = 0;
; 1551 : 		judy->stack[judy->level].off = off;
; 1552 : #endif
; 1553 : 		next = &node[-1];
; 1554 : 
; 1555 : 		off |= JUDY_key_mask;
; 1556 : 		depth++;

  003c5	ff 45 f8	 inc	 DWORD PTR _depth$[ebp]
  003c8	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  003cb	8b 02		 mov	 eax, DWORD PTR [edx]
  003cd	89 44 8e 34	 mov	 DWORD PTR [esi+ecx*4+52], eax
  003d1	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003d4	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  003d8	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0
  003df	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  003e2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  003e5	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  003e8	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx
  003ec	83 c0 fc	 add	 eax, -4			; fffffffcH
  003ef	83 cb 03	 or	 ebx, 3
  003f2	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax

; 1557 : 		off++;

  003f5	43		 inc	 ebx
$LN19@judy_cell:

; 1558 : 	}
; 1559 : 
; 1560 : 	//	produce span nodes to consume rest of key
; 1561 : 	//  or judy_1 nodes if not string tree
; 1562 : 
; 1563 : #ifndef ASKITIS
; 1564 : 	if( !judy->depth )

  003f6	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  003f9	85 c0		 test	 eax, eax
  003fb	0f 85 b2 00 00
	00		 jne	 $LN81@judy_cell

; 1565 : 	  while( off <= max ) {

  00401	85 db		 test	 ebx, ebx
  00403	0f 85 2b 01 00
	00		 jne	 $LN2@judy_cell
  00409	8d a4 24 00 00
	00 00		 npad	 7
$LL9@judy_cell:

; 1566 : 		base = (uchar*)judy_alloc (judy, JUDY_span);

  00410	56		 push	 esi
  00411	b9 07 00 00 00	 mov	 ecx, 7
  00416	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1567 : 		*next = (JudySlot)base | JUDY_span;

  0041b	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0041e	8b f8		 mov	 edi, eax
  00420	8b cf		 mov	 ecx, edi
  00422	83 c9 07	 or	 ecx, 7
  00425	89 0a		 mov	 DWORD PTR [edx], ecx

; 1568 : 		node = (JudySlot  *)(base + JudySize[JUDY_span]);

  00427	a1 1c 00 00 00	 mov	 eax, DWORD PTR ?JudySize@@3PAHA+28
  0042c	03 c7		 add	 eax, edi
  0042e	89 45 f4	 mov	 DWORD PTR _node$[ebp], eax

; 1569 : 		cnt = tst = JUDY_span_bytes;
; 1570 : 		if( tst > (int)(max - off) )

  00431	8b c3		 mov	 eax, ebx
  00433	f7 d8		 neg	 eax
  00435	83 c4 04	 add	 esp, 4
  00438	c7 45 ec 1c 00
	00 00		 mov	 DWORD PTR _tst$[ebp], 28 ; 0000001cH
  0043f	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  00442	7d 03		 jge	 SHORT $LN7@judy_cell

; 1571 : 			tst = max - off;

  00444	89 45 ec	 mov	 DWORD PTR _tst$[ebp], eax
$LN7@judy_cell:

; 1572 : 		memcpy (base, buff + off, tst);

  00447	8b 4d ec	 mov	 ecx, DWORD PTR _tst$[ebp]
  0044a	8b 55 08	 mov	 edx, DWORD PTR _buff$[ebp]
  0044d	51		 push	 ecx
  0044e	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00451	50		 push	 eax
  00452	57		 push	 edi
  00453	e8 00 00 00 00	 call	 _memcpy

; 1573 : 
; 1574 : 		if( judy->level < judy->max )

  00458	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0045b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0045e	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  00461	73 04		 jae	 SHORT $LN6@judy_cell

; 1575 : 			judy->level++;

  00463	40		 inc	 eax
  00464	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN6@judy_cell:

; 1576 : 		judy->stack[judy->level].next = *next;

  00467	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0046a	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  0046d	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00470	8b 02		 mov	 eax, DWORD PTR [edx]
  00472	89 44 8e 34	 mov	 DWORD PTR [esi+ecx*4+52], eax

; 1577 : 		judy->stack[judy->level].slot = 0;

  00476	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00479	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  0047d	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0

; 1578 : 		judy->stack[judy->level].off = off;

  00484	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00487	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 1579 : 		next = &node[-1];

  0048a	8b 45 f4	 mov	 eax, DWORD PTR _node$[ebp]
  0048d	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx

; 1580 : 		off += tst;

  00491	03 5d ec	 add	 ebx, DWORD PTR _tst$[ebp]
  00494	83 c0 fc	 add	 eax, -4			; fffffffcH

; 1581 : 		depth++;
; 1582 : 
; 1583 : 		if( !base[cnt-1] )	// done on leaf

  00497	80 7f 1b 00	 cmp	 BYTE PTR [edi+27], 0
  0049b	89 45 fc	 mov	 DWORD PTR _next$[ebp], eax
  0049e	0f 84 90 00 00
	00		 je	 $LN2@judy_cell

; 1565 : 	  while( off <= max ) {

  004a4	85 db		 test	 ebx, ebx
  004a6	0f 84 64 ff ff
	ff		 je	 $LL9@judy_cell
  004ac	5f		 pop	 edi
  004ad	5e		 pop	 esi
  004ae	5b		 pop	 ebx

; 1612 : }

  004af	8b e5		 mov	 esp, ebp
  004b1	5d		 pop	 ebp
  004b2	c3		 ret	 0
$LN81@judy_cell:

; 1584 : 			break;
; 1585 : 	  }
; 1586 : 	else
; 1587 : 	  while( depth < judy->depth ) {

  004b3	39 45 f8	 cmp	 DWORD PTR _depth$[ebp], eax
  004b6	73 7c		 jae	 SHORT $LN2@judy_cell
  004b8	8b 7d fc	 mov	 edi, DWORD PTR _next$[ebp]
  004bb	eb 03 8d 49 00	 npad	 5
$LL3@judy_cell:

; 1588 : 		base = (uchar*)judy_alloc (judy, JUDY_1);

  004c0	56		 push	 esi
  004c1	b9 01 00 00 00	 mov	 ecx, 1
  004c6	e8 00 00 00 00	 call	 ?judy_alloc@@YAPAXPAUJudy@@I@Z ; judy_alloc

; 1589 : 		node = (JudySlot  *)(base + JudySize[JUDY_1]);

  004cb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?JudySize@@3PAHA+4
  004d1	03 c8		 add	 ecx, eax

; 1590 : 		*next = (JudySlot)base | JUDY_1;

  004d3	8b d0		 mov	 edx, eax
  004d5	83 ca 01	 or	 edx, 1
  004d8	89 17		 mov	 DWORD PTR [edi], edx

; 1591 : 
; 1592 : 		//	fill in slot 0 with bytes of key
; 1593 : 
; 1594 : 		*(judyvalue *)base = src[depth];

  004da	8b 55 f8	 mov	 edx, DWORD PTR _depth$[ebp]
  004dd	89 4d f4	 mov	 DWORD PTR _node$[ebp], ecx
  004e0	8b 4d 08	 mov	 ecx, DWORD PTR _buff$[ebp]
  004e3	8b 0c 91	 mov	 ecx, DWORD PTR [ecx+edx*4]
  004e6	89 08		 mov	 DWORD PTR [eax], ecx

; 1595 : 
; 1596 : 		if( judy->level < judy->max )

  004e8	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004eb	83 c4 04	 add	 esp, 4
  004ee	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  004f1	73 04		 jae	 SHORT $LN1@judy_cell

; 1597 : 			judy->level++;

  004f3	40		 inc	 eax
  004f4	89 46 28	 mov	 DWORD PTR [esi+40], eax
$LN1@judy_cell:

; 1598 : 		judy->stack[judy->level].next = *next;

  004f7	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004fa	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  004fd	8b 07		 mov	 eax, DWORD PTR [edi]

; 1599 : 		judy->stack[judy->level].slot = 0;
; 1600 : 		judy->stack[judy->level].off = off;
; 1601 : 		next = &node[-1];

  004ff	8b 7d f4	 mov	 edi, DWORD PTR _node$[ebp]
  00502	89 44 96 34	 mov	 DWORD PTR [esi+edx*4+52], eax
  00506	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00509	8d 4c 40 0f	 lea	 ecx, DWORD PTR [eax+eax*2+15]
  0050d	c7 04 8e 00 00
	00 00		 mov	 DWORD PTR [esi+ecx*4], 0
  00514	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00517	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]

; 1602 : 		off |= JUDY_key_mask;
; 1603 : 		depth++;

  0051a	8b 45 f8	 mov	 eax, DWORD PTR _depth$[ebp]
  0051d	89 5c 96 38	 mov	 DWORD PTR [esi+edx*4+56], ebx
  00521	83 cb 03	 or	 ebx, 3
  00524	40		 inc	 eax
  00525	83 c7 fc	 add	 edi, -4			; fffffffcH

; 1604 : 		off++;

  00528	43		 inc	 ebx
  00529	89 45 f8	 mov	 DWORD PTR _depth$[ebp], eax
  0052c	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0052f	72 8f		 jb	 SHORT $LL3@judy_cell

; 1599 : 		judy->stack[judy->level].slot = 0;
; 1600 : 		judy->stack[judy->level].off = off;
; 1601 : 		next = &node[-1];

  00531	89 7d fc	 mov	 DWORD PTR _next$[ebp], edi
$LN2@judy_cell:

; 1605 : 	  }
; 1606 : #endif
; 1607 : 
; 1608 : #ifdef ASKITIS
; 1609 : 	Inserts++;
; 1610 : #endif
; 1611 : 	return next;

  00534	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
$LN67@judy_cell:
  00537	5f		 pop	 edi
  00538	5e		 pop	 esi
  00539	5b		 pop	 ebx

; 1612 : }

  0053a	8b e5		 mov	 esp, ebp
  0053c	5d		 pop	 ebp
  0053d	c3		 ret	 0
?judy_cell@@YAPAIPAUJudy@@PAEI@Z ENDP			; judy_cell
_TEXT	ENDS
PUBLIC	_tommy_hashlin_bucket
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.c
;	COMDAT _tommy_hashlin_bucket
_TEXT	SEGMENT
_tommy_hashlin_bucket PROC				; COMDAT
; _hash$ = ecx

; 291  : 	return *tommy_hashlin_bucket_ptr(hashlin, hash);

  00000	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  00005	8b 00		 mov	 eax, DWORD PTR [eax]

; 292  : }

  00007	c3		 ret	 0
_tommy_hashlin_bucket ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashlin_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashlin_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashlin_insert PROC				; COMDAT
; _node$ = esi
; _hash$ = edi

; 268  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 269  : 	tommy_list_insert_tail(tommy_hashlin_bucket_ptr(hashlin, hash), node, data);

  00003	8b cf		 mov	 ecx, edi
  00005	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	85 c9		 test	 ecx, ecx
  0000e	74 16		 je	 SHORT $LN4@tommy_hash@9
  00010	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00013	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00016	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00022	89 31		 mov	 DWORD PTR [ecx], esi
  00024	eb 0b		 jmp	 SHORT $LN11@tommy_hash@9
$LN4@tommy_hash@9:
  00026	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0002f	89 30		 mov	 DWORD PTR [eax], esi
$LN11@tommy_hash@9:
  00031	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00034	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 270  : 
; 271  : 	node->key = hash;

  00037	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 272  : 
; 273  : 	++hashlin->count;

  0003a	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 276  : }

  00040	5d		 pop	 ebp

; 274  : 
; 275  : 	hashlin_grow_step(hashlin);

  00041	e9 00 00 00 00	 jmp	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
_tommy_hashlin_insert ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z
_TEXT	SEGMENT
_count$205335 = -4					; size = 4
?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z PROC ; hashlin_shrink_step, COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 203  : 	/* shrink if less than 12.5% full */
; 204  : 	if (hashlin->state != TOMMY_HASHLIN_STATE_SHRINK
; 205  : 		&& hashlin->count < hashlin->bucket_max / 8
; 206  : 	) {

  00004	8b 0d 9c 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156
  0000a	56		 push	 esi
  0000b	8b 35 a0 00 00
	00		 mov	 esi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  00011	83 f9 02	 cmp	 ecx, 2
  00014	74 5e		 je	 SHORT $LN40@hashlin_sh
  00016	a1 84 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132
  0001b	8b d0		 mov	 edx, eax
  0001d	c1 ea 03	 shr	 edx, 3
  00020	3b f2		 cmp	 esi, edx
  00022	0f 83 25 01 00
	00		 jae	 $LN2@hashlin_sh

; 207  : 		/* avoid to shrink the first bucket */
; 208  : 		if (hashlin->bucket_bit > TOMMY_HASHLIN_BIT) {

  00028	83 3d 80 00 00
	00 06		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, 6
  0002f	0f 86 18 01 00
	00		 jbe	 $LN2@hashlin_sh

; 209  : 			/* if we are stable, setup a new shrink state */
; 210  : 			/* otherwise continue with the already setup grow one */
; 211  : 			/* but in backward direction */
; 212  : 			if (hashlin->state == TOMMY_HASHLIN_STATE_STABLE) {

  00035	85 c9		 test	 ecx, ecx
  00037	75 29		 jne	 SHORT $LN39@hashlin_sh

; 213  : 				/* set the lower size */
; 214  : 				hashlin->low_max = hashlin->bucket_max / 2;
; 215  : 				hashlin->low_mask = hashlin->bucket_mask / 2;

  00039	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  0003f	d1 e8		 shr	 eax, 1
  00041	d1 e9		 shr	 ecx, 1

; 216  : 
; 217  : 				/* start from the half going backward */
; 218  : 				hashlin->split = hashlin->low_max;

  00043	8b d0		 mov	 edx, eax
  00045	a3 90 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144, eax
  0004a	89 0d 94 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148, ecx
  00050	89 15 98 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, edx

; 219  : 			}
; 220  : 
; 221  : 			/* start reallocation */
; 222  : 			hashlin->state = TOMMY_HASHLIN_STATE_SHRINK;

  00056	c7 05 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 2
  00060	eb 18		 jmp	 SHORT $LN38@hashlin_sh
$LN39@hashlin_sh:

; 216  : 
; 217  : 				/* start from the half going backward */
; 218  : 				hashlin->split = hashlin->low_max;

  00062	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152

; 219  : 			}
; 220  : 
; 221  : 			/* start reallocation */
; 222  : 			hashlin->state = TOMMY_HASHLIN_STATE_SHRINK;

  00068	c7 05 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 2
  00072	eb 06		 jmp	 SHORT $LN38@hashlin_sh
$LN40@hashlin_sh:
  00074	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN38@hashlin_sh:

; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 	/* if we are shrinking */
; 227  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_SHRINK) {
; 228  : 		/* compute the split target required to finish the reallocation before the next resize */
; 229  : 		unsigned split_target = 8 * hashlin->count;
; 230  : 
; 231  : 		/* reallocate buckets until the split target */
; 232  : 		while (hashlin->split + hashlin->low_max > split_target) {

  0007a	a1 90 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  0007f	03 f6		 add	 esi, esi
  00081	03 f6		 add	 esi, esi
  00083	03 f6		 add	 esi, esi
  00085	8d 0c 02	 lea	 ecx, DWORD PTR [edx+eax]
  00088	3b ce		 cmp	 ecx, esi
  0008a	0f 86 bd 00 00
	00		 jbe	 $LN2@hashlin_sh
  00090	57		 push	 edi
$LL3@hashlin_sh:

; 233  : 			tommy_hashlin_node** split[2];
; 234  : 
; 235  : 			/* go backward position */
; 236  : 			--hashlin->split;

  00091	4a		 dec	 edx
  00092	89 15 98 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152, edx

; 237  :    
; 238  : 			/* get the low bucket */
; 239  : 			split[0] = tommy_hashlin_pos(hashlin, hashlin->split);

  00098	83 fa 40	 cmp	 edx, 64			; 00000040H
  0009b	73 0a		 jae	 SHORT $LN10@hashlin_sh
  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  000a2	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000a5	eb 1b		 jmp	 SHORT $LN11@hashlin_sh
$LN10@hashlin_sh:
  000a7	0f bd ca	 bsr	 ecx, edx
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	d3 e0		 shl	 eax, cl
  000b1	89 4d fc	 mov	 DWORD PTR _count$205335[ebp], ecx
  000b4	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  000bb	8b fa		 mov	 edi, edx
  000bd	2b f8		 sub	 edi, eax
  000bf	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
$LN11@hashlin_sh:

; 240  : 
; 241  : 			/* get the high bucket */
; 242  : 			/* it's always in the second half, so we can index it directly */
; 243  : 			/* without calling tommy_hashlin_pos() */
; 244  : 			split[1] = &hashlin->bucket[hashlin->bucket_mac-1][hashlin->split];

  000c2	a1 8c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  000c7	8b 04 85 fc ff
	ff ff		 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[eax*4-4]
  000ce	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 245  : 
; 246  : 			/* concat the high bucket into the low one */
; 247  : 			tommy_list_concat(split[0], split[1]);

  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	85 c0		 test	 eax, eax
  000d5	74 1a		 je	 SHORT $LN17@hashlin_sh
  000d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d9	85 d2		 test	 edx, edx
  000db	74 0c		 je	 SHORT $LN42@hashlin_sh
  000dd	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000e0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e3	89 7a 04	 mov	 DWORD PTR [edx+4], edi
  000e6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN42@hashlin_sh:
  000e9	89 01		 mov	 DWORD PTR [ecx], eax
  000eb	8b 15 98 00 00
	00		 mov	 edx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
$LN17@hashlin_sh:

; 248  : 
; 249  : 			/* if we have finished, clean up and change the state */
; 250  : 			if (hashlin->split == 0) {

  000f1	85 d2		 test	 edx, edx
  000f3	74 13		 je	 SHORT $LN37@hashlin_sh

; 223  : 		}
; 224  : 	}
; 225  : 
; 226  : 	/* if we are shrinking */
; 227  : 	if (hashlin->state == TOMMY_HASHLIN_STATE_SHRINK) {
; 228  : 		/* compute the split target required to finish the reallocation before the next resize */
; 229  : 		unsigned split_target = 8 * hashlin->count;
; 230  : 
; 231  : 		/* reallocate buckets until the split target */
; 232  : 		while (hashlin->split + hashlin->low_max > split_target) {

  000f5	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+144
  000fb	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  000fe	3b c6		 cmp	 eax, esi
  00100	77 8f		 ja	 SHORT $LL3@hashlin_sh
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi

; 261  : 				break;
; 262  : 			}
; 263  : 		}
; 264  : 	}
; 265  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
$LN37@hashlin_sh:

; 251  : 				hashlin->state = TOMMY_HASHLIN_STATE_STABLE;
; 252  : 
; 253  : 				/* shrink the hash size */
; 254  : 				--hashlin->bucket_bit;

  00108	8b 0d 80 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128
  0010e	49		 dec	 ecx

; 255  : 				hashlin->bucket_max = 1 << hashlin->bucket_bit;

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	d3 e0		 shl	 eax, cl
  00116	c7 05 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  00120	89 0d 80 00 00
	00		 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+128, ecx
  00126	a3 84 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+132, eax

; 256  : 				hashlin->bucket_mask = hashlin->bucket_max - 1;

  0012b	48		 dec	 eax
  0012c	a3 88 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136, eax

; 257  : 
; 258  : 				/* free the last segment */
; 259  : 				--hashlin->bucket_mac;

  00131	a1 8c 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140
  00136	48		 dec	 eax
  00137	a3 8c 00 00 00	 mov	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+140, eax

; 260  : 				tommy_free(hashlin->bucket[hashlin->bucket_mac]);

  0013c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[eax*4]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 _free
  00149	83 c4 04	 add	 esp, 4
  0014c	5f		 pop	 edi
$LN2@hashlin_sh:
  0014d	5e		 pop	 esi

; 261  : 				break;
; 262  : 			}
; 263  : 		}
; 264  : 	}
; 265  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ENDP ; hashlin_shrink_step
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.c
_TEXT	ENDS
;	COMDAT ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z
_TEXT	SEGMENT
_new_bucket_mask$ = -16					; size = 4
tv478 = -12						; size = 4
_bucket_max$ = -12					; size = 4
_new_bucket_max$ = -8					; size = 4
tv435 = -4						; size = 4
_new_bucket_bit$ = 8					; size = 4
?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z PROC ; tommy_hashdyn_resize, COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 58   : 	unsigned bucket_bit;
; 59   : 	unsigned bucket_max;
; 60   : 	unsigned new_bucket_max;
; 61   : 	unsigned new_bucket_mask;
; 62   : 	tommy_hashdyn_node** new_bucket;
; 63   : 
; 64   : 	bucket_bit = hashdyn->bucket_bit;
; 65   : 	bucket_max = hashdyn->bucket_max;
; 66   : 
; 67   : 	new_bucket_max = 1 << new_bucket_bit;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _new_bucket_bit$[ebp]
  00009	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0000e	53		 push	 ebx
  0000f	bb 01 00 00 00	 mov	 ebx, 1
  00014	d3 e3		 shl	 ebx, cl
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	89 45 f4	 mov	 DWORD PTR _bucket_max$[ebp], eax

; 68   : 	new_bucket_mask = new_bucket_max - 1;

  0001b	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]

; 69   : 	new_bucket = tommy_cast(tommy_hashdyn_node**, tommy_malloc(new_bucket_max * sizeof(tommy_hashdyn_node*)));

  0001e	8d 3c 9d 00 00
	00 00		 lea	 edi, DWORD PTR [ebx*4]
  00025	57		 push	 edi
  00026	89 5d f8	 mov	 DWORD PTR _new_bucket_max$[ebp], ebx
  00029	89 4d f0	 mov	 DWORD PTR _new_bucket_mask$[ebp], ecx
  0002c	e8 00 00 00 00	 call	 _malloc

; 70   : 
; 71   : 	/* reinsert all the elements */
; 72   : 	if (new_bucket_bit > bucket_bit) {

  00031	8b 55 08	 mov	 edx, DWORD PTR _new_bucket_bit$[ebp]
  00034	83 c4 04	 add	 esp, 4
  00037	8b f0		 mov	 esi, eax
  00039	3b 15 04 00 00
	00		 cmp	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  0003f	0f 86 b4 00 00
	00		 jbe	 $LN12@tommy_hash@10

; 73   : 		unsigned i;
; 74   : 
; 75   : 		/* grow */
; 76   : 		for(i=0;i<bucket_max;++i) {

  00045	8b 4d f4	 mov	 ecx, DWORD PTR _bucket_max$[ebp]
  00048	33 db		 xor	 ebx, ebx
  0004a	85 c9		 test	 ecx, ecx
  0004c	74 75		 je	 SHORT $LN47@tommy_hash@10
  0004e	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]
  00051	89 45 fc	 mov	 DWORD PTR tv435[ebp], eax
  00054	eb 0a 8d a4 24
	00 00 00 00 8d
	49 00		 npad	 12
$LL48@tommy_hash@10:

; 77   : 			tommy_hashdyn_node* j;
; 78   : 
; 79   : 			/* setup the new two buckets */
; 80   : 			new_bucket[i] = 0;
; 81   : 			new_bucket[i + bucket_max] = 0;

  00060	8b 55 fc	 mov	 edx, DWORD PTR tv435[ebp]
  00063	c7 04 9e 00 00
	00 00		 mov	 DWORD PTR [esi+ebx*4], 0
  0006a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 82   : 
; 83   : 			/* reinsert the bucket */
; 84   : 			j = hashdyn->bucket[i];

  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00075	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 85   : 			while (j) {

  00078	85 c0		 test	 eax, eax
  0007a	74 3e		 je	 SHORT $LN10@tommy_hash@10
  0007c	8d 64 24 00	 npad	 4
$LL8@tommy_hash@10:

; 86   : 				tommy_hashdyn_node* j_next = j->next;
; 87   : 				unsigned index = j->key & new_bucket_mask;

  00080	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00083	23 4d f0	 and	 ecx, DWORD PTR _new_bucket_mask$[ebp]
  00086	8b 38		 mov	 edi, DWORD PTR [eax]

; 88   : 				if (new_bucket[index])

  00088	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  0008b	85 d2		 test	 edx, edx
  0008d	74 16		 je	 SHORT $LN6@tommy_hash@10

; 89   : 					tommy_list_insert_tail_not_empty(new_bucket[index], j);

  0008f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00092	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00095	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00098	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0009b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000a1	89 02		 mov	 DWORD PTR [edx], eax

; 90   : 				else

  000a3	eb 0c		 jmp	 SHORT $LN17@tommy_hash@10
$LN6@tommy_hash@10:

; 91   : 					tommy_list_insert_first(&new_bucket[index], j);

  000a5	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  000ae	89 04 8e	 mov	 DWORD PTR [esi+ecx*4], eax
$LN17@tommy_hash@10:

; 92   : 				j = j_next;

  000b1	8b c7		 mov	 eax, edi
  000b3	85 ff		 test	 edi, edi
  000b5	75 c9		 jne	 SHORT $LL8@tommy_hash@10

; 85   : 			while (j) {

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _bucket_max$[ebp]
$LN10@tommy_hash@10:

; 73   : 		unsigned i;
; 74   : 
; 75   : 		/* grow */
; 76   : 		for(i=0;i<bucket_max;++i) {

  000ba	83 45 fc 04	 add	 DWORD PTR tv435[ebp], 4
  000be	43		 inc	 ebx
  000bf	3b d9		 cmp	 ebx, ecx
  000c1	72 9d		 jb	 SHORT $LL48@tommy_hash@10
$LN47@tommy_hash@10:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  000c3	8b 5d f8	 mov	 ebx, DWORD PTR _new_bucket_max$[ebp]
$LN46@tommy_hash@10:

; 105  : 		}
; 106  : 	}
; 107  : 
; 108  : 	tommy_free(hashdyn->bucket);

  000c6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _free

; 109  : 
; 110  : 	/* setup */
; 111  : 	hashdyn->bucket_bit = new_bucket_bit;

  000d2	8b 45 08	 mov	 eax, DWORD PTR _new_bucket_bit$[ebp]

; 112  : 	hashdyn->bucket_max = new_bucket_max;
; 113  : 	hashdyn->bucket_mask = new_bucket_mask;

  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _new_bucket_mask$[ebp]
  000d8	83 c4 04	 add	 esp, 4
  000db	5f		 pop	 edi

; 114  : 	hashdyn->bucket = new_bucket;

  000dc	89 35 00 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A, esi
  000e2	5e		 pop	 esi
  000e3	89 1d 08 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8, ebx
  000e9	a3 04 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4, eax
  000ee	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12, ecx
  000f4	5b		 pop	 ebx

; 115  : }

  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c3		 ret	 0
$LN12@tommy_hash@10:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  000f9	33 c0		 xor	 eax, eax
  000fb	85 db		 test	 ebx, ebx
  000fd	74 c7		 je	 SHORT $LN46@tommy_hash@10
  000ff	89 7d f4	 mov	 DWORD PTR tv478[ebp], edi
$LL49@tommy_hash@10:

; 100  : 			/* setup the new bucket with the lower bucket*/
; 101  : 			new_bucket[i] = hashdyn->bucket[i];

  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00108	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0010b	89 14 86	 mov	 DWORD PTR [esi+eax*4], edx

; 102  : 
; 103  : 			/* concat the upper bucket */
; 104  : 			tommy_list_concat(&new_bucket[i], &hashdyn->bucket[i + new_bucket_max]);

  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00114	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00117	85 c9		 test	 ecx, ecx
  00119	74 1a		 je	 SHORT $LN2@tommy_hash@10
  0011b	85 d2		 test	 edx, edx
  0011d	75 05		 jne	 SHORT $LN19@tommy_hash@10
  0011f	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  00122	eb 11		 jmp	 SHORT $LN2@tommy_hash@10
$LN19@tommy_hash@10:
  00124	8b 59 04	 mov	 ebx, DWORD PTR [ecx+4]
  00127	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0012a	89 5a 04	 mov	 DWORD PTR [edx+4], ebx
  0012d	8b 5d f8	 mov	 ebx, DWORD PTR _new_bucket_max$[ebp]
  00130	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00133	89 0f		 mov	 DWORD PTR [edi], ecx
$LN2@tommy_hash@10:

; 93   : 			}
; 94   : 		}
; 95   : 	} else {
; 96   : 		unsigned i;
; 97   : 
; 98   : 		/* shrink */
; 99   : 		for(i=0;i<new_bucket_max;++i) {

  00135	8b 7d f4	 mov	 edi, DWORD PTR tv478[ebp]
  00138	40		 inc	 eax
  00139	83 c7 04	 add	 edi, 4
  0013c	89 7d f4	 mov	 DWORD PTR tv478[ebp], edi
  0013f	3b c3		 cmp	 eax, ebx
  00141	72 bf		 jb	 SHORT $LL49@tommy_hash@10
  00143	eb 81		 jmp	 SHORT $LN46@tommy_hash@10
?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ENDP ; tommy_hashdyn_resize
_TEXT	ENDS
PUBLIC	_tommy_trie_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommytrie.c
;	COMDAT _tommy_trie_remove
_TEXT	SEGMENT
_tommy_trie_remove PROC					; COMDAT
; _key$ = eax

; 254  : 	tommy_trie_node* ret;
; 255  : 	tommy_trie_node** let_ptr;
; 256  : 
; 257  : 	let_ptr = &trie->bucket[key >> TOMMY_TRIE_BUCKET_SHIFT];

  00000	8b c8		 mov	 ecx, eax
  00002	c1 e9 1c	 shr	 ecx, 28			; 0000001cH
  00005	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]

; 258  : 
; 259  : 	ret = trie_bucket_remove_existing(trie, TOMMY_TRIE_BUCKET_SHIFT, let_ptr, 0, key);

  0000c	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing

; 260  : 
; 261  : 	if (!ret)

  00011	85 c0		 test	 eax, eax
  00013	75 01		 jne	 SHORT $LN1@tommy_trie@8

; 267  : }

  00015	c3		 ret	 0
$LN1@tommy_trie@8:

; 262  : 		return 0;
; 263  : 
; 264  : 	--trie->count;

  00016	ff 0d 40 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64

; 265  : 
; 266  : 	return ret->data;

  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 267  : }

  0001f	c3		 ret	 0
_tommy_trie_remove ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.h
_TEXT	ENDS
;	COMDAT _tommy_hashlin_search
_TEXT	SEGMENT
_tommy_hashlin_search PROC				; COMDAT
; _cmp_arg$ = edi
; _hash$ = esi

; 233  : 	tommy_hashlin_node* i = tommy_hashlin_bucket(hashlin, hash);

  00000	8b ce		 mov	 ecx, esi
  00002	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr
  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 234  : 	while (i) {

  00009	85 c0		 test	 eax, eax
  0000b	74 18		 je	 SHORT $LN2@tommy_hash@11
  0000d	8d 49 00	 npad	 3
$LL3@tommy_hash@11:

; 235  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 236  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0)

  00010	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  00013	75 0a		 jne	 SHORT $LN1@tommy_hash@11
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	8b 17		 mov	 edx, DWORD PTR [edi]
  0001a	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  0001d	74 09		 je	 SHORT $LN12@tommy_hash@11
$LN1@tommy_hash@11:

; 238  : 		i = i->next;

  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	85 c0		 test	 eax, eax
  00023	75 eb		 jne	 SHORT $LL3@tommy_hash@11
$LN2@tommy_hash@11:

; 239  : 	}
; 240  : 	return 0;

  00025	33 c0		 xor	 eax, eax

; 241  : }

  00027	c3		 ret	 0
$LN12@tommy_hash@11:

; 237  : 			return i->data;

  00028	8b c1		 mov	 eax, ecx

; 241  : }

  0002a	c3		 ret	 0
_tommy_hashlin_search ENDP
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xhash
_TEXT	ENDS
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z
_TEXT	SEGMENT
$T205509 = -8						; size = 8
__Last$ = 8						; size = 4
?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z PROC ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 899  : 		{	// insert elements in [begin(), _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 900  : 		if (begin() != _Last)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000f	39 01		 cmp	 DWORD PTR [ecx], eax
  00011	74 2b		 je	 SHORT $LN54@Reinsert

; 901  : 			for (--_Last; ; )

  00013	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00016	89 55 08	 mov	 DWORD PTR __Last$[ebp], edx
  00019	53		 push	 ebx
  0001a	8d 9b 00 00 00
	00		 npad	 6
$LL3@Reinsert:

; 902  : 				{	// reinsert elements in [begin(), _Last]
; 903  : 				iterator _First = begin();

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]

; 904  : 				bool _Done = _First == _Last;

  00025	3b 45 08	 cmp	 eax, DWORD PTR __Last$[ebp]

; 905  : 				_Insert(*_First, _First);

  00028	50		 push	 eax
  00029	8d 4d f8	 lea	 ecx, DWORD PTR $T205509[ebp]
  0002c	51		 push	 ecx
  0002d	0f 94 c3	 sete	 bl
  00030	83 c0 08	 add	 eax, 8
  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert

; 906  : 				if (_Done)

  00039	84 db		 test	 bl, bl
  0003b	74 e3		 je	 SHORT $LL3@Reinsert
  0003d	5b		 pop	 ebx
$LN54@Reinsert:
  0003e	5e		 pop	 esi

; 907  : 					break;
; 908  : 				}
; 909  : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?_Reinsert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ENDP ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Reinsert
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted, COMDAT
; _this$ = eax
; _it$ = ecx

; 447  :     assert(settings.use_deleted());
; 448  :     return test_deleted(it);

  00000	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00004	76 10		 jbe	 SHORT $LN15@clear_dele
  00006	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00009	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000c	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000e	75 06		 jne	 SHORT $LN15@clear_dele
  00010	b8 01 00 00 00	 mov	 eax, 1

; 449  :   }

  00015	c3		 ret	 0

; 447  :     assert(settings.use_deleted());
; 448  :     return test_deleted(it);

$LN15@clear_dele:
  00016	33 c0		 xor	 eax, eax

; 449  :   }

  00018	c3		 ret	 0
?clear_deleted@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NAAU?$dense_hashtable_const_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::clear_deleted
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z
_TEXT	SEGMENT
$T205744 = -12						; size = 12
$T205762 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_obj$ = 12						; size = 4
?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at, COMDAT
; _this$ = ecx
; _pos$ = eax

; 889  :   iterator insert_at(const_reference obj, size_type pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 890  :     if (size() >= max_size())

  00003	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0000e	8b de		 mov	 ebx, esi
  00010	2b da		 sub	 ebx, edx
  00012	57		 push	 edi
  00013	8b f8		 mov	 edi, eax
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	81 fb ff ff ff
	1f		 cmp	 ebx, 536870911		; 1fffffffH
  0001e	72 28		 jb	 SHORT $LN3@insert_at

; 891  :       throw std::length_error("insert overflow");

  00020	8d 45 08	 lea	 eax, DWORD PTR $T205762[ebp]
  00023	50		 push	 eax
  00024	8d 4d f4	 lea	 ecx, DWORD PTR $T205744[ebp]
  00027	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T205762[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  0002e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00033	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  00038	8d 4d f4	 lea	 ecx, DWORD PTR $T205744[ebp]
  0003b	51		 push	 ecx
  0003c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T205744[ebp], OFFSET ??_7length_error@std@@6B@
  00043	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN105@insert_at:
$LN3@insert_at:

; 892  :     if ( test_deleted(pos) ) {      // just replace if it's been del.

  00048	85 d2		 test	 edx, edx
  0004a	74 14		 je	 SHORT $LN103@insert_at
  0004c	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0004f	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]
  00052	3b 1c f8	 cmp	 ebx, DWORD PTR [eax+edi*8]

; 898  :     } else {

  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	75 06		 jne	 SHORT $LN103@insert_at

; 893  :       // shrug: shouldn't need to be const.
; 894  :       const_iterator delpos(this, table + pos, table + num_buckets, false);
; 895  :       clear_deleted(delpos);
; 896  :       assert( num_deleted > 0);
; 897  :       --num_deleted;                // used to be, now it isn't

  0005a	4a		 dec	 edx
  0005b	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 898  :     } else {

  0005e	eb 04		 jmp	 SHORT $LN1@insert_at
$LN103@insert_at:

; 899  :       ++num_elements;               // replacing an empty bucket

  00060	46		 inc	 esi
  00061	89 71 24	 mov	 DWORD PTR [ecx+36], esi
$LN1@insert_at:

; 900  :     }
; 901  :     set_value(&table[pos], obj);

  00064	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00067	8d 34 fd 00 00
	00 00		 lea	 esi, DWORD PTR [edi*8]
  0006e	03 d6		 add	 edx, esi
  00070	74 0d		 je	 SHORT $LN88@insert_at
  00072	8b 7d 0c	 mov	 edi, DWORD PTR _obj$[ebp]
  00075	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00077	89 1a		 mov	 DWORD PTR [edx], ebx
  00079	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0007c	89 7a 04	 mov	 DWORD PTR [edx+4], edi
$LN88@insert_at:

; 902  :     return iterator(this, table + pos, table + num_buckets, false);

  0007f	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00082	03 f2		 add	 esi, edx
  00084	89 08		 mov	 DWORD PTR [eax], ecx
  00086	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00089	5f		 pop	 edi
  0008a	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0008d	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  00090	5e		 pop	 esi
  00091	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00094	5b		 pop	 ebx

; 903  :   }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
$LN104@insert_at:
?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z
_TEXT	SEGMENT
_tmp$ = -76						; size = 56
$T206132 = -20						; size = 12
_needed_size$ = -8					; size = 4
tv282 = 8						; size = 4
$T206148 = 8						; size = 4
_this$ = 8						; size = 4
_did_resize$ = 11					; size = 1
?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta, COMDAT
; _delta$ = eax

; 556  :   bool resize_delta(size_type delta) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 557  :     bool did_resize = false;
; 558  :     if ( settings.consider_shrink() ) {  // see if lots of deletes happened

  0000a	80 7b 10 00	 cmp	 BYTE PTR [ebx+16], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f8		 mov	 edi, eax
  00012	c6 45 0b 00	 mov	 BYTE PTR _did_resize$[ebp], 0
  00016	74 0f		 je	 SHORT $LN6@resize_del

; 559  :       if ( maybe_shrink() )

  00018	8b f3		 mov	 esi, ebx
  0001a	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  0001f	84 c0		 test	 al, al
  00021	74 04		 je	 SHORT $LN6@resize_del

; 560  :         did_resize = true;

  00023	c6 45 0b 01	 mov	 BYTE PTR _did_resize$[ebp], 1
$LN6@resize_del:

; 561  :     }
; 562  :     if (num_elements >= (STL_NAMESPACE::numeric_limits<size_type>::max)() - delta)

  00027	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0002a	83 c9 ff	 or	 ecx, -1
  0002d	2b cf		 sub	 ecx, edi
  0002f	3b c1		 cmp	 eax, ecx
  00031	72 28		 jb	 SHORT $LN5@resize_del

; 563  :       throw std::length_error("resize overflow");

  00033	8d 55 08	 lea	 edx, DWORD PTR $T206148[ebp]
  00036	52		 push	 edx
  00037	8d 4d ec	 lea	 ecx, DWORD PTR $T206132[ebp]
  0003a	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T206148[ebp], OFFSET ??_C@_0BA@LHAGHPDP@resize?5overflow?$AA@
  00041	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00046	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0004b	8d 45 ec	 lea	 eax, DWORD PTR $T206132[ebp]
  0004e	50		 push	 eax
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T206132[ebp], OFFSET ??_7length_error@std@@6B@
  00056	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN46@resize_del:
$LN5@resize_del:

; 564  :     if ( bucket_count() >= HT_MIN_BUCKETS &&
; 565  :          (num_elements + delta) <= settings.enlarge_threshold() )

  0005b	83 7b 28 04	 cmp	 DWORD PTR [ebx+40], 4
  0005f	72 13		 jb	 SHORT $LN4@resize_del
  00061	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  00064	3b 0b		 cmp	 ecx, DWORD PTR [ebx]
  00066	77 0c		 ja	 SHORT $LN4@resize_del
$LN45@resize_del:

; 566  :       return did_resize;                          // we're ok as we are

  00068	8a 45 0b	 mov	 al, BYTE PTR _did_resize$[ebp]

; 600  :   }

  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
$LN4@resize_del:

; 567  : 
; 568  :     // Sometimes, we need to resize just to get rid of all the
; 569  :     // "deleted" buckets that are clogging up the hashtable.  So when
; 570  :     // deciding whether to resize, count the deleted buckets (which
; 571  :     // are currently taking up room).  But later, when we decide what
; 572  :     // size to resize to, *don't* count deleted buckets, since they
; 573  :     // get discarded during the resize.
; 574  :     const size_type needed_size = settings.min_buckets(num_elements + delta, 0);

  00074	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]
  00077	33 f6		 xor	 esi, esi
  00079	8b c3		 mov	 eax, ebx
  0007b	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets

; 575  :     if ( needed_size <= bucket_count() )      // we have enough buckets

  00080	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  00083	89 45 f8	 mov	 DWORD PTR _needed_size$[ebp], eax
  00086	3b c6		 cmp	 eax, esi

; 576  :       return did_resize;

  00088	76 de		 jbe	 SHORT $LN45@resize_del

; 577  : 
; 578  :     size_type resize_to =
; 579  :       settings.min_buckets(num_elements - num_deleted + delta, bucket_count());

  0008a	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  0008d	2b 53 20	 sub	 edx, DWORD PTR [ebx+32]
  00090	8b c3		 mov	 eax, ebx
  00092	03 d7		 add	 edx, edi
  00094	e8 00 00 00 00	 call	 ?min_buckets@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QAEIII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::min_buckets
  00099	8b f0		 mov	 esi, eax

; 580  : 
; 581  :     if (resize_to < needed_size &&    // may double resize_to
; 582  :         resize_to < (STL_NAMESPACE::numeric_limits<size_type>::max)() / 2) {

  0009b	3b 75 f8	 cmp	 esi, DWORD PTR _needed_size$[ebp]
  0009e	73 24		 jae	 SHORT $LN1@resize_del
  000a0	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000a6	73 1c		 jae	 SHORT $LN1@resize_del

; 583  :       // This situation means that we have enough deleted elements,
; 584  :       // that once we purge them, we won't actually have needed to
; 585  :       // grow.  But we may want to grow anyway: if we just purge one
; 586  :       // element, say, we'll have to grow anyway next time we
; 587  :       // insert.  Might as well grow now, since we're already going
; 588  :       // through the trouble of copying (in order to purge the
; 589  :       // deleted elements).
; 590  :       const size_type target =
; 591  :           static_cast<size_type>(settings.shrink_size(resize_to*2));

  000a8	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  000ab	8b cb		 mov	 ecx, ebx
  000ad	89 45 08	 mov	 DWORD PTR tv282[ebp], eax
  000b0	e8 00 00 00 00	 call	 ?shrink_size@?$sh_hashtable_settings@IVcpp_tommy_inthash_u32@@I$03@@QBEII@Z ; sh_hashtable_settings<unsigned int,cpp_tommy_inthash_u32,unsigned int,4>::shrink_size

; 592  :       if (num_elements - num_deleted + delta >= target) {

  000b5	8b 53 24	 mov	 edx, DWORD PTR [ebx+36]
  000b8	2b 53 20	 sub	 edx, DWORD PTR [ebx+32]
  000bb	03 d7		 add	 edx, edi
  000bd	3b d0		 cmp	 edx, eax
  000bf	72 03		 jb	 SHORT $LN1@resize_del

; 593  :         // Good, we won't be below the shrink threshhold even if we double.
; 594  :         resize_to *= 2;

  000c1	8b 75 08	 mov	 esi, DWORD PTR tv282[ebp]
$LN1@resize_del:

; 595  :       }
; 596  :     }
; 597  :     dense_hashtable tmp(*this, resize_to);

  000c4	8b c6		 mov	 eax, esi
  000c6	8b cb		 mov	 ecx, ebx
  000c8	8d 7d b4	 lea	 edi, DWORD PTR _tmp$[ebp]
  000cb	e8 00 00 00 00	 call	 ??0?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE@ABV01@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >

; 598  :     swap(tmp);                             // now we are tmp

  000d0	8b d7		 mov	 edx, edi
  000d2	8b cb		 mov	 ecx, ebx
  000d4	e8 00 00 00 00	 call	 ?swap@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXAAV12@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::swap

; 599  :     return true;

  000d9	8b 45 e8	 mov	 eax, DWORD PTR _tmp$[ebp+52]
  000dc	85 c0		 test	 eax, eax
  000de	74 09		 je	 SHORT $LN39@resize_del
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _free
  000e6	83 c4 04	 add	 esp, 4
$LN39@resize_del:

; 600  :   }

  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	b0 01		 mov	 al, 1
  000ed	5b		 pop	 ebx
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 04 00	 ret	 4
$LN44@resize_del:
?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 12
?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase, COMDAT
; _this$ = eax

; 998  :   void erase(iterator pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 999  :     if ( pos == end() ) return;    // sanity check

  00003	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00006	8b 50 34	 mov	 edx, DWORD PTR [eax+52]
  00009	56		 push	 esi
  0000a	8d 34 ca	 lea	 esi, DWORD PTR [edx+ecx*8]
  0000d	8b ce		 mov	 ecx, esi
  0000f	3b ce		 cmp	 ecx, esi
  00011	74 1d		 je	 SHORT $LN93@erase@9
  00013	57		 push	 edi
  00014	8b 78 2c	 mov	 edi, DWORD PTR [eax+44]
$LL12@erase@9:
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	3b fa		 cmp	 edi, edx
  0001b	74 0b		 je	 SHORT $LN10@erase@9
  0001d	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00021	76 0c		 jbe	 SHORT $LN94@erase@9
  00023	39 50 1c	 cmp	 DWORD PTR [eax+28], edx
  00026	75 07		 jne	 SHORT $LN94@erase@9
$LN10@erase@9:
  00028	83 c1 08	 add	 ecx, 8
  0002b	3b ce		 cmp	 ecx, esi
  0002d	75 e8		 jne	 SHORT $LL12@erase@9
$LN94@erase@9:
  0002f	5f		 pop	 edi
$LN93@erase@9:
  00030	8b 55 0c	 mov	 edx, DWORD PTR _pos$[ebp+4]
  00033	3b d1		 cmp	 edx, ecx
  00035	74 31		 je	 SHORT $LN89@erase@9

; 1000 :     if ( set_deleted(pos) ) {      // true if object has been newly deleted

  00037	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0003b	53		 push	 ebx
  0003c	76 0e		 jbe	 SHORT $LN73@erase@9
  0003e	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00041	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  00043	75 07		 jne	 SHORT $LN73@erase@9
  00045	bb 01 00 00 00	 mov	 ebx, 1
  0004a	eb 02		 jmp	 SHORT $LN74@erase@9
$LN73@erase@9:
  0004c	33 db		 xor	 ebx, ebx
$LN74@erase@9:
  0004e	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00051	8b ca		 mov	 ecx, edx
  00053	84 db		 test	 bl, bl
  00055	89 32		 mov	 DWORD PTR [edx], esi
  00057	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0005e	5b		 pop	 ebx
  0005f	75 07		 jne	 SHORT $LN89@erase@9

; 1001 :       ++num_deleted;

  00061	ff 40 20	 inc	 DWORD PTR [eax+32]

; 1002 :       settings.set_consider_shrink(true); // will think about shrink after next insert

  00064	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1
$LN89@erase@9:
  00068	5e		 pop	 esi

; 1003 :     }
; 1004 :   }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z
_TEXT	SEGMENT
_pos$ = -8						; size = 8
_key$ = 8						; size = 4
?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 834  :   iterator find(const key_type& key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b f8		 mov	 edi, eax

; 835  :     if ( size() == 0 ) return end();

  00009	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0000c	2b 47 20	 sub	 eax, DWORD PTR [edi+32]
  0000f	75 21		 jne	 SHORT $LN3@find@3
  00011	89 3e		 mov	 DWORD PTR [esi], edi
$LN22@find@3:
  00013	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00016	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00019	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0001c	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00022	8b c6		 mov	 eax, esi
  00024	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted

; 839  :     else
; 840  :       return iterator(this, table + pos.first, table + num_buckets, false);

  00029	8b c6		 mov	 eax, esi
  0002b	5f		 pop	 edi

; 841  :   }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN3@find@3:

; 836  :     pair<size_type, size_type> pos = find_position(key);

  00032	8d 45 f8	 lea	 eax, DWORD PTR _pos$[ebp]
  00035	50		 push	 eax
  00036	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  00039	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 837  :     if ( pos.first == ILLEGAL_BUCKET )     // alas, not there

  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _pos$[ebp]

; 838  :       return end();

  00041	89 3e		 mov	 DWORD PTR [esi], edi
  00043	83 f9 ff	 cmp	 ecx, -1
  00046	74 cb		 je	 SHORT $LN22@find@3

; 839  :     else
; 840  :       return iterator(this, table + pos.first, table + num_buckets, false);

  00048	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004b	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  0004e	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00051	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00054	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00057	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0005a	8b c6		 mov	 eax, esi
  0005c	5f		 pop	 edi

; 841  :   }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?find@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize, COMDAT
; _this$ = esi

; 643  :   void resize(size_type req_elements) {       // resize to this or larger

  00000	51		 push	 ecx

; 644  :     if ( settings.consider_shrink() || req_elements == 0 )
; 645  :       maybe_shrink();

  00001	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  00006	59		 pop	 ecx

; 646  :     if ( req_elements > num_elements )
; 647  :       resize_delta(req_elements - num_elements);
; 648  :   }

  00007	c3		 ret	 0
?resize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 12
?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase, COMDAT

; 307  :   void erase(iterator it)                            { rep.erase(it); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f3 0f 7e 45 08	 movq	 xmm0, QWORD PTR _it$[ebp]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _it$[ebp+8]
  0000b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000e	8b c4		 mov	 eax, esp
  00010	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00014	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0001c	e8 00 00 00 00	 call	 ?erase@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::erase
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z
_TEXT	SEGMENT
_pos$206733 = -8					; size = 8
_key$ = 8						; size = 4
?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find, COMDAT
; ___$ReturnUdt$ = esi

; 262  :   iterator find(const key_type& key)                 { return rep.find(key); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	57		 push	 edi
  00007	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0000d	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00010	2b 47 20	 sub	 eax, DWORD PTR [edi+32]
  00013	75 21		 jne	 SHORT $LN5@find@4
  00015	89 3e		 mov	 DWORD PTR [esi], edi
$LN24@find@4:
  00017	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0001a	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0001d	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  00020	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00023	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00026	8b c6		 mov	 eax, esi
  00028	e8 00 00 00 00	 call	 ?advance_past_empty_and_deleted@?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEXXZ ; google::dense_hashtable_iterator<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::advance_past_empty_and_deleted
  0002d	8b c6		 mov	 eax, esi
  0002f	5f		 pop	 edi
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN5@find@4:
  00036	8d 45 f8	 lea	 eax, DWORD PTR _pos$206733[ebp]
  00039	50		 push	 eax
  0003a	8b 45 08	 mov	 eax, DWORD PTR _key$[ebp]
  0003d	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _pos$206733[ebp]
  00045	89 3e		 mov	 DWORD PTR [esi], edi
  00047	83 f9 ff	 cmp	 ecx, -1
  0004a	74 cb		 je	 SHORT $LN24@find@4
  0004c	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  0004f	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00052	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00055	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00058	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0005b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0005e	8b c6		 mov	 eax, esi
  00060	5f		 pop	 edi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?find@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize, COMDAT

; 258  :   void resize(size_type hint)         { rep.resize(hint); }

  00000	56		 push	 esi
  00001	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00007	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink
  0000c	5e		 pop	 esi
  0000d	c3		 ret	 0
?resize@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEXI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize
_TEXT	ENDS
PUBLIC	?test_miss@@YAXPAI@Z				; test_miss
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
;	COMDAT ?test_miss@@YAXPAI@Z
_TEXT	SEGMENT
$T206777 = -52						; size = 16
$T211376 = -44						; size = 8
_t$211383 = -44						; size = 8
$T211316 = -44						; size = 8
_t$211323 = -44						; size = 8
$T211290 = -44						; size = 8
_t$211298 = -44						; size = 8
$T211270 = -44						; size = 8
$T211244 = -44						; size = 8
$T211224 = -44						; size = 8
_t$211231 = -44						; size = 8
_t$211206 = -44						; size = 8
$T211198 = -44						; size = 8
$T211178 = -44						; size = 8
$T211152 = -44						; size = 8
$T211071 = -44						; size = 8
$T211045 = -44						; size = 8
$T210684 = -44						; size = 8
$T210658 = -44						; size = 8
$T210550 = -44						; size = 8
$T210524 = -44						; size = 8
$T210118 = -44						; size = 8
$T208960 = -44						; size = 8
$T208934 = -44						; size = 8
_t$207310 = -44						; size = 8
_t$211252 = -36						; size = 8
_t$211160 = -36						; size = 8
_t$211053 = -36						; size = 8
_t$210669 = -36						; size = 8
_t$210535 = -36						; size = 8
_t$208942 = -36						; size = 8
_t$207285 = -36						; size = 8
_t$211277 = -28						; size = 8
_t$211185 = -28						; size = 8
_t$211078 = -28						; size = 8
_t$210693 = -28						; size = 8
_t$210559 = -28						; size = 8
_t$208967 = -28						; size = 8
_pos$208487 = -28					; size = 8
$T207304 = -28						; size = 8
$T207278 = -28						; size = 8
_t$207261 = -28						; size = 8
tv3831 = -20						; size = 8
tv3810 = -20						; size = 8
tv3761 = -20						; size = 8
tv3737 = -20						; size = 8
tv3714 = -20						; size = 8
tv3660 = -20						; size = 8
tv3556 = -20						; size = 8
tv3508 = -20						; size = 8
tv3388 = -20						; size = 8
tv3140 = -20						; size = 8
tv3094 = -20						; size = 8
tv3052 = -20						; size = 8
tv2269 = -20						; size = 8
tv2219 = -20						; size = 8
tv1861 = -20						; size = 8
$T210119 = -20						; size = 8
tv1542 = -20						; size = 8
tv1430 = -20						; size = 8
tv1192 = -20						; size = 8
tv1161 = -20						; size = 8
tv1129 = -20						; size = 8
tv1123 = -20						; size = 8
$T207254 = -20						; size = 8
$T207228 = -20						; size = 8
$T207189 = -20						; size = 8
tv1013 = -20						; size = 8
tv904 = -20						; size = 8
_t$207196 = -20						; size = 8
$T207163 = -20						; size = 8
_t$207171 = -20						; size = 8
$T207110 = -20						; size = 8
_t$207117 = -20						; size = 8
$T207084 = -20						; size = 8
tv752 = -20						; size = 8
_t$207092 = -20						; size = 8
$T206949 = -20						; size = 8
_t$206956 = -20						; size = 8
$T206923 = -20						; size = 8
_t$206931 = -20						; size = 8
$T206875 = -20						; size = 8
_t$206882 = -20						; size = 8
tv503 = -20						; size = 8
tv409 = -20						; size = 8
tv143 = -20						; size = 8
tv95 = -20						; size = 8
_bitpos$211349 = -16					; size = 4
__Where$210926 = -16					; size = 4
_count$207058 = -16					; size = 4
_key$152192 = -16					; size = 4
_key$152090 = -16					; size = 4
_key$152081 = -16					; size = 4
_key$152062 = -16					; size = 4
_key$152042 = -16					; size = 4
_t$207236 = -12						; size = 8
$T210922 = -8						; size = 4
$T206782 = -8						; size = 4
_i$ = -8						; size = 4
_SEARCH$ = 8						; size = 4
?test_miss@@YAXPAI@Z PROC				; test_miss, COMDAT

; 1336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	53		 push	 ebx

; 1337 : 	unsigned i;
; 1338 : 
; 1339 : 	const unsigned DELTA = 0;
; 1340 : 
; 1341 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	0f 85 91 00 00
	00		 jne	 $LN124@test_miss
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00029	75 2e		 jne	 SHORT $LN134@test_miss
  0002b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00036	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003d	50		 push	 eax
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00043	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0004a	52		 push	 edx
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET $SG-101
  00051	e8 00 00 00 00	 call	 _printf
  00056	83 c4 10	 add	 esp, 16			; 00000010H
$LN134@test_miss:
  00059	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005e	33 ff		 xor	 edi, edi
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00065	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006b	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00071	76 40		 jbe	 SHORT $LN124@test_miss
$LL126@test_miss:

; 1342 : 		struct rbt_object key;
; 1343 : 		key.value = SEARCH[i] + DELTA;
; 1344 : 		if (rbt_search(&tree, &key))

  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?tree@@3Urbtree_t@@A
  00078	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]
  0007b	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00080	74 28		 je	 SHORT $LN125@test_miss
$LL144@test_miss:
  00082	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00085	3b d1		 cmp	 edx, ecx
  00087	7c 11		 jl	 SHORT $LN1172@test_miss
  00089	7e 13		 jle	 SHORT $LN143@test_miss
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	83 e0 fe	 and	 eax, -2			; fffffffeH
$LN141@test_miss:
  00091	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  00096	75 ea		 jne	 SHORT $LL144@test_miss
  00098	eb 10		 jmp	 SHORT $LN125@test_miss
$LN1172@test_miss:
  0009a	8b 00		 mov	 eax, DWORD PTR [eax]
  0009c	eb f3		 jmp	 SHORT $LN141@test_miss
$LN143@test_miss:
  0009e	3d 04 00 00 00	 cmp	 eax, OFFSET ?tree@@3Urbtree_t@@A+4
  000a3	74 05		 je	 SHORT $LN125@test_miss

; 1345 : 			abort();

  000a5	e8 00 00 00 00	 call	 _abort
$LN125@test_miss:

; 1337 : 	unsigned i;
; 1338 : 
; 1339 : 	const unsigned DELTA = 0;
; 1340 : 
; 1341 : 	START(DATA_TREE) {

  000aa	47		 inc	 edi
  000ab	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  000b1	72 c0		 jb	 SHORT $LL126@test_miss
$LN124@test_miss:

; 1346 : 	} STOP();

  000b3	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1347 : 
; 1348 : 	START(DATA_HASHTABLE) {

  000b8	33 ff		 xor	 edi, edi
  000ba	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, edi ; the_start_data
  000c0	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, edi ; the_data
  000c6	0f 85 cb 00 00
	00		 jne	 $LN119@test_miss
  000cc	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, edi ; the_log
  000d2	75 2f		 jne	 SHORT $LN151@test_miss
  000d4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA
  000da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  000df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  000e6	52		 push	 edx
  000e7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  000ed	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  000f4	51		 push	 ecx
  000f5	50		 push	 eax
  000f6	68 00 00 00 00	 push	 OFFSET $SG-101
  000fb	e8 00 00 00 00	 call	 _printf
  00100	83 c4 10	 add	 esp, 16			; 00000010H
$LN151@test_miss:
  00103	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00108	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0010d	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00113	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00119	76 7c		 jbe	 SHORT $LN119@test_miss
  0011b	eb 03 8d 49 00	 npad	 5
$LL121@test_miss:

; 1349 : 		unsigned key = SEARCH[i] + DELTA;

  00120	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]

; 1350 : 		unsigned hash_key = hash(key);

  00123	8b ca		 mov	 ecx, edx
  00125	c1 e1 06	 shl	 ecx, 6
  00128	8b c2		 mov	 eax, edx
  0012a	2b c1		 sub	 eax, ecx
  0012c	8b c8		 mov	 ecx, eax
  0012e	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00131	33 c1		 xor	 eax, ecx
  00133	8b c8		 mov	 ecx, eax
  00135	c1 e1 09	 shl	 ecx, 9
  00138	2b c1		 sub	 eax, ecx

; 1351 : 		struct hashtable_object* obj;
; 1352 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  0013a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00140	8b c8		 mov	 ecx, eax
  00142	c1 e1 04	 shl	 ecx, 4
  00145	33 c1		 xor	 eax, ecx
  00147	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0014e	2b c1		 sub	 eax, ecx
  00150	8b c8		 mov	 ecx, eax
  00152	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00155	33 c1		 xor	 eax, ecx
  00157	8b c8		 mov	 ecx, eax
  00159	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  0015c	33 c8		 xor	 ecx, eax
  0015e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00163	23 c1		 and	 eax, ecx
  00165	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  00168	85 c0		 test	 eax, eax
  0016a	74 22		 je	 SHORT $LN120@test_miss
  0016c	8d 64 24 00	 npad	 4
$LL161@test_miss:
  00170	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00173	75 08		 jne	 SHORT $LN159@test_miss
  00175	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  00178	3b 53 10	 cmp	 edx, DWORD PTR [ebx+16]
  0017b	74 08		 je	 SHORT $LN1133@test_miss
$LN159@test_miss:
  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
  0017f	85 c0		 test	 eax, eax
  00181	75 ed		 jne	 SHORT $LL161@test_miss
  00183	eb 09		 jmp	 SHORT $LN120@test_miss
$LN1133@test_miss:

; 1353 : 		if (obj)

  00185	85 db		 test	 ebx, ebx
  00187	74 05		 je	 SHORT $LN120@test_miss

; 1354 : 			abort();

  00189	e8 00 00 00 00	 call	 _abort
$LN120@test_miss:

; 1347 : 
; 1348 : 	START(DATA_HASHTABLE) {

  0018e	47		 inc	 edi
  0018f	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00195	72 89		 jb	 SHORT $LL121@test_miss
$LN119@test_miss:

; 1355 : 	} STOP();

  00197	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1356 : 
; 1357 : 	START(DATA_HASHDYN) {

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001a6	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001ac	0f 85 38 01 00
	00		 jne	 $LN114@test_miss
  001b2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001b9	75 30		 jne	 SHORT $LN169@test_miss
  001bb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  001c7	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  001ce	51		 push	 ecx
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  001d5	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  001dc	50		 push	 eax
  001dd	52		 push	 edx
  001de	68 00 00 00 00	 push	 OFFSET $SG-101
  001e3	e8 00 00 00 00	 call	 _printf
  001e8	83 c4 10	 add	 esp, 16			; 00000010H
$LN169@test_miss:
  001eb	8d 45 ec	 lea	 eax, DWORD PTR _t$206882[ebp]
  001ee	50		 push	 eax
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  001f5	85 c0		 test	 eax, eax
  001f7	75 11		 jne	 SHORT $LN175@test_miss
  001f9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001fd	66 0f 13 45 ec	 movlpd	 QWORD PTR $T206875[ebp], xmm0
  00202	8b 5d f0	 mov	 ebx, DWORD PTR $T206875[ebp+4]
  00205	8b 7d ec	 mov	 edi, DWORD PTR $T206875[ebp]
  00208	eb 57		 jmp	 SHORT $LN176@test_miss
$LN175@test_miss:
  0020a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00210	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00216	8b 4d f0	 mov	 ecx, DWORD PTR _t$206882[ebp+4]
  00219	8b 55 ec	 mov	 edx, DWORD PTR _t$206882[ebp]
  0021c	57		 push	 edi
  0021d	56		 push	 esi
  0021e	51		 push	 ecx
  0021f	52		 push	 edx
  00220	e8 00 00 00 00	 call	 __alldvrm
  00225	6a 00		 push	 0
  00227	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0022c	53		 push	 ebx
  0022d	51		 push	 ecx
  0022e	89 45 ec	 mov	 DWORD PTR tv95[ebp], eax
  00231	89 55 f0	 mov	 DWORD PTR tv95[ebp+4], edx
  00234	e8 00 00 00 00	 call	 __allmul
  00239	57		 push	 edi
  0023a	56		 push	 esi
  0023b	52		 push	 edx
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 __alldiv
  00242	8b 4d ec	 mov	 ecx, DWORD PTR tv95[ebp]
  00245	6a 00		 push	 0
  00247	8b f8		 mov	 edi, eax
  00249	8b 45 f0	 mov	 eax, DWORD PTR tv95[ebp+4]
  0024c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00251	50		 push	 eax
  00252	51		 push	 ecx
  00253	8b da		 mov	 ebx, edx
  00255	e8 00 00 00 00	 call	 __allmul
  0025a	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  0025d	03 f8		 add	 edi, eax
  0025f	13 da		 adc	 ebx, edx
$LN176@test_miss:
  00261	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00267	33 ff		 xor	 edi, edi
  00269	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0026f	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00275	76 73		 jbe	 SHORT $LN114@test_miss
$LL116@test_miss:

; 1358 : 		unsigned key = SEARCH[i] + DELTA;

  00277	8b 14 be	 mov	 edx, DWORD PTR [esi+edi*4]

; 1359 : 		unsigned hash_key = hash(key);

  0027a	8b ca		 mov	 ecx, edx
  0027c	c1 e1 06	 shl	 ecx, 6
  0027f	8b c2		 mov	 eax, edx
  00281	2b c1		 sub	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00288	33 c1		 xor	 eax, ecx
  0028a	8b c8		 mov	 ecx, eax
  0028c	c1 e1 09	 shl	 ecx, 9
  0028f	2b c1		 sub	 eax, ecx

; 1360 : 		struct hashtable_object* obj;
; 1361 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  00291	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00297	8b c8		 mov	 ecx, eax
  00299	c1 e1 04	 shl	 ecx, 4
  0029c	33 c1		 xor	 eax, ecx
  0029e	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  002a5	2b c1		 sub	 eax, ecx
  002a7	8b c8		 mov	 ecx, eax
  002a9	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002ac	33 c1		 xor	 eax, ecx
  002ae	8b c8		 mov	 ecx, eax
  002b0	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002b3	33 c8		 xor	 ecx, eax
  002b5	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002ba	23 c1		 and	 eax, ecx
  002bc	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  002bf	85 c0		 test	 eax, eax
  002c1	74 1e		 je	 SHORT $LN115@test_miss
$LL182@test_miss:
  002c3	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  002c6	75 08		 jne	 SHORT $LN180@test_miss
  002c8	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  002cb	3b 53 10	 cmp	 edx, DWORD PTR [ebx+16]
  002ce	74 08		 je	 SHORT $LN1134@test_miss
$LN180@test_miss:
  002d0	8b 00		 mov	 eax, DWORD PTR [eax]
  002d2	85 c0		 test	 eax, eax
  002d4	75 ed		 jne	 SHORT $LL182@test_miss
  002d6	eb 09		 jmp	 SHORT $LN115@test_miss
$LN1134@test_miss:

; 1362 : 		if (obj)

  002d8	85 db		 test	 ebx, ebx
  002da	74 05		 je	 SHORT $LN115@test_miss

; 1363 : 			abort();

  002dc	e8 00 00 00 00	 call	 _abort
$LN115@test_miss:

; 1356 : 
; 1357 : 	START(DATA_HASHDYN) {

  002e1	47		 inc	 edi
  002e2	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  002e8	72 8d		 jb	 SHORT $LL116@test_miss
$LN114@test_miss:

; 1364 : 	} STOP();

  002ea	8d 4d ec	 lea	 ecx, DWORD PTR _t$206931[ebp]
  002ed	51		 push	 ecx
  002ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  002f4	85 c0		 test	 eax, eax
  002f6	75 11		 jne	 SHORT $LN194@test_miss
  002f8	66 0f 57 c0	 xorpd	 xmm0, xmm0
  002fc	66 0f 13 45 ec	 movlpd	 QWORD PTR $T206923[ebp], xmm0
  00301	8b 5d f0	 mov	 ebx, DWORD PTR $T206923[ebp+4]
  00304	8b 7d ec	 mov	 edi, DWORD PTR $T206923[ebp]
  00307	eb 54		 jmp	 SHORT $LN195@test_miss
$LN194@test_miss:
  00309	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0030f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00315	8b 55 f0	 mov	 edx, DWORD PTR _t$206931[ebp+4]
  00318	8b 45 ec	 mov	 eax, DWORD PTR _t$206931[ebp]
  0031b	57		 push	 edi
  0031c	56		 push	 esi
  0031d	52		 push	 edx
  0031e	50		 push	 eax
  0031f	e8 00 00 00 00	 call	 __alldvrm
  00324	6a 00		 push	 0
  00326	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0032b	53		 push	 ebx
  0032c	51		 push	 ecx
  0032d	89 45 ec	 mov	 DWORD PTR tv752[ebp], eax
  00330	89 55 f0	 mov	 DWORD PTR tv752[ebp+4], edx
  00333	e8 00 00 00 00	 call	 __allmul
  00338	57		 push	 edi
  00339	56		 push	 esi
  0033a	52		 push	 edx
  0033b	50		 push	 eax
  0033c	e8 00 00 00 00	 call	 __alldiv
  00341	8b 4d f0	 mov	 ecx, DWORD PTR tv752[ebp+4]
  00344	6a 00		 push	 0
  00346	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0034b	8b da		 mov	 ebx, edx
  0034d	8b 55 ec	 mov	 edx, DWORD PTR tv752[ebp]
  00350	51		 push	 ecx
  00351	52		 push	 edx
  00352	8b f8		 mov	 edi, eax
  00354	e8 00 00 00 00	 call	 __allmul
  00359	03 f8		 add	 edi, eax
  0035b	13 da		 adc	 ebx, edx
$LN195@test_miss:
  0035d	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00363	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00369	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0036f	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00375	75 63		 jne	 SHORT $LN192@test_miss
  00377	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0037e	75 23		 jne	 SHORT $LN190@test_miss
  00380	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00385	6a 00		 push	 0
  00387	50		 push	 eax
  00388	53		 push	 ebx
  00389	57		 push	 edi
  0038a	e8 00 00 00 00	 call	 __aulldiv
  0038f	50		 push	 eax
  00390	68 00 00 00 00	 push	 OFFSET $SG-102
  00395	e8 00 00 00 00	 call	 _printf
  0039a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  003a0	83 c4 08	 add	 esp, 8
$LN190@test_miss:
  003a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  003a9	6a 00		 push	 0
  003ab	51		 push	 ecx
  003ac	53		 push	 ebx
  003ad	57		 push	 edi
  003ae	e8 00 00 00 00	 call	 __aulldiv
  003b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  003b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  003bf	c1 e2 04	 shl	 edx, 4
  003c2	03 d6		 add	 edx, esi
  003c4	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  003c7	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  003ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  003d0	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  003d3	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN192@test_miss:

; 1365 : 
; 1366 : 	START(DATA_HASHLIN) {

  003da	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 2 ; the_start_data
  003e4	83 fe 02	 cmp	 esi, 2
  003e7	0f 85 82 01 00
	00		 jne	 $LN109@test_miss
  003ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  003f4	75 2e		 jne	 SHORT $LN199@test_miss
  003f6	a1 08 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  003fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00401	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00408	50		 push	 eax
  00409	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0040e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00415	52		 push	 edx
  00416	51		 push	 ecx
  00417	68 00 00 00 00	 push	 OFFSET $SG-101
  0041c	e8 00 00 00 00	 call	 _printf
  00421	83 c4 10	 add	 esp, 16			; 00000010H
$LN199@test_miss:
  00424	8d 55 ec	 lea	 edx, DWORD PTR _t$206956[ebp]
  00427	52		 push	 edx
  00428	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0042e	85 c0		 test	 eax, eax
  00430	75 11		 jne	 SHORT $LN205@test_miss
  00432	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00436	66 0f 13 45 ec	 movlpd	 QWORD PTR $T206949[ebp], xmm0
  0043b	8b 5d f0	 mov	 ebx, DWORD PTR $T206949[ebp+4]
  0043e	8b 7d ec	 mov	 edi, DWORD PTR $T206949[ebp]
  00441	eb 54		 jmp	 SHORT $LN206@test_miss
$LN205@test_miss:
  00443	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00449	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0044f	8b 45 f0	 mov	 eax, DWORD PTR _t$206956[ebp+4]
  00452	8b 4d ec	 mov	 ecx, DWORD PTR _t$206956[ebp]
  00455	57		 push	 edi
  00456	56		 push	 esi
  00457	50		 push	 eax
  00458	51		 push	 ecx
  00459	e8 00 00 00 00	 call	 __alldvrm
  0045e	6a 00		 push	 0
  00460	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00465	53		 push	 ebx
  00466	51		 push	 ecx
  00467	89 45 ec	 mov	 DWORD PTR tv143[ebp], eax
  0046a	89 55 f0	 mov	 DWORD PTR tv143[ebp+4], edx
  0046d	e8 00 00 00 00	 call	 __allmul
  00472	57		 push	 edi
  00473	56		 push	 esi
  00474	52		 push	 edx
  00475	50		 push	 eax
  00476	e8 00 00 00 00	 call	 __alldiv
  0047b	6a 00		 push	 0
  0047d	8b da		 mov	 ebx, edx
  0047f	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp+4]
  00482	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00487	8b f8		 mov	 edi, eax
  00489	8b 45 ec	 mov	 eax, DWORD PTR tv143[ebp]
  0048c	52		 push	 edx
  0048d	50		 push	 eax
  0048e	e8 00 00 00 00	 call	 __allmul
  00493	03 f8		 add	 edi, eax
  00495	13 da		 adc	 ebx, edx
$LN206@test_miss:
  00497	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0049d	33 ff		 xor	 edi, edi
  0049f	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  004a5	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  004ab	0f 86 be 00 00
	00		 jbe	 $LN109@test_miss
$LN111@test_miss:

; 1367 : 		unsigned key = SEARCH[i] + DELTA;

  004b1	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  004b4	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 1368 : 		unsigned hash_key = hash(key);

  004b7	8b d6		 mov	 edx, esi
  004b9	c1 e2 06	 shl	 edx, 6
  004bc	8b c6		 mov	 eax, esi
  004be	2b c2		 sub	 eax, edx
  004c0	8b c8		 mov	 ecx, eax
  004c2	c1 e9 11	 shr	 ecx, 17			; 00000011H
  004c5	33 c1		 xor	 eax, ecx
  004c7	8b d0		 mov	 edx, eax
  004c9	c1 e2 09	 shl	 edx, 9
  004cc	2b c2		 sub	 eax, edx
  004ce	8b c8		 mov	 ecx, eax
  004d0	c1 e1 04	 shl	 ecx, 4
  004d3	33 c1		 xor	 eax, ecx
  004d5	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  004dc	2b c2		 sub	 eax, edx
  004de	8b c8		 mov	 ecx, eax
  004e0	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  004e3	33 c1		 xor	 eax, ecx
  004e5	8b d0		 mov	 edx, eax
  004e7	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  004ea	33 d0		 xor	 edx, eax

; 1369 : 		struct hashtable_object* obj;
; 1370 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  004ec	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  004f3	74 1c		 je	 SHORT $LN217@test_miss
  004f5	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  004fa	23 c2		 and	 eax, edx
  004fc	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  00502	72 0d		 jb	 SHORT $LN217@test_miss
  00504	83 f8 40	 cmp	 eax, 64			; 00000040H
  00507	73 1c		 jae	 SHORT $LN226@test_miss
  00509	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0050f	eb 2a		 jmp	 SHORT $LN1246@test_miss
$LN217@test_miss:
  00511	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00516	23 c2		 and	 eax, edx
  00518	83 f8 40	 cmp	 eax, 64			; 00000040H
  0051b	73 08		 jae	 SHORT $LN226@test_miss
  0051d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00523	eb 16		 jmp	 SHORT $LN1246@test_miss
$LN226@test_miss:
  00525	0f bd c8	 bsr	 ecx, eax
  00528	bb 01 00 00 00	 mov	 ebx, 1
  0052d	d3 e3		 shl	 ebx, cl
  0052f	89 4d f0	 mov	 DWORD PTR _count$207058[ebp], ecx
  00532	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00539	2b c3		 sub	 eax, ebx
$LN1246@test_miss:
  0053b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0053e	8b 00		 mov	 eax, DWORD PTR [eax]
  00540	85 c0		 test	 eax, eax
  00542	74 1e		 je	 SHORT $LN110@test_miss
$LL212@test_miss:
  00544	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00547	75 08		 jne	 SHORT $LN210@test_miss
  00549	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0054c	3b 71 10	 cmp	 esi, DWORD PTR [ecx+16]
  0054f	74 08		 je	 SHORT $LN1135@test_miss
$LN210@test_miss:
  00551	8b 00		 mov	 eax, DWORD PTR [eax]
  00553	85 c0		 test	 eax, eax
  00555	75 ed		 jne	 SHORT $LL212@test_miss
  00557	eb 09		 jmp	 SHORT $LN110@test_miss
$LN1135@test_miss:

; 1371 : 		if (obj)

  00559	85 c9		 test	 ecx, ecx
  0055b	74 05		 je	 SHORT $LN110@test_miss

; 1372 : 			abort();

  0055d	e8 00 00 00 00	 call	 _abort
$LN110@test_miss:

; 1365 : 
; 1366 : 	START(DATA_HASHLIN) {

  00562	47		 inc	 edi
  00563	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00569	0f 82 42 ff ff
	ff		 jb	 $LN111@test_miss
$LN109@test_miss:

; 1373 : 	} STOP();

  0056f	8d 55 ec	 lea	 edx, DWORD PTR _t$207092[ebp]
  00572	52		 push	 edx
  00573	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00579	85 c0		 test	 eax, eax
  0057b	75 11		 jne	 SHORT $LN238@test_miss
  0057d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00581	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207084[ebp], xmm0
  00586	8b 5d f0	 mov	 ebx, DWORD PTR $T207084[ebp+4]
  00589	8b 7d ec	 mov	 edi, DWORD PTR $T207084[ebp]
  0058c	eb 54		 jmp	 SHORT $LN239@test_miss
$LN238@test_miss:
  0058e	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00594	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0059a	8b 45 f0	 mov	 eax, DWORD PTR _t$207092[ebp+4]
  0059d	8b 4d ec	 mov	 ecx, DWORD PTR _t$207092[ebp]
  005a0	57		 push	 edi
  005a1	56		 push	 esi
  005a2	50		 push	 eax
  005a3	51		 push	 ecx
  005a4	e8 00 00 00 00	 call	 __alldvrm
  005a9	6a 00		 push	 0
  005ab	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005b0	53		 push	 ebx
  005b1	51		 push	 ecx
  005b2	89 45 ec	 mov	 DWORD PTR tv904[ebp], eax
  005b5	89 55 f0	 mov	 DWORD PTR tv904[ebp+4], edx
  005b8	e8 00 00 00 00	 call	 __allmul
  005bd	57		 push	 edi
  005be	56		 push	 esi
  005bf	52		 push	 edx
  005c0	50		 push	 eax
  005c1	e8 00 00 00 00	 call	 __alldiv
  005c6	6a 00		 push	 0
  005c8	8b da		 mov	 ebx, edx
  005ca	8b 55 f0	 mov	 edx, DWORD PTR tv904[ebp+4]
  005cd	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005d2	8b f8		 mov	 edi, eax
  005d4	8b 45 ec	 mov	 eax, DWORD PTR tv904[ebp]
  005d7	52		 push	 edx
  005d8	50		 push	 eax
  005d9	e8 00 00 00 00	 call	 __allmul
  005de	03 f8		 add	 edi, eax
  005e0	13 da		 adc	 ebx, edx
$LN239@test_miss:
  005e2	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  005e8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  005ee	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  005f4	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  005fa	75 64		 jne	 SHORT $LN236@test_miss
  005fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00603	75 24		 jne	 SHORT $LN234@test_miss
  00605	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  0060b	6a 00		 push	 0
  0060d	51		 push	 ecx
  0060e	53		 push	 ebx
  0060f	57		 push	 edi
  00610	e8 00 00 00 00	 call	 __aulldiv
  00615	50		 push	 eax
  00616	68 00 00 00 00	 push	 OFFSET $SG-102
  0061b	e8 00 00 00 00	 call	 _printf
  00620	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00626	83 c4 08	 add	 esp, 8
$LN234@test_miss:
  00629	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0062f	6a 00		 push	 0
  00631	52		 push	 edx
  00632	53		 push	 ebx
  00633	57		 push	 edi
  00634	e8 00 00 00 00	 call	 __aulldiv
  00639	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0063f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00645	c1 e1 04	 shl	 ecx, 4
  00648	03 ce		 add	 ecx, esi
  0064a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0064d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00653	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00656	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00659	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN236@test_miss:

; 1374 : 
; 1375 : 	START(DATA_TRIE) {

  00660	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 3 ; the_start_data
  0066a	83 fe 03	 cmp	 esi, 3
  0066d	0f 85 0d 01 00
	00		 jne	 $LN104@test_miss
  00673	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0067a	75 2f		 jne	 SHORT $LN243@test_miss
  0067c	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  00682	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00687	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0068e	52		 push	 edx
  0068f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00695	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0069c	51		 push	 ecx
  0069d	50		 push	 eax
  0069e	68 00 00 00 00	 push	 OFFSET $SG-101
  006a3	e8 00 00 00 00	 call	 _printf
  006a8	83 c4 10	 add	 esp, 16			; 00000010H
$LN243@test_miss:
  006ab	8d 4d ec	 lea	 ecx, DWORD PTR _t$207117[ebp]
  006ae	51		 push	 ecx
  006af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  006b5	85 c0		 test	 eax, eax
  006b7	75 11		 jne	 SHORT $LN249@test_miss
  006b9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  006bd	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207110[ebp], xmm0
  006c2	8b 5d f0	 mov	 ebx, DWORD PTR $T207110[ebp+4]
  006c5	8b 7d ec	 mov	 edi, DWORD PTR $T207110[ebp]
  006c8	eb 54		 jmp	 SHORT $LN250@test_miss
$LN249@test_miss:
  006ca	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  006d0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  006d6	8b 55 f0	 mov	 edx, DWORD PTR _t$207117[ebp+4]
  006d9	8b 45 ec	 mov	 eax, DWORD PTR _t$207117[ebp]
  006dc	57		 push	 edi
  006dd	56		 push	 esi
  006de	52		 push	 edx
  006df	50		 push	 eax
  006e0	e8 00 00 00 00	 call	 __alldvrm
  006e5	6a 00		 push	 0
  006e7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006ec	53		 push	 ebx
  006ed	51		 push	 ecx
  006ee	89 45 ec	 mov	 DWORD PTR tv3831[ebp], eax
  006f1	89 55 f0	 mov	 DWORD PTR tv3831[ebp+4], edx
  006f4	e8 00 00 00 00	 call	 __allmul
  006f9	57		 push	 edi
  006fa	56		 push	 esi
  006fb	52		 push	 edx
  006fc	50		 push	 eax
  006fd	e8 00 00 00 00	 call	 __alldiv
  00702	8b 4d f0	 mov	 ecx, DWORD PTR tv3831[ebp+4]
  00705	6a 00		 push	 0
  00707	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0070c	8b da		 mov	 ebx, edx
  0070e	8b 55 ec	 mov	 edx, DWORD PTR tv3831[ebp]
  00711	51		 push	 ecx
  00712	52		 push	 edx
  00713	8b f8		 mov	 edi, eax
  00715	e8 00 00 00 00	 call	 __allmul
  0071a	03 f8		 add	 edi, eax
  0071c	13 da		 adc	 ebx, edx
$LN250@test_miss:
  0071e	33 f6		 xor	 esi, esi
  00720	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00726	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0072c	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00732	76 4c		 jbe	 SHORT $LN104@test_miss
  00734	8b 7d 08	 mov	 edi, DWORD PTR _SEARCH$[ebp]
$LL106@test_miss:

; 1376 : 		struct trie_object* obj;
; 1377 : 		obj = (struct trie_object*)tommy_trie_search(&trie, SEARCH[i] + DELTA);

  00737	8b 14 b7	 mov	 edx, DWORD PTR [edi+esi*4]
  0073a	8b c2		 mov	 eax, edx
  0073c	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  0073f	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  00746	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0074b	85 c0		 test	 eax, eax
  0074d	74 28		 je	 SHORT $LN105@test_miss
$recurse$207147:
  0074f	a8 01		 test	 al, 1
  00751	74 14		 je	 SHORT $LN257@test_miss
  00753	8b da		 mov	 ebx, edx
  00755	d3 eb		 shr	 ebx, cl
  00757	83 e9 04	 sub	 ecx, 4
  0075a	83 e3 0f	 and	 ebx, 15			; 0000000fH
  0075d	8b 44 98 ff	 mov	 eax, DWORD PTR [eax+ebx*4-1]
  00761	85 c0		 test	 eax, eax
  00763	75 ea		 jne	 SHORT $recurse$207147
  00765	eb 10		 jmp	 SHORT $LN105@test_miss
$LN257@test_miss:
  00767	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  0076a	75 0b		 jne	 SHORT $LN105@test_miss

; 1378 : 		if (obj)

  0076c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00770	74 05		 je	 SHORT $LN105@test_miss

; 1379 : 			abort();

  00772	e8 00 00 00 00	 call	 _abort
$LN105@test_miss:

; 1374 : 
; 1375 : 	START(DATA_TRIE) {

  00777	46		 inc	 esi
  00778	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0077e	72 b7		 jb	 SHORT $LL106@test_miss
$LN104@test_miss:

; 1380 : 	} STOP();

  00780	8d 4d ec	 lea	 ecx, DWORD PTR _t$207171[ebp]
  00783	51		 push	 ecx
  00784	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0078a	85 c0		 test	 eax, eax
  0078c	75 11		 jne	 SHORT $LN267@test_miss
  0078e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00792	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207163[ebp], xmm0
  00797	8b 5d f0	 mov	 ebx, DWORD PTR $T207163[ebp+4]
  0079a	8b 7d ec	 mov	 edi, DWORD PTR $T207163[ebp]
  0079d	eb 54		 jmp	 SHORT $LN268@test_miss
$LN267@test_miss:
  0079f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  007a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  007ab	8b 55 f0	 mov	 edx, DWORD PTR _t$207171[ebp+4]
  007ae	8b 45 ec	 mov	 eax, DWORD PTR _t$207171[ebp]
  007b1	57		 push	 edi
  007b2	56		 push	 esi
  007b3	52		 push	 edx
  007b4	50		 push	 eax
  007b5	e8 00 00 00 00	 call	 __alldvrm
  007ba	6a 00		 push	 0
  007bc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007c1	53		 push	 ebx
  007c2	51		 push	 ecx
  007c3	89 45 ec	 mov	 DWORD PTR tv1013[ebp], eax
  007c6	89 55 f0	 mov	 DWORD PTR tv1013[ebp+4], edx
  007c9	e8 00 00 00 00	 call	 __allmul
  007ce	57		 push	 edi
  007cf	56		 push	 esi
  007d0	52		 push	 edx
  007d1	50		 push	 eax
  007d2	e8 00 00 00 00	 call	 __alldiv
  007d7	8b 4d f0	 mov	 ecx, DWORD PTR tv1013[ebp+4]
  007da	6a 00		 push	 0
  007dc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007e1	8b da		 mov	 ebx, edx
  007e3	8b 55 ec	 mov	 edx, DWORD PTR tv1013[ebp]
  007e6	51		 push	 ecx
  007e7	52		 push	 edx
  007e8	8b f8		 mov	 edi, eax
  007ea	e8 00 00 00 00	 call	 __allmul
  007ef	03 f8		 add	 edi, eax
  007f1	13 da		 adc	 ebx, edx
$LN268@test_miss:
  007f3	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  007f9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  007ff	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00805	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  0080b	75 63		 jne	 SHORT $LN265@test_miss
  0080d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00814	75 23		 jne	 SHORT $LN263@test_miss
  00816	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0081b	6a 00		 push	 0
  0081d	50		 push	 eax
  0081e	53		 push	 ebx
  0081f	57		 push	 edi
  00820	e8 00 00 00 00	 call	 __aulldiv
  00825	50		 push	 eax
  00826	68 00 00 00 00	 push	 OFFSET $SG-102
  0082b	e8 00 00 00 00	 call	 _printf
  00830	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00836	83 c4 08	 add	 esp, 8
$LN263@test_miss:
  00839	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  0083f	6a 00		 push	 0
  00841	51		 push	 ecx
  00842	53		 push	 ebx
  00843	57		 push	 edi
  00844	e8 00 00 00 00	 call	 __aulldiv
  00849	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  0084f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00855	c1 e2 04	 shl	 edx, 4
  00858	03 d6		 add	 edx, esi
  0085a	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0085d	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00860	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00866	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00869	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN265@test_miss:

; 1381 : 
; 1382 : 	START(DATA_TRIE_INPLACE) {

  00870	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 4 ; the_start_data
  0087a	83 fe 04	 cmp	 esi, 4
  0087d	0f 85 0c 01 00
	00		 jne	 $LN99@test_miss
  00883	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0088a	75 2e		 jne	 SHORT $LN272@test_miss
  0088c	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  00891	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00897	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0089e	50		 push	 eax
  0089f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  008a4	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  008ab	52		 push	 edx
  008ac	51		 push	 ecx
  008ad	68 00 00 00 00	 push	 OFFSET $SG-101
  008b2	e8 00 00 00 00	 call	 _printf
  008b7	83 c4 10	 add	 esp, 16			; 00000010H
$LN272@test_miss:
  008ba	8d 55 ec	 lea	 edx, DWORD PTR _t$207196[ebp]
  008bd	52		 push	 edx
  008be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  008c4	85 c0		 test	 eax, eax
  008c6	75 11		 jne	 SHORT $LN278@test_miss
  008c8	66 0f 57 c0	 xorpd	 xmm0, xmm0
  008cc	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207189[ebp], xmm0
  008d1	8b 5d f0	 mov	 ebx, DWORD PTR $T207189[ebp+4]
  008d4	8b 7d ec	 mov	 edi, DWORD PTR $T207189[ebp]
  008d7	eb 54		 jmp	 SHORT $LN279@test_miss
$LN278@test_miss:
  008d9	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  008df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  008e5	8b 45 f0	 mov	 eax, DWORD PTR _t$207196[ebp+4]
  008e8	8b 4d ec	 mov	 ecx, DWORD PTR _t$207196[ebp]
  008eb	57		 push	 edi
  008ec	56		 push	 esi
  008ed	50		 push	 eax
  008ee	51		 push	 ecx
  008ef	e8 00 00 00 00	 call	 __alldvrm
  008f4	6a 00		 push	 0
  008f6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  008fb	53		 push	 ebx
  008fc	51		 push	 ecx
  008fd	89 45 ec	 mov	 DWORD PTR tv1129[ebp], eax
  00900	89 55 f0	 mov	 DWORD PTR tv1129[ebp+4], edx
  00903	e8 00 00 00 00	 call	 __allmul
  00908	57		 push	 edi
  00909	56		 push	 esi
  0090a	52		 push	 edx
  0090b	50		 push	 eax
  0090c	e8 00 00 00 00	 call	 __alldiv
  00911	6a 00		 push	 0
  00913	8b da		 mov	 ebx, edx
  00915	8b 55 f0	 mov	 edx, DWORD PTR tv1129[ebp+4]
  00918	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0091d	8b f8		 mov	 edi, eax
  0091f	8b 45 ec	 mov	 eax, DWORD PTR tv1129[ebp]
  00922	52		 push	 edx
  00923	50		 push	 eax
  00924	e8 00 00 00 00	 call	 __allmul
  00929	03 f8		 add	 edi, eax
  0092b	13 da		 adc	 ebx, edx
$LN279@test_miss:
  0092d	33 f6		 xor	 esi, esi
  0092f	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00935	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0093b	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00941	76 4c		 jbe	 SHORT $LN99@test_miss
  00943	8b 7d 08	 mov	 edi, DWORD PTR _SEARCH$[ebp]
$LL101@test_miss:

; 1383 : 		struct trie_inplace_object* obj;
; 1384 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_search(&trie_inplace, SEARCH[i] + DELTA);

  00946	8b 14 b7	 mov	 edx, DWORD PTR [edi+esi*4]
  00949	8b ca		 mov	 ecx, edx
  0094b	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  0094e	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  00955	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  0095a	85 c0		 test	 eax, eax
  0095c	74 28		 je	 SHORT $LN100@test_miss
$LN285@test_miss:
  0095e	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00961	74 14		 je	 SHORT $LN284@test_miss
  00963	8b da		 mov	 ebx, edx
  00965	d3 eb		 shr	 ebx, cl
  00967	83 e9 02	 sub	 ecx, 2
  0096a	83 e3 03	 and	 ebx, 3
  0096d	8b 44 98 10	 mov	 eax, DWORD PTR [eax+ebx*4+16]
  00971	85 c0		 test	 eax, eax
  00973	75 e9		 jne	 SHORT $LN285@test_miss
  00975	eb 0f		 jmp	 SHORT $LN100@test_miss
$LN284@test_miss:
  00977	85 c0		 test	 eax, eax
  00979	74 0b		 je	 SHORT $LN100@test_miss

; 1385 : 		if (obj)

  0097b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0097f	74 05		 je	 SHORT $LN100@test_miss

; 1386 : 			abort();

  00981	e8 00 00 00 00	 call	 _abort
$LN100@test_miss:

; 1381 : 
; 1382 : 	START(DATA_TRIE_INPLACE) {

  00986	46		 inc	 esi
  00987	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0098d	72 b7		 jb	 SHORT $LL101@test_miss
$LN99@test_miss:

; 1387 : 	} STOP();

  0098f	8d 55 f4	 lea	 edx, DWORD PTR _t$207236[ebp]
  00992	52		 push	 edx
  00993	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00999	85 c0		 test	 eax, eax
  0099b	75 11		 jne	 SHORT $LN292@test_miss
  0099d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  009a1	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207228[ebp], xmm0
  009a6	8b 5d f0	 mov	 ebx, DWORD PTR $T207228[ebp+4]
  009a9	8b 7d ec	 mov	 edi, DWORD PTR $T207228[ebp]
  009ac	eb 54		 jmp	 SHORT $LN293@test_miss
$LN292@test_miss:
  009ae	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  009b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  009ba	8b 45 f8	 mov	 eax, DWORD PTR _t$207236[ebp+4]
  009bd	8b 4d f4	 mov	 ecx, DWORD PTR _t$207236[ebp]
  009c0	57		 push	 edi
  009c1	56		 push	 esi
  009c2	50		 push	 eax
  009c3	51		 push	 ecx
  009c4	e8 00 00 00 00	 call	 __alldvrm
  009c9	6a 00		 push	 0
  009cb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  009d0	53		 push	 ebx
  009d1	51		 push	 ecx
  009d2	89 45 ec	 mov	 DWORD PTR tv1123[ebp], eax
  009d5	89 55 f0	 mov	 DWORD PTR tv1123[ebp+4], edx
  009d8	e8 00 00 00 00	 call	 __allmul
  009dd	57		 push	 edi
  009de	56		 push	 esi
  009df	52		 push	 edx
  009e0	50		 push	 eax
  009e1	e8 00 00 00 00	 call	 __alldiv
  009e6	6a 00		 push	 0
  009e8	8b da		 mov	 ebx, edx
  009ea	8b 55 f0	 mov	 edx, DWORD PTR tv1123[ebp+4]
  009ed	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  009f2	8b f8		 mov	 edi, eax
  009f4	8b 45 ec	 mov	 eax, DWORD PTR tv1123[ebp]
  009f7	52		 push	 edx
  009f8	50		 push	 eax
  009f9	e8 00 00 00 00	 call	 __allmul
  009fe	03 f8		 add	 edi, eax
  00a00	13 da		 adc	 ebx, edx
$LN293@test_miss:
  00a02	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00a08	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00a0e	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00a14	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00a1a	75 64		 jne	 SHORT $LN290@test_miss
  00a1c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a23	75 24		 jne	 SHORT $LN288@test_miss
  00a25	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00a2b	6a 00		 push	 0
  00a2d	51		 push	 ecx
  00a2e	53		 push	 ebx
  00a2f	57		 push	 edi
  00a30	e8 00 00 00 00	 call	 __aulldiv
  00a35	50		 push	 eax
  00a36	68 00 00 00 00	 push	 OFFSET $SG-102
  00a3b	e8 00 00 00 00	 call	 _printf
  00a40	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00a46	83 c4 08	 add	 esp, 8
$LN288@test_miss:
  00a49	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00a4f	6a 00		 push	 0
  00a51	52		 push	 edx
  00a52	53		 push	 ebx
  00a53	57		 push	 edi
  00a54	e8 00 00 00 00	 call	 __aulldiv
  00a59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00a5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00a65	c1 e1 04	 shl	 ecx, 4
  00a68	03 ce		 add	 ecx, esi
  00a6a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00a6d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00a73	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00a76	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00a79	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN290@test_miss:

; 1388 : 
; 1389 : 	START(DATA_KHASH) {

  00a80	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 7 ; the_start_data
  00a8a	83 fe 07	 cmp	 esi, 7
  00a8d	0f 85 1b 01 00
	00		 jne	 $LN94@test_miss
  00a93	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a9a	75 2f		 jne	 SHORT $LN297@test_miss
  00a9c	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00aa2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00aa7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00aae	52		 push	 edx
  00aaf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00ab5	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00abc	51		 push	 ecx
  00abd	50		 push	 eax
  00abe	68 00 00 00 00	 push	 OFFSET $SG-101
  00ac3	e8 00 00 00 00	 call	 _printf
  00ac8	83 c4 10	 add	 esp, 16			; 00000010H
$LN297@test_miss:
  00acb	8d 4d e4	 lea	 ecx, DWORD PTR _t$207261[ebp]
  00ace	51		 push	 ecx
  00acf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ad5	85 c0		 test	 eax, eax
  00ad7	75 11		 jne	 SHORT $LN303@test_miss
  00ad9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00add	66 0f 13 45 ec	 movlpd	 QWORD PTR $T207254[ebp], xmm0
  00ae2	8b 5d f0	 mov	 ebx, DWORD PTR $T207254[ebp+4]
  00ae5	8b 7d ec	 mov	 edi, DWORD PTR $T207254[ebp]
  00ae8	eb 54		 jmp	 SHORT $LN304@test_miss
$LN303@test_miss:
  00aea	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00af0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00af6	8b 55 e8	 mov	 edx, DWORD PTR _t$207261[ebp+4]
  00af9	8b 45 e4	 mov	 eax, DWORD PTR _t$207261[ebp]
  00afc	57		 push	 edi
  00afd	56		 push	 esi
  00afe	52		 push	 edx
  00aff	50		 push	 eax
  00b00	e8 00 00 00 00	 call	 __alldvrm
  00b05	6a 00		 push	 0
  00b07	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b0c	53		 push	 ebx
  00b0d	51		 push	 ecx
  00b0e	89 45 ec	 mov	 DWORD PTR tv1161[ebp], eax
  00b11	89 55 f0	 mov	 DWORD PTR tv1161[ebp+4], edx
  00b14	e8 00 00 00 00	 call	 __allmul
  00b19	57		 push	 edi
  00b1a	56		 push	 esi
  00b1b	52		 push	 edx
  00b1c	50		 push	 eax
  00b1d	e8 00 00 00 00	 call	 __alldiv
  00b22	8b 4d f0	 mov	 ecx, DWORD PTR tv1161[ebp+4]
  00b25	6a 00		 push	 0
  00b27	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b2c	8b da		 mov	 ebx, edx
  00b2e	8b 55 ec	 mov	 edx, DWORD PTR tv1161[ebp]
  00b31	51		 push	 ecx
  00b32	52		 push	 edx
  00b33	8b f8		 mov	 edi, eax
  00b35	e8 00 00 00 00	 call	 __allmul
  00b3a	03 f8		 add	 edi, eax
  00b3c	13 da		 adc	 ebx, edx
$LN304@test_miss:
  00b3e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00b44	33 ff		 xor	 edi, edi
  00b46	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00b4c	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00b52	76 5a		 jbe	 SHORT $LN94@test_miss
  00b54	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LL96@test_miss:

; 1390 : 		unsigned key = SEARCH[i] + DELTA;
; 1391 : 		unsigned hash_key = hash(key);

  00b57	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]
  00b5a	8b c8		 mov	 ecx, eax
  00b5c	c1 e1 06	 shl	 ecx, 6
  00b5f	2b c1		 sub	 eax, ecx
  00b61	8b d0		 mov	 edx, eax
  00b63	c1 ea 11	 shr	 edx, 17			; 00000011H
  00b66	33 c2		 xor	 eax, edx
  00b68	8b c8		 mov	 ecx, eax
  00b6a	c1 e1 09	 shl	 ecx, 9
  00b6d	2b c1		 sub	 eax, ecx
  00b6f	8b d0		 mov	 edx, eax
  00b71	c1 e2 04	 shl	 edx, 4
  00b74	33 c2		 xor	 eax, edx
  00b76	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00b7d	2b c1		 sub	 eax, ecx
  00b7f	8b d0		 mov	 edx, eax
  00b81	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00b84	33 c2		 xor	 eax, edx
  00b86	8b c8		 mov	 ecx, eax
  00b88	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00b8b	33 c8		 xor	 ecx, eax

; 1392 : 		khiter_t k;
; 1393 : 		k = kh_get(word, khash, hash_key);

  00b8d	51		 push	 ecx
  00b8e	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word

; 1394 : 		if (k != kh_end(khash))

  00b93	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00b99	83 c4 04	 add	 esp, 4
  00b9c	3b 02		 cmp	 eax, DWORD PTR [edx]
  00b9e	74 05		 je	 SHORT $LN95@test_miss

; 1395 : 			abort();

  00ba0	e8 00 00 00 00	 call	 _abort
$LN95@test_miss:

; 1388 : 
; 1389 : 	START(DATA_KHASH) {

  00ba5	47		 inc	 edi
  00ba6	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00bac	72 a9		 jb	 SHORT $LL96@test_miss
$LN94@test_miss:

; 1396 : 	} STOP();

  00bae	8d 45 dc	 lea	 eax, DWORD PTR _t$207285[ebp]
  00bb1	50		 push	 eax
  00bb2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00bb8	85 c0		 test	 eax, eax
  00bba	75 11		 jne	 SHORT $LN312@test_miss
  00bbc	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00bc0	66 0f 13 45 e4	 movlpd	 QWORD PTR $T207278[ebp], xmm0
  00bc5	8b 5d e8	 mov	 ebx, DWORD PTR $T207278[ebp+4]
  00bc8	8b 7d e4	 mov	 edi, DWORD PTR $T207278[ebp]
  00bcb	eb 54		 jmp	 SHORT $LN313@test_miss
$LN312@test_miss:
  00bcd	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00bd3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00bd9	8b 4d e0	 mov	 ecx, DWORD PTR _t$207285[ebp+4]
  00bdc	8b 55 dc	 mov	 edx, DWORD PTR _t$207285[ebp]
  00bdf	57		 push	 edi
  00be0	56		 push	 esi
  00be1	51		 push	 ecx
  00be2	52		 push	 edx
  00be3	e8 00 00 00 00	 call	 __alldvrm
  00be8	6a 00		 push	 0
  00bea	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00bef	53		 push	 ebx
  00bf0	51		 push	 ecx
  00bf1	89 45 ec	 mov	 DWORD PTR tv1192[ebp], eax
  00bf4	89 55 f0	 mov	 DWORD PTR tv1192[ebp+4], edx
  00bf7	e8 00 00 00 00	 call	 __allmul
  00bfc	57		 push	 edi
  00bfd	56		 push	 esi
  00bfe	52		 push	 edx
  00bff	50		 push	 eax
  00c00	e8 00 00 00 00	 call	 __alldiv
  00c05	8b 4d ec	 mov	 ecx, DWORD PTR tv1192[ebp]
  00c08	6a 00		 push	 0
  00c0a	8b f8		 mov	 edi, eax
  00c0c	8b 45 f0	 mov	 eax, DWORD PTR tv1192[ebp+4]
  00c0f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c14	50		 push	 eax
  00c15	51		 push	 ecx
  00c16	8b da		 mov	 ebx, edx
  00c18	e8 00 00 00 00	 call	 __allmul
  00c1d	03 f8		 add	 edi, eax
  00c1f	13 da		 adc	 ebx, edx
$LN313@test_miss:
  00c21	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00c27	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00c2d	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00c33	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00c39	75 63		 jne	 SHORT $LN310@test_miss
  00c3b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00c42	75 24		 jne	 SHORT $LN308@test_miss
  00c44	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00c4a	6a 00		 push	 0
  00c4c	52		 push	 edx
  00c4d	53		 push	 ebx
  00c4e	57		 push	 edi
  00c4f	e8 00 00 00 00	 call	 __aulldiv
  00c54	50		 push	 eax
  00c55	68 00 00 00 00	 push	 OFFSET $SG-102
  00c5a	e8 00 00 00 00	 call	 _printf
  00c5f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00c65	83 c4 08	 add	 esp, 8
$LN308@test_miss:
  00c68	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00c6d	6a 00		 push	 0
  00c6f	50		 push	 eax
  00c70	53		 push	 ebx
  00c71	57		 push	 edi
  00c72	e8 00 00 00 00	 call	 __aulldiv
  00c77	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00c7d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00c83	c1 e1 04	 shl	 ecx, 4
  00c86	03 ce		 add	 ecx, esi
  00c88	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00c8b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00c91	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00c94	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00c97	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN310@test_miss:

; 1397 : 
; 1398 : #ifdef USE_CGOOGLEDENSEHASH
; 1399 : 	START(DATA_CGOOGLE) {
; 1400 : 		unsigned key = SEARCH[i] + DELTA;
; 1401 : 		HTItem* ptr;
; 1402 : 		ptr = HashFind(cgoogledensehash, key);
; 1403 : 		if (ptr)
; 1404 : 			abort();
; 1405 : 	} STOP();
; 1406 : #endif
; 1407 : 
; 1408 : #ifdef USE_GOOGLEDENSEHASH
; 1409 : 	START(DATA_GOOGLEDENSEHASH) {

  00c9e	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 11 ; the_start_data, 0000000bH
  00ca8	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00cab	0f 85 9a 01 00
	00		 jne	 $LN89@test_miss
  00cb1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00cb8	75 2f		 jne	 SHORT $LN317@test_miss
  00cba	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00cc0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00cc5	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00ccc	52		 push	 edx
  00ccd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00cd3	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00cda	51		 push	 ecx
  00cdb	50		 push	 eax
  00cdc	68 00 00 00 00	 push	 OFFSET $SG-101
  00ce1	e8 00 00 00 00	 call	 _printf
  00ce6	83 c4 10	 add	 esp, 16			; 00000010H
$LN317@test_miss:
  00ce9	8d 4d d4	 lea	 ecx, DWORD PTR _t$207310[ebp]
  00cec	51		 push	 ecx
  00ced	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00cf3	85 c0		 test	 eax, eax
  00cf5	75 11		 jne	 SHORT $LN323@test_miss
  00cf7	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00cfb	66 0f 13 45 e4	 movlpd	 QWORD PTR $T207304[ebp], xmm0
  00d00	8b 5d e8	 mov	 ebx, DWORD PTR $T207304[ebp+4]
  00d03	8b 7d e4	 mov	 edi, DWORD PTR $T207304[ebp]
  00d06	eb 54		 jmp	 SHORT $LN324@test_miss
$LN323@test_miss:
  00d08	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00d0e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00d14	8b 55 d8	 mov	 edx, DWORD PTR _t$207310[ebp+4]
  00d17	8b 45 d4	 mov	 eax, DWORD PTR _t$207310[ebp]
  00d1a	57		 push	 edi
  00d1b	56		 push	 esi
  00d1c	52		 push	 edx
  00d1d	50		 push	 eax
  00d1e	e8 00 00 00 00	 call	 __alldvrm
  00d23	6a 00		 push	 0
  00d25	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d2a	53		 push	 ebx
  00d2b	51		 push	 ecx
  00d2c	89 45 ec	 mov	 DWORD PTR tv3810[ebp], eax
  00d2f	89 55 f0	 mov	 DWORD PTR tv3810[ebp+4], edx
  00d32	e8 00 00 00 00	 call	 __allmul
  00d37	57		 push	 edi
  00d38	56		 push	 esi
  00d39	52		 push	 edx
  00d3a	50		 push	 eax
  00d3b	e8 00 00 00 00	 call	 __alldiv
  00d40	8b 4d f0	 mov	 ecx, DWORD PTR tv3810[ebp+4]
  00d43	6a 00		 push	 0
  00d45	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d4a	8b da		 mov	 ebx, edx
  00d4c	8b 55 ec	 mov	 edx, DWORD PTR tv3810[ebp]
  00d4f	51		 push	 ecx
  00d50	52		 push	 edx
  00d51	8b f8		 mov	 edi, eax
  00d53	e8 00 00 00 00	 call	 __allmul
  00d58	03 f8		 add	 edi, eax
  00d5a	13 da		 adc	 ebx, edx
$LN324@test_miss:
  00d5c	33 c0		 xor	 eax, eax
  00d5e	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00d64	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00d6a	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00d6d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  00d73	0f 86 d2 00 00
	00		 jbe	 $LN89@test_miss
  00d79	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00d7f	90		 npad	 1
$LL91@test_miss:

; 1410 : 		unsigned key = SEARCH[i] + DELTA;

  00d80	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00d83	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]

; 1411 : 		googledensehash_t::const_iterator ptr = googledensehash->find(key);

  00d86	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  00d89	2b 4f 20	 sub	 ecx, DWORD PTR [edi+32]
  00d8c	89 55 f0	 mov	 DWORD PTR _key$152042[ebp], edx
  00d8f	75 2c		 jne	 SHORT $LN330@test_miss
  00d91	8b 5f 34	 mov	 ebx, DWORD PTR [edi+52]
  00d94	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00d97	8d 14 d3	 lea	 edx, DWORD PTR [ebx+edx*8]
  00d9a	8b c2		 mov	 eax, edx
  00d9c	3b c2		 cmp	 eax, edx
  00d9e	74 60		 je	 SHORT $LN444@test_miss
  00da0	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL342@test_miss:
  00da3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00da5	3b f1		 cmp	 esi, ecx
  00da7	74 0b		 je	 SHORT $LN340@test_miss
  00da9	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00dad	76 51		 jbe	 SHORT $LN444@test_miss
  00daf	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00db2	75 4c		 jne	 SHORT $LN444@test_miss
$LN340@test_miss:
  00db4	83 c0 08	 add	 eax, 8
  00db7	3b c2		 cmp	 eax, edx
  00db9	75 e8		 jne	 SHORT $LL342@test_miss
  00dbb	eb 43		 jmp	 SHORT $LN444@test_miss
$LN330@test_miss:
  00dbd	8d 45 e4	 lea	 eax, DWORD PTR _pos$208487[ebp]
  00dc0	50		 push	 eax
  00dc1	8d 45 f0	 lea	 eax, DWORD PTR _key$152042[ebp]
  00dc4	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00dc9	8b 45 e4	 mov	 eax, DWORD PTR _pos$208487[ebp]
  00dcc	8b 5f 34	 mov	 ebx, DWORD PTR [edi+52]
  00dcf	83 f8 ff	 cmp	 eax, -1
  00dd2	75 29		 jne	 SHORT $LN329@test_miss
  00dd4	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00dd7	8d 14 cb	 lea	 edx, DWORD PTR [ebx+ecx*8]
  00dda	8b c2		 mov	 eax, edx
  00ddc	3b c2		 cmp	 eax, edx
  00dde	74 20		 je	 SHORT $LN444@test_miss
  00de0	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL394@test_miss:
  00de3	8b 08		 mov	 ecx, DWORD PTR [eax]
  00de5	3b f1		 cmp	 esi, ecx
  00de7	74 0b		 je	 SHORT $LN392@test_miss
  00de9	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00ded	76 11		 jbe	 SHORT $LN444@test_miss
  00def	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00df2	75 0c		 jne	 SHORT $LN444@test_miss
$LN392@test_miss:
  00df4	83 c0 08	 add	 eax, 8
  00df7	3b c2		 cmp	 eax, edx
  00df9	75 e8		 jne	 SHORT $LL394@test_miss
  00dfb	eb 03		 jmp	 SHORT $LN444@test_miss
$LN329@test_miss:
  00dfd	8d 04 c3	 lea	 eax, DWORD PTR [ebx+eax*8]
$LN444@test_miss:

; 1412 : 		if (ptr != googledensehash->end())

  00e00	8b 57 28	 mov	 edx, DWORD PTR [edi+40]
  00e03	8d 1c d3	 lea	 ebx, DWORD PTR [ebx+edx*8]
  00e06	8b cb		 mov	 ecx, ebx
  00e08	3b cb		 cmp	 ecx, ebx
  00e0a	74 1d		 je	 SHORT $LN537@test_miss
  00e0c	8d 64 24 00	 npad	 4
$LL500@test_miss:
  00e10	8b 11		 mov	 edx, DWORD PTR [ecx]
  00e12	39 57 2c	 cmp	 DWORD PTR [edi+44], edx
  00e15	74 0b		 je	 SHORT $LN498@test_miss
  00e17	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00e1b	76 0c		 jbe	 SHORT $LN537@test_miss
  00e1d	39 57 1c	 cmp	 DWORD PTR [edi+28], edx
  00e20	75 07		 jne	 SHORT $LN537@test_miss
$LN498@test_miss:
  00e22	83 c1 08	 add	 ecx, 8
  00e25	3b cb		 cmp	 ecx, ebx
  00e27	75 e7		 jne	 SHORT $LL500@test_miss
$LN537@test_miss:
  00e29	3b c1		 cmp	 eax, ecx
  00e2b	74 0b		 je	 SHORT $LN90@test_miss

; 1413 : 			abort();

  00e2d	e8 00 00 00 00	 call	 _abort
  00e32	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN90@test_miss:

; 1397 : 
; 1398 : #ifdef USE_CGOOGLEDENSEHASH
; 1399 : 	START(DATA_CGOOGLE) {
; 1400 : 		unsigned key = SEARCH[i] + DELTA;
; 1401 : 		HTItem* ptr;
; 1402 : 		ptr = HashFind(cgoogledensehash, key);
; 1403 : 		if (ptr)
; 1404 : 			abort();
; 1405 : 	} STOP();
; 1406 : #endif
; 1407 : 
; 1408 : #ifdef USE_GOOGLEDENSEHASH
; 1409 : 	START(DATA_GOOGLEDENSEHASH) {

  00e38	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00e3b	40		 inc	 eax
  00e3c	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00e3f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00e45	0f 82 35 ff ff
	ff		 jb	 $LL91@test_miss
$LN89@test_miss:

; 1414 : 	} STOP();

  00e4b	8d 45 dc	 lea	 eax, DWORD PTR _t$208942[ebp]
  00e4e	50		 push	 eax
  00e4f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00e55	85 c0		 test	 eax, eax
  00e57	75 11		 jne	 SHORT $LN553@test_miss
  00e59	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00e5d	66 0f 13 45 d4	 movlpd	 QWORD PTR $T208934[ebp], xmm0
  00e62	8b 5d d8	 mov	 ebx, DWORD PTR $T208934[ebp+4]
  00e65	8b 7d d4	 mov	 edi, DWORD PTR $T208934[ebp]
  00e68	eb 54		 jmp	 SHORT $LN554@test_miss
$LN553@test_miss:
  00e6a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00e70	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00e76	8b 4d e0	 mov	 ecx, DWORD PTR _t$208942[ebp+4]
  00e79	8b 55 dc	 mov	 edx, DWORD PTR _t$208942[ebp]
  00e7c	57		 push	 edi
  00e7d	56		 push	 esi
  00e7e	51		 push	 ecx
  00e7f	52		 push	 edx
  00e80	e8 00 00 00 00	 call	 __alldvrm
  00e85	6a 00		 push	 0
  00e87	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e8c	53		 push	 ebx
  00e8d	51		 push	 ecx
  00e8e	89 45 ec	 mov	 DWORD PTR tv1430[ebp], eax
  00e91	89 55 f0	 mov	 DWORD PTR tv1430[ebp+4], edx
  00e94	e8 00 00 00 00	 call	 __allmul
  00e99	57		 push	 edi
  00e9a	56		 push	 esi
  00e9b	52		 push	 edx
  00e9c	50		 push	 eax
  00e9d	e8 00 00 00 00	 call	 __alldiv
  00ea2	8b 4d ec	 mov	 ecx, DWORD PTR tv1430[ebp]
  00ea5	6a 00		 push	 0
  00ea7	8b f8		 mov	 edi, eax
  00ea9	8b 45 f0	 mov	 eax, DWORD PTR tv1430[ebp+4]
  00eac	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00eb1	50		 push	 eax
  00eb2	51		 push	 ecx
  00eb3	8b da		 mov	 ebx, edx
  00eb5	e8 00 00 00 00	 call	 __allmul
  00eba	03 f8		 add	 edi, eax
  00ebc	13 da		 adc	 ebx, edx
$LN554@test_miss:
  00ebe	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00ec4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00eca	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00ed0	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00ed6	75 63		 jne	 SHORT $LN551@test_miss
  00ed8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00edf	75 24		 jne	 SHORT $LN549@test_miss
  00ee1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00ee7	6a 00		 push	 0
  00ee9	52		 push	 edx
  00eea	53		 push	 ebx
  00eeb	57		 push	 edi
  00eec	e8 00 00 00 00	 call	 __aulldiv
  00ef1	50		 push	 eax
  00ef2	68 00 00 00 00	 push	 OFFSET $SG-102
  00ef7	e8 00 00 00 00	 call	 _printf
  00efc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00f02	83 c4 08	 add	 esp, 8
$LN549@test_miss:
  00f05	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00f0a	6a 00		 push	 0
  00f0c	50		 push	 eax
  00f0d	53		 push	 ebx
  00f0e	57		 push	 edi
  00f0f	e8 00 00 00 00	 call	 __aulldiv
  00f14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00f1a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00f20	c1 e1 04	 shl	 ecx, 4
  00f23	03 ce		 add	 ecx, esi
  00f25	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00f28	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00f2e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00f31	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00f34	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN551@test_miss:

; 1415 : #endif
; 1416 : 
; 1417 : #ifdef USE_GOOGLEBTREE
; 1418 : 	START(DATA_GOOGLEBTREE) {

  00f3b	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 12 ; the_start_data, 0000000cH
  00f45	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00f48	0f 85 f7 01 00
	00		 jne	 $LN84@test_miss
  00f4e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00f55	75 2f		 jne	 SHORT $LN558@test_miss
  00f57	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  00f5d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00f62	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00f69	52		 push	 edx
  00f6a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00f70	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00f77	51		 push	 ecx
  00f78	50		 push	 eax
  00f79	68 00 00 00 00	 push	 OFFSET $SG-101
  00f7e	e8 00 00 00 00	 call	 _printf
  00f83	83 c4 10	 add	 esp, 16			; 00000010H
$LN558@test_miss:
  00f86	8d 4d e4	 lea	 ecx, DWORD PTR _t$208967[ebp]
  00f89	51		 push	 ecx
  00f8a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00f90	85 c0		 test	 eax, eax
  00f92	75 11		 jne	 SHORT $LN564@test_miss
  00f94	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00f98	66 0f 13 45 d4	 movlpd	 QWORD PTR $T208960[ebp], xmm0
  00f9d	8b 5d d8	 mov	 ebx, DWORD PTR $T208960[ebp+4]
  00fa0	8b 7d d4	 mov	 edi, DWORD PTR $T208960[ebp]
  00fa3	eb 54		 jmp	 SHORT $LN565@test_miss
$LN564@test_miss:
  00fa5	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00fab	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00fb1	8b 55 e8	 mov	 edx, DWORD PTR _t$208967[ebp+4]
  00fb4	8b 45 e4	 mov	 eax, DWORD PTR _t$208967[ebp]
  00fb7	57		 push	 edi
  00fb8	56		 push	 esi
  00fb9	52		 push	 edx
  00fba	50		 push	 eax
  00fbb	e8 00 00 00 00	 call	 __alldvrm
  00fc0	6a 00		 push	 0
  00fc2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fc7	53		 push	 ebx
  00fc8	51		 push	 ecx
  00fc9	89 45 ec	 mov	 DWORD PTR tv1542[ebp], eax
  00fcc	89 55 f0	 mov	 DWORD PTR tv1542[ebp+4], edx
  00fcf	e8 00 00 00 00	 call	 __allmul
  00fd4	57		 push	 edi
  00fd5	56		 push	 esi
  00fd6	52		 push	 edx
  00fd7	50		 push	 eax
  00fd8	e8 00 00 00 00	 call	 __alldiv
  00fdd	8b 4d f0	 mov	 ecx, DWORD PTR tv1542[ebp+4]
  00fe0	6a 00		 push	 0
  00fe2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fe7	8b da		 mov	 ebx, edx
  00fe9	8b 55 ec	 mov	 edx, DWORD PTR tv1542[ebp]
  00fec	51		 push	 ecx
  00fed	52		 push	 edx
  00fee	8b f8		 mov	 edi, eax
  00ff0	e8 00 00 00 00	 call	 __allmul
  00ff5	03 f8		 add	 edi, eax
  00ff7	13 da		 adc	 ebx, edx
$LN565@test_miss:
  00ff9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01000	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01006	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0100c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01013	0f 86 2c 01 00
	00		 jbe	 $LN84@test_miss
$LN86@test_miss:

; 1419 : 		unsigned key = SEARCH[i] + DELTA;
; 1420 : 		googlebtree_t::const_iterator ptr = googlebtree->find(key);

  01019	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0101f	8b 1a		 mov	 ebx, DWORD PTR [edx]
  01021	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  01024	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01027	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  0102a	85 db		 test	 ebx, ebx
  0102c	74 6c		 je	 SHORT $LN696@test_miss
  0102e	8b cb		 mov	 ecx, ebx
$LL593@test_miss:
  01030	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  01034	33 c0		 xor	 eax, eax
  01036	85 ff		 test	 edi, edi
  01038	7e 12		 jle	 SHORT $LN1137@test_miss
  0103a	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  0103d	8d 49 00	 npad	 3
$LL608@test_miss:
  01040	39 32		 cmp	 DWORD PTR [edx], esi
  01042	73 08		 jae	 SHORT $LN1137@test_miss
  01044	40		 inc	 eax
  01045	83 c2 08	 add	 edx, 8
  01048	3b c7		 cmp	 eax, edi
  0104a	7c f4		 jl	 SHORT $LL608@test_miss
$LN1137@test_miss:
  0104c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0104f	75 0f		 jne	 SHORT $LL1138@test_miss
  01051	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  01058	eb d6		 jmp	 SHORT $LL593@test_miss
  0105a	8d 9b 00 00 00
	00		 npad	 6
$LL1138@test_miss:
  01060	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  01064	3b c2		 cmp	 eax, edx
  01066	75 1d		 jne	 SHORT $LN650@test_miss
  01068	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  0106c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0106f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  01072	74 ec		 je	 SHORT $LL1138@test_miss
$LN686@test_miss:
  01074	85 db		 test	 ebx, ebx
  01076	74 22		 je	 SHORT $LN696@test_miss
  01078	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0107b	75 1d		 jne	 SHORT $LN696@test_miss
  0107d	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  01083	eb 17		 jmp	 SHORT $LN708@test_miss
$LN650@test_miss:
  01085	85 c9		 test	 ecx, ecx
  01087	74 eb		 je	 SHORT $LN686@test_miss
  01089	3b 74 c1 08	 cmp	 esi, DWORD PTR [ecx+eax*8+8]
  0108d	72 e5		 jb	 SHORT $LN686@test_miss
  0108f	89 45 d8	 mov	 DWORD PTR $T210118[ebp+4], eax
  01092	89 4d d4	 mov	 DWORD PTR $T210118[ebp], ecx
  01095	8d 45 d4	 lea	 eax, DWORD PTR $T210118[ebp]
  01098	eb 41		 jmp	 SHORT $LN687@test_miss
$LN696@test_miss:
  0109a	8b c3		 mov	 eax, ebx
$LN708@test_miss:
  0109c	85 c0		 test	 eax, eax
  0109e	74 1d		 je	 SHORT $LN692@test_miss
  010a0	85 db		 test	 ebx, ebx
  010a2	74 11		 je	 SHORT $LN712@test_miss
  010a4	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  010a7	75 0c		 jne	 SHORT $LN712@test_miss
  010a9	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  010af	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  010b3	eb 0a		 jmp	 SHORT $LN693@test_miss
$LN712@test_miss:
  010b5	8b c3		 mov	 eax, ebx
  010b7	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  010bb	eb 02		 jmp	 SHORT $LN693@test_miss
$LN692@test_miss:
  010bd	33 c9		 xor	 ecx, ecx
$LN693@test_miss:
  010bf	85 db		 test	 ebx, ebx
  010c1	74 0d		 je	 SHORT $LN730@test_miss
  010c3	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  010c6	75 08		 jne	 SHORT $LN730@test_miss
  010c8	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  010ce	eb 02		 jmp	 SHORT $LN742@test_miss
$LN730@test_miss:
  010d0	8b c3		 mov	 eax, ebx
$LN742@test_miss:
  010d2	89 45 ec	 mov	 DWORD PTR $T210119[ebp], eax
  010d5	89 4d f0	 mov	 DWORD PTR $T210119[ebp+4], ecx
  010d8	8d 45 ec	 lea	 eax, DWORD PTR $T210119[ebp]
$LN687@test_miss:
  010db	8b 10		 mov	 edx, DWORD PTR [eax]
  010dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1421 : 		if (ptr != googlebtree->end())

  010e0	85 db		 test	 ebx, ebx
  010e2	74 0d		 je	 SHORT $LN758@test_miss
  010e4	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  010e7	75 08		 jne	 SHORT $LN758@test_miss
  010e9	8b 8b 80 01 00
	00		 mov	 ecx, DWORD PTR [ebx+384]
  010ef	eb 02		 jmp	 SHORT $LN770@test_miss
$LN758@test_miss:
  010f1	8b cb		 mov	 ecx, ebx
$LN770@test_miss:
  010f3	85 c9		 test	 ecx, ecx
  010f5	74 1d		 je	 SHORT $LN754@test_miss
  010f7	85 db		 test	 ebx, ebx
  010f9	74 11		 je	 SHORT $LN774@test_miss
  010fb	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  010fe	75 0c		 jne	 SHORT $LN774@test_miss
  01100	8b 8b 80 01 00
	00		 mov	 ecx, DWORD PTR [ebx+384]
  01106	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  0110a	eb 0a		 jmp	 SHORT $LN755@test_miss
$LN774@test_miss:
  0110c	8b cb		 mov	 ecx, ebx
  0110e	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  01112	eb 02		 jmp	 SHORT $LN755@test_miss
$LN754@test_miss:
  01114	33 c9		 xor	 ecx, ecx
$LN755@test_miss:
  01116	85 db		 test	 ebx, ebx
  01118	74 0b		 je	 SHORT $LN792@test_miss
  0111a	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0111d	75 06		 jne	 SHORT $LN792@test_miss
  0111f	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN792@test_miss:
  01125	3b d3		 cmp	 edx, ebx
  01127	75 04		 jne	 SHORT $LN812@test_miss
  01129	3b c1		 cmp	 eax, ecx
  0112b	74 05		 je	 SHORT $LN85@test_miss
$LN812@test_miss:

; 1422 : 			abort();

  0112d	e8 00 00 00 00	 call	 _abort
$LN85@test_miss:

; 1415 : #endif
; 1416 : 
; 1417 : #ifdef USE_GOOGLEBTREE
; 1418 : 	START(DATA_GOOGLEBTREE) {

  01132	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01135	40		 inc	 eax
  01136	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01139	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0113f	0f 82 d4 fe ff
	ff		 jb	 $LN86@test_miss
$LN84@test_miss:

; 1423 : 	} STOP();

  01145	8d 45 dc	 lea	 eax, DWORD PTR _t$210535[ebp]
  01148	50		 push	 eax
  01149	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0114f	85 c0		 test	 eax, eax
  01151	75 11		 jne	 SHORT $LN818@test_miss
  01153	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01157	66 0f 13 45 d4	 movlpd	 QWORD PTR $T210524[ebp], xmm0
  0115c	8b 5d d8	 mov	 ebx, DWORD PTR $T210524[ebp+4]
  0115f	8b 7d d4	 mov	 edi, DWORD PTR $T210524[ebp]
  01162	eb 54		 jmp	 SHORT $LN819@test_miss
$LN818@test_miss:
  01164	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0116a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01170	8b 4d e0	 mov	 ecx, DWORD PTR _t$210535[ebp+4]
  01173	8b 55 dc	 mov	 edx, DWORD PTR _t$210535[ebp]
  01176	57		 push	 edi
  01177	56		 push	 esi
  01178	51		 push	 ecx
  01179	52		 push	 edx
  0117a	e8 00 00 00 00	 call	 __alldvrm
  0117f	6a 00		 push	 0
  01181	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01186	53		 push	 ebx
  01187	51		 push	 ecx
  01188	89 45 ec	 mov	 DWORD PTR tv3761[ebp], eax
  0118b	89 55 f0	 mov	 DWORD PTR tv3761[ebp+4], edx
  0118e	e8 00 00 00 00	 call	 __allmul
  01193	57		 push	 edi
  01194	56		 push	 esi
  01195	52		 push	 edx
  01196	50		 push	 eax
  01197	e8 00 00 00 00	 call	 __alldiv
  0119c	8b 4d ec	 mov	 ecx, DWORD PTR tv3761[ebp]
  0119f	6a 00		 push	 0
  011a1	8b f8		 mov	 edi, eax
  011a3	8b 45 f0	 mov	 eax, DWORD PTR tv3761[ebp+4]
  011a6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  011ab	50		 push	 eax
  011ac	51		 push	 ecx
  011ad	8b da		 mov	 ebx, edx
  011af	e8 00 00 00 00	 call	 __allmul
  011b4	03 f8		 add	 edi, eax
  011b6	13 da		 adc	 ebx, edx
$LN819@test_miss:
  011b8	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  011be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  011c4	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  011ca	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  011d0	75 63		 jne	 SHORT $LN816@test_miss
  011d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  011d9	75 24		 jne	 SHORT $LN814@test_miss
  011db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  011e1	6a 00		 push	 0
  011e3	52		 push	 edx
  011e4	53		 push	 ebx
  011e5	57		 push	 edi
  011e6	e8 00 00 00 00	 call	 __aulldiv
  011eb	50		 push	 eax
  011ec	68 00 00 00 00	 push	 OFFSET $SG-102
  011f1	e8 00 00 00 00	 call	 _printf
  011f6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  011fc	83 c4 08	 add	 esp, 8
$LN814@test_miss:
  011ff	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01204	6a 00		 push	 0
  01206	50		 push	 eax
  01207	53		 push	 ebx
  01208	57		 push	 edi
  01209	e8 00 00 00 00	 call	 __aulldiv
  0120e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01214	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0121a	c1 e1 04	 shl	 ecx, 4
  0121d	03 ce		 add	 ecx, esi
  0121f	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01222	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01228	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0122b	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0122e	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN816@test_miss:

; 1424 : #endif
; 1425 : 
; 1426 : #ifdef USE_STXBTREE
; 1427 : 	START(DATA_STXBTREE) {

  01235	c7 05 00 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 13 ; the_start_data, 0000000dH
  0123f	83 fe 0d	 cmp	 esi, 13			; 0000000dH
  01242	0f 85 0b 01 00
	00		 jne	 $LN79@test_miss
  01248	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0124f	75 2f		 jne	 SHORT $LN823@test_miss
  01251	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  01257	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0125c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01263	52		 push	 edx
  01264	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0126a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01271	51		 push	 ecx
  01272	50		 push	 eax
  01273	68 00 00 00 00	 push	 OFFSET $SG-101
  01278	e8 00 00 00 00	 call	 _printf
  0127d	83 c4 10	 add	 esp, 16			; 00000010H
$LN823@test_miss:
  01280	8d 4d e4	 lea	 ecx, DWORD PTR _t$210559[ebp]
  01283	51		 push	 ecx
  01284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0128a	85 c0		 test	 eax, eax
  0128c	75 11		 jne	 SHORT $LN829@test_miss
  0128e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01292	66 0f 13 45 d4	 movlpd	 QWORD PTR $T210550[ebp], xmm0
  01297	8b 5d d8	 mov	 ebx, DWORD PTR $T210550[ebp+4]
  0129a	8b 7d d4	 mov	 edi, DWORD PTR $T210550[ebp]
  0129d	eb 54		 jmp	 SHORT $LN830@test_miss
$LN829@test_miss:
  0129f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  012a5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  012ab	8b 55 e8	 mov	 edx, DWORD PTR _t$210559[ebp+4]
  012ae	8b 45 e4	 mov	 eax, DWORD PTR _t$210559[ebp]
  012b1	57		 push	 edi
  012b2	56		 push	 esi
  012b3	52		 push	 edx
  012b4	50		 push	 eax
  012b5	e8 00 00 00 00	 call	 __alldvrm
  012ba	6a 00		 push	 0
  012bc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012c1	53		 push	 ebx
  012c2	51		 push	 ecx
  012c3	89 45 ec	 mov	 DWORD PTR tv1861[ebp], eax
  012c6	89 55 f0	 mov	 DWORD PTR tv1861[ebp+4], edx
  012c9	e8 00 00 00 00	 call	 __allmul
  012ce	57		 push	 edi
  012cf	56		 push	 esi
  012d0	52		 push	 edx
  012d1	50		 push	 eax
  012d2	e8 00 00 00 00	 call	 __alldiv
  012d7	8b 4d f0	 mov	 ecx, DWORD PTR tv1861[ebp+4]
  012da	6a 00		 push	 0
  012dc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012e1	8b da		 mov	 ebx, edx
  012e3	8b 55 ec	 mov	 edx, DWORD PTR tv1861[ebp]
  012e6	51		 push	 ecx
  012e7	52		 push	 edx
  012e8	8b f8		 mov	 edi, eax
  012ea	e8 00 00 00 00	 call	 __allmul
  012ef	03 f8		 add	 edi, eax
  012f1	13 da		 adc	 ebx, edx
$LN830@test_miss:
  012f3	33 f6		 xor	 esi, esi
  012f5	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  012fb	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01301	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01307	76 4a		 jbe	 SHORT $LN79@test_miss
  01309	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  0130f	8b 5d 08	 mov	 ebx, DWORD PTR _SEARCH$[ebp]
$LL81@test_miss:

; 1428 : 		unsigned key = SEARCH[i] + DELTA;

  01312	8b 04 b3	 mov	 eax, DWORD PTR [ebx+esi*4]

; 1429 : 		stxbtree_t::const_iterator ptr = stxbtree->find(key);

  01315	8d 4d cc	 lea	 ecx, DWORD PTR $T206777[ebp]
  01318	51		 push	 ecx
  01319	89 45 f0	 mov	 DWORD PTR _key$152062[ebp], eax
  0131c	57		 push	 edi
  0131d	8d 45 f0	 lea	 eax, DWORD PTR _key$152062[ebp]
  01320	e8 00 00 00 00	 call	 ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find

; 1430 : 		if (ptr != stxbtree->end())

  01325	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  01328	85 c0		 test	 eax, eax
  0132a	74 06		 je	 SHORT $LN844@test_miss
  0132c	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  01330	eb 02		 jmp	 SHORT $LN845@test_miss
$LN844@test_miss:
  01332	33 c9		 xor	 ecx, ecx
$LN845@test_miss:
  01334	3b 45 cc	 cmp	 eax, DWORD PTR $T206777[ebp]
  01337	75 06		 jne	 SHORT $LN860@test_miss
  01339	66 3b 4d d0	 cmp	 cx, WORD PTR $T206777[ebp+4]
  0133d	74 0b		 je	 SHORT $LN80@test_miss
$LN860@test_miss:

; 1431 : 			abort();

  0133f	e8 00 00 00 00	 call	 _abort
  01344	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN80@test_miss:

; 1424 : #endif
; 1425 : 
; 1426 : #ifdef USE_STXBTREE
; 1427 : 	START(DATA_STXBTREE) {

  0134a	46		 inc	 esi
  0134b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01351	72 bf		 jb	 SHORT $LL81@test_miss
$LN79@test_miss:

; 1432 : 	} STOP();

  01353	8d 55 dc	 lea	 edx, DWORD PTR _t$210669[ebp]
  01356	52		 push	 edx
  01357	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0135d	85 c0		 test	 eax, eax
  0135f	75 11		 jne	 SHORT $LN866@test_miss
  01361	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01365	66 0f 13 45 d4	 movlpd	 QWORD PTR $T210658[ebp], xmm0
  0136a	8b 5d d8	 mov	 ebx, DWORD PTR $T210658[ebp+4]
  0136d	8b 7d d4	 mov	 edi, DWORD PTR $T210658[ebp]
  01370	eb 54		 jmp	 SHORT $LN867@test_miss
$LN866@test_miss:
  01372	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01378	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0137e	8b 45 e0	 mov	 eax, DWORD PTR _t$210669[ebp+4]
  01381	8b 4d dc	 mov	 ecx, DWORD PTR _t$210669[ebp]
  01384	57		 push	 edi
  01385	56		 push	 esi
  01386	50		 push	 eax
  01387	51		 push	 ecx
  01388	e8 00 00 00 00	 call	 __alldvrm
  0138d	6a 00		 push	 0
  0138f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01394	53		 push	 ebx
  01395	51		 push	 ecx
  01396	89 45 ec	 mov	 DWORD PTR tv3737[ebp], eax
  01399	89 55 f0	 mov	 DWORD PTR tv3737[ebp+4], edx
  0139c	e8 00 00 00 00	 call	 __allmul
  013a1	57		 push	 edi
  013a2	56		 push	 esi
  013a3	52		 push	 edx
  013a4	50		 push	 eax
  013a5	e8 00 00 00 00	 call	 __alldiv
  013aa	6a 00		 push	 0
  013ac	8b da		 mov	 ebx, edx
  013ae	8b 55 f0	 mov	 edx, DWORD PTR tv3737[ebp+4]
  013b1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013b6	8b f8		 mov	 edi, eax
  013b8	8b 45 ec	 mov	 eax, DWORD PTR tv3737[ebp]
  013bb	52		 push	 edx
  013bc	50		 push	 eax
  013bd	e8 00 00 00 00	 call	 __allmul
  013c2	03 f8		 add	 edi, eax
  013c4	13 da		 adc	 ebx, edx
$LN867@test_miss:
  013c6	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  013cc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  013d2	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  013d8	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  013de	75 64		 jne	 SHORT $LN864@test_miss
  013e0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  013e7	75 24		 jne	 SHORT $LN862@test_miss
  013e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  013ef	6a 00		 push	 0
  013f1	51		 push	 ecx
  013f2	53		 push	 ebx
  013f3	57		 push	 edi
  013f4	e8 00 00 00 00	 call	 __aulldiv
  013f9	50		 push	 eax
  013fa	68 00 00 00 00	 push	 OFFSET $SG-102
  013ff	e8 00 00 00 00	 call	 _printf
  01404	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  0140a	83 c4 08	 add	 esp, 8
$LN862@test_miss:
  0140d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01413	6a 00		 push	 0
  01415	52		 push	 edx
  01416	53		 push	 ebx
  01417	57		 push	 edi
  01418	e8 00 00 00 00	 call	 __aulldiv
  0141d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01423	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01429	c1 e1 04	 shl	 ecx, 4
  0142c	03 ce		 add	 ecx, esi
  0142e	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01431	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01437	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0143a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0143d	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN864@test_miss:

; 1433 : #endif
; 1434 : 
; 1435 : 
; 1436 : #ifdef USE_CPPMAP
; 1437 : 	START(DATA_CPPMAP) {

  01444	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 15 ; the_start_data, 0000000fH
  0144e	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  01451	0f 85 1c 01 00
	00		 jne	 $LN74@test_miss
  01457	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0145e	75 2f		 jne	 SHORT $LN871@test_miss
  01460	8b 15 3c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+60
  01466	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0146b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01472	52		 push	 edx
  01473	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01479	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01480	51		 push	 ecx
  01481	50		 push	 eax
  01482	68 00 00 00 00	 push	 OFFSET $SG-101
  01487	e8 00 00 00 00	 call	 _printf
  0148c	83 c4 10	 add	 esp, 16			; 00000010H
$LN871@test_miss:
  0148f	8d 4d e4	 lea	 ecx, DWORD PTR _t$210693[ebp]
  01492	51		 push	 ecx
  01493	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01499	85 c0		 test	 eax, eax
  0149b	75 11		 jne	 SHORT $LN877@test_miss
  0149d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  014a1	66 0f 13 45 d4	 movlpd	 QWORD PTR $T210684[ebp], xmm0
  014a6	8b 5d d8	 mov	 ebx, DWORD PTR $T210684[ebp+4]
  014a9	8b 7d d4	 mov	 edi, DWORD PTR $T210684[ebp]
  014ac	eb 54		 jmp	 SHORT $LN878@test_miss
$LN877@test_miss:
  014ae	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  014b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  014ba	8b 55 e8	 mov	 edx, DWORD PTR _t$210693[ebp+4]
  014bd	8b 45 e4	 mov	 eax, DWORD PTR _t$210693[ebp]
  014c0	57		 push	 edi
  014c1	56		 push	 esi
  014c2	52		 push	 edx
  014c3	50		 push	 eax
  014c4	e8 00 00 00 00	 call	 __alldvrm
  014c9	6a 00		 push	 0
  014cb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  014d0	53		 push	 ebx
  014d1	51		 push	 ecx
  014d2	89 45 ec	 mov	 DWORD PTR tv3714[ebp], eax
  014d5	89 55 f0	 mov	 DWORD PTR tv3714[ebp+4], edx
  014d8	e8 00 00 00 00	 call	 __allmul
  014dd	57		 push	 edi
  014de	56		 push	 esi
  014df	52		 push	 edx
  014e0	50		 push	 eax
  014e1	e8 00 00 00 00	 call	 __alldiv
  014e6	8b 4d f0	 mov	 ecx, DWORD PTR tv3714[ebp+4]
  014e9	6a 00		 push	 0
  014eb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  014f0	8b da		 mov	 ebx, edx
  014f2	8b 55 ec	 mov	 edx, DWORD PTR tv3714[ebp]
  014f5	51		 push	 ecx
  014f6	52		 push	 edx
  014f7	8b f8		 mov	 edi, eax
  014f9	e8 00 00 00 00	 call	 __allmul
  014fe	03 f8		 add	 edi, eax
  01500	13 da		 adc	 ebx, edx
$LN878@test_miss:
  01502	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01508	33 ff		 xor	 edi, edi
  0150a	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01510	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01516	76 5b		 jbe	 SHORT $LN74@test_miss
  01518	8b 5d 08	 mov	 ebx, DWORD PTR _SEARCH$[ebp]
  0151b	eb 03 8d 49 00	 npad	 5
$LL76@test_miss:

; 1438 : 		unsigned key = SEARCH[i] + DELTA;
; 1439 : 		cppmap_t::const_iterator ptr = cppmap->find(key);

  01520	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  01525	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01528	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0152b	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0152f	8b 34 bb	 mov	 esi, DWORD PTR [ebx+edi*4]
  01532	8b d1		 mov	 edx, ecx
  01534	75 14		 jne	 SHORT $LN888@test_miss
$LL889@test_miss:
  01536	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  01539	73 05		 jae	 SHORT $LN887@test_miss
  0153b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0153e	eb 04		 jmp	 SHORT $LN886@test_miss
$LN887@test_miss:
  01540	8b d0		 mov	 edx, eax
  01542	8b 00		 mov	 eax, DWORD PTR [eax]
$LN886@test_miss:
  01544	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  01548	74 ec		 je	 SHORT $LL889@test_miss
$LN888@test_miss:
  0154a	89 55 f0	 mov	 DWORD PTR __Where$210926[ebp], edx
  0154d	3b d1		 cmp	 edx, ecx
  0154f	74 0a		 je	 SHORT $LN882@test_miss
  01551	3b 72 0c	 cmp	 esi, DWORD PTR [edx+12]
  01554	72 05		 jb	 SHORT $LN882@test_miss
  01556	8d 45 f0	 lea	 eax, DWORD PTR __Where$210926[ebp]
  01559	eb 06		 jmp	 SHORT $LN883@test_miss
$LN882@test_miss:
  0155b	89 4d f8	 mov	 DWORD PTR $T210922[ebp], ecx
  0155e	8d 45 f8	 lea	 eax, DWORD PTR $T210922[ebp]
$LN883@test_miss:

; 1440 : 		if (ptr != cppmap->end())

  01561	39 08		 cmp	 DWORD PTR [eax], ecx
  01563	74 05		 je	 SHORT $LN75@test_miss

; 1441 : 			abort();

  01565	e8 00 00 00 00	 call	 _abort
$LN75@test_miss:

; 1433 : #endif
; 1434 : 
; 1435 : 
; 1436 : #ifdef USE_CPPMAP
; 1437 : 	START(DATA_CPPMAP) {

  0156a	47		 inc	 edi
  0156b	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01571	72 ad		 jb	 SHORT $LL76@test_miss
$LN74@test_miss:

; 1442 : 	} STOP();

  01573	8d 4d dc	 lea	 ecx, DWORD PTR _t$211053[ebp]
  01576	51		 push	 ecx
  01577	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0157d	85 c0		 test	 eax, eax
  0157f	75 11		 jne	 SHORT $LN968@test_miss
  01581	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01585	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211045[ebp], xmm0
  0158a	8b 5d d8	 mov	 ebx, DWORD PTR $T211045[ebp+4]
  0158d	8b 7d d4	 mov	 edi, DWORD PTR $T211045[ebp]
  01590	eb 54		 jmp	 SHORT $LN969@test_miss
$LN968@test_miss:
  01592	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01598	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0159e	8b 55 e0	 mov	 edx, DWORD PTR _t$211053[ebp+4]
  015a1	8b 45 dc	 mov	 eax, DWORD PTR _t$211053[ebp]
  015a4	57		 push	 edi
  015a5	56		 push	 esi
  015a6	52		 push	 edx
  015a7	50		 push	 eax
  015a8	e8 00 00 00 00	 call	 __alldvrm
  015ad	6a 00		 push	 0
  015af	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015b4	53		 push	 ebx
  015b5	51		 push	 ecx
  015b6	89 45 ec	 mov	 DWORD PTR tv2219[ebp], eax
  015b9	89 55 f0	 mov	 DWORD PTR tv2219[ebp+4], edx
  015bc	e8 00 00 00 00	 call	 __allmul
  015c1	57		 push	 edi
  015c2	56		 push	 esi
  015c3	52		 push	 edx
  015c4	50		 push	 eax
  015c5	e8 00 00 00 00	 call	 __alldiv
  015ca	8b 4d f0	 mov	 ecx, DWORD PTR tv2219[ebp+4]
  015cd	6a 00		 push	 0
  015cf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015d4	8b da		 mov	 ebx, edx
  015d6	8b 55 ec	 mov	 edx, DWORD PTR tv2219[ebp]
  015d9	51		 push	 ecx
  015da	52		 push	 edx
  015db	8b f8		 mov	 edi, eax
  015dd	e8 00 00 00 00	 call	 __allmul
  015e2	03 f8		 add	 edi, eax
  015e4	13 da		 adc	 ebx, edx
$LN969@test_miss:
  015e6	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  015ec	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  015f2	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  015f8	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  015fe	75 63		 jne	 SHORT $LN966@test_miss
  01600	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01607	75 23		 jne	 SHORT $LN964@test_miss
  01609	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0160e	6a 00		 push	 0
  01610	50		 push	 eax
  01611	53		 push	 ebx
  01612	57		 push	 edi
  01613	e8 00 00 00 00	 call	 __aulldiv
  01618	50		 push	 eax
  01619	68 00 00 00 00	 push	 OFFSET $SG-102
  0161e	e8 00 00 00 00	 call	 _printf
  01623	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01629	83 c4 08	 add	 esp, 8
$LN964@test_miss:
  0162c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  01632	6a 00		 push	 0
  01634	51		 push	 ecx
  01635	53		 push	 ebx
  01636	57		 push	 edi
  01637	e8 00 00 00 00	 call	 __aulldiv
  0163c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  01642	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01648	c1 e2 04	 shl	 edx, 4
  0164b	03 d6		 add	 edx, esi
  0164d	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  01650	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  01653	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01659	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0165c	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN966@test_miss:

; 1443 : #endif
; 1444 : 
; 1445 : #ifdef USE_CPPUNORDEREDMAP
; 1446 : 	START(DATA_CPPUNORDEREDMAP) {

  01663	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 14 ; the_start_data, 0000000eH
  0166d	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  01670	0f 85 fa 00 00
	00		 jne	 $LN69@test_miss
  01676	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0167d	75 2e		 jne	 SHORT $LN973@test_miss
  0167f	a1 38 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  01684	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0168a	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  01691	50		 push	 eax
  01692	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01697	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0169e	52		 push	 edx
  0169f	51		 push	 ecx
  016a0	68 00 00 00 00	 push	 OFFSET $SG-101
  016a5	e8 00 00 00 00	 call	 _printf
  016aa	83 c4 10	 add	 esp, 16			; 00000010H
$LN973@test_miss:
  016ad	8d 55 e4	 lea	 edx, DWORD PTR _t$211078[ebp]
  016b0	52		 push	 edx
  016b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  016b7	85 c0		 test	 eax, eax
  016b9	75 11		 jne	 SHORT $LN979@test_miss
  016bb	66 0f 57 c0	 xorpd	 xmm0, xmm0
  016bf	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211071[ebp], xmm0
  016c4	8b 5d d8	 mov	 ebx, DWORD PTR $T211071[ebp+4]
  016c7	8b 7d d4	 mov	 edi, DWORD PTR $T211071[ebp]
  016ca	eb 54		 jmp	 SHORT $LN980@test_miss
$LN979@test_miss:
  016cc	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  016d2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  016d8	8b 45 e8	 mov	 eax, DWORD PTR _t$211078[ebp+4]
  016db	8b 4d e4	 mov	 ecx, DWORD PTR _t$211078[ebp]
  016de	57		 push	 edi
  016df	56		 push	 esi
  016e0	50		 push	 eax
  016e1	51		 push	 ecx
  016e2	e8 00 00 00 00	 call	 __alldvrm
  016e7	6a 00		 push	 0
  016e9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  016ee	53		 push	 ebx
  016ef	51		 push	 ecx
  016f0	89 45 ec	 mov	 DWORD PTR tv2269[ebp], eax
  016f3	89 55 f0	 mov	 DWORD PTR tv2269[ebp+4], edx
  016f6	e8 00 00 00 00	 call	 __allmul
  016fb	57		 push	 edi
  016fc	56		 push	 esi
  016fd	52		 push	 edx
  016fe	50		 push	 eax
  016ff	e8 00 00 00 00	 call	 __alldiv
  01704	6a 00		 push	 0
  01706	8b da		 mov	 ebx, edx
  01708	8b 55 f0	 mov	 edx, DWORD PTR tv2269[ebp+4]
  0170b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01710	8b f8		 mov	 edi, eax
  01712	8b 45 ec	 mov	 eax, DWORD PTR tv2269[ebp]
  01715	52		 push	 edx
  01716	50		 push	 eax
  01717	e8 00 00 00 00	 call	 __allmul
  0171c	03 f8		 add	 edi, eax
  0171e	13 da		 adc	 ebx, edx
$LN980@test_miss:
  01720	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01726	33 ff		 xor	 edi, edi
  01728	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0172e	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01734	76 3a		 jbe	 SHORT $LN69@test_miss
  01736	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  0173c	8b 5d 08	 mov	 ebx, DWORD PTR _SEARCH$[ebp]
  0173f	90		 npad	 1
$LL71@test_miss:

; 1447 : 		unsigned key = SEARCH[i] + DELTA;

  01740	8b 0c bb	 mov	 ecx, DWORD PTR [ebx+edi*4]

; 1448 : 		cppunorderedmap_t::const_iterator ptr = cppunorderedmap->find(key);

  01743	8d 55 f8	 lea	 edx, DWORD PTR $T206782[ebp]
  01746	89 4d f0	 mov	 DWORD PTR _key$152081[ebp], ecx
  01749	52		 push	 edx
  0174a	8d 45 f0	 lea	 eax, DWORD PTR _key$152081[ebp]
  0174d	8b ce		 mov	 ecx, esi
  0174f	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1449 : 		if (ptr != cppunorderedmap->end())

  01754	8b 45 f8	 mov	 eax, DWORD PTR $T206782[ebp]
  01757	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0175a	74 0b		 je	 SHORT $LN70@test_miss

; 1450 : 			abort();

  0175c	e8 00 00 00 00	 call	 _abort
  01761	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN70@test_miss:

; 1443 : #endif
; 1444 : 
; 1445 : #ifdef USE_CPPUNORDEREDMAP
; 1446 : 	START(DATA_CPPUNORDEREDMAP) {

  01767	47		 inc	 edi
  01768	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  0176e	72 d0		 jb	 SHORT $LL71@test_miss
$LN69@test_miss:

; 1451 : 	} STOP();

  01770	8d 4d dc	 lea	 ecx, DWORD PTR _t$211160[ebp]
  01773	51		 push	 ecx
  01774	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0177a	85 c0		 test	 eax, eax
  0177c	75 11		 jne	 SHORT $LN1004@test_miss
  0177e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01782	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211152[ebp], xmm0
  01787	8b 5d d8	 mov	 ebx, DWORD PTR $T211152[ebp+4]
  0178a	8b 7d d4	 mov	 edi, DWORD PTR $T211152[ebp]
  0178d	eb 54		 jmp	 SHORT $LN1005@test_miss
$LN1004@test_miss:
  0178f	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01795	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0179b	8b 55 e0	 mov	 edx, DWORD PTR _t$211160[ebp+4]
  0179e	8b 45 dc	 mov	 eax, DWORD PTR _t$211160[ebp]
  017a1	57		 push	 edi
  017a2	56		 push	 esi
  017a3	52		 push	 edx
  017a4	50		 push	 eax
  017a5	e8 00 00 00 00	 call	 __alldvrm
  017aa	6a 00		 push	 0
  017ac	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  017b1	53		 push	 ebx
  017b2	51		 push	 ecx
  017b3	89 45 ec	 mov	 DWORD PTR tv3508[ebp], eax
  017b6	89 55 f0	 mov	 DWORD PTR tv3508[ebp+4], edx
  017b9	e8 00 00 00 00	 call	 __allmul
  017be	57		 push	 edi
  017bf	56		 push	 esi
  017c0	52		 push	 edx
  017c1	50		 push	 eax
  017c2	e8 00 00 00 00	 call	 __alldiv
  017c7	8b 4d f0	 mov	 ecx, DWORD PTR tv3508[ebp+4]
  017ca	6a 00		 push	 0
  017cc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  017d1	8b da		 mov	 ebx, edx
  017d3	8b 55 ec	 mov	 edx, DWORD PTR tv3508[ebp]
  017d6	51		 push	 ecx
  017d7	52		 push	 edx
  017d8	8b f8		 mov	 edi, eax
  017da	e8 00 00 00 00	 call	 __allmul
  017df	03 f8		 add	 edi, eax
  017e1	13 da		 adc	 ebx, edx
$LN1005@test_miss:
  017e3	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  017e9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  017ef	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  017f5	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  017fb	75 63		 jne	 SHORT $LN1002@test_miss
  017fd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01804	75 23		 jne	 SHORT $LN1000@test_miss
  01806	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0180b	6a 00		 push	 0
  0180d	50		 push	 eax
  0180e	53		 push	 ebx
  0180f	57		 push	 edi
  01810	e8 00 00 00 00	 call	 __aulldiv
  01815	50		 push	 eax
  01816	68 00 00 00 00	 push	 OFFSET $SG-102
  0181b	e8 00 00 00 00	 call	 _printf
  01820	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01826	83 c4 08	 add	 esp, 8
$LN1000@test_miss:
  01829	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  0182f	6a 00		 push	 0
  01831	51		 push	 ecx
  01832	53		 push	 ebx
  01833	57		 push	 edi
  01834	e8 00 00 00 00	 call	 __aulldiv
  01839	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  0183f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01845	c1 e2 04	 shl	 edx, 4
  01848	03 d6		 add	 edx, esi
  0184a	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0184d	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  01850	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01856	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  01859	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN1002@test_miss:

; 1452 : #endif
; 1453 : 
; 1454 : 	START(DATA_UTHASH) {

  01860	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 8 ; the_start_data
  0186a	83 fe 08	 cmp	 esi, 8
  0186d	0f 85 c7 01 00
	00		 jne	 $LN64@test_miss
  01873	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0187a	75 2e		 jne	 SHORT $LN1009@test_miss
  0187c	a1 20 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  01881	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01887	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0188e	50		 push	 eax
  0188f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01894	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0189b	52		 push	 edx
  0189c	51		 push	 ecx
  0189d	68 00 00 00 00	 push	 OFFSET $SG-101
  018a2	e8 00 00 00 00	 call	 _printf
  018a7	83 c4 10	 add	 esp, 16			; 00000010H
$LN1009@test_miss:
  018aa	8d 55 e4	 lea	 edx, DWORD PTR _t$211185[ebp]
  018ad	52		 push	 edx
  018ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  018b4	85 c0		 test	 eax, eax
  018b6	75 11		 jne	 SHORT $LN1015@test_miss
  018b8	66 0f 57 c0	 xorpd	 xmm0, xmm0
  018bc	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211178[ebp], xmm0
  018c1	8b 5d d8	 mov	 ebx, DWORD PTR $T211178[ebp+4]
  018c4	8b 7d d4	 mov	 edi, DWORD PTR $T211178[ebp]
  018c7	eb 54		 jmp	 SHORT $LN1016@test_miss
$LN1015@test_miss:
  018c9	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  018cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  018d5	8b 45 e8	 mov	 eax, DWORD PTR _t$211185[ebp+4]
  018d8	8b 4d e4	 mov	 ecx, DWORD PTR _t$211185[ebp]
  018db	57		 push	 edi
  018dc	56		 push	 esi
  018dd	50		 push	 eax
  018de	51		 push	 ecx
  018df	e8 00 00 00 00	 call	 __alldvrm
  018e4	6a 00		 push	 0
  018e6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  018eb	53		 push	 ebx
  018ec	51		 push	 ecx
  018ed	89 45 ec	 mov	 DWORD PTR tv3140[ebp], eax
  018f0	89 55 f0	 mov	 DWORD PTR tv3140[ebp+4], edx
  018f3	e8 00 00 00 00	 call	 __allmul
  018f8	57		 push	 edi
  018f9	56		 push	 esi
  018fa	52		 push	 edx
  018fb	50		 push	 eax
  018fc	e8 00 00 00 00	 call	 __alldiv
  01901	6a 00		 push	 0
  01903	8b da		 mov	 ebx, edx
  01905	8b 55 f0	 mov	 edx, DWORD PTR tv3140[ebp+4]
  01908	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0190d	8b f8		 mov	 edi, eax
  0190f	8b 45 ec	 mov	 eax, DWORD PTR tv3140[ebp]
  01912	52		 push	 edx
  01913	50		 push	 eax
  01914	e8 00 00 00 00	 call	 __allmul
  01919	03 f8		 add	 edi, eax
  0191b	13 da		 adc	 ebx, edx
$LN1016@test_miss:
  0191d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01924	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0192a	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01930	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01937	0f 86 fd 00 00
	00		 jbe	 $LN64@test_miss
  0193d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LL66@test_miss:

; 1455 : 		unsigned key = SEARCH[i] + DELTA;

  01943	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  01946	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  01949	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]
  0194c	89 5d f0	 mov	 DWORD PTR _key$152090[ebp], ebx

; 1456 : 		struct uthash_object* obj;
; 1457 : 		HASH_FIND_INT(uthash, &key, obj);  

  0194f	85 f6		 test	 esi, esi
  01951	0f 84 d0 00 00
	00		 je	 $LN65@test_miss
  01957	0f be 45 f3	 movsx	 eax, BYTE PTR _key$152090[ebp+3]
  0195b	0f be 4d f2	 movsx	 ecx, BYTE PTR _key$152090[ebp+2]
  0195f	c1 e0 18	 shl	 eax, 24			; 00000018H
  01962	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01967	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0196a	03 c1		 add	 eax, ecx
  0196c	0f be d7	 movsx	 edx, bh
  0196f	c1 e2 08	 shl	 edx, 8
  01972	03 d0		 add	 edx, eax
  01974	0f be cb	 movsx	 ecx, bl
  01977	03 d1		 add	 edx, ecx
  01979	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  0197f	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  01985	8b c2		 mov	 eax, edx
  01987	c1 e0 08	 shl	 eax, 8
  0198a	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  0198f	2b ca		 sub	 ecx, edx
  01991	33 c8		 xor	 ecx, eax
  01993	8b f9		 mov	 edi, ecx
  01995	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  01998	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  0199d	2b c1		 sub	 eax, ecx
  0199f	2b c2		 sub	 eax, edx
  019a1	33 c7		 xor	 eax, edi
  019a3	2b d1		 sub	 edx, ecx
  019a5	2b d0		 sub	 edx, eax
  019a7	8b f8		 mov	 edi, eax
  019a9	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  019ac	33 d7		 xor	 edx, edi
  019ae	2b ca		 sub	 ecx, edx
  019b0	2b c8		 sub	 ecx, eax
  019b2	8b fa		 mov	 edi, edx
  019b4	c1 e7 10	 shl	 edi, 16			; 00000010H
  019b7	33 cf		 xor	 ecx, edi
  019b9	2b c1		 sub	 eax, ecx
  019bb	2b c2		 sub	 eax, edx
  019bd	8b f9		 mov	 edi, ecx
  019bf	c1 ef 05	 shr	 edi, 5
  019c2	33 c7		 xor	 eax, edi
  019c4	2b d1		 sub	 edx, ecx
  019c6	2b d0		 sub	 edx, eax
  019c8	8b f8		 mov	 edi, eax
  019ca	c1 ef 03	 shr	 edi, 3
  019cd	33 d7		 xor	 edx, edi
  019cf	2b ca		 sub	 ecx, edx
  019d1	2b c8		 sub	 ecx, eax
  019d3	8b fa		 mov	 edi, edx
  019d5	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  019d8	33 cf		 xor	 ecx, edi
  019da	8b 3e		 mov	 edi, DWORD PTR [esi]
  019dc	2b c1		 sub	 eax, ecx
  019de	2b c2		 sub	 eax, edx
  019e0	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  019e3	33 c1		 xor	 eax, ecx
  019e5	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  019e8	49		 dec	 ecx
  019e9	23 c1		 and	 eax, ecx
  019eb	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  019ee	8b 07		 mov	 eax, DWORD PTR [edi]
  019f0	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  019f3	85 c0		 test	 eax, eax
  019f5	74 30		 je	 SHORT $LN65@test_miss
  019f7	8b 7f 14	 mov	 edi, DWORD PTR [edi+20]
  019fa	2b c7		 sub	 eax, edi
  019fc	74 29		 je	 SHORT $LN65@test_miss
  019fe	b9 04 00 00 00	 mov	 ecx, 4
$LL26@test_miss:
  01a03	39 48 18	 cmp	 DWORD PTR [eax+24], ecx
  01a06	75 07		 jne	 SHORT $LN23@test_miss
  01a08	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  01a0b	39 1a		 cmp	 DWORD PTR [edx], ebx
  01a0d	74 0d		 je	 SHORT $LN33@test_miss
$LN23@test_miss:
  01a0f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  01a12	85 c0		 test	 eax, eax
  01a14	74 11		 je	 SHORT $LN65@test_miss
  01a16	2b c7		 sub	 eax, edi
  01a18	75 e9		 jne	 SHORT $LL26@test_miss

; 1458 : 		if (obj)

  01a1a	eb 0b		 jmp	 SHORT $LN65@test_miss
$LN33@test_miss:

; 1459 : 			abort();

  01a1c	e8 00 00 00 00	 call	 _abort
  01a21	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN65@test_miss:

; 1452 : #endif
; 1453 : 
; 1454 : 	START(DATA_UTHASH) {

  01a27	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01a2a	40		 inc	 eax
  01a2b	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01a2e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01a34	0f 82 09 ff ff
	ff		 jb	 $LL66@test_miss
$LN64@test_miss:

; 1460 : 	} STOP();

  01a3a	8d 45 d4	 lea	 eax, DWORD PTR _t$211206[ebp]
  01a3d	50		 push	 eax
  01a3e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01a44	85 c0		 test	 eax, eax
  01a46	75 11		 jne	 SHORT $LN1022@test_miss
  01a48	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01a4c	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211198[ebp], xmm0
  01a51	8b 5d d8	 mov	 ebx, DWORD PTR $T211198[ebp+4]
  01a54	8b 7d d4	 mov	 edi, DWORD PTR $T211198[ebp]
  01a57	eb 54		 jmp	 SHORT $LN1023@test_miss
$LN1022@test_miss:
  01a59	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01a5f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01a65	8b 4d d8	 mov	 ecx, DWORD PTR _t$211206[ebp+4]
  01a68	8b 55 d4	 mov	 edx, DWORD PTR _t$211206[ebp]
  01a6b	57		 push	 edi
  01a6c	56		 push	 esi
  01a6d	51		 push	 ecx
  01a6e	52		 push	 edx
  01a6f	e8 00 00 00 00	 call	 __alldvrm
  01a74	6a 00		 push	 0
  01a76	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01a7b	53		 push	 ebx
  01a7c	51		 push	 ecx
  01a7d	89 45 ec	 mov	 DWORD PTR tv3556[ebp], eax
  01a80	89 55 f0	 mov	 DWORD PTR tv3556[ebp+4], edx
  01a83	e8 00 00 00 00	 call	 __allmul
  01a88	57		 push	 edi
  01a89	56		 push	 esi
  01a8a	52		 push	 edx
  01a8b	50		 push	 eax
  01a8c	e8 00 00 00 00	 call	 __alldiv
  01a91	8b 4d ec	 mov	 ecx, DWORD PTR tv3556[ebp]
  01a94	6a 00		 push	 0
  01a96	8b f8		 mov	 edi, eax
  01a98	8b 45 f0	 mov	 eax, DWORD PTR tv3556[ebp+4]
  01a9b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01aa0	50		 push	 eax
  01aa1	51		 push	 ecx
  01aa2	8b da		 mov	 ebx, edx
  01aa4	e8 00 00 00 00	 call	 __allmul
  01aa9	03 f8		 add	 edi, eax
  01aab	13 da		 adc	 ebx, edx
$LN1023@test_miss:
  01aad	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01ab3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01ab9	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01abf	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01ac5	75 63		 jne	 SHORT $LN1020@test_miss
  01ac7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01ace	75 24		 jne	 SHORT $LN1018@test_miss
  01ad0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01ad6	6a 00		 push	 0
  01ad8	52		 push	 edx
  01ad9	53		 push	 ebx
  01ada	57		 push	 edi
  01adb	e8 00 00 00 00	 call	 __aulldiv
  01ae0	50		 push	 eax
  01ae1	68 00 00 00 00	 push	 OFFSET $SG-102
  01ae6	e8 00 00 00 00	 call	 _printf
  01aeb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01af1	83 c4 08	 add	 esp, 8
$LN1018@test_miss:
  01af4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01af9	6a 00		 push	 0
  01afb	50		 push	 eax
  01afc	53		 push	 ebx
  01afd	57		 push	 edi
  01afe	e8 00 00 00 00	 call	 __aulldiv
  01b03	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01b09	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01b0f	c1 e1 04	 shl	 ecx, 4
  01b12	03 ce		 add	 ecx, esi
  01b14	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01b17	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01b1d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01b20	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01b23	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1020@test_miss:

; 1461 : 
; 1462 : #ifdef USE_JUDY
; 1463 : 	START(DATA_JUDY) {

  01b2a	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 9 ; the_start_data
  01b34	83 fe 09	 cmp	 esi, 9
  01b37	0f 85 ea 00 00
	00		 jne	 $LN13@test_miss
  01b3d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01b44	75 2f		 jne	 SHORT $LN1027@test_miss
  01b46	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  01b4c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01b51	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01b58	52		 push	 edx
  01b59	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01b5f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01b66	51		 push	 ecx
  01b67	50		 push	 eax
  01b68	68 00 00 00 00	 push	 OFFSET $SG-101
  01b6d	e8 00 00 00 00	 call	 _printf
  01b72	83 c4 10	 add	 esp, 16			; 00000010H
$LN1027@test_miss:
  01b75	8d 4d d4	 lea	 ecx, DWORD PTR _t$211231[ebp]
  01b78	51		 push	 ecx
  01b79	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01b7f	85 c0		 test	 eax, eax
  01b81	75 11		 jne	 SHORT $LN1033@test_miss
  01b83	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01b87	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211224[ebp], xmm0
  01b8c	8b 5d d8	 mov	 ebx, DWORD PTR $T211224[ebp+4]
  01b8f	8b 7d d4	 mov	 edi, DWORD PTR $T211224[ebp]
  01b92	eb 54		 jmp	 SHORT $LN1034@test_miss
$LN1033@test_miss:
  01b94	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01b9a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01ba0	8b 55 d8	 mov	 edx, DWORD PTR _t$211231[ebp+4]
  01ba3	8b 45 d4	 mov	 eax, DWORD PTR _t$211231[ebp]
  01ba6	57		 push	 edi
  01ba7	56		 push	 esi
  01ba8	52		 push	 edx
  01ba9	50		 push	 eax
  01baa	e8 00 00 00 00	 call	 __alldvrm
  01baf	6a 00		 push	 0
  01bb1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01bb6	53		 push	 ebx
  01bb7	51		 push	 ecx
  01bb8	89 45 ec	 mov	 DWORD PTR tv3094[ebp], eax
  01bbb	89 55 f0	 mov	 DWORD PTR tv3094[ebp+4], edx
  01bbe	e8 00 00 00 00	 call	 __allmul
  01bc3	57		 push	 edi
  01bc4	56		 push	 esi
  01bc5	52		 push	 edx
  01bc6	50		 push	 eax
  01bc7	e8 00 00 00 00	 call	 __alldiv
  01bcc	8b 4d f0	 mov	 ecx, DWORD PTR tv3094[ebp+4]
  01bcf	6a 00		 push	 0
  01bd1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01bd6	8b da		 mov	 ebx, edx
  01bd8	8b 55 ec	 mov	 edx, DWORD PTR tv3094[ebp]
  01bdb	51		 push	 ecx
  01bdc	52		 push	 edx
  01bdd	8b f8		 mov	 edi, eax
  01bdf	e8 00 00 00 00	 call	 __allmul
  01be4	03 f8		 add	 edi, eax
  01be6	13 da		 adc	 ebx, edx
$LN1034@test_miss:
  01be8	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01bee	33 ff		 xor	 edi, edi
  01bf0	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01bf6	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01bfc	76 29		 jbe	 SHORT $LN13@test_miss
  01bfe	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
$LL15@test_miss:

; 1464 : 		Word_t key = SEARCH[i] + DELTA;

  01c01	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]

; 1465 : 		Pvoid_t PValue;
; 1466 : 		JLG(PValue, judy, key);

  01c04	6a 00		 push	 0
  01c06	50		 push	 eax
  01c07	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judy@@3PAXA ; judy
  01c0c	50		 push	 eax
  01c0d	e8 00 00 00 00	 call	 _JudyLGet
  01c12	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1467 : 		if (PValue)

  01c15	85 c0		 test	 eax, eax
  01c17	74 05		 je	 SHORT $LN14@test_miss

; 1468 : 			abort();

  01c19	e8 00 00 00 00	 call	 _abort
$LN14@test_miss:

; 1461 : 
; 1462 : #ifdef USE_JUDY
; 1463 : 	START(DATA_JUDY) {

  01c1e	47		 inc	 edi
  01c1f	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01c25	72 da		 jb	 SHORT $LL15@test_miss
$LN13@test_miss:

; 1469 : 	} STOP();

  01c27	8d 4d dc	 lea	 ecx, DWORD PTR _t$211252[ebp]
  01c2a	51		 push	 ecx
  01c2b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01c31	85 c0		 test	 eax, eax
  01c33	75 11		 jne	 SHORT $LN1040@test_miss
  01c35	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01c39	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211244[ebp], xmm0
  01c3e	8b 5d d8	 mov	 ebx, DWORD PTR $T211244[ebp+4]
  01c41	8b 7d d4	 mov	 edi, DWORD PTR $T211244[ebp]
  01c44	eb 54		 jmp	 SHORT $LN1041@test_miss
$LN1040@test_miss:
  01c46	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01c4c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01c52	8b 55 e0	 mov	 edx, DWORD PTR _t$211252[ebp+4]
  01c55	8b 45 dc	 mov	 eax, DWORD PTR _t$211252[ebp]
  01c58	57		 push	 edi
  01c59	56		 push	 esi
  01c5a	52		 push	 edx
  01c5b	50		 push	 eax
  01c5c	e8 00 00 00 00	 call	 __alldvrm
  01c61	6a 00		 push	 0
  01c63	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01c68	53		 push	 ebx
  01c69	51		 push	 ecx
  01c6a	89 45 ec	 mov	 DWORD PTR tv3660[ebp], eax
  01c6d	89 55 f0	 mov	 DWORD PTR tv3660[ebp+4], edx
  01c70	e8 00 00 00 00	 call	 __allmul
  01c75	57		 push	 edi
  01c76	56		 push	 esi
  01c77	52		 push	 edx
  01c78	50		 push	 eax
  01c79	e8 00 00 00 00	 call	 __alldiv
  01c7e	8b 4d f0	 mov	 ecx, DWORD PTR tv3660[ebp+4]
  01c81	6a 00		 push	 0
  01c83	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01c88	8b da		 mov	 ebx, edx
  01c8a	8b 55 ec	 mov	 edx, DWORD PTR tv3660[ebp]
  01c8d	51		 push	 ecx
  01c8e	52		 push	 edx
  01c8f	8b f8		 mov	 edi, eax
  01c91	e8 00 00 00 00	 call	 __allmul
  01c96	03 f8		 add	 edi, eax
  01c98	13 da		 adc	 ebx, edx
$LN1041@test_miss:
  01c9a	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01ca0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01ca6	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01cac	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01cb2	75 63		 jne	 SHORT $LN1038@test_miss
  01cb4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01cbb	75 23		 jne	 SHORT $LN1036@test_miss
  01cbd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01cc2	6a 00		 push	 0
  01cc4	50		 push	 eax
  01cc5	53		 push	 ebx
  01cc6	57		 push	 edi
  01cc7	e8 00 00 00 00	 call	 __aulldiv
  01ccc	50		 push	 eax
  01ccd	68 00 00 00 00	 push	 OFFSET $SG-102
  01cd2	e8 00 00 00 00	 call	 _printf
  01cd7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01cdd	83 c4 08	 add	 esp, 8
$LN1036@test_miss:
  01ce0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  01ce6	6a 00		 push	 0
  01ce8	51		 push	 ecx
  01ce9	53		 push	 ebx
  01cea	57		 push	 edi
  01ceb	e8 00 00 00 00	 call	 __aulldiv
  01cf0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  01cf6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01cfc	c1 e2 04	 shl	 edx, 4
  01cff	03 d6		 add	 edx, esi
  01d01	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  01d04	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  01d07	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01d0d	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  01d10	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN1038@test_miss:

; 1470 : #endif
; 1471 : 
; 1472 : #ifdef USE_JUDYARRAY
; 1473 : 	START(DATA_JUDYARRAY) {

  01d17	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 10 ; the_start_data, 0000000aH
  01d21	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  01d24	0f 85 ef 00 00
	00		 jne	 $LN8@test_miss
  01d2a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01d31	75 2e		 jne	 SHORT $LN1045@test_miss
  01d33	a1 28 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  01d38	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01d3e	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  01d45	50		 push	 eax
  01d46	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01d4b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  01d52	52		 push	 edx
  01d53	51		 push	 ecx
  01d54	68 00 00 00 00	 push	 OFFSET $SG-101
  01d59	e8 00 00 00 00	 call	 _printf
  01d5e	83 c4 10	 add	 esp, 16			; 00000010H
$LN1045@test_miss:
  01d61	8d 55 e4	 lea	 edx, DWORD PTR _t$211277[ebp]
  01d64	52		 push	 edx
  01d65	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01d6b	85 c0		 test	 eax, eax
  01d6d	75 11		 jne	 SHORT $LN1051@test_miss
  01d6f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01d73	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211270[ebp], xmm0
  01d78	8b 5d d8	 mov	 ebx, DWORD PTR $T211270[ebp+4]
  01d7b	8b 7d d4	 mov	 edi, DWORD PTR $T211270[ebp]
  01d7e	eb 54		 jmp	 SHORT $LN1052@test_miss
$LN1051@test_miss:
  01d80	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01d86	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01d8c	8b 45 e8	 mov	 eax, DWORD PTR _t$211277[ebp+4]
  01d8f	8b 4d e4	 mov	 ecx, DWORD PTR _t$211277[ebp]
  01d92	57		 push	 edi
  01d93	56		 push	 esi
  01d94	50		 push	 eax
  01d95	51		 push	 ecx
  01d96	e8 00 00 00 00	 call	 __alldvrm
  01d9b	6a 00		 push	 0
  01d9d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01da2	53		 push	 ebx
  01da3	51		 push	 ecx
  01da4	89 45 ec	 mov	 DWORD PTR tv409[ebp], eax
  01da7	89 55 f0	 mov	 DWORD PTR tv409[ebp+4], edx
  01daa	e8 00 00 00 00	 call	 __allmul
  01daf	57		 push	 edi
  01db0	56		 push	 esi
  01db1	52		 push	 edx
  01db2	50		 push	 eax
  01db3	e8 00 00 00 00	 call	 __alldiv
  01db8	6a 00		 push	 0
  01dba	8b da		 mov	 ebx, edx
  01dbc	8b 55 f0	 mov	 edx, DWORD PTR tv409[ebp+4]
  01dbf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01dc4	8b f8		 mov	 edi, eax
  01dc6	8b 45 ec	 mov	 eax, DWORD PTR tv409[ebp]
  01dc9	52		 push	 edx
  01dca	50		 push	 eax
  01dcb	e8 00 00 00 00	 call	 __allmul
  01dd0	03 f8		 add	 edi, eax
  01dd2	13 da		 adc	 ebx, edx
$LN1052@test_miss:
  01dd4	33 f6		 xor	 esi, esi
  01dd6	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01ddc	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01de2	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01de8	76 2f		 jbe	 SHORT $LN8@test_miss
  01dea	8b 7d 08	 mov	 edi, DWORD PTR _SEARCH$[ebp]
  01ded	8d 49 00	 npad	 3
$LL10@test_miss:

; 1474 : 		judyvalue key = SEARCH[i] + DELTA;

  01df0	8b 0c b7	 mov	 ecx, DWORD PTR [edi+esi*4]

; 1475 : 		JudySlot* pvalue;
; 1476 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01df3	8d 55 f0	 lea	 edx, DWORD PTR _key$152192[ebp]
  01df6	52		 push	 edx
  01df7	89 4d f0	 mov	 DWORD PTR _key$152192[ebp], ecx
  01dfa	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01dff	83 c4 04	 add	 esp, 4

; 1477 : 		if (pvalue) {

  01e02	85 c0		 test	 eax, eax
  01e04	74 0a		 je	 SHORT $LN9@test_miss

; 1478 : 			/* workaround for a judyarray bug. Sometimes it returns a pvalue pointing to NULL */
; 1479 : 			void* obj = *(void**)pvalue;
; 1480 : 			if (obj)

  01e06	83 38 00	 cmp	 DWORD PTR [eax], 0
  01e09	74 05		 je	 SHORT $LN9@test_miss

; 1481 : 				abort();

  01e0b	e8 00 00 00 00	 call	 _abort
$LN9@test_miss:

; 1470 : #endif
; 1471 : 
; 1472 : #ifdef USE_JUDYARRAY
; 1473 : 	START(DATA_JUDYARRAY) {

  01e10	46		 inc	 esi
  01e11	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01e17	72 d7		 jb	 SHORT $LL10@test_miss
$LN8@test_miss:

; 1482 : 		}
; 1483 : 	} STOP();

  01e19	8d 45 d4	 lea	 eax, DWORD PTR _t$211298[ebp]
  01e1c	50		 push	 eax
  01e1d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01e23	85 c0		 test	 eax, eax
  01e25	75 11		 jne	 SHORT $LN1058@test_miss
  01e27	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01e2b	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211290[ebp], xmm0
  01e30	8b 5d d8	 mov	 ebx, DWORD PTR $T211290[ebp+4]
  01e33	8b 7d d4	 mov	 edi, DWORD PTR $T211290[ebp]
  01e36	eb 54		 jmp	 SHORT $LN1059@test_miss
$LN1058@test_miss:
  01e38	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01e3e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01e44	8b 4d d8	 mov	 ecx, DWORD PTR _t$211298[ebp+4]
  01e47	8b 55 d4	 mov	 edx, DWORD PTR _t$211298[ebp]
  01e4a	57		 push	 edi
  01e4b	56		 push	 esi
  01e4c	51		 push	 ecx
  01e4d	52		 push	 edx
  01e4e	e8 00 00 00 00	 call	 __alldvrm
  01e53	6a 00		 push	 0
  01e55	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01e5a	53		 push	 ebx
  01e5b	51		 push	 ecx
  01e5c	89 45 ec	 mov	 DWORD PTR tv3388[ebp], eax
  01e5f	89 55 f0	 mov	 DWORD PTR tv3388[ebp+4], edx
  01e62	e8 00 00 00 00	 call	 __allmul
  01e67	57		 push	 edi
  01e68	56		 push	 esi
  01e69	52		 push	 edx
  01e6a	50		 push	 eax
  01e6b	e8 00 00 00 00	 call	 __alldiv
  01e70	8b 4d ec	 mov	 ecx, DWORD PTR tv3388[ebp]
  01e73	6a 00		 push	 0
  01e75	8b f8		 mov	 edi, eax
  01e77	8b 45 f0	 mov	 eax, DWORD PTR tv3388[ebp+4]
  01e7a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01e7f	50		 push	 eax
  01e80	51		 push	 ecx
  01e81	8b da		 mov	 ebx, edx
  01e83	e8 00 00 00 00	 call	 __allmul
  01e88	03 f8		 add	 edi, eax
  01e8a	13 da		 adc	 ebx, edx
$LN1059@test_miss:
  01e8c	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01e92	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01e98	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01e9e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01ea4	75 63		 jne	 SHORT $LN1056@test_miss
  01ea6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01ead	75 24		 jne	 SHORT $LN1054@test_miss
  01eaf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01eb5	6a 00		 push	 0
  01eb7	52		 push	 edx
  01eb8	53		 push	 ebx
  01eb9	57		 push	 edi
  01eba	e8 00 00 00 00	 call	 __aulldiv
  01ebf	50		 push	 eax
  01ec0	68 00 00 00 00	 push	 OFFSET $SG-102
  01ec5	e8 00 00 00 00	 call	 _printf
  01eca	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01ed0	83 c4 08	 add	 esp, 8
$LN1054@test_miss:
  01ed3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01ed8	6a 00		 push	 0
  01eda	50		 push	 eax
  01edb	53		 push	 ebx
  01edc	57		 push	 edi
  01edd	e8 00 00 00 00	 call	 __aulldiv
  01ee2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01ee8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01eee	c1 e1 04	 shl	 ecx, 4
  01ef1	03 ce		 add	 ecx, esi
  01ef3	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01ef6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01efc	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01eff	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01f02	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1056@test_miss:

; 1484 : #endif
; 1485 : 
; 1486 : 	START(DATA_NEDTRIE) {

  01f09	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 6 ; the_start_data
  01f13	83 fe 06	 cmp	 esi, 6
  01f16	0f 85 28 01 00
	00		 jne	 $LN2@test_miss
  01f1c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01f23	75 2f		 jne	 SHORT $LN1063@test_miss
  01f25	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  01f2b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01f30	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01f37	52		 push	 edx
  01f38	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01f3e	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01f45	51		 push	 ecx
  01f46	50		 push	 eax
  01f47	68 00 00 00 00	 push	 OFFSET $SG-101
  01f4c	e8 00 00 00 00	 call	 _printf
  01f51	83 c4 10	 add	 esp, 16			; 00000010H
$LN1063@test_miss:
  01f54	8d 4d d4	 lea	 ecx, DWORD PTR _t$211323[ebp]
  01f57	51		 push	 ecx
  01f58	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01f5e	85 c0		 test	 eax, eax
  01f60	75 11		 jne	 SHORT $LN1069@test_miss
  01f62	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01f66	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211316[ebp], xmm0
  01f6b	8b 5d d8	 mov	 ebx, DWORD PTR $T211316[ebp+4]
  01f6e	8b 7d d4	 mov	 edi, DWORD PTR $T211316[ebp]
  01f71	eb 54		 jmp	 SHORT $LN1070@test_miss
$LN1069@test_miss:
  01f73	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01f79	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01f7f	8b 55 d8	 mov	 edx, DWORD PTR _t$211323[ebp+4]
  01f82	8b 45 d4	 mov	 eax, DWORD PTR _t$211323[ebp]
  01f85	57		 push	 edi
  01f86	56		 push	 esi
  01f87	52		 push	 edx
  01f88	50		 push	 eax
  01f89	e8 00 00 00 00	 call	 __alldvrm
  01f8e	6a 00		 push	 0
  01f90	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01f95	53		 push	 ebx
  01f96	51		 push	 ecx
  01f97	89 45 ec	 mov	 DWORD PTR tv3052[ebp], eax
  01f9a	89 55 f0	 mov	 DWORD PTR tv3052[ebp+4], edx
  01f9d	e8 00 00 00 00	 call	 __allmul
  01fa2	57		 push	 edi
  01fa3	56		 push	 esi
  01fa4	52		 push	 edx
  01fa5	50		 push	 eax
  01fa6	e8 00 00 00 00	 call	 __alldiv
  01fab	8b 4d f0	 mov	 ecx, DWORD PTR tv3052[ebp+4]
  01fae	6a 00		 push	 0
  01fb0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01fb5	8b da		 mov	 ebx, edx
  01fb7	8b 55 ec	 mov	 edx, DWORD PTR tv3052[ebp]
  01fba	51		 push	 ecx
  01fbb	52		 push	 edx
  01fbc	8b f8		 mov	 edi, eax
  01fbe	e8 00 00 00 00	 call	 __allmul
  01fc3	03 f8		 add	 edi, eax
  01fc5	13 da		 adc	 ebx, edx
$LN1070@test_miss:
  01fc7	33 f6		 xor	 esi, esi
  01fc9	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01fcf	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01fd5	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01fdb	76 67		 jbe	 SHORT $LN2@test_miss
  01fdd	8b 5d 08	 mov	 ebx, DWORD PTR _SEARCH$[ebp]
$LN4@test_miss:

; 1487 : 		unsigned key = SEARCH[i] + DELTA;
; 1488 : 		struct nedtrie_object key_obj;
; 1489 : 		struct nedtrie_object* obj;
; 1490 : 		key_obj.value = key;
; 1491 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01fe0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  01fe7	8b 3c b3	 mov	 edi, DWORD PTR [ebx+esi*4]
  01fea	74 4f		 je	 SHORT $LN3@test_miss
  01fec	8b c7		 mov	 eax, edi
  01fee	83 c8 01	 or	 eax, 1
  01ff1	0f bd c8	 bsr	 ecx, eax
  01ff4	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  01ffb	89 4d f0	 mov	 DWORD PTR _bitpos$211349[ebp], ecx
  01ffe	85 c0		 test	 eax, eax
  02000	74 39		 je	 SHORT $LN3@test_miss
  02002	ba 01 00 00 00	 mov	 edx, 1
  02007	d3 e2		 shl	 edx, cl
  02009	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  0200c	74 1b		 je	 SHORT $end$211366
  0200e	8b ff		 npad	 2
$LL1077@test_miss:
  02010	d1 ea		 shr	 edx, 1
  02012	8b ca		 mov	 ecx, edx
  02014	23 cf		 and	 ecx, edi
  02016	f7 d9		 neg	 ecx
  02018	1b c9		 sbb	 ecx, ecx
  0201a	f7 d9		 neg	 ecx
  0201c	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  02020	85 c0		 test	 eax, eax
  02022	74 17		 je	 SHORT $LN3@test_miss
  02024	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  02027	75 e7		 jne	 SHORT $LL1077@test_miss
$end$211366:
  02029	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0202c	85 c9		 test	 ecx, ecx
  0202e	74 02		 je	 SHORT $LN1082@test_miss
  02030	8b c1		 mov	 eax, ecx
$LN1082@test_miss:

; 1492 : 		if (obj)

  02032	85 c0		 test	 eax, eax
  02034	74 05		 je	 SHORT $LN3@test_miss

; 1493 : 			abort();

  02036	e8 00 00 00 00	 call	 _abort
$LN3@test_miss:

; 1484 : #endif
; 1485 : 
; 1486 : 	START(DATA_NEDTRIE) {

  0203b	46		 inc	 esi
  0203c	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  02042	72 9c		 jb	 SHORT $LN4@test_miss
$LN2@test_miss:

; 1494 : 	} STOP();

  02044	8d 55 d4	 lea	 edx, DWORD PTR _t$211383[ebp]
  02047	52		 push	 edx
  02048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0204e	85 c0		 test	 eax, eax
  02050	75 11		 jne	 SHORT $LN1094@test_miss
  02052	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02056	66 0f 13 45 d4	 movlpd	 QWORD PTR $T211376[ebp], xmm0
  0205b	8b 7d d8	 mov	 edi, DWORD PTR $T211376[ebp+4]
  0205e	8b 75 d4	 mov	 esi, DWORD PTR $T211376[ebp]
  02061	eb 54		 jmp	 SHORT $LN1095@test_miss
$LN1094@test_miss:
  02063	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  02069	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0206f	8b 45 d8	 mov	 eax, DWORD PTR _t$211383[ebp+4]
  02072	8b 4d d4	 mov	 ecx, DWORD PTR _t$211383[ebp]
  02075	56		 push	 esi
  02076	57		 push	 edi
  02077	50		 push	 eax
  02078	51		 push	 ecx
  02079	e8 00 00 00 00	 call	 __alldvrm
  0207e	6a 00		 push	 0
  02080	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  02085	53		 push	 ebx
  02086	51		 push	 ecx
  02087	89 45 ec	 mov	 DWORD PTR tv503[ebp], eax
  0208a	89 55 f0	 mov	 DWORD PTR tv503[ebp+4], edx
  0208d	e8 00 00 00 00	 call	 __allmul
  02092	56		 push	 esi
  02093	57		 push	 edi
  02094	52		 push	 edx
  02095	50		 push	 eax
  02096	e8 00 00 00 00	 call	 __alldiv
  0209b	6a 00		 push	 0
  0209d	8b fa		 mov	 edi, edx
  0209f	8b 55 f0	 mov	 edx, DWORD PTR tv503[ebp+4]
  020a2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  020a7	8b f0		 mov	 esi, eax
  020a9	8b 45 ec	 mov	 eax, DWORD PTR tv503[ebp]
  020ac	52		 push	 edx
  020ad	50		 push	 eax
  020ae	e8 00 00 00 00	 call	 __allmul
  020b3	03 f0		 add	 esi, eax
  020b5	13 fa		 adc	 edi, edx
$LN1095@test_miss:
  020b7	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  020bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  020c3	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  020c9	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  020cf	75 61		 jne	 SHORT $LN1092@test_miss
  020d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  020d8	75 1e		 jne	 SHORT $LN1090@test_miss
  020da	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  020e0	6a 00		 push	 0
  020e2	52		 push	 edx
  020e3	57		 push	 edi
  020e4	56		 push	 esi
  020e5	e8 00 00 00 00	 call	 __aulldiv
  020ea	50		 push	 eax
  020eb	68 00 00 00 00	 push	 OFFSET $SG-102
  020f0	e8 00 00 00 00	 call	 _printf
  020f5	83 c4 08	 add	 esp, 8
$LN1090@test_miss:
  020f8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  020fd	6a 00		 push	 0
  020ff	50		 push	 eax
  02100	57		 push	 edi
  02101	56		 push	 esi
  02102	e8 00 00 00 00	 call	 __aulldiv
  02107	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0210d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  02113	c1 e1 04	 shl	 ecx, 4
  02116	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  0211c	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0211f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  02125	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  02128	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0212b	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1092@test_miss:

; 1495 : }

  02132	5f		 pop	 edi
  02133	5e		 pop	 esi
  02134	5b		 pop	 ebx
  02135	8b e5		 mov	 esp, ebp
  02137	5d		 pop	 ebp
  02138	c3		 ret	 0
?test_miss@@YAXPAI@Z ENDP				; test_miss
_TEXT	ENDS
PUBLIC	?test_hit@@YAXPAI@Z				; test_hit
; Function compile flags: /Ogtp
;	COMDAT ?test_hit@@YAXPAI@Z
_TEXT	SEGMENT
$T211550 = -60						; size = 16
$T216264 = -52						; size = 8
_t$216272 = -52						; size = 8
$T216204 = -52						; size = 8
_t$216211 = -52						; size = 8
$T216178 = -52						; size = 8
_t$216186 = -52						; size = 8
$T216158 = -52						; size = 8
$T216132 = -52						; size = 8
$T216112 = -52						; size = 8
_t$216119 = -52						; size = 8
_t$216094 = -52						; size = 8
$T216086 = -52						; size = 8
$T216066 = -52						; size = 8
$T216040 = -52						; size = 8
$T215949 = -52						; size = 8
$T215923 = -52						; size = 8
$T215552 = -52						; size = 8
$T215526 = -52						; size = 8
$T215338 = -52						; size = 8
$T215312 = -52						; size = 8
$T214953 = -52						; size = 8
_pos$213185 = -52					; size = 8
_t$216140 = -44						; size = 8
_t$216051 = -44						; size = 8
_t$215934 = -44						; size = 8
_t$215537 = -44						; size = 8
_t$215320 = -44						; size = 8
$T214952 = -44						; size = 8
$T213740 = -44						; size = 8
$T213714 = -44						; size = 8
_t$212082 = -44						; size = 8
_t$216165 = -36						; size = 8
_t$216077 = -36						; size = 8
_t$215958 = -36						; size = 8
_t$215561 = -36						; size = 8
_t$215345 = -36						; size = 8
_t$213725 = -36						; size = 8
_t$212057 = -36						; size = 8
_t$213749 = -28						; size = 8
$T212075 = -28						; size = 8
$T212049 = -28						; size = 8
_t$212032 = -28						; size = 8
tv3969 = -20						; size = 8
tv3954 = -20						; size = 8
tv3903 = -20						; size = 8
tv3874 = -20						; size = 8
tv3831 = -20						; size = 8
tv3817 = -20						; size = 8
tv3470 = -20						; size = 8
tv3447 = -20						; size = 8
tv3436 = -20						; size = 8
tv3408 = -20						; size = 8
tv3383 = -20						; size = 8
tv3338 = -20						; size = 8
tv3296 = -20						; size = 8
tv3225 = -20						; size = 8
tv2853 = -20						; size = 8
tv2664 = -20						; size = 8
tv2509 = -20						; size = 8
tv2360 = -20						; size = 8
tv2204 = -20						; size = 8
tv1934 = -20						; size = 8
tv1408 = -20						; size = 8
tv1269 = -20						; size = 8
$T212025 = -20						; size = 8
$T211999 = -20						; size = 8
$T211961 = -20						; size = 8
_t$211970 = -20						; size = 8
$T211935 = -20						; size = 8
_t$211946 = -20						; size = 8
tv1107 = -20						; size = 8
tv984 = -20						; size = 8
$T211883 = -20						; size = 8
_t$211892 = -20						; size = 8
$T211857 = -20						; size = 8
_t$211868 = -20						; size = 8
$T211722 = -20						; size = 8
_t$211731 = -20						; size = 8
tv842 = -20						; size = 8
$T211696 = -20						; size = 8
_t$211707 = -20						; size = 8
$T211648 = -20						; size = 8
_t$211657 = -20						; size = 8
tv531 = -20						; size = 8
tv509 = -20						; size = 8
tv462 = -20						; size = 8
_bitpos$216237 = -16					; size = 4
__Where$215861 = -16					; size = 4
_count$211844 = -16					; size = 4
_key$151960 = -16					; size = 4
_key$151852 = -16					; size = 4
_key$151707 = -16					; size = 4
_key$151126 = -16					; size = 4
_key$151025 = -16					; size = 4
_key$150842 = -16					; size = 4
_t$212007 = -12						; size = 8
$T215790 = -8						; size = 4
$T211555 = -8						; size = 4
_i$ = -8						; size = 4
_SEARCH$ = 8						; size = 4
?test_hit@@YAXPAI@Z PROC				; test_hit, COMDAT

; 1092 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx

; 1093 : 	unsigned i;
; 1094 : 
; 1095 : 	/* always dereference the object found. It has cache effect. */
; 1096 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1097 : 	/* this favorites data structures that store part of the information in the object itself */
; 1098 : 	const int dereference = 1;
; 1099 : 
; 1100 : 	const unsigned DELTA = 1;
; 1101 : 
; 1102 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00013	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00019	0f 85 ad 00 00
	00		 jne	 $LN155@test_hit
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00026	75 2e		 jne	 SHORT $LN165@test_hit
  00028	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00033	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003a	50		 push	 eax
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00040	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00047	52		 push	 edx
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET $SG-101
  0004e	e8 00 00 00 00	 call	 _printf
  00053	83 c4 10	 add	 esp, 16			; 00000010H
$LN165@test_hit:
  00056	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005b	33 f6		 xor	 esi, esi
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00062	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00068	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  0006e	76 5c		 jbe	 SHORT $LN155@test_hit
$LL157@test_hit:

; 1103 : 		unsigned key = SEARCH[i] + DELTA;

  00070	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  00073	8b 1c b2	 mov	 ebx, DWORD PTR [edx+esi*4]

; 1104 : 		struct rbt_object key_obj;
; 1105 : 		struct rbt_object* obj;
; 1106 : 		key_obj.value = key;
; 1107 : 		obj = rbt_search(&tree, &key_obj); 

  00076	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?tree@@3Urbtree_t@@A
  0007c	43		 inc	 ebx
  0007d	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  00083	74 27		 je	 SHORT $LN1241@test_hit
$LL175@test_hit:
  00085	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00088	3b d8		 cmp	 ebx, eax
  0008a	7c 14		 jl	 SHORT $LN1244@test_hit
  0008c	7e 16		 jle	 SHORT $LN174@test_hit
  0008e	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00091	83 e7 fe	 and	 edi, -2			; fffffffeH
$LN172@test_hit:
  00094	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  0009a	75 e9		 jne	 SHORT $LL175@test_hit
  0009c	33 ff		 xor	 edi, edi

; 1108 : 		if (!obj)

  0009e	eb 14		 jmp	 SHORT $LN1279@test_hit
$LN1244@test_hit:

; 1104 : 		struct rbt_object key_obj;
; 1105 : 		struct rbt_object* obj;
; 1106 : 		key_obj.value = key;
; 1107 : 		obj = rbt_search(&tree, &key_obj); 

  000a0	8b 3f		 mov	 edi, DWORD PTR [edi]
  000a2	eb f0		 jmp	 SHORT $LN172@test_hit
$LN174@test_hit:
  000a4	81 ff 04 00 00
	00		 cmp	 edi, OFFSET ?tree@@3Urbtree_t@@A+4
  000aa	75 04		 jne	 SHORT $LN171@test_hit
$LN1241@test_hit:
  000ac	33 ff		 xor	 edi, edi

; 1108 : 		if (!obj)

  000ae	eb 04		 jmp	 SHORT $LN1279@test_hit

; 1104 : 		struct rbt_object key_obj;
; 1105 : 		struct rbt_object* obj;
; 1106 : 		key_obj.value = key;
; 1107 : 		obj = rbt_search(&tree, &key_obj); 

$LN171@test_hit:

; 1108 : 		if (!obj)

  000b0	85 ff		 test	 edi, edi
  000b2	75 05		 jne	 SHORT $LN154@test_hit
$LN1279@test_hit:

; 1109 : 			abort();

  000b4	e8 00 00 00 00	 call	 _abort
$LN154@test_hit:

; 1110 : 		if (dereference) {
; 1111 : 			if (obj->value != key)

  000b9	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  000bc	74 05		 je	 SHORT $LN156@test_hit

; 1112 : 				abort();

  000be	e8 00 00 00 00	 call	 _abort
$LN156@test_hit:

; 1093 : 	unsigned i;
; 1094 : 
; 1095 : 	/* always dereference the object found. It has cache effect. */
; 1096 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1097 : 	/* this favorites data structures that store part of the information in the object itself */
; 1098 : 	const int dereference = 1;
; 1099 : 
; 1100 : 	const unsigned DELTA = 1;
; 1101 : 
; 1102 : 	START(DATA_TREE) {

  000c3	46		 inc	 esi
  000c4	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  000ca	72 a4		 jb	 SHORT $LL157@test_hit
$LN155@test_hit:

; 1113 : 		}
; 1114 : 	} STOP();

  000cc	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1115 : 
; 1116 : 	START(DATA_HASHTABLE) {

  000d1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  000d8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 0 ; the_start_data
  000e2	0f 85 e1 00 00
	00		 jne	 $LN148@test_hit
  000e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  000ef	75 2e		 jne	 SHORT $LN182@test_hit
  000f1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA
  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  000fc	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00103	50		 push	 eax
  00104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00109	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00110	52		 push	 edx
  00111	51		 push	 ecx
  00112	68 00 00 00 00	 push	 OFFSET $SG-101
  00117	e8 00 00 00 00	 call	 _printf
  0011c	83 c4 10	 add	 esp, 16			; 00000010H
$LN182@test_hit:
  0011f	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00124	33 f6		 xor	 esi, esi
  00126	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0012b	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00131	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00137	0f 86 8c 00 00
	00		 jbe	 $LN148@test_hit
  0013d	8d 49 00	 npad	 3
$LL150@test_hit:

; 1117 : 		unsigned key = SEARCH[i] + DELTA;

  00140	8b 55 08	 mov	 edx, DWORD PTR _SEARCH$[ebp]
  00143	8b 3c b2	 mov	 edi, DWORD PTR [edx+esi*4]
  00146	47		 inc	 edi

; 1118 : 		unsigned hash_key = hash(key);

  00147	8b cf		 mov	 ecx, edi
  00149	c1 e1 06	 shl	 ecx, 6
  0014c	8b c7		 mov	 eax, edi
  0014e	2b c1		 sub	 eax, ecx
  00150	8b d0		 mov	 edx, eax
  00152	c1 ea 11	 shr	 edx, 17			; 00000011H
  00155	33 c2		 xor	 eax, edx
  00157	8b c8		 mov	 ecx, eax
  00159	c1 e1 09	 shl	 ecx, 9
  0015c	2b c1		 sub	 eax, ecx
  0015e	8b d0		 mov	 edx, eax
  00160	c1 e2 04	 shl	 edx, 4
  00163	33 c2		 xor	 eax, edx
  00165	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0016c	2b c1		 sub	 eax, ecx
  0016e	8b d0		 mov	 edx, eax
  00170	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00173	33 c2		 xor	 eax, edx

; 1119 : 		struct hashtable_object* obj;
; 1120 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  00175	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0017b	8b c8		 mov	 ecx, eax
  0017d	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00180	33 c8		 xor	 ecx, eax
  00182	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00187	23 c1		 and	 eax, ecx
  00189	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  0018c	85 c0		 test	 eax, eax
  0018e	74 13		 je	 SHORT $LN191@test_hit
$LL192@test_hit:
  00190	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00193	75 08		 jne	 SHORT $LN190@test_hit
  00195	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00198	3b 7a 10	 cmp	 edi, DWORD PTR [edx+16]
  0019b	74 0a		 je	 SHORT $LN1204@test_hit
$LN190@test_hit:
  0019d	8b 00		 mov	 eax, DWORD PTR [eax]
  0019f	85 c0		 test	 eax, eax
  001a1	75 ed		 jne	 SHORT $LL192@test_hit
$LN191@test_hit:
  001a3	33 db		 xor	 ebx, ebx

; 1121 : 		if (!obj)

  001a5	eb 06		 jmp	 SHORT $LN1246@test_hit
$LN1204@test_hit:

; 1119 : 		struct hashtable_object* obj;
; 1120 : 		obj = (struct hashtable_object*)tommy_hashtable_search(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001a7	8b da		 mov	 ebx, edx

; 1121 : 		if (!obj)

  001a9	85 db		 test	 ebx, ebx
  001ab	75 05		 jne	 SHORT $LN147@test_hit
$LN1246@test_hit:

; 1122 : 			abort();

  001ad	e8 00 00 00 00	 call	 _abort
$LN147@test_hit:

; 1123 : 		if (dereference) {
; 1124 : 			if (obj->value != key)

  001b2	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  001b5	74 05		 je	 SHORT $LN149@test_hit

; 1125 : 				abort();

  001b7	e8 00 00 00 00	 call	 _abort
$LN149@test_hit:

; 1115 : 
; 1116 : 	START(DATA_HASHTABLE) {

  001bc	46		 inc	 esi
  001bd	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  001c3	0f 82 77 ff ff
	ff		 jb	 $LL150@test_hit
$LN148@test_hit:

; 1126 : 		}
; 1127 : 	} STOP();

  001c9	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1128 : 
; 1129 : 	START(DATA_HASHDYN) {

  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001d8	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001de	0f 85 4d 01 00
	00		 jne	 $LN141@test_hit
  001e4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001eb	75 2e		 jne	 SHORT $LN200@test_hit
  001ed	a1 04 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  001f8	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  001ff	50		 push	 eax
  00200	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00205	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0020c	52		 push	 edx
  0020d	51		 push	 ecx
  0020e	68 00 00 00 00	 push	 OFFSET $SG-101
  00213	e8 00 00 00 00	 call	 _printf
  00218	83 c4 10	 add	 esp, 16			; 00000010H
$LN200@test_hit:
  0021b	8d 55 ec	 lea	 edx, DWORD PTR _t$211657[ebp]
  0021e	52		 push	 edx
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00225	85 c0		 test	 eax, eax
  00227	75 11		 jne	 SHORT $LN206@test_hit
  00229	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0022d	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211648[ebp], xmm0
  00232	8b 5d f0	 mov	 ebx, DWORD PTR $T211648[ebp+4]
  00235	8b 7d ec	 mov	 edi, DWORD PTR $T211648[ebp]
  00238	eb 54		 jmp	 SHORT $LN207@test_hit
$LN206@test_hit:
  0023a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00240	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00246	8b 45 f0	 mov	 eax, DWORD PTR _t$211657[ebp+4]
  00249	8b 4d ec	 mov	 ecx, DWORD PTR _t$211657[ebp]
  0024c	57		 push	 edi
  0024d	56		 push	 esi
  0024e	50		 push	 eax
  0024f	51		 push	 ecx
  00250	e8 00 00 00 00	 call	 __alldvrm
  00255	6a 00		 push	 0
  00257	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0025c	53		 push	 ebx
  0025d	51		 push	 ecx
  0025e	89 45 ec	 mov	 DWORD PTR tv842[ebp], eax
  00261	89 55 f0	 mov	 DWORD PTR tv842[ebp+4], edx
  00264	e8 00 00 00 00	 call	 __allmul
  00269	57		 push	 edi
  0026a	56		 push	 esi
  0026b	52		 push	 edx
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 __alldiv
  00272	6a 00		 push	 0
  00274	8b da		 mov	 ebx, edx
  00276	8b 55 f0	 mov	 edx, DWORD PTR tv842[ebp+4]
  00279	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0027e	8b f8		 mov	 edi, eax
  00280	8b 45 ec	 mov	 eax, DWORD PTR tv842[ebp]
  00283	52		 push	 edx
  00284	50		 push	 eax
  00285	e8 00 00 00 00	 call	 __allmul
  0028a	03 f8		 add	 edi, eax
  0028c	13 da		 adc	 ebx, edx
$LN207@test_hit:
  0028e	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00294	33 db		 xor	 ebx, ebx
  00296	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  0029c	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  002a2	0f 86 89 00 00
	00		 jbe	 $LN141@test_hit
$LL143@test_hit:

; 1130 : 		unsigned key = SEARCH[i] + DELTA;

  002a8	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  002ab	8b 3c 99	 mov	 edi, DWORD PTR [ecx+ebx*4]
  002ae	47		 inc	 edi

; 1131 : 		unsigned hash_key = hash(key);

  002af	8b d7		 mov	 edx, edi
  002b1	c1 e2 06	 shl	 edx, 6
  002b4	8b c7		 mov	 eax, edi
  002b6	2b c2		 sub	 eax, edx
  002b8	8b c8		 mov	 ecx, eax
  002ba	c1 e9 11	 shr	 ecx, 17			; 00000011H
  002bd	33 c1		 xor	 eax, ecx
  002bf	8b d0		 mov	 edx, eax
  002c1	c1 e2 09	 shl	 edx, 9
  002c4	2b c2		 sub	 eax, edx
  002c6	8b c8		 mov	 ecx, eax
  002c8	c1 e1 04	 shl	 ecx, 4
  002cb	33 c1		 xor	 eax, ecx
  002cd	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  002d4	2b c2		 sub	 eax, edx

; 1132 : 		struct hashtable_object* obj;
; 1133 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  002d6	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002dc	8b c8		 mov	 ecx, eax
  002de	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002e1	33 c1		 xor	 eax, ecx
  002e3	8b c8		 mov	 ecx, eax
  002e5	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002e8	33 c8		 xor	 ecx, eax
  002ea	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  002ef	23 d1		 and	 edx, ecx
  002f1	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  002f4	85 c0		 test	 eax, eax
  002f6	74 13		 je	 SHORT $LN212@test_hit
$LL213@test_hit:
  002f8	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  002fb	75 08		 jne	 SHORT $LN211@test_hit
  002fd	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00300	3b 7a 10	 cmp	 edi, DWORD PTR [edx+16]
  00303	74 0a		 je	 SHORT $LN1205@test_hit
$LN211@test_hit:
  00305	8b 00		 mov	 eax, DWORD PTR [eax]
  00307	85 c0		 test	 eax, eax
  00309	75 ed		 jne	 SHORT $LL213@test_hit
$LN212@test_hit:
  0030b	33 f6		 xor	 esi, esi

; 1134 : 		if (!obj)

  0030d	eb 06		 jmp	 SHORT $LN1248@test_hit
$LN1205@test_hit:

; 1132 : 		struct hashtable_object* obj;
; 1133 : 		obj = (struct hashtable_object*)tommy_hashdyn_search(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  0030f	8b f2		 mov	 esi, edx

; 1134 : 		if (!obj)

  00311	85 f6		 test	 esi, esi
  00313	75 05		 jne	 SHORT $LN140@test_hit
$LN1248@test_hit:

; 1135 : 			abort();

  00315	e8 00 00 00 00	 call	 _abort
$LN140@test_hit:

; 1136 : 		if (dereference) {
; 1137 : 			if (obj->value != key)

  0031a	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  0031d	74 05		 je	 SHORT $LN142@test_hit

; 1138 : 				abort();

  0031f	e8 00 00 00 00	 call	 _abort
$LN142@test_hit:

; 1128 : 
; 1129 : 	START(DATA_HASHDYN) {

  00324	43		 inc	 ebx
  00325	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  0032b	0f 82 77 ff ff
	ff		 jb	 $LL143@test_hit
$LN141@test_hit:

; 1139 : 		}
; 1140 : 	} STOP();

  00331	8d 45 ec	 lea	 eax, DWORD PTR _t$211707[ebp]
  00334	50		 push	 eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0033b	85 c0		 test	 eax, eax
  0033d	75 11		 jne	 SHORT $LN225@test_hit
  0033f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00343	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211696[ebp], xmm0
  00348	8b 5d f0	 mov	 ebx, DWORD PTR $T211696[ebp+4]
  0034b	8b 7d ec	 mov	 edi, DWORD PTR $T211696[ebp]
  0034e	eb 54		 jmp	 SHORT $LN226@test_hit
$LN225@test_hit:
  00350	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00356	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0035c	8b 4d f0	 mov	 ecx, DWORD PTR _t$211707[ebp+4]
  0035f	8b 55 ec	 mov	 edx, DWORD PTR _t$211707[ebp]
  00362	57		 push	 edi
  00363	56		 push	 esi
  00364	51		 push	 ecx
  00365	52		 push	 edx
  00366	e8 00 00 00 00	 call	 __alldvrm
  0036b	6a 00		 push	 0
  0036d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00372	53		 push	 ebx
  00373	51		 push	 ecx
  00374	89 45 ec	 mov	 DWORD PTR tv3296[ebp], eax
  00377	89 55 f0	 mov	 DWORD PTR tv3296[ebp+4], edx
  0037a	e8 00 00 00 00	 call	 __allmul
  0037f	57		 push	 edi
  00380	56		 push	 esi
  00381	52		 push	 edx
  00382	50		 push	 eax
  00383	e8 00 00 00 00	 call	 __alldiv
  00388	8b 4d ec	 mov	 ecx, DWORD PTR tv3296[ebp]
  0038b	6a 00		 push	 0
  0038d	8b f8		 mov	 edi, eax
  0038f	8b 45 f0	 mov	 eax, DWORD PTR tv3296[ebp+4]
  00392	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00397	50		 push	 eax
  00398	51		 push	 ecx
  00399	8b da		 mov	 ebx, edx
  0039b	e8 00 00 00 00	 call	 __allmul
  003a0	03 f8		 add	 edi, eax
  003a2	13 da		 adc	 ebx, edx
$LN226@test_hit:
  003a4	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  003aa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  003b0	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  003b6	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  003bc	75 63		 jne	 SHORT $LN223@test_hit
  003be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  003c5	75 24		 jne	 SHORT $LN221@test_hit
  003c7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  003cd	6a 00		 push	 0
  003cf	52		 push	 edx
  003d0	53		 push	 ebx
  003d1	57		 push	 edi
  003d2	e8 00 00 00 00	 call	 __aulldiv
  003d7	50		 push	 eax
  003d8	68 00 00 00 00	 push	 OFFSET $SG-102
  003dd	e8 00 00 00 00	 call	 _printf
  003e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  003e8	83 c4 08	 add	 esp, 8
$LN221@test_hit:
  003eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  003f0	6a 00		 push	 0
  003f2	50		 push	 eax
  003f3	53		 push	 ebx
  003f4	57		 push	 edi
  003f5	e8 00 00 00 00	 call	 __aulldiv
  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00400	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00406	c1 e1 04	 shl	 ecx, 4
  00409	03 ce		 add	 ecx, esi
  0040b	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0040e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00414	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00417	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0041a	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN223@test_hit:

; 1141 : 
; 1142 : 	START(DATA_HASHLIN) {

  00421	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 2 ; the_start_data
  0042b	83 fe 02	 cmp	 esi, 2
  0042e	0f 85 9b 01 00
	00		 jne	 $LN134@test_hit
  00434	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0043b	75 2f		 jne	 SHORT $LN230@test_hit
  0043d	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00443	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00448	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0044f	52		 push	 edx
  00450	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00456	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0045d	51		 push	 ecx
  0045e	50		 push	 eax
  0045f	68 00 00 00 00	 push	 OFFSET $SG-101
  00464	e8 00 00 00 00	 call	 _printf
  00469	83 c4 10	 add	 esp, 16			; 00000010H
$LN230@test_hit:
  0046c	8d 4d ec	 lea	 ecx, DWORD PTR _t$211731[ebp]
  0046f	51		 push	 ecx
  00470	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00476	85 c0		 test	 eax, eax
  00478	75 11		 jne	 SHORT $LN236@test_hit
  0047a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0047e	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211722[ebp], xmm0
  00483	8b 5d f0	 mov	 ebx, DWORD PTR $T211722[ebp+4]
  00486	8b 7d ec	 mov	 edi, DWORD PTR $T211722[ebp]
  00489	eb 54		 jmp	 SHORT $LN237@test_hit
$LN236@test_hit:
  0048b	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00491	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00497	8b 55 f0	 mov	 edx, DWORD PTR _t$211731[ebp+4]
  0049a	8b 45 ec	 mov	 eax, DWORD PTR _t$211731[ebp]
  0049d	57		 push	 edi
  0049e	56		 push	 esi
  0049f	52		 push	 edx
  004a0	50		 push	 eax
  004a1	e8 00 00 00 00	 call	 __alldvrm
  004a6	6a 00		 push	 0
  004a8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004ad	53		 push	 ebx
  004ae	51		 push	 ecx
  004af	89 45 ec	 mov	 DWORD PTR tv984[ebp], eax
  004b2	89 55 f0	 mov	 DWORD PTR tv984[ebp+4], edx
  004b5	e8 00 00 00 00	 call	 __allmul
  004ba	57		 push	 edi
  004bb	56		 push	 esi
  004bc	52		 push	 edx
  004bd	50		 push	 eax
  004be	e8 00 00 00 00	 call	 __alldiv
  004c3	8b 4d f0	 mov	 ecx, DWORD PTR tv984[ebp+4]
  004c6	6a 00		 push	 0
  004c8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004cd	8b da		 mov	 ebx, edx
  004cf	8b 55 ec	 mov	 edx, DWORD PTR tv984[ebp]
  004d2	51		 push	 ecx
  004d3	52		 push	 edx
  004d4	8b f8		 mov	 edi, eax
  004d6	e8 00 00 00 00	 call	 __allmul
  004db	03 f8		 add	 edi, eax
  004dd	13 da		 adc	 ebx, edx
$LN237@test_hit:
  004df	33 c0		 xor	 eax, eax
  004e1	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  004e7	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  004ed	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  004f0	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  004f6	0f 86 d3 00 00
	00		 jbe	 $LN134@test_hit
$LN136@test_hit:

; 1143 : 		unsigned key = SEARCH[i] + DELTA;

  004fc	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  004ff	8b 3c 81	 mov	 edi, DWORD PTR [ecx+eax*4]
  00502	47		 inc	 edi

; 1144 : 		unsigned hash_key = hash(key);

  00503	8b d7		 mov	 edx, edi
  00505	c1 e2 06	 shl	 edx, 6
  00508	8b c7		 mov	 eax, edi
  0050a	2b c2		 sub	 eax, edx
  0050c	8b c8		 mov	 ecx, eax
  0050e	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00511	33 c1		 xor	 eax, ecx
  00513	8b d0		 mov	 edx, eax
  00515	c1 e2 09	 shl	 edx, 9
  00518	2b c2		 sub	 eax, edx
  0051a	8b c8		 mov	 ecx, eax
  0051c	c1 e1 04	 shl	 ecx, 4
  0051f	33 c1		 xor	 eax, ecx
  00521	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00528	2b c2		 sub	 eax, edx
  0052a	8b c8		 mov	 ecx, eax
  0052c	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  0052f	33 c1		 xor	 eax, ecx
  00531	8b d0		 mov	 edx, eax
  00533	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00536	33 d0		 xor	 edx, eax

; 1145 : 		struct hashtable_object* obj;
; 1146 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  00538	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0053f	74 1c		 je	 SHORT $LN248@test_hit
  00541	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00546	23 c2		 and	 eax, edx
  00548	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  0054e	72 0d		 jb	 SHORT $LN248@test_hit
  00550	83 f8 40	 cmp	 eax, 64			; 00000040H
  00553	73 1c		 jae	 SHORT $LN257@test_hit
  00555	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0055b	eb 2a		 jmp	 SHORT $LN1323@test_hit
$LN248@test_hit:
  0055d	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00562	23 c2		 and	 eax, edx
  00564	83 f8 40	 cmp	 eax, 64			; 00000040H
  00567	73 08		 jae	 SHORT $LN257@test_hit
  00569	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0056f	eb 16		 jmp	 SHORT $LN1323@test_hit
$LN257@test_hit:
  00571	0f bd c8	 bsr	 ecx, eax
  00574	be 01 00 00 00	 mov	 esi, 1
  00579	d3 e6		 shl	 esi, cl
  0057b	89 4d f0	 mov	 DWORD PTR _count$211844[ebp], ecx
  0057e	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00585	2b c6		 sub	 eax, esi
$LN1323@test_hit:
  00587	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0058a	8b 00		 mov	 eax, DWORD PTR [eax]
  0058c	85 c0		 test	 eax, eax
  0058e	74 13		 je	 SHORT $LN242@test_hit
$LL243@test_hit:
  00590	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00593	75 08		 jne	 SHORT $LN241@test_hit
  00595	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00598	3b 79 10	 cmp	 edi, DWORD PTR [ecx+16]
  0059b	74 0a		 je	 SHORT $LN1206@test_hit
$LN241@test_hit:
  0059d	8b 00		 mov	 eax, DWORD PTR [eax]
  0059f	85 c0		 test	 eax, eax
  005a1	75 ed		 jne	 SHORT $LL243@test_hit
$LN242@test_hit:
  005a3	33 f6		 xor	 esi, esi

; 1147 : 		if (!obj)

  005a5	eb 06		 jmp	 SHORT $LN1250@test_hit
$LN1206@test_hit:

; 1145 : 		struct hashtable_object* obj;
; 1146 : 		obj = (struct hashtable_object*)tommy_hashlin_search(&hashlin, tommy_hashtable_compare, &key, hash_key);

  005a7	8b f1		 mov	 esi, ecx

; 1147 : 		if (!obj)

  005a9	85 f6		 test	 esi, esi
  005ab	75 05		 jne	 SHORT $LN133@test_hit
$LN1250@test_hit:

; 1148 : 			abort();

  005ad	e8 00 00 00 00	 call	 _abort
$LN133@test_hit:

; 1149 : 		if (dereference) {
; 1150 : 			if (obj->value != key)

  005b2	39 7e 10	 cmp	 DWORD PTR [esi+16], edi
  005b5	74 05		 je	 SHORT $LN135@test_hit

; 1151 : 				abort();

  005b7	e8 00 00 00 00	 call	 _abort
$LN135@test_hit:

; 1141 : 
; 1142 : 	START(DATA_HASHLIN) {

  005bc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  005bf	40		 inc	 eax
  005c0	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  005c3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  005c9	0f 82 2d ff ff
	ff		 jb	 $LN136@test_hit
$LN134@test_hit:

; 1152 : 		}
; 1153 : 	} STOP();

  005cf	8d 55 ec	 lea	 edx, DWORD PTR _t$211868[ebp]
  005d2	52		 push	 edx
  005d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  005d9	85 c0		 test	 eax, eax
  005db	75 11		 jne	 SHORT $LN269@test_hit
  005dd	66 0f 57 c0	 xorpd	 xmm0, xmm0
  005e1	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211857[ebp], xmm0
  005e6	8b 5d f0	 mov	 ebx, DWORD PTR $T211857[ebp+4]
  005e9	8b 7d ec	 mov	 edi, DWORD PTR $T211857[ebp]
  005ec	eb 54		 jmp	 SHORT $LN270@test_hit
$LN269@test_hit:
  005ee	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  005f4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  005fa	8b 45 f0	 mov	 eax, DWORD PTR _t$211868[ebp+4]
  005fd	8b 4d ec	 mov	 ecx, DWORD PTR _t$211868[ebp]
  00600	57		 push	 edi
  00601	56		 push	 esi
  00602	50		 push	 eax
  00603	51		 push	 ecx
  00604	e8 00 00 00 00	 call	 __alldvrm
  00609	6a 00		 push	 0
  0060b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00610	53		 push	 ebx
  00611	51		 push	 ecx
  00612	89 45 ec	 mov	 DWORD PTR tv3470[ebp], eax
  00615	89 55 f0	 mov	 DWORD PTR tv3470[ebp+4], edx
  00618	e8 00 00 00 00	 call	 __allmul
  0061d	57		 push	 edi
  0061e	56		 push	 esi
  0061f	52		 push	 edx
  00620	50		 push	 eax
  00621	e8 00 00 00 00	 call	 __alldiv
  00626	6a 00		 push	 0
  00628	8b da		 mov	 ebx, edx
  0062a	8b 55 f0	 mov	 edx, DWORD PTR tv3470[ebp+4]
  0062d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00632	8b f8		 mov	 edi, eax
  00634	8b 45 ec	 mov	 eax, DWORD PTR tv3470[ebp]
  00637	52		 push	 edx
  00638	50		 push	 eax
  00639	e8 00 00 00 00	 call	 __allmul
  0063e	03 f8		 add	 edi, eax
  00640	13 da		 adc	 ebx, edx
$LN270@test_hit:
  00642	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00648	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  0064e	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00654	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  0065a	75 64		 jne	 SHORT $LN267@test_hit
  0065c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00663	75 24		 jne	 SHORT $LN265@test_hit
  00665	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  0066b	6a 00		 push	 0
  0066d	51		 push	 ecx
  0066e	53		 push	 ebx
  0066f	57		 push	 edi
  00670	e8 00 00 00 00	 call	 __aulldiv
  00675	50		 push	 eax
  00676	68 00 00 00 00	 push	 OFFSET $SG-102
  0067b	e8 00 00 00 00	 call	 _printf
  00680	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00686	83 c4 08	 add	 esp, 8
$LN265@test_hit:
  00689	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0068f	6a 00		 push	 0
  00691	52		 push	 edx
  00692	53		 push	 ebx
  00693	57		 push	 edi
  00694	e8 00 00 00 00	 call	 __aulldiv
  00699	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0069f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  006a5	c1 e1 04	 shl	 ecx, 4
  006a8	03 ce		 add	 ecx, esi
  006aa	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  006ad	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  006b3	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  006b6	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  006b9	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN267@test_hit:

; 1154 : 
; 1155 : 	START(DATA_TRIE) {

  006c0	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 3 ; the_start_data
  006ca	83 fe 03	 cmp	 esi, 3
  006cd	0f 85 1f 01 00
	00		 jne	 $LN127@test_hit
  006d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  006da	75 2f		 jne	 SHORT $LN274@test_hit
  006dc	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  006e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  006e7	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  006ee	52		 push	 edx
  006ef	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  006f5	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  006fc	51		 push	 ecx
  006fd	50		 push	 eax
  006fe	68 00 00 00 00	 push	 OFFSET $SG-101
  00703	e8 00 00 00 00	 call	 _printf
  00708	83 c4 10	 add	 esp, 16			; 00000010H
$LN274@test_hit:
  0070b	8d 4d ec	 lea	 ecx, DWORD PTR _t$211892[ebp]
  0070e	51		 push	 ecx
  0070f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00715	85 c0		 test	 eax, eax
  00717	75 11		 jne	 SHORT $LN280@test_hit
  00719	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0071d	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211883[ebp], xmm0
  00722	8b 5d f0	 mov	 ebx, DWORD PTR $T211883[ebp+4]
  00725	8b 7d ec	 mov	 edi, DWORD PTR $T211883[ebp]
  00728	eb 54		 jmp	 SHORT $LN281@test_hit
$LN280@test_hit:
  0072a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00730	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00736	8b 55 f0	 mov	 edx, DWORD PTR _t$211892[ebp+4]
  00739	8b 45 ec	 mov	 eax, DWORD PTR _t$211892[ebp]
  0073c	57		 push	 edi
  0073d	56		 push	 esi
  0073e	52		 push	 edx
  0073f	50		 push	 eax
  00740	e8 00 00 00 00	 call	 __alldvrm
  00745	6a 00		 push	 0
  00747	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0074c	53		 push	 ebx
  0074d	51		 push	 ecx
  0074e	89 45 ec	 mov	 DWORD PTR tv1107[ebp], eax
  00751	89 55 f0	 mov	 DWORD PTR tv1107[ebp+4], edx
  00754	e8 00 00 00 00	 call	 __allmul
  00759	57		 push	 edi
  0075a	56		 push	 esi
  0075b	52		 push	 edx
  0075c	50		 push	 eax
  0075d	e8 00 00 00 00	 call	 __alldiv
  00762	8b 4d f0	 mov	 ecx, DWORD PTR tv1107[ebp+4]
  00765	6a 00		 push	 0
  00767	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0076c	8b da		 mov	 ebx, edx
  0076e	8b 55 ec	 mov	 edx, DWORD PTR tv1107[ebp]
  00771	51		 push	 ecx
  00772	52		 push	 edx
  00773	8b f8		 mov	 edi, eax
  00775	e8 00 00 00 00	 call	 __allmul
  0077a	03 f8		 add	 edi, eax
  0077c	13 da		 adc	 ebx, edx
$LN281@test_hit:
  0077e	33 f6		 xor	 esi, esi
  00780	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00786	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0078c	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00792	76 5e		 jbe	 SHORT $LN127@test_hit
$LN129@test_hit:

; 1156 : 		unsigned key = SEARCH[i] + DELTA;

  00794	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  00797	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]
  0079a	47		 inc	 edi

; 1157 : 		struct trie_object* obj;
; 1158 : 		obj = (struct trie_object*)tommy_trie_search(&trie, key);

  0079b	8b cf		 mov	 ecx, edi
  0079d	c1 e9 1c	 shr	 ecx, 28			; 0000001cH
  007a0	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]
  007a7	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  007ac	85 c0		 test	 eax, eax
  007ae	74 1f		 je	 SHORT $LN1252@test_hit
$recurse$211920:
  007b0	a8 01		 test	 al, 1
  007b2	74 16		 je	 SHORT $LN288@test_hit
  007b4	8b d7		 mov	 edx, edi
  007b6	d3 ea		 shr	 edx, cl
  007b8	83 e9 04	 sub	 ecx, 4
  007bb	83 e2 0f	 and	 edx, 15			; 0000000fH
  007be	8b 44 90 ff	 mov	 eax, DWORD PTR [eax+edx*4-1]
  007c2	85 c0		 test	 eax, eax
  007c4	75 ea		 jne	 SHORT $recurse$211920
  007c6	33 db		 xor	 ebx, ebx
  007c8	eb 10		 jmp	 SHORT $LN1253@test_hit
$LN288@test_hit:
  007ca	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  007cd	74 04		 je	 SHORT $LN283@test_hit
$LN1252@test_hit:
  007cf	33 db		 xor	 ebx, ebx
  007d1	eb 07		 jmp	 SHORT $LN1253@test_hit
$LN283@test_hit:
  007d3	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1159 : 		if (!obj)

  007d6	85 db		 test	 ebx, ebx
  007d8	75 05		 jne	 SHORT $LN126@test_hit
$LN1253@test_hit:

; 1160 : 			abort();

  007da	e8 00 00 00 00	 call	 _abort
$LN126@test_hit:

; 1161 : 		if (dereference) {
; 1162 : 			if (obj->value != key)

  007df	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  007e2	74 05		 je	 SHORT $LN128@test_hit

; 1163 : 				abort();

  007e4	e8 00 00 00 00	 call	 _abort
$LN128@test_hit:

; 1154 : 
; 1155 : 	START(DATA_TRIE) {

  007e9	46		 inc	 esi
  007ea	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  007f0	72 a2		 jb	 SHORT $LN129@test_hit
$LN127@test_hit:

; 1164 : 		}
; 1165 : 	} STOP();

  007f2	8d 45 ec	 lea	 eax, DWORD PTR _t$211946[ebp]
  007f5	50		 push	 eax
  007f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  007fc	85 c0		 test	 eax, eax
  007fe	75 11		 jne	 SHORT $LN298@test_hit
  00800	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00804	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211935[ebp], xmm0
  00809	8b 5d f0	 mov	 ebx, DWORD PTR $T211935[ebp+4]
  0080c	8b 7d ec	 mov	 edi, DWORD PTR $T211935[ebp]
  0080f	eb 54		 jmp	 SHORT $LN299@test_hit
$LN298@test_hit:
  00811	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00817	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0081d	8b 4d f0	 mov	 ecx, DWORD PTR _t$211946[ebp+4]
  00820	8b 55 ec	 mov	 edx, DWORD PTR _t$211946[ebp]
  00823	57		 push	 edi
  00824	56		 push	 esi
  00825	51		 push	 ecx
  00826	52		 push	 edx
  00827	e8 00 00 00 00	 call	 __alldvrm
  0082c	6a 00		 push	 0
  0082e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00833	53		 push	 ebx
  00834	51		 push	 ecx
  00835	89 45 ec	 mov	 DWORD PTR tv3436[ebp], eax
  00838	89 55 f0	 mov	 DWORD PTR tv3436[ebp+4], edx
  0083b	e8 00 00 00 00	 call	 __allmul
  00840	57		 push	 edi
  00841	56		 push	 esi
  00842	52		 push	 edx
  00843	50		 push	 eax
  00844	e8 00 00 00 00	 call	 __alldiv
  00849	8b 4d ec	 mov	 ecx, DWORD PTR tv3436[ebp]
  0084c	6a 00		 push	 0
  0084e	8b f8		 mov	 edi, eax
  00850	8b 45 f0	 mov	 eax, DWORD PTR tv3436[ebp+4]
  00853	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00858	50		 push	 eax
  00859	51		 push	 ecx
  0085a	8b da		 mov	 ebx, edx
  0085c	e8 00 00 00 00	 call	 __allmul
  00861	03 f8		 add	 edi, eax
  00863	13 da		 adc	 ebx, edx
$LN299@test_hit:
  00865	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  0086b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00871	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00877	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  0087d	75 63		 jne	 SHORT $LN296@test_hit
  0087f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00886	75 24		 jne	 SHORT $LN294@test_hit
  00888	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0088e	6a 00		 push	 0
  00890	52		 push	 edx
  00891	53		 push	 ebx
  00892	57		 push	 edi
  00893	e8 00 00 00 00	 call	 __aulldiv
  00898	50		 push	 eax
  00899	68 00 00 00 00	 push	 OFFSET $SG-102
  0089e	e8 00 00 00 00	 call	 _printf
  008a3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  008a9	83 c4 08	 add	 esp, 8
$LN294@test_hit:
  008ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  008b1	6a 00		 push	 0
  008b3	50		 push	 eax
  008b4	53		 push	 ebx
  008b5	57		 push	 edi
  008b6	e8 00 00 00 00	 call	 __aulldiv
  008bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  008c1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  008c7	c1 e1 04	 shl	 ecx, 4
  008ca	03 ce		 add	 ecx, esi
  008cc	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  008cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  008d5	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  008d8	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  008db	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN296@test_hit:

; 1166 : 
; 1167 : 	START(DATA_TRIE_INPLACE) {

  008e2	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 4 ; the_start_data
  008ec	83 fe 04	 cmp	 esi, 4
  008ef	0f 85 1f 01 00
	00		 jne	 $LN120@test_hit
  008f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  008fc	75 2f		 jne	 SHORT $LN303@test_hit
  008fe	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  00904	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00909	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00910	52		 push	 edx
  00911	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00917	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0091e	51		 push	 ecx
  0091f	50		 push	 eax
  00920	68 00 00 00 00	 push	 OFFSET $SG-101
  00925	e8 00 00 00 00	 call	 _printf
  0092a	83 c4 10	 add	 esp, 16			; 00000010H
$LN303@test_hit:
  0092d	8d 4d ec	 lea	 ecx, DWORD PTR _t$211970[ebp]
  00930	51		 push	 ecx
  00931	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00937	85 c0		 test	 eax, eax
  00939	75 11		 jne	 SHORT $LN309@test_hit
  0093b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0093f	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211961[ebp], xmm0
  00944	8b 5d f0	 mov	 ebx, DWORD PTR $T211961[ebp+4]
  00947	8b 7d ec	 mov	 edi, DWORD PTR $T211961[ebp]
  0094a	eb 54		 jmp	 SHORT $LN310@test_hit
$LN309@test_hit:
  0094c	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00952	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00958	8b 55 f0	 mov	 edx, DWORD PTR _t$211970[ebp+4]
  0095b	8b 45 ec	 mov	 eax, DWORD PTR _t$211970[ebp]
  0095e	57		 push	 edi
  0095f	56		 push	 esi
  00960	52		 push	 edx
  00961	50		 push	 eax
  00962	e8 00 00 00 00	 call	 __alldvrm
  00967	6a 00		 push	 0
  00969	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0096e	53		 push	 ebx
  0096f	51		 push	 ecx
  00970	89 45 ec	 mov	 DWORD PTR tv3447[ebp], eax
  00973	89 55 f0	 mov	 DWORD PTR tv3447[ebp+4], edx
  00976	e8 00 00 00 00	 call	 __allmul
  0097b	57		 push	 edi
  0097c	56		 push	 esi
  0097d	52		 push	 edx
  0097e	50		 push	 eax
  0097f	e8 00 00 00 00	 call	 __alldiv
  00984	8b 4d f0	 mov	 ecx, DWORD PTR tv3447[ebp+4]
  00987	6a 00		 push	 0
  00989	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0098e	8b da		 mov	 ebx, edx
  00990	8b 55 ec	 mov	 edx, DWORD PTR tv3447[ebp]
  00993	51		 push	 ecx
  00994	52		 push	 edx
  00995	8b f8		 mov	 edi, eax
  00997	e8 00 00 00 00	 call	 __allmul
  0099c	03 f8		 add	 edi, eax
  0099e	13 da		 adc	 ebx, edx
$LN310@test_hit:
  009a0	33 f6		 xor	 esi, esi
  009a2	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  009a8	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  009ae	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  009b4	76 5e		 jbe	 SHORT $LN120@test_hit
$LL122@test_hit:

; 1168 : 		unsigned key = SEARCH[i] + DELTA;

  009b6	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  009b9	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]
  009bc	47		 inc	 edi

; 1169 : 		struct trie_inplace_object* obj;
; 1170 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_search(&trie_inplace, key);

  009bd	8b cf		 mov	 ecx, edi
  009bf	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  009c2	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  009c9	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  009ce	85 c0		 test	 eax, eax
  009d0	74 1f		 je	 SHORT $LN1280@test_hit
$LL316@test_hit:
  009d2	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  009d5	74 16		 je	 SHORT $LN315@test_hit
  009d7	8b d7		 mov	 edx, edi
  009d9	d3 ea		 shr	 edx, cl
  009db	83 e9 02	 sub	 ecx, 2
  009de	83 e2 03	 and	 edx, 3
  009e1	8b 44 90 10	 mov	 eax, DWORD PTR [eax+edx*4+16]
  009e5	85 c0		 test	 eax, eax
  009e7	75 e9		 jne	 SHORT $LL316@test_hit
  009e9	33 db		 xor	 ebx, ebx
  009eb	eb 0f		 jmp	 SHORT $LN1255@test_hit
$LN315@test_hit:
  009ed	85 c0		 test	 eax, eax
  009ef	75 04		 jne	 SHORT $LN312@test_hit
$LN1280@test_hit:
  009f1	33 db		 xor	 ebx, ebx
  009f3	eb 07		 jmp	 SHORT $LN1255@test_hit
$LN312@test_hit:
  009f5	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1171 : 		if (!obj)

  009f8	85 db		 test	 ebx, ebx
  009fa	75 05		 jne	 SHORT $LN119@test_hit
$LN1255@test_hit:

; 1172 : 			abort();

  009fc	e8 00 00 00 00	 call	 _abort
$LN119@test_hit:

; 1173 : 		if (dereference) {
; 1174 : 			if (obj->value != key)

  00a01	39 7b 20	 cmp	 DWORD PTR [ebx+32], edi
  00a04	74 05		 je	 SHORT $LN121@test_hit

; 1175 : 				abort();

  00a06	e8 00 00 00 00	 call	 _abort
$LN121@test_hit:

; 1166 : 
; 1167 : 	START(DATA_TRIE_INPLACE) {

  00a0b	46		 inc	 esi
  00a0c	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00a12	72 a2		 jb	 SHORT $LL122@test_hit
$LN120@test_hit:

; 1176 : 		}
; 1177 : 	} STOP();

  00a14	8d 45 f4	 lea	 eax, DWORD PTR _t$212007[ebp]
  00a17	50		 push	 eax
  00a18	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00a1e	85 c0		 test	 eax, eax
  00a20	75 11		 jne	 SHORT $LN323@test_hit
  00a22	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00a26	66 0f 13 45 ec	 movlpd	 QWORD PTR $T211999[ebp], xmm0
  00a2b	8b 5d f0	 mov	 ebx, DWORD PTR $T211999[ebp+4]
  00a2e	8b 7d ec	 mov	 edi, DWORD PTR $T211999[ebp]
  00a31	eb 54		 jmp	 SHORT $LN324@test_hit
$LN323@test_hit:
  00a33	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00a39	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00a3f	8b 4d f8	 mov	 ecx, DWORD PTR _t$212007[ebp+4]
  00a42	8b 55 f4	 mov	 edx, DWORD PTR _t$212007[ebp]
  00a45	57		 push	 edi
  00a46	56		 push	 esi
  00a47	51		 push	 ecx
  00a48	52		 push	 edx
  00a49	e8 00 00 00 00	 call	 __alldvrm
  00a4e	6a 00		 push	 0
  00a50	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a55	53		 push	 ebx
  00a56	51		 push	 ecx
  00a57	89 45 ec	 mov	 DWORD PTR tv3408[ebp], eax
  00a5a	89 55 f0	 mov	 DWORD PTR tv3408[ebp+4], edx
  00a5d	e8 00 00 00 00	 call	 __allmul
  00a62	57		 push	 edi
  00a63	56		 push	 esi
  00a64	52		 push	 edx
  00a65	50		 push	 eax
  00a66	e8 00 00 00 00	 call	 __alldiv
  00a6b	8b 4d ec	 mov	 ecx, DWORD PTR tv3408[ebp]
  00a6e	6a 00		 push	 0
  00a70	8b f8		 mov	 edi, eax
  00a72	8b 45 f0	 mov	 eax, DWORD PTR tv3408[ebp+4]
  00a75	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a7a	50		 push	 eax
  00a7b	51		 push	 ecx
  00a7c	8b da		 mov	 ebx, edx
  00a7e	e8 00 00 00 00	 call	 __allmul
  00a83	03 f8		 add	 edi, eax
  00a85	13 da		 adc	 ebx, edx
$LN324@test_hit:
  00a87	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00a8d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00a93	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00a99	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00a9f	75 63		 jne	 SHORT $LN321@test_hit
  00aa1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00aa8	75 24		 jne	 SHORT $LN319@test_hit
  00aaa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00ab0	6a 00		 push	 0
  00ab2	52		 push	 edx
  00ab3	53		 push	 ebx
  00ab4	57		 push	 edi
  00ab5	e8 00 00 00 00	 call	 __aulldiv
  00aba	50		 push	 eax
  00abb	68 00 00 00 00	 push	 OFFSET $SG-102
  00ac0	e8 00 00 00 00	 call	 _printf
  00ac5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00acb	83 c4 08	 add	 esp, 8
$LN319@test_hit:
  00ace	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00ad3	6a 00		 push	 0
  00ad5	50		 push	 eax
  00ad6	53		 push	 ebx
  00ad7	57		 push	 edi
  00ad8	e8 00 00 00 00	 call	 __aulldiv
  00add	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00ae3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00ae9	c1 e1 04	 shl	 ecx, 4
  00aec	03 ce		 add	 ecx, esi
  00aee	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00af1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00af7	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00afa	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00afd	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN321@test_hit:

; 1178 : 
; 1179 : 	START(DATA_KHASH) {

  00b04	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 7 ; the_start_data
  00b0e	83 fe 07	 cmp	 esi, 7
  00b11	0f 85 3c 01 00
	00		 jne	 $LN113@test_hit
  00b17	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00b1e	75 2f		 jne	 SHORT $LN328@test_hit
  00b20	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00b26	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00b2b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00b32	52		 push	 edx
  00b33	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00b39	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00b40	51		 push	 ecx
  00b41	50		 push	 eax
  00b42	68 00 00 00 00	 push	 OFFSET $SG-101
  00b47	e8 00 00 00 00	 call	 _printf
  00b4c	83 c4 10	 add	 esp, 16			; 00000010H
$LN328@test_hit:
  00b4f	8d 4d e4	 lea	 ecx, DWORD PTR _t$212032[ebp]
  00b52	51		 push	 ecx
  00b53	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00b59	85 c0		 test	 eax, eax
  00b5b	75 11		 jne	 SHORT $LN334@test_hit
  00b5d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00b61	66 0f 13 45 ec	 movlpd	 QWORD PTR $T212025[ebp], xmm0
  00b66	8b 5d f0	 mov	 ebx, DWORD PTR $T212025[ebp+4]
  00b69	8b 7d ec	 mov	 edi, DWORD PTR $T212025[ebp]
  00b6c	eb 54		 jmp	 SHORT $LN335@test_hit
$LN334@test_hit:
  00b6e	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00b74	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00b7a	8b 55 e8	 mov	 edx, DWORD PTR _t$212032[ebp+4]
  00b7d	8b 45 e4	 mov	 eax, DWORD PTR _t$212032[ebp]
  00b80	57		 push	 edi
  00b81	56		 push	 esi
  00b82	52		 push	 edx
  00b83	50		 push	 eax
  00b84	e8 00 00 00 00	 call	 __alldvrm
  00b89	6a 00		 push	 0
  00b8b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b90	53		 push	 ebx
  00b91	51		 push	 ecx
  00b92	89 45 ec	 mov	 DWORD PTR tv1269[ebp], eax
  00b95	89 55 f0	 mov	 DWORD PTR tv1269[ebp+4], edx
  00b98	e8 00 00 00 00	 call	 __allmul
  00b9d	57		 push	 edi
  00b9e	56		 push	 esi
  00b9f	52		 push	 edx
  00ba0	50		 push	 eax
  00ba1	e8 00 00 00 00	 call	 __alldiv
  00ba6	8b 4d f0	 mov	 ecx, DWORD PTR tv1269[ebp+4]
  00ba9	6a 00		 push	 0
  00bab	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00bb0	8b da		 mov	 ebx, edx
  00bb2	8b 55 ec	 mov	 edx, DWORD PTR tv1269[ebp]
  00bb5	51		 push	 ecx
  00bb6	52		 push	 edx
  00bb7	8b f8		 mov	 edi, eax
  00bb9	e8 00 00 00 00	 call	 __allmul
  00bbe	03 f8		 add	 edi, eax
  00bc0	13 da		 adc	 ebx, edx
$LN335@test_hit:
  00bc2	33 f6		 xor	 esi, esi
  00bc4	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00bca	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00bd0	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  00bd6	0f 86 77 00 00
	00		 jbe	 $LN113@test_hit
  00bdc	8d 64 24 00	 npad	 4
$LL115@test_hit:

; 1180 : 		unsigned key = SEARCH[i] + DELTA;

  00be0	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  00be3	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]
  00be6	47		 inc	 edi

; 1181 : 		unsigned hash_key = hash(key);

  00be7	8b cf		 mov	 ecx, edi
  00be9	c1 e1 06	 shl	 ecx, 6
  00bec	8b c7		 mov	 eax, edi
  00bee	2b c1		 sub	 eax, ecx
  00bf0	8b d0		 mov	 edx, eax
  00bf2	c1 ea 11	 shr	 edx, 17			; 00000011H
  00bf5	33 c2		 xor	 eax, edx
  00bf7	8b c8		 mov	 ecx, eax
  00bf9	c1 e1 09	 shl	 ecx, 9
  00bfc	2b c1		 sub	 eax, ecx
  00bfe	8b d0		 mov	 edx, eax
  00c00	c1 e2 04	 shl	 edx, 4
  00c03	33 c2		 xor	 eax, edx
  00c05	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00c0c	2b c1		 sub	 eax, ecx
  00c0e	8b d0		 mov	 edx, eax
  00c10	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00c13	33 c2		 xor	 eax, edx
  00c15	8b c8		 mov	 ecx, eax
  00c17	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00c1a	33 c8		 xor	 ecx, eax

; 1182 : 		khiter_t k;
; 1183 : 		k = kh_get(word, khash, hash_key);

  00c1c	51		 push	 ecx
  00c1d	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word

; 1184 : 		if (k == kh_end(khash))

  00c22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00c28	8b d8		 mov	 ebx, eax
  00c2a	83 c4 04	 add	 esp, 4
  00c2d	3b 1a		 cmp	 ebx, DWORD PTR [edx]
  00c2f	75 05		 jne	 SHORT $LN112@test_hit

; 1185 : 			abort();

  00c31	e8 00 00 00 00	 call	 _abort
$LN112@test_hit:

; 1186 : 		if (dereference) {
; 1187 : 			struct khash_object* obj = kh_value(khash, k);

  00c36	a1 00 00 00 00	 mov	 eax, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00c3b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00c3e	8b 14 99	 mov	 edx, DWORD PTR [ecx+ebx*4]

; 1188 : 			if (obj->value != key)

  00c41	39 3a		 cmp	 DWORD PTR [edx], edi
  00c43	74 05		 je	 SHORT $LN114@test_hit

; 1189 : 				abort();

  00c45	e8 00 00 00 00	 call	 _abort
$LN114@test_hit:

; 1178 : 
; 1179 : 	START(DATA_KHASH) {

  00c4a	46		 inc	 esi
  00c4b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  00c51	72 8d		 jb	 SHORT $LL115@test_hit
$LN113@test_hit:

; 1190 : 		}
; 1191 : 	} STOP();

  00c53	8d 45 dc	 lea	 eax, DWORD PTR _t$212057[ebp]
  00c56	50		 push	 eax
  00c57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00c5d	85 c0		 test	 eax, eax
  00c5f	75 11		 jne	 SHORT $LN343@test_hit
  00c61	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00c65	66 0f 13 45 e4	 movlpd	 QWORD PTR $T212049[ebp], xmm0
  00c6a	8b 5d e8	 mov	 ebx, DWORD PTR $T212049[ebp+4]
  00c6d	8b 7d e4	 mov	 edi, DWORD PTR $T212049[ebp]
  00c70	eb 54		 jmp	 SHORT $LN344@test_hit
$LN343@test_hit:
  00c72	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00c78	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00c7e	8b 4d e0	 mov	 ecx, DWORD PTR _t$212057[ebp+4]
  00c81	8b 55 dc	 mov	 edx, DWORD PTR _t$212057[ebp]
  00c84	57		 push	 edi
  00c85	56		 push	 esi
  00c86	51		 push	 ecx
  00c87	52		 push	 edx
  00c88	e8 00 00 00 00	 call	 __alldvrm
  00c8d	6a 00		 push	 0
  00c8f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c94	53		 push	 ebx
  00c95	51		 push	 ecx
  00c96	89 45 ec	 mov	 DWORD PTR tv3383[ebp], eax
  00c99	89 55 f0	 mov	 DWORD PTR tv3383[ebp+4], edx
  00c9c	e8 00 00 00 00	 call	 __allmul
  00ca1	57		 push	 edi
  00ca2	56		 push	 esi
  00ca3	52		 push	 edx
  00ca4	50		 push	 eax
  00ca5	e8 00 00 00 00	 call	 __alldiv
  00caa	8b 4d ec	 mov	 ecx, DWORD PTR tv3383[ebp]
  00cad	6a 00		 push	 0
  00caf	8b f8		 mov	 edi, eax
  00cb1	8b 45 f0	 mov	 eax, DWORD PTR tv3383[ebp+4]
  00cb4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00cb9	50		 push	 eax
  00cba	51		 push	 ecx
  00cbb	8b da		 mov	 ebx, edx
  00cbd	e8 00 00 00 00	 call	 __allmul
  00cc2	03 f8		 add	 edi, eax
  00cc4	13 da		 adc	 ebx, edx
$LN344@test_hit:
  00cc6	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00ccc	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00cd2	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00cd8	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00cde	75 63		 jne	 SHORT $LN341@test_hit
  00ce0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00ce7	75 24		 jne	 SHORT $LN339@test_hit
  00ce9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00cef	6a 00		 push	 0
  00cf1	52		 push	 edx
  00cf2	53		 push	 ebx
  00cf3	57		 push	 edi
  00cf4	e8 00 00 00 00	 call	 __aulldiv
  00cf9	50		 push	 eax
  00cfa	68 00 00 00 00	 push	 OFFSET $SG-102
  00cff	e8 00 00 00 00	 call	 _printf
  00d04	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00d0a	83 c4 08	 add	 esp, 8
$LN339@test_hit:
  00d0d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00d12	6a 00		 push	 0
  00d14	50		 push	 eax
  00d15	53		 push	 ebx
  00d16	57		 push	 edi
  00d17	e8 00 00 00 00	 call	 __aulldiv
  00d1c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00d22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00d28	c1 e1 04	 shl	 ecx, 4
  00d2b	03 ce		 add	 ecx, esi
  00d2d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d30	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d36	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00d39	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d3c	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN341@test_hit:

; 1192 : 
; 1193 : #ifdef USE_CGOOGLEDENSEHASH
; 1194 : 	START(DATA_CGOOGLE) {
; 1195 : 		unsigned key = SEARCH[i] + DELTA;
; 1196 : 		HTItem* ptr;
; 1197 : 		ptr = HashFind(cgoogledensehash, key);
; 1198 : 		if (!ptr)
; 1199 : 			abort();
; 1200 : 		if (dereference) {
; 1201 : 			struct google_object* obj = (void*)ptr->data;
; 1202 : 			if (obj->value != key)
; 1203 : 				abort();
; 1204 : 		}
; 1205 : 	} STOP();
; 1206 : #endif
; 1207 : 
; 1208 : #ifdef USE_GOOGLEDENSEHASH
; 1209 : 	START(DATA_GOOGLEDENSEHASH) {

  00d43	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 11 ; the_start_data, 0000000bH
  00d4d	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00d50	0f 85 ab 01 00
	00		 jne	 $LN106@test_hit
  00d56	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d5d	75 2f		 jne	 SHORT $LN348@test_hit
  00d5f	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00d65	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00d6a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00d71	52		 push	 edx
  00d72	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00d78	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00d7f	51		 push	 ecx
  00d80	50		 push	 eax
  00d81	68 00 00 00 00	 push	 OFFSET $SG-101
  00d86	e8 00 00 00 00	 call	 _printf
  00d8b	83 c4 10	 add	 esp, 16			; 00000010H
$LN348@test_hit:
  00d8e	8d 4d d4	 lea	 ecx, DWORD PTR _t$212082[ebp]
  00d91	51		 push	 ecx
  00d92	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00d98	85 c0		 test	 eax, eax
  00d9a	75 11		 jne	 SHORT $LN354@test_hit
  00d9c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00da0	66 0f 13 45 e4	 movlpd	 QWORD PTR $T212075[ebp], xmm0
  00da5	8b 5d e8	 mov	 ebx, DWORD PTR $T212075[ebp+4]
  00da8	8b 7d e4	 mov	 edi, DWORD PTR $T212075[ebp]
  00dab	eb 54		 jmp	 SHORT $LN355@test_hit
$LN354@test_hit:
  00dad	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00db3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00db9	8b 55 d8	 mov	 edx, DWORD PTR _t$212082[ebp+4]
  00dbc	8b 45 d4	 mov	 eax, DWORD PTR _t$212082[ebp]
  00dbf	57		 push	 edi
  00dc0	56		 push	 esi
  00dc1	52		 push	 edx
  00dc2	50		 push	 eax
  00dc3	e8 00 00 00 00	 call	 __alldvrm
  00dc8	6a 00		 push	 0
  00dca	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00dcf	53		 push	 ebx
  00dd0	51		 push	 ecx
  00dd1	89 45 ec	 mov	 DWORD PTR tv1408[ebp], eax
  00dd4	89 55 f0	 mov	 DWORD PTR tv1408[ebp+4], edx
  00dd7	e8 00 00 00 00	 call	 __allmul
  00ddc	57		 push	 edi
  00ddd	56		 push	 esi
  00dde	52		 push	 edx
  00ddf	50		 push	 eax
  00de0	e8 00 00 00 00	 call	 __alldiv
  00de5	8b 4d f0	 mov	 ecx, DWORD PTR tv1408[ebp+4]
  00de8	6a 00		 push	 0
  00dea	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00def	8b da		 mov	 ebx, edx
  00df1	8b 55 ec	 mov	 edx, DWORD PTR tv1408[ebp]
  00df4	51		 push	 ecx
  00df5	52		 push	 edx
  00df6	8b f8		 mov	 edi, eax
  00df8	e8 00 00 00 00	 call	 __allmul
  00dfd	03 f8		 add	 edi, eax
  00dff	13 da		 adc	 ebx, edx
$LN355@test_hit:
  00e01	33 c0		 xor	 eax, eax
  00e03	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00e09	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00e0f	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00e12	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  00e18	0f 86 e3 00 00
	00		 jbe	 $LN106@test_hit
  00e1e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LL108@test_hit:

; 1210 : 		unsigned key = SEARCH[i] + DELTA;

  00e24	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  00e27	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1211 : 		googledensehash_t::const_iterator ptr = googledensehash->find(key);

  00e2a	8b 57 24	 mov	 edx, DWORD PTR [edi+36]
  00e2d	40		 inc	 eax
  00e2e	2b 57 20	 sub	 edx, DWORD PTR [edi+32]
  00e31	89 45 f0	 mov	 DWORD PTR _key$150842[ebp], eax
  00e34	75 2c		 jne	 SHORT $LN361@test_hit
  00e36	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00e39	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00e3c	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00e3f	8b d9		 mov	 ebx, ecx
  00e41	3b d9		 cmp	 ebx, ecx
  00e43	74 60		 je	 SHORT $LN475@test_hit
  00e45	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL373@test_hit:
  00e48	8b 03		 mov	 eax, DWORD PTR [ebx]
  00e4a	3b f0		 cmp	 esi, eax
  00e4c	74 0b		 je	 SHORT $LN371@test_hit
  00e4e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00e52	76 51		 jbe	 SHORT $LN475@test_hit
  00e54	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00e57	75 4c		 jne	 SHORT $LN475@test_hit
$LN371@test_hit:
  00e59	83 c3 08	 add	 ebx, 8
  00e5c	3b d9		 cmp	 ebx, ecx
  00e5e	75 e8		 jne	 SHORT $LL373@test_hit
  00e60	eb 43		 jmp	 SHORT $LN475@test_hit
$LN361@test_hit:
  00e62	8d 4d cc	 lea	 ecx, DWORD PTR _pos$213185[ebp]
  00e65	51		 push	 ecx
  00e66	8d 45 f0	 lea	 eax, DWORD PTR _key$150842[ebp]
  00e69	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00e6e	8b 45 cc	 mov	 eax, DWORD PTR _pos$213185[ebp]
  00e71	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00e74	83 f8 ff	 cmp	 eax, -1
  00e77	75 29		 jne	 SHORT $LN360@test_hit
  00e79	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  00e7c	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00e7f	8b d9		 mov	 ebx, ecx
  00e81	3b d9		 cmp	 ebx, ecx
  00e83	74 20		 je	 SHORT $LN475@test_hit
  00e85	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
$LL425@test_hit:
  00e88	8b 03		 mov	 eax, DWORD PTR [ebx]
  00e8a	3b f0		 cmp	 esi, eax
  00e8c	74 0b		 je	 SHORT $LN423@test_hit
  00e8e	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00e92	76 11		 jbe	 SHORT $LN475@test_hit
  00e94	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  00e97	75 0c		 jne	 SHORT $LN475@test_hit
$LN423@test_hit:
  00e99	83 c3 08	 add	 ebx, 8
  00e9c	3b d9		 cmp	 ebx, ecx
  00e9e	75 e8		 jne	 SHORT $LL425@test_hit
  00ea0	eb 03		 jmp	 SHORT $LN475@test_hit
$LN360@test_hit:
  00ea2	8d 1c c2	 lea	 ebx, DWORD PTR [edx+eax*8]
$LN475@test_hit:

; 1212 : 		if (ptr == googledensehash->end())

  00ea5	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00ea8	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  00eab	8b c2		 mov	 eax, edx
  00ead	3b c2		 cmp	 eax, edx
  00eaf	74 19		 je	 SHORT $LN568@test_hit
$LL531@test_hit:
  00eb1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00eb3	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  00eb6	74 0b		 je	 SHORT $LN529@test_hit
  00eb8	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  00ebc	76 0c		 jbe	 SHORT $LN568@test_hit
  00ebe	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  00ec1	75 07		 jne	 SHORT $LN568@test_hit
$LN529@test_hit:
  00ec3	83 c0 08	 add	 eax, 8
  00ec6	3b c2		 cmp	 eax, edx
  00ec8	75 e7		 jne	 SHORT $LL531@test_hit
$LN568@test_hit:
  00eca	3b d8		 cmp	 ebx, eax
  00ecc	75 0b		 jne	 SHORT $LN105@test_hit

; 1213 : 			abort();

  00ece	e8 00 00 00 00	 call	 _abort
  00ed3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN105@test_hit:

; 1214 : 		if (dereference) {
; 1215 : 			struct google_object* obj = ptr->second;

  00ed9	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]

; 1216 : 			if (obj->value != key)

  00edc	8b 45 f0	 mov	 eax, DWORD PTR _key$150842[ebp]
  00edf	39 02		 cmp	 DWORD PTR [edx], eax
  00ee1	74 0b		 je	 SHORT $LN107@test_hit

; 1217 : 				abort();

  00ee3	e8 00 00 00 00	 call	 _abort
  00ee8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN107@test_hit:

; 1192 : 
; 1193 : #ifdef USE_CGOOGLEDENSEHASH
; 1194 : 	START(DATA_CGOOGLE) {
; 1195 : 		unsigned key = SEARCH[i] + DELTA;
; 1196 : 		HTItem* ptr;
; 1197 : 		ptr = HashFind(cgoogledensehash, key);
; 1198 : 		if (!ptr)
; 1199 : 			abort();
; 1200 : 		if (dereference) {
; 1201 : 			struct google_object* obj = (void*)ptr->data;
; 1202 : 			if (obj->value != key)
; 1203 : 				abort();
; 1204 : 		}
; 1205 : 	} STOP();
; 1206 : #endif
; 1207 : 
; 1208 : #ifdef USE_GOOGLEDENSEHASH
; 1209 : 	START(DATA_GOOGLEDENSEHASH) {

  00eee	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00ef1	40		 inc	 eax
  00ef2	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00ef5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00efb	0f 82 23 ff ff
	ff		 jb	 $LL108@test_hit
$LN106@test_hit:

; 1218 : 		}
; 1219 : 	} STOP();

  00f01	8d 4d dc	 lea	 ecx, DWORD PTR _t$213725[ebp]
  00f04	51		 push	 ecx
  00f05	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00f0b	85 c0		 test	 eax, eax
  00f0d	75 11		 jne	 SHORT $LN588@test_hit
  00f0f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00f13	66 0f 13 45 d4	 movlpd	 QWORD PTR $T213714[ebp], xmm0
  00f18	8b 5d d8	 mov	 ebx, DWORD PTR $T213714[ebp+4]
  00f1b	8b 7d d4	 mov	 edi, DWORD PTR $T213714[ebp]
  00f1e	eb 54		 jmp	 SHORT $LN589@test_hit
$LN588@test_hit:
  00f20	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00f26	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00f2c	8b 55 e0	 mov	 edx, DWORD PTR _t$213725[ebp+4]
  00f2f	8b 45 dc	 mov	 eax, DWORD PTR _t$213725[ebp]
  00f32	57		 push	 edi
  00f33	56		 push	 esi
  00f34	52		 push	 edx
  00f35	50		 push	 eax
  00f36	e8 00 00 00 00	 call	 __alldvrm
  00f3b	6a 00		 push	 0
  00f3d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f42	53		 push	 ebx
  00f43	51		 push	 ecx
  00f44	89 45 ec	 mov	 DWORD PTR tv3969[ebp], eax
  00f47	89 55 f0	 mov	 DWORD PTR tv3969[ebp+4], edx
  00f4a	e8 00 00 00 00	 call	 __allmul
  00f4f	57		 push	 edi
  00f50	56		 push	 esi
  00f51	52		 push	 edx
  00f52	50		 push	 eax
  00f53	e8 00 00 00 00	 call	 __alldiv
  00f58	8b 4d f0	 mov	 ecx, DWORD PTR tv3969[ebp+4]
  00f5b	6a 00		 push	 0
  00f5d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f62	8b da		 mov	 ebx, edx
  00f64	8b 55 ec	 mov	 edx, DWORD PTR tv3969[ebp]
  00f67	51		 push	 ecx
  00f68	52		 push	 edx
  00f69	8b f8		 mov	 edi, eax
  00f6b	e8 00 00 00 00	 call	 __allmul
  00f70	03 f8		 add	 edi, eax
  00f72	13 da		 adc	 ebx, edx
$LN589@test_hit:
  00f74	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00f7a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00f80	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00f86	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00f8c	75 63		 jne	 SHORT $LN586@test_hit
  00f8e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00f95	75 23		 jne	 SHORT $LN584@test_hit
  00f97	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00f9c	6a 00		 push	 0
  00f9e	50		 push	 eax
  00f9f	53		 push	 ebx
  00fa0	57		 push	 edi
  00fa1	e8 00 00 00 00	 call	 __aulldiv
  00fa6	50		 push	 eax
  00fa7	68 00 00 00 00	 push	 OFFSET $SG-102
  00fac	e8 00 00 00 00	 call	 _printf
  00fb1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00fb7	83 c4 08	 add	 esp, 8
$LN584@test_hit:
  00fba	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00fc0	6a 00		 push	 0
  00fc2	51		 push	 ecx
  00fc3	53		 push	 ebx
  00fc4	57		 push	 edi
  00fc5	e8 00 00 00 00	 call	 __aulldiv
  00fca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  00fd0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00fd6	c1 e2 04	 shl	 edx, 4
  00fd9	03 d6		 add	 edx, esi
  00fdb	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00fde	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00fe1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00fe7	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00fea	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN586@test_hit:

; 1220 : #endif
; 1221 : 
; 1222 : #ifdef USE_GOOGLEBTREE
; 1223 : 	START(DATA_GOOGLEBTREE) {

  00ff1	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 12 ; the_start_data, 0000000cH
  00ffb	83 fe 0c	 cmp	 esi, 12			; 0000000cH
  00ffe	0f 85 11 02 00
	00		 jne	 $LN99@test_hit
  01004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0100b	75 2e		 jne	 SHORT $LN593@test_hit
  0100d	a1 30 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  01012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01018	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0101f	50		 push	 eax
  01020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01025	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0102c	52		 push	 edx
  0102d	51		 push	 ecx
  0102e	68 00 00 00 00	 push	 OFFSET $SG-101
  01033	e8 00 00 00 00	 call	 _printf
  01038	83 c4 10	 add	 esp, 16			; 00000010H
$LN593@test_hit:
  0103b	8d 55 e4	 lea	 edx, DWORD PTR _t$213749[ebp]
  0103e	52		 push	 edx
  0103f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01045	85 c0		 test	 eax, eax
  01047	75 11		 jne	 SHORT $LN599@test_hit
  01049	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0104d	66 0f 13 45 d4	 movlpd	 QWORD PTR $T213740[ebp], xmm0
  01052	8b 5d d8	 mov	 ebx, DWORD PTR $T213740[ebp+4]
  01055	8b 7d d4	 mov	 edi, DWORD PTR $T213740[ebp]
  01058	eb 54		 jmp	 SHORT $LN600@test_hit
$LN599@test_hit:
  0105a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01060	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01066	8b 45 e8	 mov	 eax, DWORD PTR _t$213749[ebp+4]
  01069	8b 4d e4	 mov	 ecx, DWORD PTR _t$213749[ebp]
  0106c	57		 push	 edi
  0106d	56		 push	 esi
  0106e	50		 push	 eax
  0106f	51		 push	 ecx
  01070	e8 00 00 00 00	 call	 __alldvrm
  01075	6a 00		 push	 0
  01077	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0107c	53		 push	 ebx
  0107d	51		 push	 ecx
  0107e	89 45 ec	 mov	 DWORD PTR tv3954[ebp], eax
  01081	89 55 f0	 mov	 DWORD PTR tv3954[ebp+4], edx
  01084	e8 00 00 00 00	 call	 __allmul
  01089	57		 push	 edi
  0108a	56		 push	 esi
  0108b	52		 push	 edx
  0108c	50		 push	 eax
  0108d	e8 00 00 00 00	 call	 __alldiv
  01092	6a 00		 push	 0
  01094	8b da		 mov	 ebx, edx
  01096	8b 55 f0	 mov	 edx, DWORD PTR tv3954[ebp+4]
  01099	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0109e	8b f8		 mov	 edi, eax
  010a0	8b 45 ec	 mov	 eax, DWORD PTR tv3954[ebp]
  010a3	52		 push	 edx
  010a4	50		 push	 eax
  010a5	e8 00 00 00 00	 call	 __allmul
  010aa	03 f8		 add	 edi, eax
  010ac	13 da		 adc	 ebx, edx
$LN600@test_hit:
  010ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  010b5	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  010bb	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  010c1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  010c8	0f 86 47 01 00
	00		 jbe	 $LN99@test_hit
$LN101@test_hit:

; 1224 : 		unsigned key = SEARCH[i] + DELTA;

  010ce	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  010d1	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]

; 1225 : 		googlebtree_t::const_iterator ptr = googlebtree->find(key);

  010d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  010d9	8b 34 91	 mov	 esi, DWORD PTR [ecx+edx*4]
  010dc	8b 18		 mov	 ebx, DWORD PTR [eax]
  010de	46		 inc	 esi
  010df	89 75 f0	 mov	 DWORD PTR _key$151025[ebp], esi
  010e2	85 db		 test	 ebx, ebx
  010e4	0f 84 70 00 00
	00		 je	 $LN731@test_hit
  010ea	8b cb		 mov	 ecx, ebx
  010ec	8d 64 24 00	 npad	 4
$LL628@test_hit:
  010f0	0f b6 79 03	 movzx	 edi, BYTE PTR [ecx+3]
  010f4	33 c0		 xor	 eax, eax
  010f6	85 ff		 test	 edi, edi
  010f8	7e 12		 jle	 SHORT $LN1208@test_hit
  010fa	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
  010fd	8d 49 00	 npad	 3
$LL643@test_hit:
  01100	39 32		 cmp	 DWORD PTR [edx], esi
  01102	73 08		 jae	 SHORT $LN1208@test_hit
  01104	40		 inc	 eax
  01105	83 c2 08	 add	 edx, 8
  01108	3b c7		 cmp	 eax, edi
  0110a	7c f4		 jl	 SHORT $LL643@test_hit
$LN1208@test_hit:
  0110c	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0110f	75 0f		 jne	 SHORT $LL1209@test_hit
  01111	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  01118	eb d6		 jmp	 SHORT $LL628@test_hit
  0111a	8d 9b 00 00 00
	00		 npad	 6
$LL1209@test_hit:
  01120	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  01124	3b c2		 cmp	 eax, edx
  01126	75 1d		 jne	 SHORT $LN685@test_hit
  01128	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  0112c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0112f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  01132	74 ec		 je	 SHORT $LL1209@test_hit
$LN721@test_hit:
  01134	85 db		 test	 ebx, ebx
  01136	74 22		 je	 SHORT $LN731@test_hit
  01138	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0113b	75 1d		 jne	 SHORT $LN731@test_hit
  0113d	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  01143	eb 17		 jmp	 SHORT $LN743@test_hit
$LN685@test_hit:
  01145	85 c9		 test	 ecx, ecx
  01147	74 eb		 je	 SHORT $LN721@test_hit
  01149	3b 74 c1 08	 cmp	 esi, DWORD PTR [ecx+eax*8+8]
  0114d	72 e5		 jb	 SHORT $LN721@test_hit
  0114f	89 45 d8	 mov	 DWORD PTR $T214952[ebp+4], eax
  01152	89 4d d4	 mov	 DWORD PTR $T214952[ebp], ecx
  01155	8d 45 d4	 lea	 eax, DWORD PTR $T214952[ebp]
  01158	eb 41		 jmp	 SHORT $LN722@test_hit
$LN731@test_hit:
  0115a	8b c3		 mov	 eax, ebx
$LN743@test_hit:
  0115c	85 c0		 test	 eax, eax
  0115e	74 1d		 je	 SHORT $LN727@test_hit
  01160	85 db		 test	 ebx, ebx
  01162	74 11		 je	 SHORT $LN747@test_hit
  01164	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  01167	75 0c		 jne	 SHORT $LN747@test_hit
  01169	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  0116f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  01173	eb 0a		 jmp	 SHORT $LN728@test_hit
$LN747@test_hit:
  01175	8b c3		 mov	 eax, ebx
  01177	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0117b	eb 02		 jmp	 SHORT $LN728@test_hit
$LN727@test_hit:
  0117d	33 c9		 xor	 ecx, ecx
$LN728@test_hit:
  0117f	85 db		 test	 ebx, ebx
  01181	74 0d		 je	 SHORT $LN765@test_hit
  01183	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  01186	75 08		 jne	 SHORT $LN765@test_hit
  01188	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  0118e	eb 02		 jmp	 SHORT $LN777@test_hit
$LN765@test_hit:
  01190	8b c3		 mov	 eax, ebx
$LN777@test_hit:
  01192	89 45 cc	 mov	 DWORD PTR $T214953[ebp], eax
  01195	89 4d d0	 mov	 DWORD PTR $T214953[ebp+4], ecx
  01198	8d 45 cc	 lea	 eax, DWORD PTR $T214953[ebp]
$LN722@test_hit:
  0119b	8b 38		 mov	 edi, DWORD PTR [eax]
  0119d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 1226 : 		if (ptr == googlebtree->end())

  011a0	85 db		 test	 ebx, ebx
  011a2	74 0d		 je	 SHORT $LN793@test_hit
  011a4	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011a7	75 08		 jne	 SHORT $LN793@test_hit
  011a9	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  011af	eb 02		 jmp	 SHORT $LN805@test_hit
$LN793@test_hit:
  011b1	8b c3		 mov	 eax, ebx
$LN805@test_hit:
  011b3	85 c0		 test	 eax, eax
  011b5	74 1d		 je	 SHORT $LN789@test_hit
  011b7	85 db		 test	 ebx, ebx
  011b9	74 11		 je	 SHORT $LN809@test_hit
  011bb	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011be	75 0c		 jne	 SHORT $LN809@test_hit
  011c0	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  011c6	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  011ca	eb 0a		 jmp	 SHORT $LN790@test_hit
$LN809@test_hit:
  011cc	8b c3		 mov	 eax, ebx
  011ce	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  011d2	eb 02		 jmp	 SHORT $LN790@test_hit
$LN789@test_hit:
  011d4	33 c0		 xor	 eax, eax
$LN790@test_hit:
  011d6	85 db		 test	 ebx, ebx
  011d8	74 0b		 je	 SHORT $LN827@test_hit
  011da	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011dd	75 06		 jne	 SHORT $LN827@test_hit
  011df	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN827@test_hit:
  011e5	3b fb		 cmp	 edi, ebx
  011e7	75 09		 jne	 SHORT $LN98@test_hit
  011e9	3b f0		 cmp	 esi, eax
  011eb	75 05		 jne	 SHORT $LN98@test_hit

; 1227 : 			abort();

  011ed	e8 00 00 00 00	 call	 _abort
$LN98@test_hit:

; 1228 : 		if (dereference) {
; 1229 : 			struct google_object* obj = ptr->second;

  011f2	8b 44 f7 0c	 mov	 eax, DWORD PTR [edi+esi*8+12]

; 1230 : 			if (obj->value != key)

  011f6	8b 4d f0	 mov	 ecx, DWORD PTR _key$151025[ebp]
  011f9	39 08		 cmp	 DWORD PTR [eax], ecx
  011fb	74 05		 je	 SHORT $LN100@test_hit

; 1231 : 				abort();

  011fd	e8 00 00 00 00	 call	 _abort
$LN100@test_hit:

; 1220 : #endif
; 1221 : 
; 1222 : #ifdef USE_GOOGLEBTREE
; 1223 : 	START(DATA_GOOGLEBTREE) {

  01202	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01205	40		 inc	 eax
  01206	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01209	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0120f	0f 82 b9 fe ff
	ff		 jb	 $LN101@test_hit
$LN99@test_hit:

; 1232 : 		}
; 1233 : 	} STOP();

  01215	8d 55 d4	 lea	 edx, DWORD PTR _t$215320[ebp]
  01218	52		 push	 edx
  01219	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0121f	85 c0		 test	 eax, eax
  01221	75 11		 jne	 SHORT $LN857@test_hit
  01223	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01227	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215312[ebp], xmm0
  0122c	8b 5d d0	 mov	 ebx, DWORD PTR $T215312[ebp+4]
  0122f	8b 7d cc	 mov	 edi, DWORD PTR $T215312[ebp]
  01232	eb 54		 jmp	 SHORT $LN858@test_hit
$LN857@test_hit:
  01234	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0123a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01240	8b 45 d8	 mov	 eax, DWORD PTR _t$215320[ebp+4]
  01243	8b 4d d4	 mov	 ecx, DWORD PTR _t$215320[ebp]
  01246	57		 push	 edi
  01247	56		 push	 esi
  01248	50		 push	 eax
  01249	51		 push	 ecx
  0124a	e8 00 00 00 00	 call	 __alldvrm
  0124f	6a 00		 push	 0
  01251	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01256	53		 push	 ebx
  01257	51		 push	 ecx
  01258	89 45 ec	 mov	 DWORD PTR tv1934[ebp], eax
  0125b	89 55 f0	 mov	 DWORD PTR tv1934[ebp+4], edx
  0125e	e8 00 00 00 00	 call	 __allmul
  01263	57		 push	 edi
  01264	56		 push	 esi
  01265	52		 push	 edx
  01266	50		 push	 eax
  01267	e8 00 00 00 00	 call	 __alldiv
  0126c	6a 00		 push	 0
  0126e	8b da		 mov	 ebx, edx
  01270	8b 55 f0	 mov	 edx, DWORD PTR tv1934[ebp+4]
  01273	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01278	8b f8		 mov	 edi, eax
  0127a	8b 45 ec	 mov	 eax, DWORD PTR tv1934[ebp]
  0127d	52		 push	 edx
  0127e	50		 push	 eax
  0127f	e8 00 00 00 00	 call	 __allmul
  01284	03 f8		 add	 edi, eax
  01286	13 da		 adc	 ebx, edx
$LN858@test_hit:
  01288	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  0128e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01294	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0129a	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  012a0	75 64		 jne	 SHORT $LN855@test_hit
  012a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  012a9	75 24		 jne	 SHORT $LN853@test_hit
  012ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  012b1	6a 00		 push	 0
  012b3	51		 push	 ecx
  012b4	53		 push	 ebx
  012b5	57		 push	 edi
  012b6	e8 00 00 00 00	 call	 __aulldiv
  012bb	50		 push	 eax
  012bc	68 00 00 00 00	 push	 OFFSET $SG-102
  012c1	e8 00 00 00 00	 call	 _printf
  012c6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  012cc	83 c4 08	 add	 esp, 8
$LN853@test_hit:
  012cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  012d5	6a 00		 push	 0
  012d7	52		 push	 edx
  012d8	53		 push	 ebx
  012d9	57		 push	 edi
  012da	e8 00 00 00 00	 call	 __aulldiv
  012df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  012e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  012eb	c1 e1 04	 shl	 ecx, 4
  012ee	03 ce		 add	 ecx, esi
  012f0	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  012f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  012f9	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  012fc	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  012ff	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN855@test_hit:

; 1234 : #endif
; 1235 : 
; 1236 : #ifdef USE_STXBTREE
; 1237 : 	START(DATA_STXBTREE) {

  01306	c7 05 00 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 13 ; the_start_data, 0000000dH
  01310	83 fe 0d	 cmp	 esi, 13			; 0000000dH
  01313	0f 85 22 01 00
	00		 jne	 $LN92@test_hit
  01319	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01320	75 2f		 jne	 SHORT $LN862@test_hit
  01322	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  01328	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0132d	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01334	52		 push	 edx
  01335	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0133b	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01342	51		 push	 ecx
  01343	50		 push	 eax
  01344	68 00 00 00 00	 push	 OFFSET $SG-101
  01349	e8 00 00 00 00	 call	 _printf
  0134e	83 c4 10	 add	 esp, 16			; 00000010H
$LN862@test_hit:
  01351	8d 4d dc	 lea	 ecx, DWORD PTR _t$215345[ebp]
  01354	51		 push	 ecx
  01355	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0135b	85 c0		 test	 eax, eax
  0135d	75 11		 jne	 SHORT $LN868@test_hit
  0135f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01363	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215338[ebp], xmm0
  01368	8b 5d d0	 mov	 ebx, DWORD PTR $T215338[ebp+4]
  0136b	8b 7d cc	 mov	 edi, DWORD PTR $T215338[ebp]
  0136e	eb 54		 jmp	 SHORT $LN869@test_hit
$LN868@test_hit:
  01370	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01376	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0137c	8b 55 e0	 mov	 edx, DWORD PTR _t$215345[ebp+4]
  0137f	8b 45 dc	 mov	 eax, DWORD PTR _t$215345[ebp]
  01382	57		 push	 edi
  01383	56		 push	 esi
  01384	52		 push	 edx
  01385	50		 push	 eax
  01386	e8 00 00 00 00	 call	 __alldvrm
  0138b	6a 00		 push	 0
  0138d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01392	53		 push	 ebx
  01393	51		 push	 ecx
  01394	89 45 ec	 mov	 DWORD PTR tv2204[ebp], eax
  01397	89 55 f0	 mov	 DWORD PTR tv2204[ebp+4], edx
  0139a	e8 00 00 00 00	 call	 __allmul
  0139f	57		 push	 edi
  013a0	56		 push	 esi
  013a1	52		 push	 edx
  013a2	50		 push	 eax
  013a3	e8 00 00 00 00	 call	 __alldiv
  013a8	8b 4d f0	 mov	 ecx, DWORD PTR tv2204[ebp+4]
  013ab	6a 00		 push	 0
  013ad	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013b2	8b da		 mov	 ebx, edx
  013b4	8b 55 ec	 mov	 edx, DWORD PTR tv2204[ebp]
  013b7	51		 push	 ecx
  013b8	52		 push	 edx
  013b9	8b f8		 mov	 edi, eax
  013bb	e8 00 00 00 00	 call	 __allmul
  013c0	03 f8		 add	 edi, eax
  013c2	13 da		 adc	 ebx, edx
$LN869@test_hit:
  013c4	33 f6		 xor	 esi, esi
  013c6	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  013cc	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  013d2	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  013d8	76 61		 jbe	 SHORT $LN92@test_hit
  013da	8d 9b 00 00 00
	00		 npad	 6
$LL94@test_hit:

; 1238 : 		unsigned key = SEARCH[i] + DELTA;

  013e0	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  013e3	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]

; 1239 : 		stxbtree_t::const_iterator ptr = stxbtree->find(key);

  013e6	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  013ec	8d 4d c4	 lea	 ecx, DWORD PTR $T211550[ebp]
  013ef	51		 push	 ecx
  013f0	47		 inc	 edi
  013f1	53		 push	 ebx
  013f2	8d 45 f0	 lea	 eax, DWORD PTR _key$151126[ebp]
  013f5	89 7d f0	 mov	 DWORD PTR _key$151126[ebp], edi
  013f8	e8 00 00 00 00	 call	 ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find

; 1240 : 		if (ptr == stxbtree->end())

  013fd	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  01400	85 c0		 test	 eax, eax
  01402	74 06		 je	 SHORT $LN883@test_hit
  01404	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  01408	eb 02		 jmp	 SHORT $LN884@test_hit
$LN883@test_hit:
  0140a	33 c9		 xor	 ecx, ecx
$LN884@test_hit:
  0140c	8b 5d c4	 mov	 ebx, DWORD PTR $T211550[ebp]
  0140f	3b c3		 cmp	 eax, ebx
  01411	75 0b		 jne	 SHORT $LN91@test_hit
  01413	66 3b 4d c8	 cmp	 cx, WORD PTR $T211550[ebp+4]
  01417	75 05		 jne	 SHORT $LN91@test_hit

; 1241 : 			abort();

  01419	e8 00 00 00 00	 call	 _abort
$LN91@test_hit:

; 1242 : 		if (dereference) {
; 1243 : 			struct stx_object* obj = ptr->second;

  0141e	0f b7 45 c8	 movzx	 eax, WORD PTR $T211550[ebp+4]
  01422	8b 84 83 8c 00
	00 00		 mov	 eax, DWORD PTR [ebx+eax*4+140]

; 1244 : 			if (obj->value != key)

  01429	39 38		 cmp	 DWORD PTR [eax], edi
  0142b	74 05		 je	 SHORT $LN93@test_hit

; 1245 : 				abort();

  0142d	e8 00 00 00 00	 call	 _abort
$LN93@test_hit:

; 1234 : #endif
; 1235 : 
; 1236 : #ifdef USE_STXBTREE
; 1237 : 	START(DATA_STXBTREE) {

  01432	46		 inc	 esi
  01433	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01439	72 a5		 jb	 SHORT $LL94@test_hit
$LN92@test_hit:

; 1246 : 		}
; 1247 : 	} STOP();

  0143b	8d 55 d4	 lea	 edx, DWORD PTR _t$215537[ebp]
  0143e	52		 push	 edx
  0143f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01445	85 c0		 test	 eax, eax
  01447	75 11		 jne	 SHORT $LN929@test_hit
  01449	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0144d	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215526[ebp], xmm0
  01452	8b 5d d0	 mov	 ebx, DWORD PTR $T215526[ebp+4]
  01455	8b 7d cc	 mov	 edi, DWORD PTR $T215526[ebp]
  01458	eb 54		 jmp	 SHORT $LN930@test_hit
$LN929@test_hit:
  0145a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01460	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01466	8b 45 d8	 mov	 eax, DWORD PTR _t$215537[ebp+4]
  01469	8b 4d d4	 mov	 ecx, DWORD PTR _t$215537[ebp]
  0146c	57		 push	 edi
  0146d	56		 push	 esi
  0146e	50		 push	 eax
  0146f	51		 push	 ecx
  01470	e8 00 00 00 00	 call	 __alldvrm
  01475	6a 00		 push	 0
  01477	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0147c	53		 push	 ebx
  0147d	51		 push	 ecx
  0147e	89 45 ec	 mov	 DWORD PTR tv3903[ebp], eax
  01481	89 55 f0	 mov	 DWORD PTR tv3903[ebp+4], edx
  01484	e8 00 00 00 00	 call	 __allmul
  01489	57		 push	 edi
  0148a	56		 push	 esi
  0148b	52		 push	 edx
  0148c	50		 push	 eax
  0148d	e8 00 00 00 00	 call	 __alldiv
  01492	6a 00		 push	 0
  01494	8b da		 mov	 ebx, edx
  01496	8b 55 f0	 mov	 edx, DWORD PTR tv3903[ebp+4]
  01499	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0149e	8b f8		 mov	 edi, eax
  014a0	8b 45 ec	 mov	 eax, DWORD PTR tv3903[ebp]
  014a3	52		 push	 edx
  014a4	50		 push	 eax
  014a5	e8 00 00 00 00	 call	 __allmul
  014aa	03 f8		 add	 edi, eax
  014ac	13 da		 adc	 ebx, edx
$LN930@test_hit:
  014ae	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  014b4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  014ba	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  014c0	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  014c6	75 64		 jne	 SHORT $LN927@test_hit
  014c8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  014cf	75 24		 jne	 SHORT $LN925@test_hit
  014d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  014d7	6a 00		 push	 0
  014d9	51		 push	 ecx
  014da	53		 push	 ebx
  014db	57		 push	 edi
  014dc	e8 00 00 00 00	 call	 __aulldiv
  014e1	50		 push	 eax
  014e2	68 00 00 00 00	 push	 OFFSET $SG-102
  014e7	e8 00 00 00 00	 call	 _printf
  014ec	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  014f2	83 c4 08	 add	 esp, 8
$LN925@test_hit:
  014f5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  014fb	6a 00		 push	 0
  014fd	52		 push	 edx
  014fe	53		 push	 ebx
  014ff	57		 push	 edi
  01500	e8 00 00 00 00	 call	 __aulldiv
  01505	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0150b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01511	c1 e1 04	 shl	 ecx, 4
  01514	03 ce		 add	 ecx, esi
  01516	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01519	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0151f	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01522	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01525	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN927@test_hit:

; 1248 : #endif
; 1249 : 
; 1250 : #ifdef USE_CPPMAP
; 1251 : 	START(DATA_CPPMAP) {

  0152c	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 15 ; the_start_data, 0000000fH
  01536	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  01539	0f 85 2c 01 00
	00		 jne	 $LN85@test_hit
  0153f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01546	75 2f		 jne	 SHORT $LN934@test_hit
  01548	8b 15 3c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+60
  0154e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01553	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0155a	52		 push	 edx
  0155b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01561	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01568	51		 push	 ecx
  01569	50		 push	 eax
  0156a	68 00 00 00 00	 push	 OFFSET $SG-101
  0156f	e8 00 00 00 00	 call	 _printf
  01574	83 c4 10	 add	 esp, 16			; 00000010H
$LN934@test_hit:
  01577	8d 4d dc	 lea	 ecx, DWORD PTR _t$215561[ebp]
  0157a	51		 push	 ecx
  0157b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01581	85 c0		 test	 eax, eax
  01583	75 11		 jne	 SHORT $LN940@test_hit
  01585	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01589	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215552[ebp], xmm0
  0158e	8b 5d d0	 mov	 ebx, DWORD PTR $T215552[ebp+4]
  01591	8b 7d cc	 mov	 edi, DWORD PTR $T215552[ebp]
  01594	eb 54		 jmp	 SHORT $LN941@test_hit
$LN940@test_hit:
  01596	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0159c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  015a2	8b 55 e0	 mov	 edx, DWORD PTR _t$215561[ebp+4]
  015a5	8b 45 dc	 mov	 eax, DWORD PTR _t$215561[ebp]
  015a8	57		 push	 edi
  015a9	56		 push	 esi
  015aa	52		 push	 edx
  015ab	50		 push	 eax
  015ac	e8 00 00 00 00	 call	 __alldvrm
  015b1	6a 00		 push	 0
  015b3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015b8	53		 push	 ebx
  015b9	51		 push	 ecx
  015ba	89 45 ec	 mov	 DWORD PTR tv3338[ebp], eax
  015bd	89 55 f0	 mov	 DWORD PTR tv3338[ebp+4], edx
  015c0	e8 00 00 00 00	 call	 __allmul
  015c5	57		 push	 edi
  015c6	56		 push	 esi
  015c7	52		 push	 edx
  015c8	50		 push	 eax
  015c9	e8 00 00 00 00	 call	 __alldiv
  015ce	8b 4d f0	 mov	 ecx, DWORD PTR tv3338[ebp+4]
  015d1	6a 00		 push	 0
  015d3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015d8	8b da		 mov	 ebx, edx
  015da	8b 55 ec	 mov	 edx, DWORD PTR tv3338[ebp]
  015dd	51		 push	 ecx
  015de	52		 push	 edx
  015df	8b f8		 mov	 edi, eax
  015e1	e8 00 00 00 00	 call	 __allmul
  015e6	03 f8		 add	 edi, eax
  015e8	13 da		 adc	 ebx, edx
$LN941@test_hit:
  015ea	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  015f0	33 db		 xor	 ebx, ebx
  015f2	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  015f8	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  015fe	76 6b		 jbe	 SHORT $LN85@test_hit
$LL87@test_hit:

; 1252 : 		unsigned key = SEARCH[i] + DELTA;

  01600	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]

; 1253 : 		cppmap_t::const_iterator ptr = cppmap->find(key);

  01603	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  01609	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0160c	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]
  0160f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01612	47		 inc	 edi
  01613	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  01617	8b d1		 mov	 edx, ecx
  01619	75 19		 jne	 SHORT $LN951@test_hit
  0161b	eb 03 8d 49 00	 npad	 5
$LL952@test_hit:
  01620	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  01623	73 05		 jae	 SHORT $LN950@test_hit
  01625	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  01628	eb 04		 jmp	 SHORT $LN949@test_hit
$LN950@test_hit:
  0162a	8b d0		 mov	 edx, eax
  0162c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN949@test_hit:
  0162e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  01632	74 ec		 je	 SHORT $LL952@test_hit
$LN951@test_hit:
  01634	89 55 f0	 mov	 DWORD PTR __Where$215861[ebp], edx
  01637	3b d1		 cmp	 edx, ecx
  01639	74 0a		 je	 SHORT $LN945@test_hit
  0163b	3b 7a 0c	 cmp	 edi, DWORD PTR [edx+12]
  0163e	72 05		 jb	 SHORT $LN945@test_hit
  01640	8d 45 f0	 lea	 eax, DWORD PTR __Where$215861[ebp]
  01643	eb 06		 jmp	 SHORT $LN946@test_hit
$LN945@test_hit:
  01645	89 4d f8	 mov	 DWORD PTR $T215790[ebp], ecx
  01648	8d 45 f8	 lea	 eax, DWORD PTR $T215790[ebp]
$LN946@test_hit:
  0164b	8b 30		 mov	 esi, DWORD PTR [eax]

; 1254 : 		if (ptr == cppmap->end())

  0164d	3b f1		 cmp	 esi, ecx
  0164f	75 05		 jne	 SHORT $LN84@test_hit

; 1255 : 			abort();

  01651	e8 00 00 00 00	 call	 _abort
$LN84@test_hit:

; 1256 : 		if (dereference) {
; 1257 : 			struct cpp_object* obj = ptr->second;

  01656	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 1258 : 			if (obj->value != key)

  01659	39 3a		 cmp	 DWORD PTR [edx], edi
  0165b	74 05		 je	 SHORT $LN86@test_hit

; 1259 : 				abort();

  0165d	e8 00 00 00 00	 call	 _abort
$LN86@test_hit:

; 1248 : #endif
; 1249 : 
; 1250 : #ifdef USE_CPPMAP
; 1251 : 	START(DATA_CPPMAP) {

  01662	43		 inc	 ebx
  01663	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01669	72 95		 jb	 SHORT $LL87@test_hit
$LN85@test_hit:

; 1260 : 		}
; 1261 : 	} STOP();

  0166b	8d 45 d4	 lea	 eax, DWORD PTR _t$215934[ebp]
  0166e	50		 push	 eax
  0166f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01675	85 c0		 test	 eax, eax
  01677	75 11		 jne	 SHORT $LN1035@test_hit
  01679	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0167d	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215923[ebp], xmm0
  01682	8b 5d d0	 mov	 ebx, DWORD PTR $T215923[ebp+4]
  01685	8b 7d cc	 mov	 edi, DWORD PTR $T215923[ebp]
  01688	eb 54		 jmp	 SHORT $LN1036@test_hit
$LN1035@test_hit:
  0168a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01690	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01696	8b 4d d8	 mov	 ecx, DWORD PTR _t$215934[ebp+4]
  01699	8b 55 d4	 mov	 edx, DWORD PTR _t$215934[ebp]
  0169c	57		 push	 edi
  0169d	56		 push	 esi
  0169e	51		 push	 ecx
  0169f	52		 push	 edx
  016a0	e8 00 00 00 00	 call	 __alldvrm
  016a5	6a 00		 push	 0
  016a7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  016ac	53		 push	 ebx
  016ad	51		 push	 ecx
  016ae	89 45 ec	 mov	 DWORD PTR tv2360[ebp], eax
  016b1	89 55 f0	 mov	 DWORD PTR tv2360[ebp+4], edx
  016b4	e8 00 00 00 00	 call	 __allmul
  016b9	57		 push	 edi
  016ba	56		 push	 esi
  016bb	52		 push	 edx
  016bc	50		 push	 eax
  016bd	e8 00 00 00 00	 call	 __alldiv
  016c2	8b 4d ec	 mov	 ecx, DWORD PTR tv2360[ebp]
  016c5	6a 00		 push	 0
  016c7	8b f8		 mov	 edi, eax
  016c9	8b 45 f0	 mov	 eax, DWORD PTR tv2360[ebp+4]
  016cc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  016d1	50		 push	 eax
  016d2	51		 push	 ecx
  016d3	8b da		 mov	 ebx, edx
  016d5	e8 00 00 00 00	 call	 __allmul
  016da	03 f8		 add	 edi, eax
  016dc	13 da		 adc	 ebx, edx
$LN1036@test_hit:
  016de	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  016e4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  016ea	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  016f0	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  016f6	75 63		 jne	 SHORT $LN1033@test_hit
  016f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  016ff	75 24		 jne	 SHORT $LN1031@test_hit
  01701	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01707	6a 00		 push	 0
  01709	52		 push	 edx
  0170a	53		 push	 ebx
  0170b	57		 push	 edi
  0170c	e8 00 00 00 00	 call	 __aulldiv
  01711	50		 push	 eax
  01712	68 00 00 00 00	 push	 OFFSET $SG-102
  01717	e8 00 00 00 00	 call	 _printf
  0171c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01722	83 c4 08	 add	 esp, 8
$LN1031@test_hit:
  01725	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0172a	6a 00		 push	 0
  0172c	50		 push	 eax
  0172d	53		 push	 ebx
  0172e	57		 push	 edi
  0172f	e8 00 00 00 00	 call	 __aulldiv
  01734	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0173a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01740	c1 e1 04	 shl	 ecx, 4
  01743	03 ce		 add	 ecx, esi
  01745	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01748	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0174e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01751	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01754	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1033@test_hit:

; 1262 : #endif
; 1263 : 
; 1264 : #ifdef USE_CPPUNORDEREDMAP
; 1265 : 	START(DATA_CPPUNORDEREDMAP) {

  0175b	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 14 ; the_start_data, 0000000eH
  01765	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  01768	0f 85 06 01 00
	00		 jne	 $LN78@test_hit
  0176e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01775	75 2f		 jne	 SHORT $LN1040@test_hit
  01777	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  0177d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01782	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01789	52		 push	 edx
  0178a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01790	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01797	51		 push	 ecx
  01798	50		 push	 eax
  01799	68 00 00 00 00	 push	 OFFSET $SG-101
  0179e	e8 00 00 00 00	 call	 _printf
  017a3	83 c4 10	 add	 esp, 16			; 00000010H
$LN1040@test_hit:
  017a6	8d 4d dc	 lea	 ecx, DWORD PTR _t$215958[ebp]
  017a9	51		 push	 ecx
  017aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  017b0	85 c0		 test	 eax, eax
  017b2	75 11		 jne	 SHORT $LN1046@test_hit
  017b4	66 0f 57 c0	 xorpd	 xmm0, xmm0
  017b8	66 0f 13 45 cc	 movlpd	 QWORD PTR $T215949[ebp], xmm0
  017bd	8b 5d d0	 mov	 ebx, DWORD PTR $T215949[ebp+4]
  017c0	8b 7d cc	 mov	 edi, DWORD PTR $T215949[ebp]
  017c3	eb 54		 jmp	 SHORT $LN1047@test_hit
$LN1046@test_hit:
  017c5	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  017cb	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  017d1	8b 55 e0	 mov	 edx, DWORD PTR _t$215958[ebp+4]
  017d4	8b 45 dc	 mov	 eax, DWORD PTR _t$215958[ebp]
  017d7	57		 push	 edi
  017d8	56		 push	 esi
  017d9	52		 push	 edx
  017da	50		 push	 eax
  017db	e8 00 00 00 00	 call	 __alldvrm
  017e0	6a 00		 push	 0
  017e2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  017e7	53		 push	 ebx
  017e8	51		 push	 ecx
  017e9	89 45 ec	 mov	 DWORD PTR tv3874[ebp], eax
  017ec	89 55 f0	 mov	 DWORD PTR tv3874[ebp+4], edx
  017ef	e8 00 00 00 00	 call	 __allmul
  017f4	57		 push	 edi
  017f5	56		 push	 esi
  017f6	52		 push	 edx
  017f7	50		 push	 eax
  017f8	e8 00 00 00 00	 call	 __alldiv
  017fd	8b 4d f0	 mov	 ecx, DWORD PTR tv3874[ebp+4]
  01800	6a 00		 push	 0
  01802	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01807	8b da		 mov	 ebx, edx
  01809	8b 55 ec	 mov	 edx, DWORD PTR tv3874[ebp]
  0180c	51		 push	 ecx
  0180d	52		 push	 edx
  0180e	8b f8		 mov	 edi, eax
  01810	e8 00 00 00 00	 call	 __allmul
  01815	03 f8		 add	 edi, eax
  01817	13 da		 adc	 ebx, edx
$LN1047@test_hit:
  01819	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0181f	33 db		 xor	 ebx, ebx
  01821	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01827	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0182d	76 45		 jbe	 SHORT $LN78@test_hit
  0182f	90		 npad	 1
$LL80@test_hit:

; 1266 : 		unsigned key = SEARCH[i] + DELTA;

  01830	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  01833	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]

; 1267 : 		cppunorderedmap_t::const_iterator ptr = cppunorderedmap->find(key);

  01836	8d 4d f8	 lea	 ecx, DWORD PTR $T211555[ebp]
  01839	51		 push	 ecx
  0183a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  01840	47		 inc	 edi
  01841	8d 45 f0	 lea	 eax, DWORD PTR _key$151707[ebp]
  01844	89 7d f0	 mov	 DWORD PTR _key$151707[ebp], edi
  01847	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1268 : 		if (ptr == cppunorderedmap->end())

  0184c	8b 75 f8	 mov	 esi, DWORD PTR $T211555[ebp]
  0184f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  01855	3b 72 04	 cmp	 esi, DWORD PTR [edx+4]
  01858	75 05		 jne	 SHORT $LN77@test_hit

; 1269 : 			abort();

  0185a	e8 00 00 00 00	 call	 _abort
$LN77@test_hit:

; 1270 : 		if (dereference) {
; 1271 : 			struct cpp_object* obj = ptr->second;

  0185f	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 1272 : 			if (obj->value != key)

  01862	39 38		 cmp	 DWORD PTR [eax], edi
  01864	74 05		 je	 SHORT $LN79@test_hit

; 1273 : 				abort();

  01866	e8 00 00 00 00	 call	 _abort
$LN79@test_hit:

; 1262 : #endif
; 1263 : 
; 1264 : #ifdef USE_CPPUNORDEREDMAP
; 1265 : 	START(DATA_CPPUNORDEREDMAP) {

  0186b	43		 inc	 ebx
  0186c	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01872	72 bc		 jb	 SHORT $LL80@test_hit
$LN78@test_hit:

; 1274 : 		}
; 1275 : 	} STOP();

  01874	8d 4d d4	 lea	 ecx, DWORD PTR _t$216051[ebp]
  01877	51		 push	 ecx
  01878	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0187e	85 c0		 test	 eax, eax
  01880	75 11		 jne	 SHORT $LN1075@test_hit
  01882	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01886	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216040[ebp], xmm0
  0188b	8b 5d d0	 mov	 ebx, DWORD PTR $T216040[ebp+4]
  0188e	8b 7d cc	 mov	 edi, DWORD PTR $T216040[ebp]
  01891	eb 54		 jmp	 SHORT $LN1076@test_hit
$LN1075@test_hit:
  01893	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01899	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0189f	8b 55 d8	 mov	 edx, DWORD PTR _t$216051[ebp+4]
  018a2	8b 45 d4	 mov	 eax, DWORD PTR _t$216051[ebp]
  018a5	57		 push	 edi
  018a6	56		 push	 esi
  018a7	52		 push	 edx
  018a8	50		 push	 eax
  018a9	e8 00 00 00 00	 call	 __alldvrm
  018ae	6a 00		 push	 0
  018b0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  018b5	53		 push	 ebx
  018b6	51		 push	 ecx
  018b7	89 45 ec	 mov	 DWORD PTR tv2509[ebp], eax
  018ba	89 55 f0	 mov	 DWORD PTR tv2509[ebp+4], edx
  018bd	e8 00 00 00 00	 call	 __allmul
  018c2	57		 push	 edi
  018c3	56		 push	 esi
  018c4	52		 push	 edx
  018c5	50		 push	 eax
  018c6	e8 00 00 00 00	 call	 __alldiv
  018cb	8b 4d f0	 mov	 ecx, DWORD PTR tv2509[ebp+4]
  018ce	6a 00		 push	 0
  018d0	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  018d5	8b da		 mov	 ebx, edx
  018d7	8b 55 ec	 mov	 edx, DWORD PTR tv2509[ebp]
  018da	51		 push	 ecx
  018db	52		 push	 edx
  018dc	8b f8		 mov	 edi, eax
  018de	e8 00 00 00 00	 call	 __allmul
  018e3	03 f8		 add	 edi, eax
  018e5	13 da		 adc	 ebx, edx
$LN1076@test_hit:
  018e7	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  018ed	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  018f3	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  018f9	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  018ff	75 63		 jne	 SHORT $LN1073@test_hit
  01901	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01908	75 23		 jne	 SHORT $LN1071@test_hit
  0190a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0190f	6a 00		 push	 0
  01911	50		 push	 eax
  01912	53		 push	 ebx
  01913	57		 push	 edi
  01914	e8 00 00 00 00	 call	 __aulldiv
  01919	50		 push	 eax
  0191a	68 00 00 00 00	 push	 OFFSET $SG-102
  0191f	e8 00 00 00 00	 call	 _printf
  01924	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  0192a	83 c4 08	 add	 esp, 8
$LN1071@test_hit:
  0192d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  01933	6a 00		 push	 0
  01935	51		 push	 ecx
  01936	53		 push	 ebx
  01937	57		 push	 edi
  01938	e8 00 00 00 00	 call	 __aulldiv
  0193d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  01943	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01949	c1 e2 04	 shl	 edx, 4
  0194c	03 d6		 add	 edx, esi
  0194e	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  01951	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  01954	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0195a	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0195d	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN1073@test_hit:

; 1276 : #endif
; 1277 : 
; 1278 : 	START(DATA_UTHASH) {

  01964	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 8 ; the_start_data
  0196e	83 fe 08	 cmp	 esi, 8
  01971	0f 85 d0 01 00
	00		 jne	 $LN71@test_hit
  01977	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0197e	75 2e		 jne	 SHORT $LN1080@test_hit
  01980	a1 20 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  01985	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0198b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  01992	50		 push	 eax
  01993	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01998	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0199f	52		 push	 edx
  019a0	51		 push	 ecx
  019a1	68 00 00 00 00	 push	 OFFSET $SG-101
  019a6	e8 00 00 00 00	 call	 _printf
  019ab	83 c4 10	 add	 esp, 16			; 00000010H
$LN1080@test_hit:
  019ae	8d 55 dc	 lea	 edx, DWORD PTR _t$216077[ebp]
  019b1	52		 push	 edx
  019b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  019b8	85 c0		 test	 eax, eax
  019ba	75 11		 jne	 SHORT $LN1086@test_hit
  019bc	66 0f 57 c0	 xorpd	 xmm0, xmm0
  019c0	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216066[ebp], xmm0
  019c5	8b 5d d0	 mov	 ebx, DWORD PTR $T216066[ebp+4]
  019c8	8b 7d cc	 mov	 edi, DWORD PTR $T216066[ebp]
  019cb	eb 54		 jmp	 SHORT $LN1087@test_hit
$LN1086@test_hit:
  019cd	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  019d3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  019d9	8b 45 e0	 mov	 eax, DWORD PTR _t$216077[ebp+4]
  019dc	8b 4d dc	 mov	 ecx, DWORD PTR _t$216077[ebp]
  019df	57		 push	 edi
  019e0	56		 push	 esi
  019e1	50		 push	 eax
  019e2	51		 push	 ecx
  019e3	e8 00 00 00 00	 call	 __alldvrm
  019e8	6a 00		 push	 0
  019ea	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  019ef	53		 push	 ebx
  019f0	51		 push	 ecx
  019f1	89 45 ec	 mov	 DWORD PTR tv2664[ebp], eax
  019f4	89 55 f0	 mov	 DWORD PTR tv2664[ebp+4], edx
  019f7	e8 00 00 00 00	 call	 __allmul
  019fc	57		 push	 edi
  019fd	56		 push	 esi
  019fe	52		 push	 edx
  019ff	50		 push	 eax
  01a00	e8 00 00 00 00	 call	 __alldiv
  01a05	6a 00		 push	 0
  01a07	8b da		 mov	 ebx, edx
  01a09	8b 55 f0	 mov	 edx, DWORD PTR tv2664[ebp+4]
  01a0c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01a11	8b f8		 mov	 edi, eax
  01a13	8b 45 ec	 mov	 eax, DWORD PTR tv2664[ebp]
  01a16	52		 push	 edx
  01a17	50		 push	 eax
  01a18	e8 00 00 00 00	 call	 __allmul
  01a1d	03 f8		 add	 edi, eax
  01a1f	13 da		 adc	 ebx, edx
$LN1087@test_hit:
  01a21	33 f6		 xor	 esi, esi
  01a23	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01a29	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01a2f	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01a35	0f 86 0c 01 00
	00		 jbe	 $LN71@test_hit
  01a3b	eb 03 8d 49 00	 npad	 5
$LL73@test_hit:

; 1279 : 		unsigned key = SEARCH[i] + DELTA;

  01a40	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  01a43	8b 1c b1	 mov	 ebx, DWORD PTR [ecx+esi*4]
  01a46	43		 inc	 ebx

; 1280 : 		struct uthash_object* obj;
; 1281 : 		HASH_FIND_INT(uthash, &key, obj);  

  01a47	33 ff		 xor	 edi, edi
  01a49	89 5d f0	 mov	 DWORD PTR _key$151852[ebp], ebx
  01a4c	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?uthash@@3PAUuthash_object@@A, edi ; uthash
  01a52	0f 84 d3 00 00
	00		 je	 $LN1240@test_hit
  01a58	0f be 45 f3	 movsx	 eax, BYTE PTR _key$151852[ebp+3]
  01a5c	0f be 55 f2	 movsx	 edx, BYTE PTR _key$151852[ebp+2]
  01a60	c1 e0 18	 shl	 eax, 24			; 00000018H
  01a63	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01a68	c1 e2 10	 shl	 edx, 16			; 00000010H
  01a6b	03 c2		 add	 eax, edx
  01a6d	0f be cf	 movsx	 ecx, bh
  01a70	c1 e1 08	 shl	 ecx, 8
  01a73	03 c1		 add	 eax, ecx
  01a75	0f be d3	 movsx	 edx, bl
  01a78	03 d0		 add	 edx, eax
  01a7a	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  01a80	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  01a86	8b c2		 mov	 eax, edx
  01a88	c1 e0 08	 shl	 eax, 8
  01a8b	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  01a90	2b ca		 sub	 ecx, edx
  01a92	33 c8		 xor	 ecx, eax
  01a94	8b f9		 mov	 edi, ecx
  01a96	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  01a99	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  01a9e	2b c1		 sub	 eax, ecx
  01aa0	2b c2		 sub	 eax, edx
  01aa2	33 c7		 xor	 eax, edi
  01aa4	2b d1		 sub	 edx, ecx
  01aa6	2b d0		 sub	 edx, eax
  01aa8	8b f8		 mov	 edi, eax
  01aaa	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  01aad	33 d7		 xor	 edx, edi
  01aaf	2b ca		 sub	 ecx, edx
  01ab1	2b c8		 sub	 ecx, eax
  01ab3	8b fa		 mov	 edi, edx
  01ab5	c1 e7 10	 shl	 edi, 16			; 00000010H
  01ab8	33 cf		 xor	 ecx, edi
  01aba	2b c1		 sub	 eax, ecx
  01abc	2b c2		 sub	 eax, edx
  01abe	8b f9		 mov	 edi, ecx
  01ac0	c1 ef 05	 shr	 edi, 5
  01ac3	33 c7		 xor	 eax, edi
  01ac5	2b d1		 sub	 edx, ecx
  01ac7	2b d0		 sub	 edx, eax
  01ac9	8b f8		 mov	 edi, eax
  01acb	c1 ef 03	 shr	 edi, 3
  01ace	33 d7		 xor	 edx, edi
  01ad0	2b ca		 sub	 ecx, edx
  01ad2	2b c8		 sub	 ecx, eax
  01ad4	8b fa		 mov	 edi, edx
  01ad6	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  01ad9	33 cf		 xor	 ecx, edi
  01adb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01ae1	8b 3f		 mov	 edi, DWORD PTR [edi]
  01ae3	2b c1		 sub	 eax, ecx
  01ae5	2b c2		 sub	 eax, edx
  01ae7	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  01aea	33 c1		 xor	 eax, ecx
  01aec	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  01aef	49		 dec	 ecx
  01af0	23 c1		 and	 eax, ecx
  01af2	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01af5	8b 07		 mov	 eax, DWORD PTR [edi]
  01af7	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  01afa	85 c0		 test	 eax, eax
  01afc	74 2b		 je	 SHORT $LN29@test_hit
  01afe	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  01b01	2b c1		 sub	 eax, ecx
  01b03	8b f8		 mov	 edi, eax
  01b05	85 ff		 test	 edi, edi
  01b07	74 22		 je	 SHORT $LN1240@test_hit
  01b09	b8 04 00 00 00	 mov	 eax, 4
  01b0e	8b ff		 npad	 2
$LL33@test_hit:
  01b10	39 47 18	 cmp	 DWORD PTR [edi+24], eax
  01b13	75 07		 jne	 SHORT $LN30@test_hit
  01b15	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  01b18	39 1a		 cmp	 DWORD PTR [edx], ebx
  01b1a	74 14		 je	 SHORT $LN24@test_hit
$LN30@test_hit:
  01b1c	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  01b1f	85 ff		 test	 edi, edi
  01b21	74 06		 je	 SHORT $LN29@test_hit
  01b23	2b f9		 sub	 edi, ecx
  01b25	75 e9		 jne	 SHORT $LL33@test_hit
  01b27	eb 02		 jmp	 SHORT $LN1240@test_hit
$LN29@test_hit:
  01b29	33 ff		 xor	 edi, edi
$LN1240@test_hit:

; 1282 : 		if (!obj)
; 1283 : 			abort();

  01b2b	e8 00 00 00 00	 call	 _abort
$LN24@test_hit:

; 1284 : 		if (dereference) {
; 1285 : 			if (obj->value != key)

  01b30	39 5f 20	 cmp	 DWORD PTR [edi+32], ebx
  01b33	74 05		 je	 SHORT $LN72@test_hit

; 1286 : 				abort();

  01b35	e8 00 00 00 00	 call	 _abort
$LN72@test_hit:

; 1276 : #endif
; 1277 : 
; 1278 : 	START(DATA_UTHASH) {

  01b3a	46		 inc	 esi
  01b3b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01b41	0f 82 f9 fe ff
	ff		 jb	 $LL73@test_hit
$LN71@test_hit:

; 1287 : 		}
; 1288 : 	} STOP();

  01b47	8d 45 cc	 lea	 eax, DWORD PTR _t$216094[ebp]
  01b4a	50		 push	 eax
  01b4b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01b51	85 c0		 test	 eax, eax
  01b53	75 11		 jne	 SHORT $LN1093@test_hit
  01b55	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01b59	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216086[ebp], xmm0
  01b5e	8b 5d d0	 mov	 ebx, DWORD PTR $T216086[ebp+4]
  01b61	8b 7d cc	 mov	 edi, DWORD PTR $T216086[ebp]
  01b64	eb 54		 jmp	 SHORT $LN1094@test_hit
$LN1093@test_hit:
  01b66	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01b6c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01b72	8b 4d d0	 mov	 ecx, DWORD PTR _t$216094[ebp+4]
  01b75	8b 55 cc	 mov	 edx, DWORD PTR _t$216094[ebp]
  01b78	57		 push	 edi
  01b79	56		 push	 esi
  01b7a	51		 push	 ecx
  01b7b	52		 push	 edx
  01b7c	e8 00 00 00 00	 call	 __alldvrm
  01b81	6a 00		 push	 0
  01b83	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01b88	53		 push	 ebx
  01b89	51		 push	 ecx
  01b8a	89 45 ec	 mov	 DWORD PTR tv2853[ebp], eax
  01b8d	89 55 f0	 mov	 DWORD PTR tv2853[ebp+4], edx
  01b90	e8 00 00 00 00	 call	 __allmul
  01b95	57		 push	 edi
  01b96	56		 push	 esi
  01b97	52		 push	 edx
  01b98	50		 push	 eax
  01b99	e8 00 00 00 00	 call	 __alldiv
  01b9e	8b 4d ec	 mov	 ecx, DWORD PTR tv2853[ebp]
  01ba1	6a 00		 push	 0
  01ba3	8b f8		 mov	 edi, eax
  01ba5	8b 45 f0	 mov	 eax, DWORD PTR tv2853[ebp+4]
  01ba8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01bad	50		 push	 eax
  01bae	51		 push	 ecx
  01baf	8b da		 mov	 ebx, edx
  01bb1	e8 00 00 00 00	 call	 __allmul
  01bb6	03 f8		 add	 edi, eax
  01bb8	13 da		 adc	 ebx, edx
$LN1094@test_hit:
  01bba	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01bc0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01bc6	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01bcc	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01bd2	75 63		 jne	 SHORT $LN1091@test_hit
  01bd4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01bdb	75 24		 jne	 SHORT $LN1089@test_hit
  01bdd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01be3	6a 00		 push	 0
  01be5	52		 push	 edx
  01be6	53		 push	 ebx
  01be7	57		 push	 edi
  01be8	e8 00 00 00 00	 call	 __aulldiv
  01bed	50		 push	 eax
  01bee	68 00 00 00 00	 push	 OFFSET $SG-102
  01bf3	e8 00 00 00 00	 call	 _printf
  01bf8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01bfe	83 c4 08	 add	 esp, 8
$LN1089@test_hit:
  01c01	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01c06	6a 00		 push	 0
  01c08	50		 push	 eax
  01c09	53		 push	 ebx
  01c0a	57		 push	 edi
  01c0b	e8 00 00 00 00	 call	 __aulldiv
  01c10	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01c16	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01c1c	c1 e1 04	 shl	 ecx, 4
  01c1f	03 ce		 add	 ecx, esi
  01c21	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01c24	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01c2a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01c2d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01c30	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1091@test_hit:

; 1289 : 
; 1290 : #ifdef USE_JUDY
; 1291 : 	START(DATA_JUDY) {

  01c37	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 9 ; the_start_data
  01c41	83 fe 09	 cmp	 esi, 9
  01c44	0f 85 fe 00 00
	00		 jne	 $LN18@test_hit
  01c4a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01c51	75 2f		 jne	 SHORT $LN1098@test_hit
  01c53	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  01c59	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01c5e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01c65	52		 push	 edx
  01c66	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01c6c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01c73	51		 push	 ecx
  01c74	50		 push	 eax
  01c75	68 00 00 00 00	 push	 OFFSET $SG-101
  01c7a	e8 00 00 00 00	 call	 _printf
  01c7f	83 c4 10	 add	 esp, 16			; 00000010H
$LN1098@test_hit:
  01c82	8d 4d cc	 lea	 ecx, DWORD PTR _t$216119[ebp]
  01c85	51		 push	 ecx
  01c86	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01c8c	85 c0		 test	 eax, eax
  01c8e	75 11		 jne	 SHORT $LN1104@test_hit
  01c90	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01c94	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216112[ebp], xmm0
  01c99	8b 5d d0	 mov	 ebx, DWORD PTR $T216112[ebp+4]
  01c9c	8b 7d cc	 mov	 edi, DWORD PTR $T216112[ebp]
  01c9f	eb 54		 jmp	 SHORT $LN1105@test_hit
$LN1104@test_hit:
  01ca1	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01ca7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01cad	8b 55 d0	 mov	 edx, DWORD PTR _t$216119[ebp+4]
  01cb0	8b 45 cc	 mov	 eax, DWORD PTR _t$216119[ebp]
  01cb3	57		 push	 edi
  01cb4	56		 push	 esi
  01cb5	52		 push	 edx
  01cb6	50		 push	 eax
  01cb7	e8 00 00 00 00	 call	 __alldvrm
  01cbc	6a 00		 push	 0
  01cbe	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01cc3	53		 push	 ebx
  01cc4	51		 push	 ecx
  01cc5	89 45 ec	 mov	 DWORD PTR tv462[ebp], eax
  01cc8	89 55 f0	 mov	 DWORD PTR tv462[ebp+4], edx
  01ccb	e8 00 00 00 00	 call	 __allmul
  01cd0	57		 push	 edi
  01cd1	56		 push	 esi
  01cd2	52		 push	 edx
  01cd3	50		 push	 eax
  01cd4	e8 00 00 00 00	 call	 __alldiv
  01cd9	8b 4d f0	 mov	 ecx, DWORD PTR tv462[ebp+4]
  01cdc	6a 00		 push	 0
  01cde	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ce3	8b da		 mov	 ebx, edx
  01ce5	8b 55 ec	 mov	 edx, DWORD PTR tv462[ebp]
  01ce8	51		 push	 ecx
  01ce9	52		 push	 edx
  01cea	8b f8		 mov	 edi, eax
  01cec	e8 00 00 00 00	 call	 __allmul
  01cf1	03 f8		 add	 edi, eax
  01cf3	13 da		 adc	 ebx, edx
$LN1105@test_hit:
  01cf5	33 f6		 xor	 esi, esi
  01cf7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01cfd	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01d03	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  01d09	76 3d		 jbe	 SHORT $LN18@test_hit
  01d0b	eb 03 8d 49 00	 npad	 5
$LL20@test_hit:

; 1292 : 		Word_t key = SEARCH[i] + DELTA;

  01d10	8b 45 08	 mov	 eax, DWORD PTR _SEARCH$[ebp]
  01d13	8b 3c b0	 mov	 edi, DWORD PTR [eax+esi*4]

; 1293 : 		Pvoid_t PValue;
; 1294 : 		JLG(PValue, judy, key);

  01d16	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?judy@@3PAXA ; judy
  01d1c	6a 00		 push	 0
  01d1e	47		 inc	 edi
  01d1f	57		 push	 edi
  01d20	51		 push	 ecx
  01d21	e8 00 00 00 00	 call	 _JudyLGet
  01d26	8b d8		 mov	 ebx, eax
  01d28	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1295 : 		if (!PValue)

  01d2b	85 db		 test	 ebx, ebx
  01d2d	75 05		 jne	 SHORT $LN17@test_hit

; 1296 : 			abort();

  01d2f	e8 00 00 00 00	 call	 _abort
$LN17@test_hit:

; 1297 : 		if (dereference) {
; 1298 : 			struct judy_object* obj = *(struct judy_object**)PValue;

  01d34	8b 13		 mov	 edx, DWORD PTR [ebx]

; 1299 : 			if (obj->value != key)

  01d36	39 3a		 cmp	 DWORD PTR [edx], edi
  01d38	74 05		 je	 SHORT $LN19@test_hit

; 1300 : 				abort();

  01d3a	e8 00 00 00 00	 call	 _abort
$LN19@test_hit:

; 1289 : 
; 1290 : #ifdef USE_JUDY
; 1291 : 	START(DATA_JUDY) {

  01d3f	46		 inc	 esi
  01d40	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  01d46	72 c8		 jb	 SHORT $LL20@test_hit
$LN18@test_hit:

; 1301 : 		}
; 1302 : 	} STOP();

  01d48	8d 45 d4	 lea	 eax, DWORD PTR _t$216140[ebp]
  01d4b	50		 push	 eax
  01d4c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01d52	85 c0		 test	 eax, eax
  01d54	75 11		 jne	 SHORT $LN1111@test_hit
  01d56	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01d5a	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216132[ebp], xmm0
  01d5f	8b 5d d0	 mov	 ebx, DWORD PTR $T216132[ebp+4]
  01d62	8b 7d cc	 mov	 edi, DWORD PTR $T216132[ebp]
  01d65	eb 54		 jmp	 SHORT $LN1112@test_hit
$LN1111@test_hit:
  01d67	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01d6d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01d73	8b 4d d8	 mov	 ecx, DWORD PTR _t$216140[ebp+4]
  01d76	8b 55 d4	 mov	 edx, DWORD PTR _t$216140[ebp]
  01d79	57		 push	 edi
  01d7a	56		 push	 esi
  01d7b	51		 push	 ecx
  01d7c	52		 push	 edx
  01d7d	e8 00 00 00 00	 call	 __alldvrm
  01d82	6a 00		 push	 0
  01d84	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01d89	53		 push	 ebx
  01d8a	51		 push	 ecx
  01d8b	89 45 ec	 mov	 DWORD PTR tv3831[ebp], eax
  01d8e	89 55 f0	 mov	 DWORD PTR tv3831[ebp+4], edx
  01d91	e8 00 00 00 00	 call	 __allmul
  01d96	57		 push	 edi
  01d97	56		 push	 esi
  01d98	52		 push	 edx
  01d99	50		 push	 eax
  01d9a	e8 00 00 00 00	 call	 __alldiv
  01d9f	8b 4d ec	 mov	 ecx, DWORD PTR tv3831[ebp]
  01da2	6a 00		 push	 0
  01da4	8b f8		 mov	 edi, eax
  01da6	8b 45 f0	 mov	 eax, DWORD PTR tv3831[ebp+4]
  01da9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01dae	50		 push	 eax
  01daf	51		 push	 ecx
  01db0	8b da		 mov	 ebx, edx
  01db2	e8 00 00 00 00	 call	 __allmul
  01db7	03 f8		 add	 edi, eax
  01db9	13 da		 adc	 ebx, edx
$LN1112@test_hit:
  01dbb	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01dc1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01dc7	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01dcd	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01dd3	75 63		 jne	 SHORT $LN1109@test_hit
  01dd5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01ddc	75 24		 jne	 SHORT $LN1107@test_hit
  01dde	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01de4	6a 00		 push	 0
  01de6	52		 push	 edx
  01de7	53		 push	 ebx
  01de8	57		 push	 edi
  01de9	e8 00 00 00 00	 call	 __aulldiv
  01dee	50		 push	 eax
  01def	68 00 00 00 00	 push	 OFFSET $SG-102
  01df4	e8 00 00 00 00	 call	 _printf
  01df9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01dff	83 c4 08	 add	 esp, 8
$LN1107@test_hit:
  01e02	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01e07	6a 00		 push	 0
  01e09	50		 push	 eax
  01e0a	53		 push	 ebx
  01e0b	57		 push	 edi
  01e0c	e8 00 00 00 00	 call	 __aulldiv
  01e11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01e17	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01e1d	c1 e1 04	 shl	 ecx, 4
  01e20	03 ce		 add	 ecx, esi
  01e22	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01e25	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01e2b	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01e2e	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01e31	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1109@test_hit:

; 1303 : #endif
; 1304 : 
; 1305 : #ifdef USE_JUDYARRAY
; 1306 : 	START(DATA_JUDYARRAY) {

  01e38	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 10 ; the_start_data, 0000000aH
  01e42	83 fe 0a	 cmp	 esi, 10			; 0000000aH
  01e45	0f 85 fa 00 00
	00		 jne	 $LN11@test_hit
  01e4b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01e52	75 2f		 jne	 SHORT $LN1116@test_hit
  01e54	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  01e5a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01e5f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01e66	52		 push	 edx
  01e67	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01e6d	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01e74	51		 push	 ecx
  01e75	50		 push	 eax
  01e76	68 00 00 00 00	 push	 OFFSET $SG-101
  01e7b	e8 00 00 00 00	 call	 _printf
  01e80	83 c4 10	 add	 esp, 16			; 00000010H
$LN1116@test_hit:
  01e83	8d 4d dc	 lea	 ecx, DWORD PTR _t$216165[ebp]
  01e86	51		 push	 ecx
  01e87	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01e8d	85 c0		 test	 eax, eax
  01e8f	75 11		 jne	 SHORT $LN1122@test_hit
  01e91	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01e95	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216158[ebp], xmm0
  01e9a	8b 5d d0	 mov	 ebx, DWORD PTR $T216158[ebp+4]
  01e9d	8b 7d cc	 mov	 edi, DWORD PTR $T216158[ebp]
  01ea0	eb 54		 jmp	 SHORT $LN1123@test_hit
$LN1122@test_hit:
  01ea2	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01ea8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01eae	8b 55 e0	 mov	 edx, DWORD PTR _t$216165[ebp+4]
  01eb1	8b 45 dc	 mov	 eax, DWORD PTR _t$216165[ebp]
  01eb4	57		 push	 edi
  01eb5	56		 push	 esi
  01eb6	52		 push	 edx
  01eb7	50		 push	 eax
  01eb8	e8 00 00 00 00	 call	 __alldvrm
  01ebd	6a 00		 push	 0
  01ebf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ec4	53		 push	 ebx
  01ec5	51		 push	 ecx
  01ec6	89 45 ec	 mov	 DWORD PTR tv509[ebp], eax
  01ec9	89 55 f0	 mov	 DWORD PTR tv509[ebp+4], edx
  01ecc	e8 00 00 00 00	 call	 __allmul
  01ed1	57		 push	 edi
  01ed2	56		 push	 esi
  01ed3	52		 push	 edx
  01ed4	50		 push	 eax
  01ed5	e8 00 00 00 00	 call	 __alldiv
  01eda	8b 4d f0	 mov	 ecx, DWORD PTR tv509[ebp+4]
  01edd	6a 00		 push	 0
  01edf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ee4	8b da		 mov	 ebx, edx
  01ee6	8b 55 ec	 mov	 edx, DWORD PTR tv509[ebp]
  01ee9	51		 push	 ecx
  01eea	52		 push	 edx
  01eeb	8b f8		 mov	 edi, eax
  01eed	e8 00 00 00 00	 call	 __allmul
  01ef2	03 f8		 add	 edi, eax
  01ef4	13 da		 adc	 ebx, edx
$LN1123@test_hit:
  01ef6	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01efc	33 db		 xor	 ebx, ebx
  01efe	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  01f04	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01f0a	76 39		 jbe	 SHORT $LN11@test_hit
  01f0c	8b 75 08	 mov	 esi, DWORD PTR _SEARCH$[ebp]
  01f0f	90		 npad	 1
$LL13@test_hit:

; 1307 : 		judyvalue key = SEARCH[i] + DELTA;

  01f10	8b 04 9e	 mov	 eax, DWORD PTR [esi+ebx*4]

; 1308 : 		JudySlot* pvalue;
; 1309 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01f13	8d 4d f0	 lea	 ecx, DWORD PTR _key$151960[ebp]
  01f16	40		 inc	 eax
  01f17	51		 push	 ecx
  01f18	89 45 f0	 mov	 DWORD PTR _key$151960[ebp], eax
  01f1b	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01f20	8b f8		 mov	 edi, eax
  01f22	83 c4 04	 add	 esp, 4

; 1310 : 		if (!pvalue)

  01f25	85 ff		 test	 edi, edi
  01f27	75 05		 jne	 SHORT $LN10@test_hit

; 1311 : 			abort();

  01f29	e8 00 00 00 00	 call	 _abort
$LN10@test_hit:

; 1312 : 		if (dereference) {
; 1313 : 			struct judyarray_object* obj = *(struct judyarray_object**)pvalue;

  01f2e	8b 17		 mov	 edx, DWORD PTR [edi]

; 1314 : 			if (obj->value != key)

  01f30	8b 02		 mov	 eax, DWORD PTR [edx]
  01f32	3b 45 f0	 cmp	 eax, DWORD PTR _key$151960[ebp]
  01f35	74 05		 je	 SHORT $LN12@test_hit

; 1315 : 				abort();

  01f37	e8 00 00 00 00	 call	 _abort
$LN12@test_hit:

; 1303 : #endif
; 1304 : 
; 1305 : #ifdef USE_JUDYARRAY
; 1306 : 	START(DATA_JUDYARRAY) {

  01f3c	43		 inc	 ebx
  01f3d	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01f43	72 cb		 jb	 SHORT $LL13@test_hit
$LN11@test_hit:

; 1316 : 		}
; 1317 : 	} STOP();

  01f45	8d 4d cc	 lea	 ecx, DWORD PTR _t$216186[ebp]
  01f48	51		 push	 ecx
  01f49	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01f4f	85 c0		 test	 eax, eax
  01f51	75 11		 jne	 SHORT $LN1129@test_hit
  01f53	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01f57	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216178[ebp], xmm0
  01f5c	8b 5d d0	 mov	 ebx, DWORD PTR $T216178[ebp+4]
  01f5f	8b 7d cc	 mov	 edi, DWORD PTR $T216178[ebp]
  01f62	eb 54		 jmp	 SHORT $LN1130@test_hit
$LN1129@test_hit:
  01f64	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  01f6a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  01f70	8b 55 d0	 mov	 edx, DWORD PTR _t$216186[ebp+4]
  01f73	8b 45 cc	 mov	 eax, DWORD PTR _t$216186[ebp]
  01f76	57		 push	 edi
  01f77	56		 push	 esi
  01f78	52		 push	 edx
  01f79	50		 push	 eax
  01f7a	e8 00 00 00 00	 call	 __alldvrm
  01f7f	6a 00		 push	 0
  01f81	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01f86	53		 push	 ebx
  01f87	51		 push	 ecx
  01f88	89 45 ec	 mov	 DWORD PTR tv3225[ebp], eax
  01f8b	89 55 f0	 mov	 DWORD PTR tv3225[ebp+4], edx
  01f8e	e8 00 00 00 00	 call	 __allmul
  01f93	57		 push	 edi
  01f94	56		 push	 esi
  01f95	52		 push	 edx
  01f96	50		 push	 eax
  01f97	e8 00 00 00 00	 call	 __alldiv
  01f9c	8b 4d f0	 mov	 ecx, DWORD PTR tv3225[ebp+4]
  01f9f	6a 00		 push	 0
  01fa1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01fa6	8b da		 mov	 ebx, edx
  01fa8	8b 55 ec	 mov	 edx, DWORD PTR tv3225[ebp]
  01fab	51		 push	 ecx
  01fac	52		 push	 edx
  01fad	8b f8		 mov	 edi, eax
  01faf	e8 00 00 00 00	 call	 __allmul
  01fb4	03 f8		 add	 edi, eax
  01fb6	13 da		 adc	 ebx, edx
$LN1130@test_hit:
  01fb8	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  01fbe	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01fc4	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01fca	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01fd0	75 63		 jne	 SHORT $LN1127@test_hit
  01fd2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01fd9	75 23		 jne	 SHORT $LN1125@test_hit
  01fdb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01fe0	6a 00		 push	 0
  01fe2	50		 push	 eax
  01fe3	53		 push	 ebx
  01fe4	57		 push	 edi
  01fe5	e8 00 00 00 00	 call	 __aulldiv
  01fea	50		 push	 eax
  01feb	68 00 00 00 00	 push	 OFFSET $SG-102
  01ff0	e8 00 00 00 00	 call	 _printf
  01ff5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  01ffb	83 c4 08	 add	 esp, 8
$LN1125@test_hit:
  01ffe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  02004	6a 00		 push	 0
  02006	51		 push	 ecx
  02007	53		 push	 ebx
  02008	57		 push	 edi
  02009	e8 00 00 00 00	 call	 __aulldiv
  0200e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  02014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  0201a	c1 e2 04	 shl	 edx, 4
  0201d	03 d6		 add	 edx, esi
  0201f	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  02022	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  02025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0202b	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0202e	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN1127@test_hit:

; 1318 : #endif
; 1319 : 
; 1320 : 	START(DATA_NEDTRIE) {

  02035	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 6 ; the_start_data
  0203f	83 fe 06	 cmp	 esi, 6
  02042	0f 85 3e 01 00
	00		 jne	 $LN4@test_hit
  02048	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0204f	75 2e		 jne	 SHORT $LN1134@test_hit
  02051	a1 18 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  02056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0205c	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  02063	50		 push	 eax
  02064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  02069	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  02070	52		 push	 edx
  02071	51		 push	 ecx
  02072	68 00 00 00 00	 push	 OFFSET $SG-101
  02077	e8 00 00 00 00	 call	 _printf
  0207c	83 c4 10	 add	 esp, 16			; 00000010H
$LN1134@test_hit:
  0207f	8d 55 cc	 lea	 edx, DWORD PTR _t$216211[ebp]
  02082	52		 push	 edx
  02083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  02089	85 c0		 test	 eax, eax
  0208b	75 11		 jne	 SHORT $LN1140@test_hit
  0208d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02091	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216204[ebp], xmm0
  02096	8b 5d d0	 mov	 ebx, DWORD PTR $T216204[ebp+4]
  02099	8b 7d cc	 mov	 edi, DWORD PTR $T216204[ebp]
  0209c	eb 54		 jmp	 SHORT $LN1141@test_hit
$LN1140@test_hit:
  0209e	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  020a4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  020aa	8b 45 d0	 mov	 eax, DWORD PTR _t$216211[ebp+4]
  020ad	8b 4d cc	 mov	 ecx, DWORD PTR _t$216211[ebp]
  020b0	57		 push	 edi
  020b1	56		 push	 esi
  020b2	50		 push	 eax
  020b3	51		 push	 ecx
  020b4	e8 00 00 00 00	 call	 __alldvrm
  020b9	6a 00		 push	 0
  020bb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  020c0	53		 push	 ebx
  020c1	51		 push	 ecx
  020c2	89 45 ec	 mov	 DWORD PTR tv531[ebp], eax
  020c5	89 55 f0	 mov	 DWORD PTR tv531[ebp+4], edx
  020c8	e8 00 00 00 00	 call	 __allmul
  020cd	57		 push	 edi
  020ce	56		 push	 esi
  020cf	52		 push	 edx
  020d0	50		 push	 eax
  020d1	e8 00 00 00 00	 call	 __alldiv
  020d6	6a 00		 push	 0
  020d8	8b da		 mov	 ebx, edx
  020da	8b 55 f0	 mov	 edx, DWORD PTR tv531[ebp+4]
  020dd	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  020e2	8b f8		 mov	 edi, eax
  020e4	8b 45 ec	 mov	 eax, DWORD PTR tv531[ebp]
  020e7	52		 push	 edx
  020e8	50		 push	 eax
  020e9	e8 00 00 00 00	 call	 __allmul
  020ee	03 f8		 add	 edi, eax
  020f0	13 da		 adc	 ebx, edx
$LN1141@test_hit:
  020f2	33 f6		 xor	 esi, esi
  020f4	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  020fa	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  02100	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  02106	0f 86 7a 00 00
	00		 jbe	 $LN4@test_hit
$LN6@test_hit:

; 1321 : 		unsigned key = SEARCH[i] + DELTA;

  0210c	8b 4d 08	 mov	 ecx, DWORD PTR _SEARCH$[ebp]
  0210f	8b 3c b1	 mov	 edi, DWORD PTR [ecx+esi*4]
  02112	47		 inc	 edi

; 1322 : 		struct nedtrie_object key_obj;
; 1323 : 		struct nedtrie_object* obj;
; 1324 : 		key_obj.value = key;
; 1325 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  02113	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?nedtrie@@3Unedtrie_t@@A, 0
  0211a	75 04		 jne	 SHORT $LN1150@test_hit
$LN1212@test_hit:
  0211c	33 db		 xor	 ebx, ebx
  0211e	eb 4e		 jmp	 SHORT $LN1270@test_hit
$LN1150@test_hit:
  02120	8b d7		 mov	 edx, edi
  02122	83 ca 01	 or	 edx, 1
  02125	0f bd c2	 bsr	 eax, edx
  02128	8b c8		 mov	 ecx, eax
  0212a	89 45 f0	 mov	 DWORD PTR _bitpos$216237[ebp], eax
  0212d	8b 04 8d 04 00
	00 00		 mov	 eax, DWORD PTR ?nedtrie@@3Unedtrie_t@@A[ecx*4+4]
  02134	85 c0		 test	 eax, eax
  02136	75 04		 jne	 SHORT $LN1149@test_hit
  02138	33 db		 xor	 ebx, ebx
  0213a	eb 32		 jmp	 SHORT $LN1270@test_hit
$LN1149@test_hit:
  0213c	ba 01 00 00 00	 mov	 edx, 1
  02141	d3 e2		 shl	 edx, cl
  02143	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  02146	74 19		 je	 SHORT $end$216254
$LL1148@test_hit:
  02148	d1 ea		 shr	 edx, 1
  0214a	8b ca		 mov	 ecx, edx
  0214c	23 cf		 and	 ecx, edi
  0214e	f7 d9		 neg	 ecx
  02150	1b c9		 sbb	 ecx, ecx
  02152	f7 d9		 neg	 ecx
  02154	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  02158	85 c0		 test	 eax, eax
  0215a	74 c0		 je	 SHORT $LN1212@test_hit
  0215c	39 78 14	 cmp	 DWORD PTR [eax+20], edi
  0215f	75 e7		 jne	 SHORT $LL1148@test_hit
$end$216254:
  02161	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  02164	85 db		 test	 ebx, ebx
  02166	75 0b		 jne	 SHORT $LN3@test_hit
  02168	8b d8		 mov	 ebx, eax

; 1326 : 		if (!obj)

  0216a	85 db		 test	 ebx, ebx
  0216c	75 05		 jne	 SHORT $LN3@test_hit
$LN1270@test_hit:

; 1327 : 			abort();

  0216e	e8 00 00 00 00	 call	 _abort
$LN3@test_hit:

; 1328 : 		if (dereference) {
; 1329 : 			if (obj->value != key)

  02173	39 7b 14	 cmp	 DWORD PTR [ebx+20], edi
  02176	74 05		 je	 SHORT $LN5@test_hit

; 1330 : 				abort();

  02178	e8 00 00 00 00	 call	 _abort
$LN5@test_hit:

; 1318 : #endif
; 1319 : 
; 1320 : 	START(DATA_NEDTRIE) {

  0217d	46		 inc	 esi
  0217e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  02184	72 86		 jb	 SHORT $LN6@test_hit
$LN4@test_hit:

; 1331 : 		}
; 1332 : 	} STOP();

  02186	8d 55 cc	 lea	 edx, DWORD PTR _t$216272[ebp]
  02189	52		 push	 edx
  0218a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  02190	85 c0		 test	 eax, eax
  02192	75 11		 jne	 SHORT $LN1165@test_hit
  02194	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02198	66 0f 13 45 cc	 movlpd	 QWORD PTR $T216264[ebp], xmm0
  0219d	8b 7d d0	 mov	 edi, DWORD PTR $T216264[ebp+4]
  021a0	8b 75 cc	 mov	 esi, DWORD PTR $T216264[ebp]
  021a3	eb 54		 jmp	 SHORT $LN1166@test_hit
$LN1165@test_hit:
  021a5	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  021ab	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  021b1	8b 45 d0	 mov	 eax, DWORD PTR _t$216272[ebp+4]
  021b4	8b 4d cc	 mov	 ecx, DWORD PTR _t$216272[ebp]
  021b7	56		 push	 esi
  021b8	57		 push	 edi
  021b9	50		 push	 eax
  021ba	51		 push	 ecx
  021bb	e8 00 00 00 00	 call	 __alldvrm
  021c0	6a 00		 push	 0
  021c2	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  021c7	53		 push	 ebx
  021c8	51		 push	 ecx
  021c9	89 45 ec	 mov	 DWORD PTR tv3817[ebp], eax
  021cc	89 55 f0	 mov	 DWORD PTR tv3817[ebp+4], edx
  021cf	e8 00 00 00 00	 call	 __allmul
  021d4	56		 push	 esi
  021d5	57		 push	 edi
  021d6	52		 push	 edx
  021d7	50		 push	 eax
  021d8	e8 00 00 00 00	 call	 __alldiv
  021dd	6a 00		 push	 0
  021df	8b fa		 mov	 edi, edx
  021e1	8b 55 f0	 mov	 edx, DWORD PTR tv3817[ebp+4]
  021e4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  021e9	8b f0		 mov	 esi, eax
  021eb	8b 45 ec	 mov	 eax, DWORD PTR tv3817[ebp]
  021ee	52		 push	 edx
  021ef	50		 push	 eax
  021f0	e8 00 00 00 00	 call	 __allmul
  021f5	03 f0		 add	 esi, eax
  021f7	13 fa		 adc	 edi, edx
$LN1166@test_hit:
  021f9	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  021ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  02205	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  0220b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  02211	75 61		 jne	 SHORT $LN1163@test_hit
  02213	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0221a	75 1e		 jne	 SHORT $LN1161@test_hit
  0221c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  02222	6a 00		 push	 0
  02224	52		 push	 edx
  02225	57		 push	 edi
  02226	56		 push	 esi
  02227	e8 00 00 00 00	 call	 __aulldiv
  0222c	50		 push	 eax
  0222d	68 00 00 00 00	 push	 OFFSET $SG-102
  02232	e8 00 00 00 00	 call	 _printf
  02237	83 c4 08	 add	 esp, 8
$LN1161@test_hit:
  0223a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0223f	6a 00		 push	 0
  02241	50		 push	 eax
  02242	57		 push	 edi
  02243	56		 push	 esi
  02244	e8 00 00 00 00	 call	 __aulldiv
  02249	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0224f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  02255	c1 e1 04	 shl	 ecx, 4
  02258	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  0225e	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  02261	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  02267	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0226a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0226d	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1163@test_hit:

; 1333 : }

  02274	5f		 pop	 edi
  02275	5e		 pop	 esi
  02276	5b		 pop	 ebx
  02277	8b e5		 mov	 esp, ebp
  02279	5d		 pop	 ebp
  0227a	c3		 ret	 0
?test_hit@@YAXPAI@Z ENDP				; test_hit
_TEXT	ENDS
PUBLIC	_tommy_hashlin_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashlin.c
;	COMDAT _tommy_hashlin_remove
_TEXT	SEGMENT
_cmp_arg$ = 8						; size = 4
_tommy_hashlin_remove PROC				; COMDAT
; _hash$ = eax

; 295  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f8		 mov	 edi, eax

; 296  : 	tommy_hashlin_node** let_ptr = tommy_hashlin_bucket_ptr(hashlin, hash);

  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 ?tommy_hashlin_bucket_ptr@@YAPAPAUtommy_node_struct@@PAUtommy_hashlin_struct@@I@Z ; tommy_hashlin_bucket_ptr

; 297  : 	tommy_hashlin_node* i = *let_ptr;

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	8b f2		 mov	 esi, edx

; 298  : 
; 299  : 	while (i) {

  00013	85 f6		 test	 esi, esi
  00015	74 18		 je	 SHORT $LN2@tommy_hash@12
$LL3@tommy_hash@12:

; 300  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 301  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00017	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  0001a	75 0d		 jne	 SHORT $LN1@tommy_hash@12
  0001c	8b 5d 08	 mov	 ebx, DWORD PTR _cmp_arg$[ebp]
  0001f	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00022	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00024	3b 59 10	 cmp	 ebx, DWORD PTR [ecx+16]
  00027	74 0d		 je	 SHORT $LN18@tommy_hash@12
$LN1@tommy_hash@12:

; 309  : 		}
; 310  : 		i = i->next;

  00029	8b 36		 mov	 esi, DWORD PTR [esi]
  0002b	85 f6		 test	 esi, esi
  0002d	75 e8		 jne	 SHORT $LL3@tommy_hash@12
$LN2@tommy_hash@12:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 311  : 	}
; 312  : 
; 313  : 	return 0;

  00031	33 c0		 xor	 eax, eax
  00033	5b		 pop	 ebx

; 314  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN18@tommy_hash@12:

; 302  : 			tommy_list_remove_existing(let_ptr, i);

  00036	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 08		 je	 SHORT $LN12@tommy_hash@12
  0003c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  0003f	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  00042	eb 06		 jmp	 SHORT $LN11@tommy_hash@12
$LN12@tommy_hash@12:
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN11@tommy_hash@12:
  0004a	3b d6		 cmp	 edx, esi
  0004c	75 17		 jne	 SHORT $LN10@tommy_hash@12
  0004e	8b 16		 mov	 edx, DWORD PTR [esi]
  00050	89 10		 mov	 DWORD PTR [eax], edx

; 303  : 
; 304  : 			--hashlin->count;

  00052	ff 0d a0 00 00
	00		 dec	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 305  : 
; 306  : 			hashlin_shrink_step(hashlin);

  00058	e8 00 00 00 00	 call	 ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_shrink_step

; 307  : 
; 308  : 			return i->data;

  0005d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx

; 314  : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0

; 302  : 			tommy_list_remove_existing(let_ptr, i);

$LN10@tommy_hash@12:
  00065	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00068	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 303  : 
; 304  : 			--hashlin->count;

  0006c	ff 0d a0 00 00
	00		 dec	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160

; 305  : 
; 306  : 			hashlin_shrink_step(hashlin);

  00072	e8 00 00 00 00	 call	 ?hashlin_shrink_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_shrink_step

; 307  : 
; 308  : 			return i->data;

  00077	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx

; 314  : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_tommy_hashlin_remove ENDP
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.c
_TEXT	ENDS
;	COMDAT ?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z
_TEXT	SEGMENT
?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z PROC ; hashdyn_shrink_step, COMDAT

; 133  : 	/* shrink if less than 12.5% full */
; 134  : 	if (hashdyn->count <= hashdyn->bucket_max / 8 && hashdyn->bucket_bit > TOMMY_HASHDYN_BIT) {

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00005	c1 e8 03	 shr	 eax, 3
  00008	39 05 10 00 00
	00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0000e	77 12		 ja	 SHORT $LN1@hashdyn_sh
  00010	a1 04 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00015	83 f8 04	 cmp	 eax, 4
  00018	76 08		 jbe	 SHORT $LN1@hashdyn_sh

; 135  : 		tommy_hashdyn_resize(hashdyn, hashdyn->bucket_bit - 1);

  0001a	48		 dec	 eax
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  00021	59		 pop	 ecx
$LN1@hashdyn_sh:

; 136  : 	}
; 137  : }

  00022	c3		 ret	 0
?hashdyn_shrink_step@@YAXPAUtommy_hashdyn_struct@@@Z ENDP ; hashdyn_shrink_step
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z
_TEXT	SEGMENT
?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z PROC	; hashdyn_grow_step, COMDAT

; 122  : 	/* grow if more than 50% full */
; 123  : 	if (hashdyn->count >= hashdyn->bucket_max / 2) {

  00000	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00005	d1 e8		 shr	 eax, 1
  00007	39 05 10 00 00
	00		 cmp	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0000d	72 0e		 jb	 SHORT $LN1@hashdyn_gr

; 124  : 		tommy_hashdyn_resize(hashdyn, hashdyn->bucket_bit + 1);

  0000f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00015	41		 inc	 ecx
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0001c	59		 pop	 ecx
$LN1@hashdyn_gr:

; 125  : 	}
; 126  : }

  0001d	c3		 ret	 0
?hashdyn_grow_step@@YAXPAUtommy_hashdyn_struct@@@Z ENDP	; hashdyn_grow_step
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\sparsehash\densehashtable.h
_TEXT	ENDS
;	COMDAT ?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z
_TEXT	SEGMENT
$T216476 = -16						; size = 12
$T216474 = -16						; size = 12
_pos$ = -12						; size = 8
$T216472 = 8						; size = 4
_obj$ = 8						; size = 4
?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi

; 906  :   pair<iterator, bool> insert_noresize(const_reference obj) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _obj$[ebp]
  0000a	57		 push	 edi
  0000b	8b f8		 mov	 edi, eax

; 907  :     // First, double-check we're not inserting delkey or emptyval
; 908  :     assert((!settings.use_empty() || !equals(get_key(obj),
; 909  :                                              get_key(val_info.emptyval)))
; 910  :            && "Inserting the empty key");
; 911  :     assert((!settings.use_deleted() || !equals(get_key(obj), key_info.delkey))
; 912  :            && "Inserting the deleted key");
; 913  :     const pair<size_type,size_type> pos = find_position(get_key(obj));

  0000d	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000f	8d 4d f4	 lea	 ecx, DWORD PTR _pos$[ebp]
  00012	89 45 08	 mov	 DWORD PTR $T216472[ebp], eax
  00015	51		 push	 ecx
  00016	8d 45 08	 lea	 eax, DWORD PTR $T216472[ebp]
  00019	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 914  :     if ( pos.first != ILLEGAL_BUCKET) {      // object was already there

  0001e	8b 4d f4	 mov	 ecx, DWORD PTR _pos$[ebp]
  00021	83 f9 ff	 cmp	 ecx, -1
  00024	74 2c		 je	 SHORT $LN2@insert_nor

; 915  :       return pair<iterator,bool>(iterator(this, table + pos.first,
; 916  :                                           table + num_buckets, false),
; 917  :                                  false);          // false: we didn't insert

  00026	8b 47 34	 mov	 eax, DWORD PTR [edi+52]
  00029	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  0002c	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  0002f	89 7d f0	 mov	 DWORD PTR $T216474[ebp], edi
  00032	89 55 f4	 mov	 DWORD PTR $T216474[ebp+4], edx
  00035	f3 0f 7e 45 f0	 movq	 xmm0, QWORD PTR $T216474[ebp]
  0003a	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 918  :     } else {                                 // pos.second says where to put it
; 919  :       return pair<iterator,bool>(insert_at(obj, pos.second), true);

  0003d	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	c6 46 0c 00	 mov	 BYTE PTR [esi+12], 0
  00048	8b c6		 mov	 eax, esi

; 920  :     }
; 921  :   }

  0004a	5f		 pop	 edi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN2@insert_nor:

; 918  :     } else {                                 // pos.second says where to put it
; 919  :       return pair<iterator,bool>(insert_at(obj, pos.second), true);

  00052	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp+4]
  00055	53		 push	 ebx
  00056	8d 55 f0	 lea	 edx, DWORD PTR $T216476[ebp]
  00059	52		 push	 edx
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
  00061	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [eax]
  00065	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00068	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0

; 920  :     }
; 921  :   }

  0006c	5f		 pop	 edi
  0006d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00070	c6 46 0c 01	 mov	 BYTE PTR [esi+12], 1
  00074	8b c6		 mov	 eax, esi
  00076	5b		 pop	 ebx
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z
_TEXT	SEGMENT
$T216820 = -24						; size = 16
$T216822 = -20						; size = 12
_pos$ = -16						; size = 8
$T216821 = -8						; size = 8
$T216819 = -8						; size = 8
??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z PROC ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>, COMDAT
; _this$ = ecx
; _key$ = eax

; 960  :   value_type& find_or_insert(const key_type& key) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	8b f0		 mov	 esi, eax
  00009	57		 push	 edi

; 961  :     // First, double-check we're not inserting emptykey or delkey
; 962  :     assert((!settings.use_empty() || !equals(key, get_key(val_info.emptyval)))
; 963  :            && "Inserting the empty key");
; 964  :     assert((!settings.use_deleted() || !equals(key, key_info.delkey))
; 965  :            && "Inserting the deleted key");
; 966  :     const pair<size_type,size_type> pos = find_position(key);

  0000a	8d 45 f0	 lea	 eax, DWORD PTR _pos$[ebp]
  0000d	50		 push	 eax
  0000e	8b f9		 mov	 edi, ecx
  00010	8b c6		 mov	 eax, esi
  00012	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position

; 967  :     DefaultValue default_value;
; 968  :     if ( pos.first != ILLEGAL_BUCKET) {  // object was already there

  00017	8b 45 f0	 mov	 eax, DWORD PTR _pos$[ebp]
  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	74 0c		 je	 SHORT $LN4@find_or_in

; 969  :       return table[pos.first];

  0001f	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00022	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 975  :     }
; 976  :   }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@find_or_in:

; 970  :     } else if (resize_delta(1)) {        // needed to rehash to make room

  0002b	57		 push	 edi
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta

; 971  :       // Since we resized, we can't use pos, so recalculate where to insert.
; 972  :       return *insert_noresize(default_value(key)).first;

  00036	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T216819[ebp+4], 0
  0003d	84 c0		 test	 al, al
  0003f	74 1c		 je	 SHORT $LN2@find_or_in
  00041	8b 16		 mov	 edx, DWORD PTR [esi]
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T216819[ebp]
  00046	50		 push	 eax
  00047	8d 75 e8	 lea	 esi, DWORD PTR $T216820[ebp]
  0004a	8b c7		 mov	 eax, edi
  0004c	89 55 f8	 mov	 DWORD PTR $T216819[ebp], edx
  0004f	e8 00 00 00 00	 call	 ?insert_noresize@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$pair@U?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@_N@std@@ABU?$pair@$$CBIPAUgoogle_object@@@4@@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_noresize

; 973  :     } else {                             // no need to rehash, insert right here
; 974  :       return *insert_at(default_value(key), pos.second);

  00054	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 975  :     }
; 976  :   }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN2@find_or_in:

; 973  :     } else {                             // no need to rehash, insert right here
; 974  :       return *insert_at(default_value(key), pos.second);

  0005d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005f	8d 55 f8	 lea	 edx, DWORD PTR $T216821[ebp]
  00062	52		 push	 edx
  00063	8d 45 ec	 lea	 eax, DWORD PTR $T216822[ebp]
  00066	89 4d f8	 mov	 DWORD PTR $T216821[ebp], ecx
  00069	50		 push	 eax
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _pos$[ebp+4]
  0006d	8b cf		 mov	 ecx, edi
  0006f	e8 00 00 00 00	 call	 ?insert_at@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE?AU?$dense_hashtable_iterator@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@2@ABU?$pair@$$CBIPAUgoogle_object@@@std@@I@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::insert_at
  00074	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 975  :     }
; 976  :   }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ENDP ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark\lib\google\dense_hash_map
_TEXT	ENDS
;	COMDAT ??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z
_TEXT	SEGMENT
??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z PROC ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[], COMDAT
; _key$ = eax

; 265  :   data_type& operator[](const key_type& key) {       // This is our value-add!

  00000	51		 push	 ecx
  00001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash

; 266  :     // If key is in the hashtable, returns find(key)->second,
; 267  :     // otherwise returns insert(value_type(key, T()).first->second.
; 268  :     // Note it does not create an empty T unless the find fails.
; 269  :     return rep.template find_or_insert<DefaultValue>(key).second;

  00007	e8 00 00 00 00	 call	 ??$find_or_insert@UDefaultValue@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@QAEAAU?$pair@$$CBIPAUgoogle_object@@@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_or_insert<google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::DefaultValue>
  0000c	83 c0 04	 add	 eax, 4
  0000f	59		 pop	 ecx

; 270  :   }

  00010	c3		 ret	 0
??A?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@QAEAAPAUgoogle_object@@ABI@Z ENDP ; google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::operator[]
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\tommyhashdyn.c
;	COMDAT _tommy_hashdyn_remove
_TEXT	SEGMENT
_cmp_arg$ = 8						; size = 4
_tommy_hashdyn_remove PROC				; COMDAT
; _hash$ = eax

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 167  : 	unsigned pos = hash % hashdyn->bucket_max;

  00005	33 d2		 xor	 edx, edx
  00007	57		 push	 edi
  00008	8b f8		 mov	 edi, eax
  0000a	f7 35 08 00 00
	00		 div	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8

; 168  : 	tommy_hashdyn_node* i = hashdyn->bucket[pos];

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00015	8b 34 90	 mov	 esi, DWORD PTR [eax+edx*4]
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _cmp_arg$[ebp]
  0001b	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]

; 169  : 
; 170  : 	while (i) {

  0001e	85 f6		 test	 esi, esi
  00020	74 15		 je	 SHORT $LN2@tommy_hash@13
$LL3@tommy_hash@13:

; 171  : 		/* we first check if the hash matches, as in the same bucket we may have multiples hash values */
; 172  : 		if (i->key == hash && cmp(cmp_arg, i->data) == 0) {

  00022	39 7e 0c	 cmp	 DWORD PTR [esi+12], edi
  00025	75 0a		 jne	 SHORT $LN1@tommy_hash@13
  00027	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0002c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002f	74 0d		 je	 SHORT $LN21@tommy_hash@13
$LN1@tommy_hash@13:

; 180  : 		}
; 181  : 		i = i->next;

  00031	8b 36		 mov	 esi, DWORD PTR [esi]
  00033	85 f6		 test	 esi, esi
  00035	75 eb		 jne	 SHORT $LL3@tommy_hash@13
$LN2@tommy_hash@13:
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 182  : 	}
; 183  : 
; 184  : 	return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	5b		 pop	 ebx

; 185  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN21@tommy_hash@13:

; 173  : 			tommy_list_remove_existing(&hashdyn->bucket[pos], i);

  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	85 c0		 test	 eax, eax
  00044	74 08		 je	 SHORT $LN12@tommy_hash@13
  00046	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00049	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0004c	eb 06		 jmp	 SHORT $LN11@tommy_hash@13
$LN12@tommy_hash@13:
  0004e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00051	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN11@tommy_hash@13:
  00054	3b d6		 cmp	 edx, esi
  00056	75 06		 jne	 SHORT $LN10@tommy_hash@13
  00058	8b 16		 mov	 edx, DWORD PTR [esi]
  0005a	89 11		 mov	 DWORD PTR [ecx], edx
  0005c	eb 07		 jmp	 SHORT $LN9@tommy_hash@13
$LN10@tommy_hash@13:
  0005e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00061	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00063	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@tommy_hash@13:

; 174  : 
; 175  : 			--hashdyn->count;

  00065	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 176  : 
; 177  : 			hashdyn_shrink_step(hashdyn);

  0006a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00070	48		 dec	 eax
  00071	c1 ea 03	 shr	 edx, 3
  00074	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  00079	3b c2		 cmp	 eax, edx
  0007b	77 14		 ja	 SHORT $LN17@tommy_hash@13
  0007d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00082	83 f8 04	 cmp	 eax, 4
  00085	76 0a		 jbe	 SHORT $LN17@tommy_hash@13
  00087	48		 dec	 eax
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0008e	83 c4 04	 add	 esp, 4
$LN17@tommy_hash@13:

; 178  : 
; 179  : 			return i->data;

  00091	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx

; 185  : }

  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_tommy_hashdyn_remove ENDP
_TEXT	ENDS
PUBLIC	_tommy_hashdyn_insert
; Function compile flags: /Ogtp
;	COMDAT _tommy_hashdyn_insert
_TEXT	SEGMENT
_data$ = 8						; size = 4
_tommy_hashdyn_insert PROC				; COMDAT
; _node$ = eax
; _hash$ = esi

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 141  : 	unsigned pos = hash & hashdyn->bucket_mask;

  00003	8b 0d 0c 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12

; 142  : 
; 143  : 	tommy_list_insert_tail(&hashdyn->bucket[pos], node, data);

  00009	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  0000f	23 ce		 and	 ecx, esi
  00011	8d 14 8a	 lea	 edx, DWORD PTR [edx+ecx*4]
  00014	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00016	85 c9		 test	 ecx, ecx
  00018	74 16		 je	 SHORT $LN4@tommy_hash@14
  0001a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
  0002e	eb 0b		 jmp	 SHORT $LN11@tommy_hash@14
$LN4@tommy_hash@14:
  00030	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00039	89 02		 mov	 DWORD PTR [edx], eax
$LN11@tommy_hash@14:
  0003b	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  0003e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 144  : 
; 145  : 	node->key = hash;

  00041	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 146  : 
; 147  : 	++hashdyn->count;

  00044	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16

; 148  : 
; 149  : 	hashdyn_grow_step(hashdyn);

  00049	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  0004f	40		 inc	 eax
  00050	d1 e9		 shr	 ecx, 1
  00052	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  00057	3b c1		 cmp	 eax, ecx
  00059	72 10		 jb	 SHORT $LN13@tommy_hash@14
  0005b	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00061	42		 inc	 edx
  00062	52		 push	 edx
  00063	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  00068	83 c4 04	 add	 esp, 4
$LN13@tommy_hash@14:

; 150  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_tommy_hashdyn_insert ENDP
_TEXT	ENDS
PUBLIC	?test_remove@@YAXPAI@Z				; test_remove
; Function compile flags: /Ogtp
; File c:\users\am\desktop\tommyds-1.8\tommyds-1.8\benchmark.cc
;	COMDAT ?test_remove@@YAXPAI@Z
_TEXT	SEGMENT
_key_obj$153009 = -108					; size = 40
_J_Error$152983 = -92					; size = 24
_ptr$152811 = -84					; size = 16
$T217146 = -76						; size = 8
$T222248 = -68						; size = 8
$T222222 = -68						; size = 8
$T221842 = -68						; size = 8
$T221816 = -68						; size = 8
_result$221803 = -68					; size = 8
$T221454 = -68						; size = 8
$T221428 = -68						; size = 8
$T221059 = -68						; size = 8
$T219847 = -68						; size = 8
$T219821 = -68						; size = 8
_t$217530 = -68						; size = 8
_t$222230 = -60						; size = 8
_t$221827 = -60						; size = 8
_t$221436 = -60						; size = 8
_t$219832 = -60						; size = 8
_t$217506 = -60						; size = 8
_t$222255 = -52						; size = 8
_t$221851 = -52						; size = 8
_t$221461 = -52						; size = 8
_t$219856 = -52						; size = 8
_pos$218706 = -52					; size = 8
$T217524 = -52						; size = 8
$T217498 = -52						; size = 8
_t$217476 = -52						; size = 8
$T221765 = -44						; size = 16
tv4339 = -36						; size = 8
tv4322 = -36						; size = 8
tv4261 = -36						; size = 8
tv4206 = -36						; size = 8
tv4177 = -36						; size = 8
tv4157 = -36						; size = 8
tv3743 = -36						; size = 8
tv3595 = -36						; size = 8
tv2807 = -36						; size = 8
$T221060 = -36						; size = 8
tv2097 = -36						; size = 8
tv2049 = -36						; size = 8
tv1541 = -36						; size = 8
tv1423 = -36						; size = 8
tv1378 = -36						; size = 8
tv1357 = -36						; size = 8
tv1341 = -36						; size = 8
$T217469 = -36						; size = 8
$T217443 = -36						; size = 8
$T217417 = -36						; size = 8
_t$217424 = -36						; size = 8
$T217391 = -36						; size = 8
_t$217399 = -36						; size = 8
$T217365 = -36						; size = 8
_t$217372 = -36						; size = 8
$T217339 = -36						; size = 8
_t$217347 = -36						; size = 8
$T217315 = -36						; size = 8
_t$217322 = -36						; size = 8
$T217289 = -36						; size = 8
_t$217297 = -36						; size = 8
$T217265 = -36						; size = 8
_t$217272 = -36						; size = 8
tv430 = -36						; size = 8
tv402 = -36						; size = 8
tv192 = -36						; size = 8
_obj$152837 = -32					; size = 4
$T217151 = -32						; size = 4
_t$217451 = -28						; size = 8
__Where$222141 = -24					; size = 4
_ptr$152838 = -24					; size = 4
_key$152795 = -24					; size = 4
_obj$152784 = -24					; size = 4
_ptr$152797 = -16					; size = 8
$T222080 = -12						; size = 4
_key$152996 = -12					; size = 4
_key$152850 = -12					; size = 4
_key$152836 = -12					; size = 4
_key$152809 = -12					; size = 4
_key$152783 = -12					; size = 4
_obj$152773 = -12					; size = 4
_key$152740 = -12					; size = 4
_key$152729 = -12					; size = 4
_i$ = -8						; size = 4
_REMOVE$ = 8						; size = 4
?test_remove@@YAXPAI@Z PROC				; test_remove, COMDAT

; 1775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	53		 push	 ebx

; 1776 : 	unsigned i;
; 1777 : 
; 1778 : 	/* always dereference the object deleted. It has cache effect. */
; 1779 : 	/* considering we are dealing with objects, it makes sense to simulate an access to it */
; 1780 : 	/* even on deletion, because you have at least to do a free() call. */
; 1781 : 	/* this favorites data structures that store part of the information in the object itself */
; 1782 : 	const int dereference = 1;
; 1783 : 
; 1784 : 	const unsigned DELTA = 1;
; 1785 : 
; 1786 : 	START(DATA_TREE) {

  00007	b8 05 00 00 00	 mov	 eax, 5
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00013	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  00019	0f 85 b4 00 00
	00		 jne	 $LN177@test_remov
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00026	75 2e		 jne	 SHORT $LN187@test_remov
  00028	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00033	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003a	50		 push	 eax
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00040	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00047	52		 push	 edx
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET $SG-101
  0004e	e8 00 00 00 00	 call	 _printf
  00053	83 c4 10	 add	 esp, 16			; 00000010H
$LN187@test_remov:
  00056	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005b	33 db		 xor	 ebx, ebx
  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00062	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00068	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0006e	76 63		 jbe	 SHORT $LN177@test_remov
$LL179@test_remov:

; 1787 : 		unsigned key = REMOVE[i] + DELTA;

  00070	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00073	8b 3c 9a	 mov	 edi, DWORD PTR [edx+ebx*4]

; 1788 : 		struct rbt_object key_obj;
; 1789 : 		struct rbt_object* obj;
; 1790 : 		key_obj.value = key;
; 1791 : 		obj = rbt_search(&tree, &key_obj); 

  00076	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?tree@@3Urbtree_t@@A
  0007c	47		 inc	 edi
  0007d	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  00083	74 27		 je	 SHORT $LN1396@test_remov
$LL197@test_remov:
  00085	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00088	3b f8		 cmp	 edi, eax
  0008a	7c 14		 jl	 SHORT $LN1399@test_remov
  0008c	7e 16		 jle	 SHORT $LN196@test_remov
  0008e	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00091	83 e6 fe	 and	 esi, -2			; fffffffeH
$LN194@test_remov:
  00094	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  0009a	75 e9		 jne	 SHORT $LL197@test_remov
  0009c	33 f6		 xor	 esi, esi

; 1792 : 		if (!obj)

  0009e	eb 14		 jmp	 SHORT $LN1422@test_remov
$LN1399@test_remov:

; 1788 : 		struct rbt_object key_obj;
; 1789 : 		struct rbt_object* obj;
; 1790 : 		key_obj.value = key;
; 1791 : 		obj = rbt_search(&tree, &key_obj); 

  000a0	8b 36		 mov	 esi, DWORD PTR [esi]
  000a2	eb f0		 jmp	 SHORT $LN194@test_remov
$LN196@test_remov:
  000a4	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  000aa	75 04		 jne	 SHORT $LN193@test_remov
$LN1396@test_remov:
  000ac	33 f6		 xor	 esi, esi

; 1792 : 		if (!obj)

  000ae	eb 04		 jmp	 SHORT $LN1422@test_remov

; 1788 : 		struct rbt_object key_obj;
; 1789 : 		struct rbt_object* obj;
; 1790 : 		key_obj.value = key;
; 1791 : 		obj = rbt_search(&tree, &key_obj); 

$LN193@test_remov:

; 1792 : 		if (!obj)

  000b0	85 f6		 test	 esi, esi
  000b2	75 05		 jne	 SHORT $LN176@test_remov
$LN1422@test_remov:

; 1793 : 			abort();

  000b4	e8 00 00 00 00	 call	 _abort
$LN176@test_remov:

; 1794 : 		if (dereference) {
; 1795 : 			if (obj->value != key)

  000b9	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  000bc	74 05		 je	 SHORT $LN174@test_remov

; 1796 : 				abort();

  000be	e8 00 00 00 00	 call	 _abort
$LN174@test_remov:

; 1797 : 		}
; 1798 : 		rbt_remove(&tree, obj);

  000c3	8b d6		 mov	 edx, esi
  000c5	e8 00 00 00 00	 call	 ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_remove
  000ca	43		 inc	 ebx
  000cb	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  000d1	72 9d		 jb	 SHORT $LL179@test_remov
$LN177@test_remov:

; 1799 : 	} STOP();

  000d3	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1800 : 
; 1801 : 	START(DATA_HASHTABLE) {

  000d8	33 db		 xor	 ebx, ebx
  000da	89 1d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, ebx ; the_start_data
  000e0	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, ebx ; the_data
  000e6	0f 85 0e 01 00
	00		 jne	 $LN170@test_remov
  000ec	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, ebx ; the_log
  000f2	75 2e		 jne	 SHORT $LN204@test_remov
  000f4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  000ff	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00106	50		 push	 eax
  00107	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0010c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	68 00 00 00 00	 push	 OFFSET $SG-101
  0011a	e8 00 00 00 00	 call	 _printf
  0011f	83 c4 10	 add	 esp, 16			; 00000010H
$LN204@test_remov:
  00122	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00127	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0012c	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00132	89 5d f8	 mov	 DWORD PTR _i$[ebp], ebx
  00135	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0013b	0f 86 b9 00 00
	00		 jbe	 $LN170@test_remov
$LL172@test_remov:

; 1802 : 		unsigned key = REMOVE[i] + DELTA;

  00141	8b 55 08	 mov	 edx, DWORD PTR _REMOVE$[ebp]
  00144	8b 34 9a	 mov	 esi, DWORD PTR [edx+ebx*4]
  00147	46		 inc	 esi

; 1803 : 		unsigned hash_key = hash(key);

  00148	8b ce		 mov	 ecx, esi
  0014a	c1 e1 06	 shl	 ecx, 6
  0014d	8b c6		 mov	 eax, esi
  0014f	2b c1		 sub	 eax, ecx
  00151	8b d0		 mov	 edx, eax
  00153	c1 ea 11	 shr	 edx, 17			; 00000011H
  00156	33 c2		 xor	 eax, edx
  00158	8b c8		 mov	 ecx, eax
  0015a	c1 e1 09	 shl	 ecx, 9
  0015d	2b c1		 sub	 eax, ecx
  0015f	8b d0		 mov	 edx, eax
  00161	c1 e2 04	 shl	 edx, 4
  00164	33 c2		 xor	 eax, edx
  00166	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0016d	2b c1		 sub	 eax, ecx
  0016f	8b d0		 mov	 edx, eax
  00171	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00174	33 c2		 xor	 eax, edx

; 1804 : 		struct hashtable_object* obj;
; 1805 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  00176	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0017c	8b c8		 mov	 ecx, eax
  0017e	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00181	33 c8		 xor	 ecx, eax
  00183	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00188	23 c1		 and	 eax, ecx
  0018a	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  0018d	8b 02		 mov	 eax, DWORD PTR [edx]
  0018f	85 c0		 test	 eax, eax
  00191	74 13		 je	 SHORT $LN213@test_remov
$LL214@test_remov:
  00193	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  00196	75 08		 jne	 SHORT $LN212@test_remov
  00198	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
  0019b	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  0019e	74 0a		 je	 SHORT $LN1366@test_remov
$LN212@test_remov:
  001a0	8b 00		 mov	 eax, DWORD PTR [eax]
  001a2	85 c0		 test	 eax, eax
  001a4	75 ed		 jne	 SHORT $LL214@test_remov
$LN213@test_remov:
  001a6	33 ff		 xor	 edi, edi

; 1806 : 		if (!obj)

  001a8	eb 31		 jmp	 SHORT $LN1401@test_remov
$LN1366@test_remov:

; 1804 : 		struct hashtable_object* obj;
; 1805 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ac	8b 3a		 mov	 edi, DWORD PTR [edx]
  001ae	85 c9		 test	 ecx, ecx
  001b0	74 0b		 je	 SHORT $LN223@test_remov
  001b2	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  001b5	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  001b8	8b 5d f8	 mov	 ebx, DWORD PTR _i$[ebp]
  001bb	eb 06		 jmp	 SHORT $LN222@test_remov
$LN223@test_remov:
  001bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c0	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
$LN222@test_remov:
  001c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c5	3b f8		 cmp	 edi, eax
  001c7	74 03		 je	 SHORT $LN1470@test_remov
  001c9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
$LN1470@test_remov:
  001cc	89 0a		 mov	 DWORD PTR [edx], ecx
  001ce	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  001d4	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1806 : 		if (!obj)

  001d7	85 ff		 test	 edi, edi
  001d9	75 05		 jne	 SHORT $LN169@test_remov
$LN1401@test_remov:

; 1807 : 			abort();

  001db	e8 00 00 00 00	 call	 _abort
$LN169@test_remov:

; 1808 : 		if (dereference) {
; 1809 : 			if (obj->value != key)

  001e0	39 77 10	 cmp	 DWORD PTR [edi+16], esi
  001e3	74 05		 je	 SHORT $LN171@test_remov

; 1810 : 				abort();

  001e5	e8 00 00 00 00	 call	 _abort
$LN171@test_remov:

; 1800 : 
; 1801 : 	START(DATA_HASHTABLE) {

  001ea	43		 inc	 ebx
  001eb	89 5d f8	 mov	 DWORD PTR _i$[ebp], ebx
  001ee	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  001f4	0f 82 47 ff ff
	ff		 jb	 $LL172@test_remov
$LN170@test_remov:

; 1811 : 		}
; 1812 : 	} STOP();

  001fa	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1813 : 
; 1814 : 	START(DATA_HASHDYN) {

  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00209	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0020f	0f 85 32 01 00
	00		 jne	 $LN163@test_remov
  00215	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0021c	75 2f		 jne	 SHORT $LN228@test_remov
  0021e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  00224	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00229	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00230	52		 push	 edx
  00231	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00237	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0023e	51		 push	 ecx
  0023f	50		 push	 eax
  00240	68 00 00 00 00	 push	 OFFSET $SG-101
  00245	e8 00 00 00 00	 call	 _printf
  0024a	83 c4 10	 add	 esp, 16			; 00000010H
$LN228@test_remov:
  0024d	8d 4d dc	 lea	 ecx, DWORD PTR _t$217272[ebp]
  00250	51		 push	 ecx
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00257	85 c0		 test	 eax, eax
  00259	75 11		 jne	 SHORT $LN234@test_remov
  0025b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0025f	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217265[ebp], xmm0
  00264	8b 5d e0	 mov	 ebx, DWORD PTR $T217265[ebp+4]
  00267	8b 75 dc	 mov	 esi, DWORD PTR $T217265[ebp]
  0026a	eb 54		 jmp	 SHORT $LN235@test_remov
$LN234@test_remov:
  0026c	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00272	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00278	8b 55 e0	 mov	 edx, DWORD PTR _t$217272[ebp+4]
  0027b	8b 45 dc	 mov	 eax, DWORD PTR _t$217272[ebp]
  0027e	56		 push	 esi
  0027f	57		 push	 edi
  00280	52		 push	 edx
  00281	50		 push	 eax
  00282	e8 00 00 00 00	 call	 __alldvrm
  00287	6a 00		 push	 0
  00289	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0028e	53		 push	 ebx
  0028f	51		 push	 ecx
  00290	89 45 dc	 mov	 DWORD PTR tv192[ebp], eax
  00293	89 55 e0	 mov	 DWORD PTR tv192[ebp+4], edx
  00296	e8 00 00 00 00	 call	 __allmul
  0029b	56		 push	 esi
  0029c	57		 push	 edi
  0029d	52		 push	 edx
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 __alldiv
  002a4	8b 4d e0	 mov	 ecx, DWORD PTR tv192[ebp+4]
  002a7	6a 00		 push	 0
  002a9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  002ae	8b da		 mov	 ebx, edx
  002b0	8b 55 dc	 mov	 edx, DWORD PTR tv192[ebp]
  002b3	51		 push	 ecx
  002b4	52		 push	 edx
  002b5	8b f0		 mov	 esi, eax
  002b7	e8 00 00 00 00	 call	 __allmul
  002bc	03 f0		 add	 esi, eax
  002be	13 da		 adc	 ebx, edx
$LN235@test_remov:
  002c0	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  002c6	33 db		 xor	 ebx, ebx
  002c8	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  002ce	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  002d4	76 71		 jbe	 SHORT $LN163@test_remov
  002d6	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
  002d9	8d a4 24 00 00
	00 00		 npad	 7
$LL165@test_remov:

; 1815 : 		unsigned key = REMOVE[i] + DELTA;

  002e0	8b 0c 9f	 mov	 ecx, DWORD PTR [edi+ebx*4]
  002e3	41		 inc	 ecx

; 1816 : 		unsigned hash_key = hash(key);

  002e4	8b c1		 mov	 eax, ecx
  002e6	c1 e0 06	 shl	 eax, 6
  002e9	89 4d f4	 mov	 DWORD PTR _key$152729[ebp], ecx
  002ec	2b c8		 sub	 ecx, eax
  002ee	8b d1		 mov	 edx, ecx
  002f0	c1 ea 11	 shr	 edx, 17			; 00000011H
  002f3	33 ca		 xor	 ecx, edx
  002f5	8b c1		 mov	 eax, ecx
  002f7	c1 e0 09	 shl	 eax, 9
  002fa	2b c8		 sub	 ecx, eax
  002fc	8b d1		 mov	 edx, ecx
  002fe	c1 e2 04	 shl	 edx, 4
  00301	33 ca		 xor	 ecx, edx
  00303	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0030a	2b c8		 sub	 ecx, eax
  0030c	8b d1		 mov	 edx, ecx
  0030e	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00311	33 ca		 xor	 ecx, edx
  00313	8b c1		 mov	 eax, ecx
  00315	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00318	33 c1		 xor	 eax, ecx

; 1817 : 		struct hashtable_object* obj;
; 1818 : 		obj = (struct hashtable_object*)tommy_hashdyn_remove(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  0031a	8d 4d f4	 lea	 ecx, DWORD PTR _key$152729[ebp]
  0031d	51		 push	 ecx
  0031e	e8 00 00 00 00	 call	 _tommy_hashdyn_remove
  00323	8b f0		 mov	 esi, eax
  00325	83 c4 04	 add	 esp, 4

; 1819 : 		if (!obj)

  00328	85 f6		 test	 esi, esi
  0032a	75 05		 jne	 SHORT $LN162@test_remov

; 1820 : 			abort();

  0032c	e8 00 00 00 00	 call	 _abort
$LN162@test_remov:

; 1821 : 		if (dereference) {
; 1822 : 			if (obj->value != key)

  00331	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00334	3b 55 f4	 cmp	 edx, DWORD PTR _key$152729[ebp]
  00337	74 05		 je	 SHORT $LN164@test_remov

; 1823 : 				abort();

  00339	e8 00 00 00 00	 call	 _abort
$LN164@test_remov:

; 1813 : 
; 1814 : 	START(DATA_HASHDYN) {

  0033e	43		 inc	 ebx
  0033f	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00345	72 99		 jb	 SHORT $LL165@test_remov
$LN163@test_remov:

; 1824 : 		}
; 1825 : 	} STOP();

  00347	8d 45 dc	 lea	 eax, DWORD PTR _t$217297[ebp]
  0034a	50		 push	 eax
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00351	85 c0		 test	 eax, eax
  00353	75 11		 jne	 SHORT $LN243@test_remov
  00355	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00359	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217289[ebp], xmm0
  0035e	8b 5d e0	 mov	 ebx, DWORD PTR $T217289[ebp+4]
  00361	8b 75 dc	 mov	 esi, DWORD PTR $T217289[ebp]
  00364	eb 54		 jmp	 SHORT $LN244@test_remov
$LN243@test_remov:
  00366	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0036c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00372	8b 4d e0	 mov	 ecx, DWORD PTR _t$217297[ebp+4]
  00375	8b 55 dc	 mov	 edx, DWORD PTR _t$217297[ebp]
  00378	56		 push	 esi
  00379	57		 push	 edi
  0037a	51		 push	 ecx
  0037b	52		 push	 edx
  0037c	e8 00 00 00 00	 call	 __alldvrm
  00381	6a 00		 push	 0
  00383	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00388	53		 push	 ebx
  00389	51		 push	 ecx
  0038a	89 45 dc	 mov	 DWORD PTR tv3743[ebp], eax
  0038d	89 55 e0	 mov	 DWORD PTR tv3743[ebp+4], edx
  00390	e8 00 00 00 00	 call	 __allmul
  00395	56		 push	 esi
  00396	57		 push	 edi
  00397	52		 push	 edx
  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 __alldiv
  0039e	8b 4d dc	 mov	 ecx, DWORD PTR tv3743[ebp]
  003a1	6a 00		 push	 0
  003a3	8b f0		 mov	 esi, eax
  003a5	8b 45 e0	 mov	 eax, DWORD PTR tv3743[ebp+4]
  003a8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  003ad	50		 push	 eax
  003ae	51		 push	 ecx
  003af	8b da		 mov	 ebx, edx
  003b1	e8 00 00 00 00	 call	 __allmul
  003b6	03 f0		 add	 esi, eax
  003b8	13 da		 adc	 ebx, edx
$LN244@test_remov:
  003ba	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  003c0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  003c6	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  003cc	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  003d2	75 63		 jne	 SHORT $LN241@test_remov
  003d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  003db	75 24		 jne	 SHORT $LN239@test_remov
  003dd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  003e3	6a 00		 push	 0
  003e5	52		 push	 edx
  003e6	53		 push	 ebx
  003e7	56		 push	 esi
  003e8	e8 00 00 00 00	 call	 __aulldiv
  003ed	50		 push	 eax
  003ee	68 00 00 00 00	 push	 OFFSET $SG-102
  003f3	e8 00 00 00 00	 call	 _printf
  003f8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  003fe	83 c4 08	 add	 esp, 8
$LN239@test_remov:
  00401	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00406	6a 00		 push	 0
  00408	50		 push	 eax
  00409	53		 push	 ebx
  0040a	56		 push	 esi
  0040b	e8 00 00 00 00	 call	 __aulldiv
  00410	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00416	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0041c	c1 e1 04	 shl	 ecx, 4
  0041f	03 cf		 add	 ecx, edi
  00421	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00424	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0042a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0042d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00430	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN241@test_remov:

; 1826 : 
; 1827 : 	START(DATA_HASHLIN) {

  00437	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 2 ; the_start_data
  00441	83 ff 02	 cmp	 edi, 2
  00444	0f 85 2d 01 00
	00		 jne	 $LN156@test_remov
  0044a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00451	75 2f		 jne	 SHORT $LN248@test_remov
  00453	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00459	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0045e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00465	52		 push	 edx
  00466	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0046c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00473	51		 push	 ecx
  00474	50		 push	 eax
  00475	68 00 00 00 00	 push	 OFFSET $SG-101
  0047a	e8 00 00 00 00	 call	 _printf
  0047f	83 c4 10	 add	 esp, 16			; 00000010H
$LN248@test_remov:
  00482	8d 4d dc	 lea	 ecx, DWORD PTR _t$217322[ebp]
  00485	51		 push	 ecx
  00486	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0048c	85 c0		 test	 eax, eax
  0048e	75 11		 jne	 SHORT $LN254@test_remov
  00490	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00494	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217315[ebp], xmm0
  00499	8b 5d e0	 mov	 ebx, DWORD PTR $T217315[ebp+4]
  0049c	8b 75 dc	 mov	 esi, DWORD PTR $T217315[ebp]
  0049f	eb 54		 jmp	 SHORT $LN255@test_remov
$LN254@test_remov:
  004a1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  004a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  004ad	8b 55 e0	 mov	 edx, DWORD PTR _t$217322[ebp+4]
  004b0	8b 45 dc	 mov	 eax, DWORD PTR _t$217322[ebp]
  004b3	56		 push	 esi
  004b4	57		 push	 edi
  004b5	52		 push	 edx
  004b6	50		 push	 eax
  004b7	e8 00 00 00 00	 call	 __alldvrm
  004bc	6a 00		 push	 0
  004be	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004c3	53		 push	 ebx
  004c4	51		 push	 ecx
  004c5	89 45 dc	 mov	 DWORD PTR tv1341[ebp], eax
  004c8	89 55 e0	 mov	 DWORD PTR tv1341[ebp+4], edx
  004cb	e8 00 00 00 00	 call	 __allmul
  004d0	56		 push	 esi
  004d1	57		 push	 edi
  004d2	52		 push	 edx
  004d3	50		 push	 eax
  004d4	e8 00 00 00 00	 call	 __alldiv
  004d9	8b 4d e0	 mov	 ecx, DWORD PTR tv1341[ebp+4]
  004dc	6a 00		 push	 0
  004de	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004e3	8b da		 mov	 ebx, edx
  004e5	8b 55 dc	 mov	 edx, DWORD PTR tv1341[ebp]
  004e8	51		 push	 ecx
  004e9	52		 push	 edx
  004ea	8b f0		 mov	 esi, eax
  004ec	e8 00 00 00 00	 call	 __allmul
  004f1	03 f0		 add	 esi, eax
  004f3	13 da		 adc	 ebx, edx
$LN255@test_remov:
  004f5	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  004fb	33 db		 xor	 ebx, ebx
  004fd	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00503	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00509	76 6c		 jbe	 SHORT $LN156@test_remov
  0050b	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
  0050e	8b ff		 npad	 2
$LL158@test_remov:

; 1828 : 		unsigned key = REMOVE[i] + DELTA;

  00510	8b 0c 9f	 mov	 ecx, DWORD PTR [edi+ebx*4]
  00513	41		 inc	 ecx

; 1829 : 		unsigned hash_key = hash(key);

  00514	8b c1		 mov	 eax, ecx
  00516	c1 e0 06	 shl	 eax, 6
  00519	89 4d f4	 mov	 DWORD PTR _key$152740[ebp], ecx
  0051c	2b c8		 sub	 ecx, eax
  0051e	8b d1		 mov	 edx, ecx
  00520	c1 ea 11	 shr	 edx, 17			; 00000011H
  00523	33 ca		 xor	 ecx, edx
  00525	8b c1		 mov	 eax, ecx
  00527	c1 e0 09	 shl	 eax, 9
  0052a	2b c8		 sub	 ecx, eax
  0052c	8b d1		 mov	 edx, ecx
  0052e	c1 e2 04	 shl	 edx, 4
  00531	33 ca		 xor	 ecx, edx
  00533	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0053a	2b c8		 sub	 ecx, eax
  0053c	8b d1		 mov	 edx, ecx
  0053e	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00541	33 ca		 xor	 ecx, edx
  00543	8b c1		 mov	 eax, ecx
  00545	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  00548	33 c1		 xor	 eax, ecx

; 1830 : 		struct hashtable_object* obj;
; 1831 : 		obj = (struct hashtable_object*)tommy_hashlin_remove(&hashlin, tommy_hashtable_compare, &key, hash_key);

  0054a	8d 4d f4	 lea	 ecx, DWORD PTR _key$152740[ebp]
  0054d	51		 push	 ecx
  0054e	e8 00 00 00 00	 call	 _tommy_hashlin_remove
  00553	8b f0		 mov	 esi, eax
  00555	83 c4 04	 add	 esp, 4

; 1832 : 		if (!obj)

  00558	85 f6		 test	 esi, esi
  0055a	75 05		 jne	 SHORT $LN155@test_remov

; 1833 : 			abort();

  0055c	e8 00 00 00 00	 call	 _abort
$LN155@test_remov:

; 1834 : 		if (dereference) {
; 1835 : 			if (obj->value != key)

  00561	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00564	3b 55 f4	 cmp	 edx, DWORD PTR _key$152740[ebp]
  00567	74 05		 je	 SHORT $LN157@test_remov

; 1836 : 				abort();

  00569	e8 00 00 00 00	 call	 _abort
$LN157@test_remov:

; 1826 : 
; 1827 : 	START(DATA_HASHLIN) {

  0056e	43		 inc	 ebx
  0056f	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00575	72 99		 jb	 SHORT $LL158@test_remov
$LN156@test_remov:

; 1837 : 		}
; 1838 : 	} STOP();

  00577	8d 45 dc	 lea	 eax, DWORD PTR _t$217347[ebp]
  0057a	50		 push	 eax
  0057b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00581	85 c0		 test	 eax, eax
  00583	75 11		 jne	 SHORT $LN263@test_remov
  00585	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00589	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217339[ebp], xmm0
  0058e	8b 5d e0	 mov	 ebx, DWORD PTR $T217339[ebp+4]
  00591	8b 75 dc	 mov	 esi, DWORD PTR $T217339[ebp]
  00594	eb 54		 jmp	 SHORT $LN264@test_remov
$LN263@test_remov:
  00596	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0059c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  005a2	8b 4d e0	 mov	 ecx, DWORD PTR _t$217347[ebp+4]
  005a5	8b 55 dc	 mov	 edx, DWORD PTR _t$217347[ebp]
  005a8	56		 push	 esi
  005a9	57		 push	 edi
  005aa	51		 push	 ecx
  005ab	52		 push	 edx
  005ac	e8 00 00 00 00	 call	 __alldvrm
  005b1	6a 00		 push	 0
  005b3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005b8	53		 push	 ebx
  005b9	51		 push	 ecx
  005ba	89 45 dc	 mov	 DWORD PTR tv1357[ebp], eax
  005bd	89 55 e0	 mov	 DWORD PTR tv1357[ebp+4], edx
  005c0	e8 00 00 00 00	 call	 __allmul
  005c5	56		 push	 esi
  005c6	57		 push	 edi
  005c7	52		 push	 edx
  005c8	50		 push	 eax
  005c9	e8 00 00 00 00	 call	 __alldiv
  005ce	8b 4d dc	 mov	 ecx, DWORD PTR tv1357[ebp]
  005d1	6a 00		 push	 0
  005d3	8b f0		 mov	 esi, eax
  005d5	8b 45 e0	 mov	 eax, DWORD PTR tv1357[ebp+4]
  005d8	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  005dd	50		 push	 eax
  005de	51		 push	 ecx
  005df	8b da		 mov	 ebx, edx
  005e1	e8 00 00 00 00	 call	 __allmul
  005e6	03 f0		 add	 esi, eax
  005e8	13 da		 adc	 ebx, edx
$LN264@test_remov:
  005ea	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  005f0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  005f6	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  005fc	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00602	75 63		 jne	 SHORT $LN261@test_remov
  00604	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0060b	75 24		 jne	 SHORT $LN259@test_remov
  0060d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00613	6a 00		 push	 0
  00615	52		 push	 edx
  00616	53		 push	 ebx
  00617	56		 push	 esi
  00618	e8 00 00 00 00	 call	 __aulldiv
  0061d	50		 push	 eax
  0061e	68 00 00 00 00	 push	 OFFSET $SG-102
  00623	e8 00 00 00 00	 call	 _printf
  00628	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  0062e	83 c4 08	 add	 esp, 8
$LN259@test_remov:
  00631	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00636	6a 00		 push	 0
  00638	50		 push	 eax
  00639	53		 push	 ebx
  0063a	56		 push	 esi
  0063b	e8 00 00 00 00	 call	 __aulldiv
  00640	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00646	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0064c	c1 e1 04	 shl	 ecx, 4
  0064f	03 cf		 add	 ecx, edi
  00651	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00654	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0065a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0065d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00660	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN261@test_remov:

; 1839 : 
; 1840 : 	START(DATA_TRIE) {

  00667	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 3 ; the_start_data
  00671	83 ff 03	 cmp	 edi, 3
  00674	0f 85 0d 01 00
	00		 jne	 $LN149@test_remov
  0067a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00681	75 2f		 jne	 SHORT $LN268@test_remov
  00683	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  00689	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0068e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00695	52		 push	 edx
  00696	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0069c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  006a3	51		 push	 ecx
  006a4	50		 push	 eax
  006a5	68 00 00 00 00	 push	 OFFSET $SG-101
  006aa	e8 00 00 00 00	 call	 _printf
  006af	83 c4 10	 add	 esp, 16			; 00000010H
$LN268@test_remov:
  006b2	8d 4d dc	 lea	 ecx, DWORD PTR _t$217372[ebp]
  006b5	51		 push	 ecx
  006b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  006bc	85 c0		 test	 eax, eax
  006be	75 11		 jne	 SHORT $LN274@test_remov
  006c0	66 0f 57 c0	 xorpd	 xmm0, xmm0
  006c4	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217365[ebp], xmm0
  006c9	8b 5d e0	 mov	 ebx, DWORD PTR $T217365[ebp+4]
  006cc	8b 75 dc	 mov	 esi, DWORD PTR $T217365[ebp]
  006cf	eb 54		 jmp	 SHORT $LN275@test_remov
$LN274@test_remov:
  006d1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  006d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  006dd	8b 55 e0	 mov	 edx, DWORD PTR _t$217372[ebp+4]
  006e0	8b 45 dc	 mov	 eax, DWORD PTR _t$217372[ebp]
  006e3	56		 push	 esi
  006e4	57		 push	 edi
  006e5	52		 push	 edx
  006e6	50		 push	 eax
  006e7	e8 00 00 00 00	 call	 __alldvrm
  006ec	6a 00		 push	 0
  006ee	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  006f3	53		 push	 ebx
  006f4	51		 push	 ecx
  006f5	89 45 dc	 mov	 DWORD PTR tv1378[ebp], eax
  006f8	89 55 e0	 mov	 DWORD PTR tv1378[ebp+4], edx
  006fb	e8 00 00 00 00	 call	 __allmul
  00700	56		 push	 esi
  00701	57		 push	 edi
  00702	52		 push	 edx
  00703	50		 push	 eax
  00704	e8 00 00 00 00	 call	 __alldiv
  00709	8b 4d e0	 mov	 ecx, DWORD PTR tv1378[ebp+4]
  0070c	6a 00		 push	 0
  0070e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00713	8b da		 mov	 ebx, edx
  00715	8b 55 dc	 mov	 edx, DWORD PTR tv1378[ebp]
  00718	51		 push	 ecx
  00719	52		 push	 edx
  0071a	8b f0		 mov	 esi, eax
  0071c	e8 00 00 00 00	 call	 __allmul
  00721	03 f0		 add	 esi, eax
  00723	13 da		 adc	 ebx, edx
$LN275@test_remov:
  00725	33 ff		 xor	 edi, edi
  00727	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0072d	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00733	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00739	76 4c		 jbe	 SHORT $LN149@test_remov
  0073b	eb 03 8d 49 00	 npad	 5
$LL151@test_remov:

; 1841 : 		unsigned key = REMOVE[i] + DELTA;

  00740	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00743	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  00746	46		 inc	 esi

; 1842 : 		struct trie_object* obj;
; 1843 : 		obj = (struct trie_object*)tommy_trie_remove(&trie, key);

  00747	8b ce		 mov	 ecx, esi
  00749	c1 e9 1c	 shr	 ecx, 28			; 0000001cH
  0074c	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[ecx*4]
  00753	8b c6		 mov	 eax, esi
  00755	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing
  0075a	85 c0		 test	 eax, eax
  0075c	75 04		 jne	 SHORT $LN277@test_remov
  0075e	33 db		 xor	 ebx, ebx
  00760	eb 0d		 jmp	 SHORT $LN1405@test_remov
$LN277@test_remov:
  00762	ff 0d 40 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  00768	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1844 : 		if (!obj)

  0076b	85 db		 test	 ebx, ebx
  0076d	75 05		 jne	 SHORT $LN148@test_remov
$LN1405@test_remov:

; 1845 : 			abort();

  0076f	e8 00 00 00 00	 call	 _abort
$LN148@test_remov:

; 1846 : 		if (dereference) {
; 1847 : 			if (obj->value != key)

  00774	39 73 10	 cmp	 DWORD PTR [ebx+16], esi
  00777	74 05		 je	 SHORT $LN150@test_remov

; 1848 : 				abort();

  00779	e8 00 00 00 00	 call	 _abort
$LN150@test_remov:

; 1839 : 
; 1840 : 	START(DATA_TRIE) {

  0077e	47		 inc	 edi
  0077f	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00785	72 b9		 jb	 SHORT $LL151@test_remov
$LN149@test_remov:

; 1849 : 		}
; 1850 : 	} STOP();

  00787	8d 55 dc	 lea	 edx, DWORD PTR _t$217399[ebp]
  0078a	52		 push	 edx
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00791	85 c0		 test	 eax, eax
  00793	75 11		 jne	 SHORT $LN284@test_remov
  00795	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00799	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217391[ebp], xmm0
  0079e	8b 5d e0	 mov	 ebx, DWORD PTR $T217391[ebp+4]
  007a1	8b 75 dc	 mov	 esi, DWORD PTR $T217391[ebp]
  007a4	eb 54		 jmp	 SHORT $LN285@test_remov
$LN284@test_remov:
  007a6	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  007ac	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  007b2	8b 45 e0	 mov	 eax, DWORD PTR _t$217399[ebp+4]
  007b5	8b 4d dc	 mov	 ecx, DWORD PTR _t$217399[ebp]
  007b8	56		 push	 esi
  007b9	57		 push	 edi
  007ba	50		 push	 eax
  007bb	51		 push	 ecx
  007bc	e8 00 00 00 00	 call	 __alldvrm
  007c1	6a 00		 push	 0
  007c3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007c8	53		 push	 ebx
  007c9	51		 push	 ecx
  007ca	89 45 dc	 mov	 DWORD PTR tv1423[ebp], eax
  007cd	89 55 e0	 mov	 DWORD PTR tv1423[ebp+4], edx
  007d0	e8 00 00 00 00	 call	 __allmul
  007d5	56		 push	 esi
  007d6	57		 push	 edi
  007d7	52		 push	 edx
  007d8	50		 push	 eax
  007d9	e8 00 00 00 00	 call	 __alldiv
  007de	6a 00		 push	 0
  007e0	8b da		 mov	 ebx, edx
  007e2	8b 55 e0	 mov	 edx, DWORD PTR tv1423[ebp+4]
  007e5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007ea	8b f0		 mov	 esi, eax
  007ec	8b 45 dc	 mov	 eax, DWORD PTR tv1423[ebp]
  007ef	52		 push	 edx
  007f0	50		 push	 eax
  007f1	e8 00 00 00 00	 call	 __allmul
  007f6	03 f0		 add	 esi, eax
  007f8	13 da		 adc	 ebx, edx
$LN285@test_remov:
  007fa	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00800	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00806	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0080c	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00812	75 64		 jne	 SHORT $LN282@test_remov
  00814	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0081b	75 24		 jne	 SHORT $LN280@test_remov
  0081d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00823	6a 00		 push	 0
  00825	51		 push	 ecx
  00826	53		 push	 ebx
  00827	56		 push	 esi
  00828	e8 00 00 00 00	 call	 __aulldiv
  0082d	50		 push	 eax
  0082e	68 00 00 00 00	 push	 OFFSET $SG-102
  00833	e8 00 00 00 00	 call	 _printf
  00838	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  0083e	83 c4 08	 add	 esp, 8
$LN280@test_remov:
  00841	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00847	6a 00		 push	 0
  00849	52		 push	 edx
  0084a	53		 push	 ebx
  0084b	56		 push	 esi
  0084c	e8 00 00 00 00	 call	 __aulldiv
  00851	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00857	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0085d	c1 e1 04	 shl	 ecx, 4
  00860	03 cf		 add	 ecx, edi
  00862	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00865	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0086b	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0086e	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00871	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN282@test_remov:

; 1851 : 
; 1852 : 	START(DATA_TRIE_INPLACE) {

  00878	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 4 ; the_start_data
  00882	83 ff 04	 cmp	 edi, 4
  00885	0f 85 10 01 00
	00		 jne	 $LN142@test_remov
  0088b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00892	75 2f		 jne	 SHORT $LN289@test_remov
  00894	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  0089a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0089f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  008a6	52		 push	 edx
  008a7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  008ad	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  008b4	51		 push	 ecx
  008b5	50		 push	 eax
  008b6	68 00 00 00 00	 push	 OFFSET $SG-101
  008bb	e8 00 00 00 00	 call	 _printf
  008c0	83 c4 10	 add	 esp, 16			; 00000010H
$LN289@test_remov:
  008c3	8d 4d dc	 lea	 ecx, DWORD PTR _t$217424[ebp]
  008c6	51		 push	 ecx
  008c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  008cd	85 c0		 test	 eax, eax
  008cf	75 11		 jne	 SHORT $LN295@test_remov
  008d1	66 0f 57 c0	 xorpd	 xmm0, xmm0
  008d5	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217417[ebp], xmm0
  008da	8b 5d e0	 mov	 ebx, DWORD PTR $T217417[ebp+4]
  008dd	8b 75 dc	 mov	 esi, DWORD PTR $T217417[ebp]
  008e0	eb 54		 jmp	 SHORT $LN296@test_remov
$LN295@test_remov:
  008e2	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  008e8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  008ee	8b 55 e0	 mov	 edx, DWORD PTR _t$217424[ebp+4]
  008f1	8b 45 dc	 mov	 eax, DWORD PTR _t$217424[ebp]
  008f4	56		 push	 esi
  008f5	57		 push	 edi
  008f6	52		 push	 edx
  008f7	50		 push	 eax
  008f8	e8 00 00 00 00	 call	 __alldvrm
  008fd	6a 00		 push	 0
  008ff	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00904	53		 push	 ebx
  00905	51		 push	 ecx
  00906	89 45 dc	 mov	 DWORD PTR tv1541[ebp], eax
  00909	89 55 e0	 mov	 DWORD PTR tv1541[ebp+4], edx
  0090c	e8 00 00 00 00	 call	 __allmul
  00911	56		 push	 esi
  00912	57		 push	 edi
  00913	52		 push	 edx
  00914	50		 push	 eax
  00915	e8 00 00 00 00	 call	 __alldiv
  0091a	8b 4d e0	 mov	 ecx, DWORD PTR tv1541[ebp+4]
  0091d	6a 00		 push	 0
  0091f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00924	8b da		 mov	 ebx, edx
  00926	8b 55 dc	 mov	 edx, DWORD PTR tv1541[ebp]
  00929	51		 push	 ecx
  0092a	52		 push	 edx
  0092b	8b f0		 mov	 esi, eax
  0092d	e8 00 00 00 00	 call	 __allmul
  00932	03 f0		 add	 esi, eax
  00934	13 da		 adc	 ebx, edx
$LN296@test_remov:
  00936	33 ff		 xor	 edi, edi
  00938	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0093e	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00944	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  0094a	76 4f		 jbe	 SHORT $LN142@test_remov
  0094c	8d 64 24 00	 npad	 4
$LL144@test_remov:

; 1853 : 		unsigned key = REMOVE[i] + DELTA;

  00950	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00953	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  00956	46		 inc	 esi

; 1854 : 		struct trie_inplace_object* obj;
; 1855 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_remove(&trie_inplace, key);

  00957	8b ce		 mov	 ecx, esi
  00959	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  0095c	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  00963	52		 push	 edx
  00964	8b d6		 mov	 edx, esi
  00966	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  0096b	83 c4 04	 add	 esp, 4
  0096e	85 c0		 test	 eax, eax
  00970	75 04		 jne	 SHORT $LN298@test_remov
  00972	33 db		 xor	 ebx, ebx
  00974	eb 0d		 jmp	 SHORT $LN1407@test_remov
$LN298@test_remov:
  00976	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  0097c	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]

; 1856 : 		if (!obj)

  0097f	85 db		 test	 ebx, ebx
  00981	75 05		 jne	 SHORT $LN141@test_remov
$LN1407@test_remov:

; 1857 : 			abort();

  00983	e8 00 00 00 00	 call	 _abort
$LN141@test_remov:

; 1858 : 		if (dereference) {
; 1859 : 			if (obj->value != key)

  00988	39 73 20	 cmp	 DWORD PTR [ebx+32], esi
  0098b	74 05		 je	 SHORT $LN143@test_remov

; 1860 : 				abort();

  0098d	e8 00 00 00 00	 call	 _abort
$LN143@test_remov:

; 1851 : 
; 1852 : 	START(DATA_TRIE_INPLACE) {

  00992	47		 inc	 edi
  00993	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00999	72 b5		 jb	 SHORT $LL144@test_remov
$LN142@test_remov:

; 1861 : 		}
; 1862 : 	} STOP();

  0099b	8d 45 e4	 lea	 eax, DWORD PTR _t$217451[ebp]
  0099e	50		 push	 eax
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  009a5	85 c0		 test	 eax, eax
  009a7	75 11		 jne	 SHORT $LN305@test_remov
  009a9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  009ad	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217443[ebp], xmm0
  009b2	8b 5d e0	 mov	 ebx, DWORD PTR $T217443[ebp+4]
  009b5	8b 75 dc	 mov	 esi, DWORD PTR $T217443[ebp]
  009b8	eb 54		 jmp	 SHORT $LN306@test_remov
$LN305@test_remov:
  009ba	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  009c0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  009c6	8b 4d e8	 mov	 ecx, DWORD PTR _t$217451[ebp+4]
  009c9	8b 55 e4	 mov	 edx, DWORD PTR _t$217451[ebp]
  009cc	56		 push	 esi
  009cd	57		 push	 edi
  009ce	51		 push	 ecx
  009cf	52		 push	 edx
  009d0	e8 00 00 00 00	 call	 __alldvrm
  009d5	6a 00		 push	 0
  009d7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  009dc	53		 push	 ebx
  009dd	51		 push	 ecx
  009de	89 45 dc	 mov	 DWORD PTR tv4339[ebp], eax
  009e1	89 55 e0	 mov	 DWORD PTR tv4339[ebp+4], edx
  009e4	e8 00 00 00 00	 call	 __allmul
  009e9	56		 push	 esi
  009ea	57		 push	 edi
  009eb	52		 push	 edx
  009ec	50		 push	 eax
  009ed	e8 00 00 00 00	 call	 __alldiv
  009f2	8b 4d dc	 mov	 ecx, DWORD PTR tv4339[ebp]
  009f5	6a 00		 push	 0
  009f7	8b f0		 mov	 esi, eax
  009f9	8b 45 e0	 mov	 eax, DWORD PTR tv4339[ebp+4]
  009fc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a01	50		 push	 eax
  00a02	51		 push	 ecx
  00a03	8b da		 mov	 ebx, edx
  00a05	e8 00 00 00 00	 call	 __allmul
  00a0a	03 f0		 add	 esi, eax
  00a0c	13 da		 adc	 ebx, edx
$LN306@test_remov:
  00a0e	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00a14	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00a1a	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00a20	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00a26	75 63		 jne	 SHORT $LN303@test_remov
  00a28	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a2f	75 24		 jne	 SHORT $LN301@test_remov
  00a31	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00a37	6a 00		 push	 0
  00a39	52		 push	 edx
  00a3a	53		 push	 ebx
  00a3b	56		 push	 esi
  00a3c	e8 00 00 00 00	 call	 __aulldiv
  00a41	50		 push	 eax
  00a42	68 00 00 00 00	 push	 OFFSET $SG-102
  00a47	e8 00 00 00 00	 call	 _printf
  00a4c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00a52	83 c4 08	 add	 esp, 8
$LN301@test_remov:
  00a55	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00a5a	6a 00		 push	 0
  00a5c	50		 push	 eax
  00a5d	53		 push	 ebx
  00a5e	56		 push	 esi
  00a5f	e8 00 00 00 00	 call	 __aulldiv
  00a64	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00a6a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00a70	c1 e1 04	 shl	 ecx, 4
  00a73	03 cf		 add	 ecx, edi
  00a75	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00a78	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00a7e	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00a81	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00a84	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN303@test_remov:

; 1863 : 
; 1864 : 	START(DATA_KHASH) {

  00a8b	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 7 ; the_start_data
  00a95	83 ff 07	 cmp	 edi, 7
  00a98	0f 85 84 01 00
	00		 jne	 $LN135@test_remov
  00a9e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00aa5	75 2f		 jne	 SHORT $LN310@test_remov
  00aa7	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00aad	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00ab2	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00ab9	52		 push	 edx
  00aba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00ac0	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00ac7	51		 push	 ecx
  00ac8	50		 push	 eax
  00ac9	68 00 00 00 00	 push	 OFFSET $SG-101
  00ace	e8 00 00 00 00	 call	 _printf
  00ad3	83 c4 10	 add	 esp, 16			; 00000010H
$LN310@test_remov:
  00ad6	8d 4d cc	 lea	 ecx, DWORD PTR _t$217476[ebp]
  00ad9	51		 push	 ecx
  00ada	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ae0	85 c0		 test	 eax, eax
  00ae2	75 11		 jne	 SHORT $LN316@test_remov
  00ae4	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ae8	66 0f 13 45 dc	 movlpd	 QWORD PTR $T217469[ebp], xmm0
  00aed	8b 5d e0	 mov	 ebx, DWORD PTR $T217469[ebp+4]
  00af0	8b 75 dc	 mov	 esi, DWORD PTR $T217469[ebp]
  00af3	eb 54		 jmp	 SHORT $LN317@test_remov
$LN316@test_remov:
  00af5	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00afb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00b01	8b 55 d0	 mov	 edx, DWORD PTR _t$217476[ebp+4]
  00b04	8b 45 cc	 mov	 eax, DWORD PTR _t$217476[ebp]
  00b07	56		 push	 esi
  00b08	57		 push	 edi
  00b09	52		 push	 edx
  00b0a	50		 push	 eax
  00b0b	e8 00 00 00 00	 call	 __alldvrm
  00b10	6a 00		 push	 0
  00b12	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b17	53		 push	 ebx
  00b18	51		 push	 ecx
  00b19	89 45 dc	 mov	 DWORD PTR tv4322[ebp], eax
  00b1c	89 55 e0	 mov	 DWORD PTR tv4322[ebp+4], edx
  00b1f	e8 00 00 00 00	 call	 __allmul
  00b24	56		 push	 esi
  00b25	57		 push	 edi
  00b26	52		 push	 edx
  00b27	50		 push	 eax
  00b28	e8 00 00 00 00	 call	 __alldiv
  00b2d	8b 4d e0	 mov	 ecx, DWORD PTR tv4322[ebp+4]
  00b30	6a 00		 push	 0
  00b32	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b37	8b da		 mov	 ebx, edx
  00b39	8b 55 dc	 mov	 edx, DWORD PTR tv4322[ebp]
  00b3c	51		 push	 ecx
  00b3d	52		 push	 edx
  00b3e	8b f0		 mov	 esi, eax
  00b40	e8 00 00 00 00	 call	 __allmul
  00b45	03 f0		 add	 esi, eax
  00b47	13 da		 adc	 ebx, edx
$LN317@test_remov:
  00b49	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00b50	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00b56	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00b5c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00b63	0f 86 b9 00 00
	00		 jbe	 $LN135@test_remov
  00b69	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00b6f	90		 npad	 1
$LL137@test_remov:

; 1865 : 		unsigned key = REMOVE[i] + DELTA;

  00b70	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00b73	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00b76	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
  00b79	43		 inc	 ebx

; 1866 : 		unsigned hash_key = hash(key);

  00b7a	8b d3		 mov	 edx, ebx
  00b7c	c1 e2 06	 shl	 edx, 6
  00b7f	8b c3		 mov	 eax, ebx
  00b81	2b c2		 sub	 eax, edx
  00b83	8b c8		 mov	 ecx, eax
  00b85	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00b88	33 c1		 xor	 eax, ecx
  00b8a	8b d0		 mov	 edx, eax
  00b8c	c1 e2 09	 shl	 edx, 9
  00b8f	2b c2		 sub	 eax, edx
  00b91	8b c8		 mov	 ecx, eax
  00b93	c1 e1 04	 shl	 ecx, 4
  00b96	33 c1		 xor	 eax, ecx
  00b98	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00b9f	2b c2		 sub	 eax, edx
  00ba1	8b c8		 mov	 ecx, eax
  00ba3	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00ba6	33 c1		 xor	 eax, ecx
  00ba8	8b d0		 mov	 edx, eax
  00baa	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00bad	33 d0		 xor	 edx, eax

; 1867 : 		struct khash_object* obj;
; 1868 : 		khiter_t k;
; 1869 : 		k = kh_get(word, khash, hash_key);

  00baf	52		 push	 edx
  00bb0	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word
  00bb5	8b f0		 mov	 esi, eax
  00bb7	83 c4 04	 add	 esp, 4

; 1870 : 		if (k == kh_end(khash))

  00bba	3b 37		 cmp	 esi, DWORD PTR [edi]
  00bbc	75 0b		 jne	 SHORT $LN134@test_remov

; 1871 : 			abort();

  00bbe	e8 00 00 00 00	 call	 _abort
  00bc3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN134@test_remov:

; 1872 : 		if (dereference) {
; 1873 : 			obj = kh_value(khash, k);

  00bc9	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00bcc	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00bcf	89 4d f4	 mov	 DWORD PTR _obj$152773[ebp], ecx

; 1874 : 		}
; 1875 : 		kh_del(word, khash, k);

  00bd2	3b 37		 cmp	 esi, DWORD PTR [edi]
  00bd4	74 27		 je	 SHORT $LN321@test_remov
  00bd6	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00bd9	8b d6		 mov	 edx, esi
  00bdb	c1 ea 04	 shr	 edx, 4
  00bde	83 e6 0f	 and	 esi, 15			; 0000000fH
  00be1	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  00be4	8b 10		 mov	 edx, DWORD PTR [eax]
  00be6	03 f6		 add	 esi, esi
  00be8	8b ce		 mov	 ecx, esi
  00bea	d3 ea		 shr	 edx, cl
  00bec	f6 c2 03	 test	 dl, 3
  00bef	75 0c		 jne	 SHORT $LN321@test_remov
  00bf1	ba 01 00 00 00	 mov	 edx, 1
  00bf6	d3 e2		 shl	 edx, cl
  00bf8	09 10		 or	 DWORD PTR [eax], edx
  00bfa	ff 4f 04	 dec	 DWORD PTR [edi+4]
$LN321@test_remov:

; 1876 : 		if (dereference) {
; 1877 : 			if (obj->value != key)

  00bfd	8b 45 f4	 mov	 eax, DWORD PTR _obj$152773[ebp]
  00c00	39 18		 cmp	 DWORD PTR [eax], ebx
  00c02	74 0b		 je	 SHORT $LN136@test_remov

; 1878 : 				abort();

  00c04	e8 00 00 00 00	 call	 _abort
  00c09	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN136@test_remov:

; 1863 : 
; 1864 : 	START(DATA_KHASH) {

  00c0f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00c12	40		 inc	 eax
  00c13	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00c16	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00c1c	0f 82 4e ff ff
	ff		 jb	 $LL137@test_remov
$LN135@test_remov:

; 1879 : 		}
; 1880 : 	} STOP();

  00c22	8d 4d c4	 lea	 ecx, DWORD PTR _t$217506[ebp]
  00c25	51		 push	 ecx
  00c26	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00c2c	85 c0		 test	 eax, eax
  00c2e	75 11		 jne	 SHORT $LN328@test_remov
  00c30	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00c34	66 0f 13 45 cc	 movlpd	 QWORD PTR $T217498[ebp], xmm0
  00c39	8b 7d d0	 mov	 edi, DWORD PTR $T217498[ebp+4]
  00c3c	8b 75 cc	 mov	 esi, DWORD PTR $T217498[ebp]
  00c3f	eb 54		 jmp	 SHORT $LN329@test_remov
$LN328@test_remov:
  00c41	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00c47	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00c4d	8b 55 c8	 mov	 edx, DWORD PTR _t$217506[ebp+4]
  00c50	8b 45 c4	 mov	 eax, DWORD PTR _t$217506[ebp]
  00c53	56		 push	 esi
  00c54	57		 push	 edi
  00c55	52		 push	 edx
  00c56	50		 push	 eax
  00c57	e8 00 00 00 00	 call	 __alldvrm
  00c5c	6a 00		 push	 0
  00c5e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c63	53		 push	 ebx
  00c64	51		 push	 ecx
  00c65	89 45 dc	 mov	 DWORD PTR tv2049[ebp], eax
  00c68	89 55 e0	 mov	 DWORD PTR tv2049[ebp+4], edx
  00c6b	e8 00 00 00 00	 call	 __allmul
  00c70	56		 push	 esi
  00c71	57		 push	 edi
  00c72	52		 push	 edx
  00c73	50		 push	 eax
  00c74	e8 00 00 00 00	 call	 __alldiv
  00c79	8b 4d e0	 mov	 ecx, DWORD PTR tv2049[ebp+4]
  00c7c	6a 00		 push	 0
  00c7e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00c83	8b fa		 mov	 edi, edx
  00c85	8b 55 dc	 mov	 edx, DWORD PTR tv2049[ebp]
  00c88	51		 push	 ecx
  00c89	52		 push	 edx
  00c8a	8b f0		 mov	 esi, eax
  00c8c	e8 00 00 00 00	 call	 __allmul
  00c91	03 f0		 add	 esi, eax
  00c93	13 fa		 adc	 edi, edx
$LN329@test_remov:
  00c95	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00c9b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  00ca1	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  00ca7	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00cad	75 63		 jne	 SHORT $LN326@test_remov
  00caf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00cb6	75 23		 jne	 SHORT $LN324@test_remov
  00cb8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00cbd	6a 00		 push	 0
  00cbf	50		 push	 eax
  00cc0	57		 push	 edi
  00cc1	56		 push	 esi
  00cc2	e8 00 00 00 00	 call	 __aulldiv
  00cc7	50		 push	 eax
  00cc8	68 00 00 00 00	 push	 OFFSET $SG-102
  00ccd	e8 00 00 00 00	 call	 _printf
  00cd2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  00cd8	83 c4 08	 add	 esp, 8
$LN324@test_remov:
  00cdb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00ce1	6a 00		 push	 0
  00ce3	51		 push	 ecx
  00ce4	57		 push	 edi
  00ce5	56		 push	 esi
  00ce6	e8 00 00 00 00	 call	 __aulldiv
  00ceb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  00cf1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00cf7	c1 e2 04	 shl	 edx, 4
  00cfa	03 d3		 add	 edx, ebx
  00cfc	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00cff	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00d02	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d08	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00d0b	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN326@test_remov:

; 1881 : 
; 1882 : #ifdef USE_CGOOGLEDENSEHASH
; 1883 : 	START(DATA_CGOOGLE) {
; 1884 : 		unsigned key = REMOVE[i] + DELTA;
; 1885 : 		HTItem* ptr;
; 1886 : 		struct google_object* obj;
; 1887 : 		ptr = HashFind(cgoogledensehash, key);
; 1888 : 		if (!ptr)
; 1889 : 			abort();
; 1890 : 		obj = (struct google_object*)ptr->data;
; 1891 : 		HashDeleteLast(cgoogledensehash);
; 1892 : 		if (dereference) {
; 1893 : 			if (obj->value != key)
; 1894 : 				abort();
; 1895 : 		}
; 1896 : 	} STOP();
; 1897 : #endif
; 1898 : 
; 1899 : #ifdef USE_GOOGLEDENSEHASH
; 1900 : 	START(DATA_GOOGLEDENSEHASH) {

  00d12	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 11 ; the_start_data, 0000000bH
  00d1c	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  00d1f	0f 85 0c 02 00
	00		 jne	 $LN127@test_remov
  00d25	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d2c	75 2e		 jne	 SHORT $LN333@test_remov
  00d2e	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00d33	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d39	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00d40	50		 push	 eax
  00d41	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00d46	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00d4d	52		 push	 edx
  00d4e	51		 push	 ecx
  00d4f	68 00 00 00 00	 push	 OFFSET $SG-101
  00d54	e8 00 00 00 00	 call	 _printf
  00d59	83 c4 10	 add	 esp, 16			; 00000010H
$LN333@test_remov:
  00d5c	8d 55 bc	 lea	 edx, DWORD PTR _t$217530[ebp]
  00d5f	52		 push	 edx
  00d60	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00d66	85 c0		 test	 eax, eax
  00d68	75 11		 jne	 SHORT $LN339@test_remov
  00d6a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00d6e	66 0f 13 45 cc	 movlpd	 QWORD PTR $T217524[ebp], xmm0
  00d73	8b 7d d0	 mov	 edi, DWORD PTR $T217524[ebp+4]
  00d76	8b 75 cc	 mov	 esi, DWORD PTR $T217524[ebp]
  00d79	eb 54		 jmp	 SHORT $LN340@test_remov
$LN339@test_remov:
  00d7b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00d81	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00d87	8b 45 c0	 mov	 eax, DWORD PTR _t$217530[ebp+4]
  00d8a	8b 4d bc	 mov	 ecx, DWORD PTR _t$217530[ebp]
  00d8d	56		 push	 esi
  00d8e	57		 push	 edi
  00d8f	50		 push	 eax
  00d90	51		 push	 ecx
  00d91	e8 00 00 00 00	 call	 __alldvrm
  00d96	6a 00		 push	 0
  00d98	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d9d	53		 push	 ebx
  00d9e	51		 push	 ecx
  00d9f	89 45 dc	 mov	 DWORD PTR tv2097[ebp], eax
  00da2	89 55 e0	 mov	 DWORD PTR tv2097[ebp+4], edx
  00da5	e8 00 00 00 00	 call	 __allmul
  00daa	56		 push	 esi
  00dab	57		 push	 edi
  00dac	52		 push	 edx
  00dad	50		 push	 eax
  00dae	e8 00 00 00 00	 call	 __alldiv
  00db3	6a 00		 push	 0
  00db5	8b fa		 mov	 edi, edx
  00db7	8b 55 e0	 mov	 edx, DWORD PTR tv2097[ebp+4]
  00dba	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00dbf	8b f0		 mov	 esi, eax
  00dc1	8b 45 dc	 mov	 eax, DWORD PTR tv2097[ebp]
  00dc4	52		 push	 edx
  00dc5	50		 push	 eax
  00dc6	e8 00 00 00 00	 call	 __allmul
  00dcb	03 f0		 add	 esi, eax
  00dcd	13 fa		 adc	 edi, edx
$LN340@test_remov:
  00dcf	33 c0		 xor	 eax, eax
  00dd1	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00dd7	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00ddd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00de0	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  00de6	0f 86 45 01 00
	00		 jbe	 $LN127@test_remov
$LN129@test_remov:

; 1901 : 		unsigned key = REMOVE[i] + DELTA;

  00dec	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]

; 1902 : 		struct google_object* obj;
; 1903 : 		googledensehash_t::iterator ptr = googledensehash->find(key);

  00def	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00df5	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00df8	8b 56 24	 mov	 edx, DWORD PTR [esi+36]
  00dfb	40		 inc	 eax
  00dfc	2b 56 20	 sub	 edx, DWORD PTR [esi+32]
  00dff	89 45 f4	 mov	 DWORD PTR _key$152783[ebp], eax
  00e02	75 2c		 jne	 SHORT $LN346@test_remov
  00e04	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00e07	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00e0a	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00e0d	8b f9		 mov	 edi, ecx
  00e0f	3b f9		 cmp	 edi, ecx
  00e11	74 62		 je	 SHORT $LN460@test_remov
  00e13	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
$LL358@test_remov:
  00e16	8b 07		 mov	 eax, DWORD PTR [edi]
  00e18	3b d8		 cmp	 ebx, eax
  00e1a	74 0b		 je	 SHORT $LN356@test_remov
  00e1c	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00e20	76 53		 jbe	 SHORT $LN460@test_remov
  00e22	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  00e25	75 4e		 jne	 SHORT $LN460@test_remov
$LN356@test_remov:
  00e27	83 c7 08	 add	 edi, 8
  00e2a	3b f9		 cmp	 edi, ecx
  00e2c	75 e8		 jne	 SHORT $LL358@test_remov
  00e2e	eb 45		 jmp	 SHORT $LN460@test_remov
$LN346@test_remov:
  00e30	8d 4d cc	 lea	 ecx, DWORD PTR _pos$218706[ebp]
  00e33	51		 push	 ecx
  00e34	8d 45 f4	 lea	 eax, DWORD PTR _key$152783[ebp]
  00e37	8b fe		 mov	 edi, esi
  00e39	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00e3e	8b 45 cc	 mov	 eax, DWORD PTR _pos$218706[ebp]
  00e41	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00e44	83 f8 ff	 cmp	 eax, -1
  00e47	75 29		 jne	 SHORT $LN345@test_remov
  00e49	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00e4c	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  00e4f	8b f9		 mov	 edi, ecx
  00e51	3b f9		 cmp	 edi, ecx
  00e53	74 20		 je	 SHORT $LN460@test_remov
  00e55	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
$LL410@test_remov:
  00e58	8b 07		 mov	 eax, DWORD PTR [edi]
  00e5a	3b d8		 cmp	 ebx, eax
  00e5c	74 0b		 je	 SHORT $LN408@test_remov
  00e5e	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00e62	76 11		 jbe	 SHORT $LN460@test_remov
  00e64	39 46 1c	 cmp	 DWORD PTR [esi+28], eax
  00e67	75 0c		 jne	 SHORT $LN460@test_remov
$LN408@test_remov:
  00e69	83 c7 08	 add	 edi, 8
  00e6c	3b f9		 cmp	 edi, ecx
  00e6e	75 e8		 jne	 SHORT $LL410@test_remov
  00e70	eb 03		 jmp	 SHORT $LN460@test_remov
$LN345@test_remov:
  00e72	8d 3c c2	 lea	 edi, DWORD PTR [edx+eax*8]
$LN460@test_remov:

; 1904 : 		if (ptr == googledensehash->end())

  00e75	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  00e78	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  00e7b	8b c2		 mov	 eax, edx
  00e7d	3b c2		 cmp	 eax, edx
  00e7f	74 19		 je	 SHORT $LN551@test_remov
$LL514@test_remov:
  00e81	8b 08		 mov	 ecx, DWORD PTR [eax]
  00e83	39 4e 2c	 cmp	 DWORD PTR [esi+44], ecx
  00e86	74 0b		 je	 SHORT $LN512@test_remov
  00e88	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00e8c	76 0c		 jbe	 SHORT $LN551@test_remov
  00e8e	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00e91	75 07		 jne	 SHORT $LN551@test_remov
$LN512@test_remov:
  00e93	83 c0 08	 add	 eax, 8
  00e96	3b c2		 cmp	 eax, edx
  00e98	75 e7		 jne	 SHORT $LL514@test_remov
$LN551@test_remov:
  00e9a	3b f8		 cmp	 edi, eax
  00e9c	75 0b		 jne	 SHORT $LN126@test_remov

; 1905 : 			abort();

  00e9e	e8 00 00 00 00	 call	 _abort
  00ea3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN126@test_remov:

; 1906 : 		obj = ptr->second;

  00ea9	8b 57 04	 mov	 edx, DWORD PTR [edi+4]

; 1907 : 		googledensehash->erase(ptr);

  00eac	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00eaf	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00eb2	89 55 e8	 mov	 DWORD PTR _obj$152784[ebp], edx
  00eb5	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00eb8	8b c2		 mov	 eax, edx
  00eba	3b c2		 cmp	 eax, edx
  00ebc	74 1b		 je	 SHORT $LN615@test_remov
  00ebe	8b 5e 2c	 mov	 ebx, DWORD PTR [esi+44]
$LL578@test_remov:
  00ec1	8b 08		 mov	 ecx, DWORD PTR [eax]
  00ec3	3b d9		 cmp	 ebx, ecx
  00ec5	74 0b		 je	 SHORT $LN576@test_remov
  00ec7	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00ecb	76 0c		 jbe	 SHORT $LN615@test_remov
  00ecd	39 4e 1c	 cmp	 DWORD PTR [esi+28], ecx
  00ed0	75 07		 jne	 SHORT $LN615@test_remov
$LN576@test_remov:
  00ed2	83 c0 08	 add	 eax, 8
  00ed5	3b c2		 cmp	 eax, edx
  00ed7	75 e8		 jne	 SHORT $LL578@test_remov
$LN615@test_remov:
  00ed9	3b f8		 cmp	 edi, eax
  00edb	74 2d		 je	 SHORT $LN655@test_remov
  00edd	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00ee1	76 0e		 jbe	 SHORT $LN639@test_remov
  00ee3	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
  00ee6	3b 17		 cmp	 edx, DWORD PTR [edi]
  00ee8	75 07		 jne	 SHORT $LN639@test_remov
  00eea	b8 01 00 00 00	 mov	 eax, 1
  00eef	eb 02		 jmp	 SHORT $LN640@test_remov
$LN639@test_remov:
  00ef1	33 c0		 xor	 eax, eax
$LN640@test_remov:
  00ef3	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00ef6	89 0f		 mov	 DWORD PTR [edi], ecx
  00ef8	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  00eff	84 c0		 test	 al, al
  00f01	75 07		 jne	 SHORT $LN655@test_remov
  00f03	ff 46 20	 inc	 DWORD PTR [esi+32]
  00f06	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN655@test_remov:

; 1908 : 
; 1909 : 		/* force a resize when we reach 20% load factor */
; 1910 : 		googledensehash->resize(0);

  00f0a	e8 00 00 00 00	 call	 ?maybe_shrink@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NXZ ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::maybe_shrink

; 1911 : 
; 1912 : 		if (dereference) {
; 1913 : 			if (obj->value != key)

  00f0f	8b 55 f4	 mov	 edx, DWORD PTR _key$152783[ebp]
  00f12	8b 45 e8	 mov	 eax, DWORD PTR _obj$152784[ebp]
  00f15	39 10		 cmp	 DWORD PTR [eax], edx
  00f17	74 05		 je	 SHORT $LN128@test_remov

; 1914 : 				abort();

  00f19	e8 00 00 00 00	 call	 _abort
$LN128@test_remov:

; 1881 : 
; 1882 : #ifdef USE_CGOOGLEDENSEHASH
; 1883 : 	START(DATA_CGOOGLE) {
; 1884 : 		unsigned key = REMOVE[i] + DELTA;
; 1885 : 		HTItem* ptr;
; 1886 : 		struct google_object* obj;
; 1887 : 		ptr = HashFind(cgoogledensehash, key);
; 1888 : 		if (!ptr)
; 1889 : 			abort();
; 1890 : 		obj = (struct google_object*)ptr->data;
; 1891 : 		HashDeleteLast(cgoogledensehash);
; 1892 : 		if (dereference) {
; 1893 : 			if (obj->value != key)
; 1894 : 				abort();
; 1895 : 		}
; 1896 : 	} STOP();
; 1897 : #endif
; 1898 : 
; 1899 : #ifdef USE_GOOGLEDENSEHASH
; 1900 : 	START(DATA_GOOGLEDENSEHASH) {

  00f1e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00f21	40		 inc	 eax
  00f22	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00f25	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00f2b	0f 82 bb fe ff
	ff		 jb	 $LN129@test_remov
$LN127@test_remov:

; 1915 : 		}
; 1916 : 	} STOP();

  00f31	8d 4d c4	 lea	 ecx, DWORD PTR _t$219832[ebp]
  00f34	51		 push	 ecx
  00f35	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00f3b	85 c0		 test	 eax, eax
  00f3d	75 11		 jne	 SHORT $LN670@test_remov
  00f3f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00f43	66 0f 13 45 bc	 movlpd	 QWORD PTR $T219821[ebp], xmm0
  00f48	8b 5d c0	 mov	 ebx, DWORD PTR $T219821[ebp+4]
  00f4b	8b 75 bc	 mov	 esi, DWORD PTR $T219821[ebp]
  00f4e	eb 54		 jmp	 SHORT $LN671@test_remov
$LN670@test_remov:
  00f50	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00f56	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00f5c	8b 55 c8	 mov	 edx, DWORD PTR _t$219832[ebp+4]
  00f5f	8b 45 c4	 mov	 eax, DWORD PTR _t$219832[ebp]
  00f62	56		 push	 esi
  00f63	57		 push	 edi
  00f64	52		 push	 edx
  00f65	50		 push	 eax
  00f66	e8 00 00 00 00	 call	 __alldvrm
  00f6b	6a 00		 push	 0
  00f6d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f72	53		 push	 ebx
  00f73	51		 push	 ecx
  00f74	89 45 dc	 mov	 DWORD PTR tv4261[ebp], eax
  00f77	89 55 e0	 mov	 DWORD PTR tv4261[ebp+4], edx
  00f7a	e8 00 00 00 00	 call	 __allmul
  00f7f	56		 push	 esi
  00f80	57		 push	 edi
  00f81	52		 push	 edx
  00f82	50		 push	 eax
  00f83	e8 00 00 00 00	 call	 __alldiv
  00f88	8b 4d e0	 mov	 ecx, DWORD PTR tv4261[ebp+4]
  00f8b	6a 00		 push	 0
  00f8d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00f92	8b da		 mov	 ebx, edx
  00f94	8b 55 dc	 mov	 edx, DWORD PTR tv4261[ebp]
  00f97	51		 push	 ecx
  00f98	52		 push	 edx
  00f99	8b f0		 mov	 esi, eax
  00f9b	e8 00 00 00 00	 call	 __allmul
  00fa0	03 f0		 add	 esi, eax
  00fa2	13 da		 adc	 ebx, edx
$LN671@test_remov:
  00fa4	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00faa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00fb0	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00fb6	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00fbc	75 63		 jne	 SHORT $LN668@test_remov
  00fbe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00fc5	75 23		 jne	 SHORT $LN666@test_remov
  00fc7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00fcc	6a 00		 push	 0
  00fce	50		 push	 eax
  00fcf	53		 push	 ebx
  00fd0	56		 push	 esi
  00fd1	e8 00 00 00 00	 call	 __aulldiv
  00fd6	50		 push	 eax
  00fd7	68 00 00 00 00	 push	 OFFSET $SG-102
  00fdc	e8 00 00 00 00	 call	 _printf
  00fe1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00fe7	83 c4 08	 add	 esp, 8
$LN666@test_remov:
  00fea	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00ff0	6a 00		 push	 0
  00ff2	51		 push	 ecx
  00ff3	53		 push	 ebx
  00ff4	56		 push	 esi
  00ff5	e8 00 00 00 00	 call	 __aulldiv
  00ffa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  01000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  01006	c1 e2 04	 shl	 edx, 4
  01009	03 d7		 add	 edx, edi
  0100b	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  0100e	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  01011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01017	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  0101a	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN668@test_remov:

; 1917 : #endif
; 1918 : 
; 1919 : #ifdef USE_GOOGLEBTREE
; 1920 : 	START(DATA_GOOGLEBTREE) {

  01021	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 12 ; the_start_data, 0000000cH
  0102b	83 ff 0c	 cmp	 edi, 12			; 0000000cH
  0102e	0f 85 21 02 00
	00		 jne	 $LN120@test_remov
  01034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0103b	75 2e		 jne	 SHORT $LN675@test_remov
  0103d	a1 30 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  01042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  01048	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0104f	50		 push	 eax
  01050	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  01055	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0105c	52		 push	 edx
  0105d	51		 push	 ecx
  0105e	68 00 00 00 00	 push	 OFFSET $SG-101
  01063	e8 00 00 00 00	 call	 _printf
  01068	83 c4 10	 add	 esp, 16			; 00000010H
$LN675@test_remov:
  0106b	8d 55 cc	 lea	 edx, DWORD PTR _t$219856[ebp]
  0106e	52		 push	 edx
  0106f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01075	85 c0		 test	 eax, eax
  01077	75 11		 jne	 SHORT $LN681@test_remov
  01079	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0107d	66 0f 13 45 bc	 movlpd	 QWORD PTR $T219847[ebp], xmm0
  01082	8b 5d c0	 mov	 ebx, DWORD PTR $T219847[ebp+4]
  01085	8b 75 bc	 mov	 esi, DWORD PTR $T219847[ebp]
  01088	eb 54		 jmp	 SHORT $LN682@test_remov
$LN681@test_remov:
  0108a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01090	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01096	8b 45 d0	 mov	 eax, DWORD PTR _t$219856[ebp+4]
  01099	8b 4d cc	 mov	 ecx, DWORD PTR _t$219856[ebp]
  0109c	56		 push	 esi
  0109d	57		 push	 edi
  0109e	50		 push	 eax
  0109f	51		 push	 ecx
  010a0	e8 00 00 00 00	 call	 __alldvrm
  010a5	6a 00		 push	 0
  010a7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010ac	53		 push	 ebx
  010ad	51		 push	 ecx
  010ae	89 45 dc	 mov	 DWORD PTR tv4206[ebp], eax
  010b1	89 55 e0	 mov	 DWORD PTR tv4206[ebp+4], edx
  010b4	e8 00 00 00 00	 call	 __allmul
  010b9	56		 push	 esi
  010ba	57		 push	 edi
  010bb	52		 push	 edx
  010bc	50		 push	 eax
  010bd	e8 00 00 00 00	 call	 __alldiv
  010c2	6a 00		 push	 0
  010c4	8b da		 mov	 ebx, edx
  010c6	8b 55 e0	 mov	 edx, DWORD PTR tv4206[ebp+4]
  010c9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  010ce	8b f0		 mov	 esi, eax
  010d0	8b 45 dc	 mov	 eax, DWORD PTR tv4206[ebp]
  010d3	52		 push	 edx
  010d4	50		 push	 eax
  010d5	e8 00 00 00 00	 call	 __allmul
  010da	03 f0		 add	 esi, eax
  010dc	13 da		 adc	 ebx, edx
$LN682@test_remov:
  010de	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  010e5	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  010eb	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  010f1	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  010f8	0f 86 57 01 00
	00		 jbe	 $LN120@test_remov
$LN122@test_remov:

; 1921 : 		unsigned key = REMOVE[i] + DELTA;

  010fe	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  01101	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]

; 1922 : 		struct google_object* obj;
; 1923 : 		googlebtree_t::iterator ptr = googlebtree->find(key);

  01104	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  01109	8b 3c 91	 mov	 edi, DWORD PTR [ecx+edx*4]
  0110c	8b 18		 mov	 ebx, DWORD PTR [eax]
  0110e	47		 inc	 edi
  0110f	89 7d e8	 mov	 DWORD PTR _key$152795[ebp], edi
  01112	85 db		 test	 ebx, ebx
  01114	74 64		 je	 SHORT $LN813@test_remov
  01116	8b cb		 mov	 ecx, ebx
$LL710@test_remov:
  01118	0f b6 71 03	 movzx	 esi, BYTE PTR [ecx+3]
  0111c	33 c0		 xor	 eax, eax
  0111e	85 f6		 test	 esi, esi
  01120	7e 0f		 jle	 SHORT $LN1367@test_remov
  01122	8d 51 08	 lea	 edx, DWORD PTR [ecx+8]
$LL725@test_remov:
  01125	39 3a		 cmp	 DWORD PTR [edx], edi
  01127	73 08		 jae	 SHORT $LN1367@test_remov
  01129	40		 inc	 eax
  0112a	83 c2 08	 add	 edx, 8
  0112d	3b c6		 cmp	 eax, esi
  0112f	7c f4		 jl	 SHORT $LL725@test_remov
$LN1367@test_remov:
  01131	80 39 00	 cmp	 BYTE PTR [ecx], 0
  01134	75 0a		 jne	 SHORT $LL1368@test_remov
  01136	8b 8c 81 00 01
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+256]
  0113d	eb d9		 jmp	 SHORT $LL710@test_remov
  0113f	90		 npad	 1
$LL1368@test_remov:
  01140	0f b6 51 03	 movzx	 edx, BYTE PTR [ecx+3]
  01144	3b c2		 cmp	 eax, edx
  01146	75 1d		 jne	 SHORT $LN767@test_remov
  01148	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  0114c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0114f	80 39 00	 cmp	 BYTE PTR [ecx], 0
  01152	74 ec		 je	 SHORT $LL1368@test_remov
$LN803@test_remov:
  01154	85 db		 test	 ebx, ebx
  01156	74 22		 je	 SHORT $LN813@test_remov
  01158	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  0115b	75 1d		 jne	 SHORT $LN813@test_remov
  0115d	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  01163	eb 17		 jmp	 SHORT $LN825@test_remov
$LN767@test_remov:
  01165	85 c9		 test	 ecx, ecx
  01167	74 eb		 je	 SHORT $LN803@test_remov
  01169	3b 7c c1 08	 cmp	 edi, DWORD PTR [ecx+eax*8+8]
  0116d	72 e5		 jb	 SHORT $LN803@test_remov
  0116f	89 45 c0	 mov	 DWORD PTR $T221059[ebp+4], eax
  01172	89 4d bc	 mov	 DWORD PTR $T221059[ebp], ecx
  01175	8d 45 bc	 lea	 eax, DWORD PTR $T221059[ebp]
  01178	eb 41		 jmp	 SHORT $LN804@test_remov
$LN813@test_remov:
  0117a	8b c3		 mov	 eax, ebx
$LN825@test_remov:
  0117c	85 c0		 test	 eax, eax
  0117e	74 1d		 je	 SHORT $LN809@test_remov
  01180	85 db		 test	 ebx, ebx
  01182	74 11		 je	 SHORT $LN829@test_remov
  01184	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  01187	75 0c		 jne	 SHORT $LN829@test_remov
  01189	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  0118f	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  01193	eb 0a		 jmp	 SHORT $LN810@test_remov
$LN829@test_remov:
  01195	8b c3		 mov	 eax, ebx
  01197	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  0119b	eb 02		 jmp	 SHORT $LN810@test_remov
$LN809@test_remov:
  0119d	33 c9		 xor	 ecx, ecx
$LN810@test_remov:
  0119f	85 db		 test	 ebx, ebx
  011a1	74 0d		 je	 SHORT $LN847@test_remov
  011a3	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011a6	75 08		 jne	 SHORT $LN847@test_remov
  011a8	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  011ae	eb 02		 jmp	 SHORT $LN859@test_remov
$LN847@test_remov:
  011b0	8b c3		 mov	 eax, ebx
$LN859@test_remov:
  011b2	89 45 dc	 mov	 DWORD PTR $T221060[ebp], eax
  011b5	89 4d e0	 mov	 DWORD PTR $T221060[ebp+4], ecx
  011b8	8d 45 dc	 lea	 eax, DWORD PTR $T221060[ebp]
$LN804@test_remov:
  011bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  011be	8b 38		 mov	 edi, DWORD PTR [eax]
  011c0	89 4d f4	 mov	 DWORD PTR _ptr$152797[ebp+4], ecx

; 1924 : 		if (ptr == googlebtree->end())

  011c3	85 db		 test	 ebx, ebx
  011c5	74 0d		 je	 SHORT $LN873@test_remov
  011c7	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011ca	75 08		 jne	 SHORT $LN873@test_remov
  011cc	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  011d2	eb 02		 jmp	 SHORT $LN885@test_remov
$LN873@test_remov:
  011d4	8b c3		 mov	 eax, ebx
$LN885@test_remov:
  011d6	85 c0		 test	 eax, eax
  011d8	74 1d		 je	 SHORT $LN869@test_remov
  011da	85 db		 test	 ebx, ebx
  011dc	74 11		 je	 SHORT $LN889@test_remov
  011de	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  011e1	75 0c		 jne	 SHORT $LN889@test_remov
  011e3	8b 83 80 01 00
	00		 mov	 eax, DWORD PTR [ebx+384]
  011e9	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  011ed	eb 0a		 jmp	 SHORT $LN870@test_remov
$LN889@test_remov:
  011ef	8b c3		 mov	 eax, ebx
  011f1	0f b6 40 03	 movzx	 eax, BYTE PTR [eax+3]
  011f5	eb 02		 jmp	 SHORT $LN870@test_remov
$LN869@test_remov:
  011f7	33 c0		 xor	 eax, eax
$LN870@test_remov:
  011f9	85 db		 test	 ebx, ebx
  011fb	74 0b		 je	 SHORT $LN907@test_remov
  011fd	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  01200	75 06		 jne	 SHORT $LN907@test_remov
  01202	8b 9b 80 01 00
	00		 mov	 ebx, DWORD PTR [ebx+384]
$LN907@test_remov:
  01208	3b fb		 cmp	 edi, ebx
  0120a	75 09		 jne	 SHORT $LN119@test_remov
  0120c	3b c8		 cmp	 ecx, eax
  0120e	75 05		 jne	 SHORT $LN119@test_remov

; 1925 : 			abort();

  01210	e8 00 00 00 00	 call	 _abort
$LN119@test_remov:

; 1926 : 		obj = ptr->second;

  01215	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$152797[ebp+4]
  01218	8b 74 cf 0c	 mov	 esi, DWORD PTR [edi+ecx*8+12]

; 1927 : 		googlebtree->erase(ptr);

  0121c	83 ec 08	 sub	 esp, 8
  0121f	8b c4		 mov	 eax, esp
  01221	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0122a	89 38		 mov	 DWORD PTR [eax], edi
  0122c	8d 45 b4	 lea	 eax, DWORD PTR $T217146[ebp]
  0122f	50		 push	 eax
  01230	51		 push	 ecx
  01231	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase

; 1928 : 
; 1929 : 		if (dereference) {
; 1930 : 			if (obj->value != key)

  01236	8b 55 e8	 mov	 edx, DWORD PTR _key$152795[ebp]
  01239	39 16		 cmp	 DWORD PTR [esi], edx
  0123b	74 05		 je	 SHORT $LN121@test_remov

; 1931 : 				abort();

  0123d	e8 00 00 00 00	 call	 _abort
$LN121@test_remov:

; 1917 : #endif
; 1918 : 
; 1919 : #ifdef USE_GOOGLEBTREE
; 1920 : 	START(DATA_GOOGLEBTREE) {

  01242	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01245	40		 inc	 eax
  01246	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01249	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0124f	0f 82 a9 fe ff
	ff		 jb	 $LN122@test_remov
$LN120@test_remov:

; 1932 : 		}
; 1933 : 	} STOP();

  01255	8d 45 c4	 lea	 eax, DWORD PTR _t$221436[ebp]
  01258	50		 push	 eax
  01259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0125f	85 c0		 test	 eax, eax
  01261	75 11		 jne	 SHORT $LN941@test_remov
  01263	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01267	66 0f 13 45 bc	 movlpd	 QWORD PTR $T221428[ebp], xmm0
  0126c	8b 7d c0	 mov	 edi, DWORD PTR $T221428[ebp+4]
  0126f	8b 75 bc	 mov	 esi, DWORD PTR $T221428[ebp]
  01272	eb 54		 jmp	 SHORT $LN942@test_remov
$LN941@test_remov:
  01274	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0127a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01280	8b 4d c8	 mov	 ecx, DWORD PTR _t$221436[ebp+4]
  01283	8b 55 c4	 mov	 edx, DWORD PTR _t$221436[ebp]
  01286	56		 push	 esi
  01287	57		 push	 edi
  01288	51		 push	 ecx
  01289	52		 push	 edx
  0128a	e8 00 00 00 00	 call	 __alldvrm
  0128f	6a 00		 push	 0
  01291	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01296	53		 push	 ebx
  01297	51		 push	 ecx
  01298	89 45 dc	 mov	 DWORD PTR tv4177[ebp], eax
  0129b	89 55 e0	 mov	 DWORD PTR tv4177[ebp+4], edx
  0129e	e8 00 00 00 00	 call	 __allmul
  012a3	56		 push	 esi
  012a4	57		 push	 edi
  012a5	52		 push	 edx
  012a6	50		 push	 eax
  012a7	e8 00 00 00 00	 call	 __alldiv
  012ac	8b 4d dc	 mov	 ecx, DWORD PTR tv4177[ebp]
  012af	6a 00		 push	 0
  012b1	8b f0		 mov	 esi, eax
  012b3	8b 45 e0	 mov	 eax, DWORD PTR tv4177[ebp+4]
  012b6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012bb	50		 push	 eax
  012bc	51		 push	 ecx
  012bd	8b fa		 mov	 edi, edx
  012bf	e8 00 00 00 00	 call	 __allmul
  012c4	03 f0		 add	 esi, eax
  012c6	13 fa		 adc	 edi, edx
$LN942@test_remov:
  012c8	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  012ce	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  012d4	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  012da	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  012e0	75 63		 jne	 SHORT $LN939@test_remov
  012e2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  012e9	75 24		 jne	 SHORT $LN937@test_remov
  012eb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  012f1	6a 00		 push	 0
  012f3	52		 push	 edx
  012f4	57		 push	 edi
  012f5	56		 push	 esi
  012f6	e8 00 00 00 00	 call	 __aulldiv
  012fb	50		 push	 eax
  012fc	68 00 00 00 00	 push	 OFFSET $SG-102
  01301	e8 00 00 00 00	 call	 _printf
  01306	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  0130c	83 c4 08	 add	 esp, 8
$LN937@test_remov:
  0130f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01314	6a 00		 push	 0
  01316	50		 push	 eax
  01317	57		 push	 edi
  01318	56		 push	 esi
  01319	e8 00 00 00 00	 call	 __aulldiv
  0131e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01324	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0132a	c1 e1 04	 shl	 ecx, 4
  0132d	03 cb		 add	 ecx, ebx
  0132f	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01332	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01338	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0133b	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0133e	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN939@test_remov:

; 1934 : #endif
; 1935 : 
; 1936 : #ifdef USE_STXBTREE
; 1937 : 	START(DATA_STXBTREE) {

  01345	c7 05 00 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 13 ; the_start_data, 0000000dH
  0134f	83 fb 0d	 cmp	 ebx, 13			; 0000000dH
  01352	0f 85 94 01 00
	00		 jne	 $LN113@test_remov
  01358	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0135f	75 2f		 jne	 SHORT $LN946@test_remov
  01361	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  01367	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0136c	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01373	52		 push	 edx
  01374	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0137a	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01381	51		 push	 ecx
  01382	50		 push	 eax
  01383	68 00 00 00 00	 push	 OFFSET $SG-101
  01388	e8 00 00 00 00	 call	 _printf
  0138d	83 c4 10	 add	 esp, 16			; 00000010H
$LN946@test_remov:
  01390	8d 4d cc	 lea	 ecx, DWORD PTR _t$221461[ebp]
  01393	51		 push	 ecx
  01394	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0139a	85 c0		 test	 eax, eax
  0139c	75 11		 jne	 SHORT $LN952@test_remov
  0139e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  013a2	66 0f 13 45 bc	 movlpd	 QWORD PTR $T221454[ebp], xmm0
  013a7	8b 7d c0	 mov	 edi, DWORD PTR $T221454[ebp+4]
  013aa	8b 75 bc	 mov	 esi, DWORD PTR $T221454[ebp]
  013ad	eb 54		 jmp	 SHORT $LN953@test_remov
$LN952@test_remov:
  013af	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  013b5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  013bb	8b 55 d0	 mov	 edx, DWORD PTR _t$221461[ebp+4]
  013be	8b 45 cc	 mov	 eax, DWORD PTR _t$221461[ebp]
  013c1	56		 push	 esi
  013c2	57		 push	 edi
  013c3	52		 push	 edx
  013c4	50		 push	 eax
  013c5	e8 00 00 00 00	 call	 __alldvrm
  013ca	6a 00		 push	 0
  013cc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013d1	53		 push	 ebx
  013d2	51		 push	 ecx
  013d3	89 45 dc	 mov	 DWORD PTR tv2807[ebp], eax
  013d6	89 55 e0	 mov	 DWORD PTR tv2807[ebp+4], edx
  013d9	e8 00 00 00 00	 call	 __allmul
  013de	56		 push	 esi
  013df	57		 push	 edi
  013e0	52		 push	 edx
  013e1	50		 push	 eax
  013e2	e8 00 00 00 00	 call	 __alldiv
  013e7	8b 4d e0	 mov	 ecx, DWORD PTR tv2807[ebp+4]
  013ea	6a 00		 push	 0
  013ec	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013f1	8b fa		 mov	 edi, edx
  013f3	8b 55 dc	 mov	 edx, DWORD PTR tv2807[ebp]
  013f6	51		 push	 ecx
  013f7	52		 push	 edx
  013f8	8b f0		 mov	 esi, eax
  013fa	e8 00 00 00 00	 call	 __allmul
  013ff	03 f0		 add	 esi, eax
  01401	13 fa		 adc	 edi, edx
$LN953@test_remov:
  01403	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0140a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01410	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  01416	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0141d	0f 86 c9 00 00
	00		 jbe	 $LN113@test_remov
  01423	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  01429	8d a4 24 00 00
	00 00		 npad	 7
$LL115@test_remov:

; 1938 : 		unsigned key = REMOVE[i] + DELTA;

  01430	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01433	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01436	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  01439	40		 inc	 eax

; 1939 : 		struct stx_object* obj;
; 1940 : 		stxbtree_t::iterator ptr = stxbtree->find(key);

  0143a	8d 55 ac	 lea	 edx, DWORD PTR _ptr$152811[ebp]
  0143d	52		 push	 edx
  0143e	89 45 f4	 mov	 DWORD PTR _key$152809[ebp], eax
  01441	56		 push	 esi
  01442	8d 45 f4	 lea	 eax, DWORD PTR _key$152809[ebp]
  01445	e8 00 00 00 00	 call	 ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find

; 1941 : 		if (ptr == stxbtree->end())

  0144a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0144d	85 c0		 test	 eax, eax
  0144f	74 06		 je	 SHORT $LN961@test_remov
  01451	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  01455	eb 02		 jmp	 SHORT $LN962@test_remov
$LN961@test_remov:
  01457	33 c9		 xor	 ecx, ecx
$LN962@test_remov:
  01459	8b 5d ac	 mov	 ebx, DWORD PTR _ptr$152811[ebp]
  0145c	3b c3		 cmp	 eax, ebx
  0145e	75 11		 jne	 SHORT $LN112@test_remov
  01460	66 3b 4d b0	 cmp	 cx, WORD PTR _ptr$152811[ebp+4]
  01464	75 0b		 jne	 SHORT $LN112@test_remov

; 1942 : 			abort();

  01466	e8 00 00 00 00	 call	 _abort
  0146b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN112@test_remov:

; 1943 : 		obj = ptr->second;

  01471	66 8b 55 b0	 mov	 dx, WORD PTR _ptr$152811[ebp+4]
  01475	0f b7 c2	 movzx	 eax, dx
  01478	8b 4c 83 0c	 mov	 ecx, DWORD PTR [ebx+eax*4+12]
  0147c	8b bc 83 8c 00
	00 00		 mov	 edi, DWORD PTR [ebx+eax*4+140]

; 1944 : 		stxbtree->erase(ptr);

  01483	8b 06		 mov	 eax, DWORD PTR [esi]
  01485	89 4d b4	 mov	 DWORD PTR _ptr$152811[ebp+8], ecx
  01488	89 7d b8	 mov	 DWORD PTR _ptr$152811[ebp+12], edi
  0148b	89 5d d4	 mov	 DWORD PTR $T221765[ebp], ebx
  0148e	66 89 55 d8	 mov	 WORD PTR $T221765[ebp+4], dx
  01492	89 4d dc	 mov	 DWORD PTR $T221765[ebp+8], ecx
  01495	89 7d e0	 mov	 DWORD PTR $T221765[ebp+12], edi
  01498	85 c0		 test	 eax, eax
  0149a	74 2b		 je	 SHORT $LN1028@test_remov
  0149c	6a 00		 push	 0
  0149e	6a 00		 push	 0
  014a0	6a 00		 push	 0
  014a2	6a 00		 push	 0
  014a4	6a 00		 push	 0
  014a6	6a 00		 push	 0
  014a8	50		 push	 eax
  014a9	8d 45 d4	 lea	 eax, DWORD PTR $T221765[ebp]
  014ac	50		 push	 eax
  014ad	8d 4d bc	 lea	 ecx, DWORD PTR _result$221803[ebp]
  014b0	51		 push	 ecx
  014b1	8b ce		 mov	 ecx, esi
  014b3	e8 00 00 00 00	 call	 ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
  014b8	f6 45 bc 01	 test	 BYTE PTR _result$221803[ebp], 1
  014bc	75 03		 jne	 SHORT $LN1430@test_remov
  014be	ff 4e 0c	 dec	 DWORD PTR [esi+12]
$LN1430@test_remov:
  014c1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN1028@test_remov:

; 1945 : 
; 1946 : 		if (dereference) {
; 1947 : 			if (obj->value != key)

  014c7	8b 55 f4	 mov	 edx, DWORD PTR _key$152809[ebp]
  014ca	39 17		 cmp	 DWORD PTR [edi], edx
  014cc	74 0b		 je	 SHORT $LN114@test_remov

; 1948 : 				abort();

  014ce	e8 00 00 00 00	 call	 _abort
  014d3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN114@test_remov:

; 1934 : #endif
; 1935 : 
; 1936 : #ifdef USE_STXBTREE
; 1937 : 	START(DATA_STXBTREE) {

  014d9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  014dc	40		 inc	 eax
  014dd	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  014e0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  014e6	0f 82 44 ff ff
	ff		 jb	 $LL115@test_remov
$LN113@test_remov:

; 1949 : 		}
; 1950 : 	} STOP();

  014ec	8d 45 c4	 lea	 eax, DWORD PTR _t$221827[ebp]
  014ef	50		 push	 eax
  014f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  014f6	85 c0		 test	 eax, eax
  014f8	75 11		 jne	 SHORT $LN1052@test_remov
  014fa	66 0f 57 c0	 xorpd	 xmm0, xmm0
  014fe	66 0f 13 45 bc	 movlpd	 QWORD PTR $T221816[ebp], xmm0
  01503	8b 7d c0	 mov	 edi, DWORD PTR $T221816[ebp+4]
  01506	8b 75 bc	 mov	 esi, DWORD PTR $T221816[ebp]
  01509	eb 54		 jmp	 SHORT $LN1053@test_remov
$LN1052@test_remov:
  0150b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01511	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01517	8b 4d c8	 mov	 ecx, DWORD PTR _t$221827[ebp+4]
  0151a	8b 55 c4	 mov	 edx, DWORD PTR _t$221827[ebp]
  0151d	56		 push	 esi
  0151e	57		 push	 edi
  0151f	51		 push	 ecx
  01520	52		 push	 edx
  01521	e8 00 00 00 00	 call	 __alldvrm
  01526	6a 00		 push	 0
  01528	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0152d	53		 push	 ebx
  0152e	51		 push	 ecx
  0152f	89 45 dc	 mov	 DWORD PTR tv3595[ebp], eax
  01532	89 55 e0	 mov	 DWORD PTR tv3595[ebp+4], edx
  01535	e8 00 00 00 00	 call	 __allmul
  0153a	56		 push	 esi
  0153b	57		 push	 edi
  0153c	52		 push	 edx
  0153d	50		 push	 eax
  0153e	e8 00 00 00 00	 call	 __alldiv
  01543	8b 4d dc	 mov	 ecx, DWORD PTR tv3595[ebp]
  01546	6a 00		 push	 0
  01548	8b f0		 mov	 esi, eax
  0154a	8b 45 e0	 mov	 eax, DWORD PTR tv3595[ebp+4]
  0154d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01552	50		 push	 eax
  01553	51		 push	 ecx
  01554	8b fa		 mov	 edi, edx
  01556	e8 00 00 00 00	 call	 __allmul
  0155b	03 f0		 add	 esi, eax
  0155d	13 fa		 adc	 edi, edx
$LN1053@test_remov:
  0155f	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  01565	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  0156b	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  01571	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01577	75 63		 jne	 SHORT $LN1050@test_remov
  01579	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01580	75 24		 jne	 SHORT $LN1048@test_remov
  01582	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01588	6a 00		 push	 0
  0158a	52		 push	 edx
  0158b	57		 push	 edi
  0158c	56		 push	 esi
  0158d	e8 00 00 00 00	 call	 __aulldiv
  01592	50		 push	 eax
  01593	68 00 00 00 00	 push	 OFFSET $SG-102
  01598	e8 00 00 00 00	 call	 _printf
  0159d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  015a3	83 c4 08	 add	 esp, 8
$LN1048@test_remov:
  015a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  015ab	6a 00		 push	 0
  015ad	50		 push	 eax
  015ae	57		 push	 edi
  015af	56		 push	 esi
  015b0	e8 00 00 00 00	 call	 __aulldiv
  015b5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  015bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  015c1	c1 e1 04	 shl	 ecx, 4
  015c4	03 cb		 add	 ecx, ebx
  015c6	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  015c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  015cf	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  015d2	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  015d5	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1050@test_remov:

; 1951 : #endif
; 1952 : 
; 1953 : #ifdef USE_CPPMAP
; 1954 : 	START(DATA_CPPMAP) {

  015dc	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 15 ; the_start_data, 0000000fH
  015e6	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  015e9	0f 85 57 01 00
	00		 jne	 $LN106@test_remov
  015ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  015f6	75 2f		 jne	 SHORT $LN1057@test_remov
  015f8	8b 15 3c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+60
  015fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01603	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0160a	52		 push	 edx
  0160b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01611	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01618	51		 push	 ecx
  01619	50		 push	 eax
  0161a	68 00 00 00 00	 push	 OFFSET $SG-101
  0161f	e8 00 00 00 00	 call	 _printf
  01624	83 c4 10	 add	 esp, 16			; 00000010H
$LN1057@test_remov:
  01627	8d 4d cc	 lea	 ecx, DWORD PTR _t$221851[ebp]
  0162a	51		 push	 ecx
  0162b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01631	85 c0		 test	 eax, eax
  01633	75 11		 jne	 SHORT $LN1063@test_remov
  01635	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01639	66 0f 13 45 bc	 movlpd	 QWORD PTR $T221842[ebp], xmm0
  0163e	8b 7d c0	 mov	 edi, DWORD PTR $T221842[ebp+4]
  01641	8b 75 bc	 mov	 esi, DWORD PTR $T221842[ebp]
  01644	eb 54		 jmp	 SHORT $LN1064@test_remov
$LN1063@test_remov:
  01646	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0164c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01652	8b 55 d0	 mov	 edx, DWORD PTR _t$221851[ebp+4]
  01655	8b 45 cc	 mov	 eax, DWORD PTR _t$221851[ebp]
  01658	56		 push	 esi
  01659	57		 push	 edi
  0165a	52		 push	 edx
  0165b	50		 push	 eax
  0165c	e8 00 00 00 00	 call	 __alldvrm
  01661	6a 00		 push	 0
  01663	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01668	53		 push	 ebx
  01669	51		 push	 ecx
  0166a	89 45 dc	 mov	 DWORD PTR tv4157[ebp], eax
  0166d	89 55 e0	 mov	 DWORD PTR tv4157[ebp+4], edx
  01670	e8 00 00 00 00	 call	 __allmul
  01675	56		 push	 esi
  01676	57		 push	 edi
  01677	52		 push	 edx
  01678	50		 push	 eax
  01679	e8 00 00 00 00	 call	 __alldiv
  0167e	8b 4d e0	 mov	 ecx, DWORD PTR tv4157[ebp+4]
  01681	6a 00		 push	 0
  01683	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01688	8b fa		 mov	 edi, edx
  0168a	8b 55 dc	 mov	 edx, DWORD PTR tv4157[ebp]
  0168d	51		 push	 ecx
  0168e	52		 push	 edx
  0168f	8b f0		 mov	 esi, eax
  01691	e8 00 00 00 00	 call	 __allmul
  01696	03 f0		 add	 esi, eax
  01698	13 fa		 adc	 edi, edx
$LN1064@test_remov:
  0169a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  016a1	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  016a7	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  016ad	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  016b4	0f 86 8c 00 00
	00		 jbe	 $LN106@test_remov
  016ba	8d 9b 00 00 00
	00		 npad	 6
$LL108@test_remov:

; 1955 : 		unsigned key = REMOVE[i] + DELTA;

  016c0	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  016c3	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  016c6	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]

; 1956 : 		struct cpp_object* obj;
; 1957 : 		cppmap_t::iterator ptr = cppmap->find(key);

  016c9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  016cf	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  016d2	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  016d5	46		 inc	 esi
  016d6	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  016da	8b d1		 mov	 edx, ecx
  016dc	75 16		 jne	 SHORT $LN1074@test_remov
  016de	8b ff		 npad	 2
$LL1075@test_remov:
  016e0	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  016e3	73 05		 jae	 SHORT $LN1073@test_remov
  016e5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  016e8	eb 04		 jmp	 SHORT $LN1072@test_remov
$LN1073@test_remov:
  016ea	8b d0		 mov	 edx, eax
  016ec	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1072@test_remov:
  016ee	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  016f2	74 ec		 je	 SHORT $LL1075@test_remov
$LN1074@test_remov:
  016f4	89 55 e8	 mov	 DWORD PTR __Where$222141[ebp], edx
  016f7	3b d1		 cmp	 edx, ecx
  016f9	74 0a		 je	 SHORT $LN1068@test_remov
  016fb	3b 72 0c	 cmp	 esi, DWORD PTR [edx+12]
  016fe	72 05		 jb	 SHORT $LN1068@test_remov
  01700	8d 45 e8	 lea	 eax, DWORD PTR __Where$222141[ebp]
  01703	eb 06		 jmp	 SHORT $LN1069@test_remov
$LN1068@test_remov:
  01705	89 4d f4	 mov	 DWORD PTR $T222080[ebp], ecx
  01708	8d 45 f4	 lea	 eax, DWORD PTR $T222080[ebp]
$LN1069@test_remov:
  0170b	8b 38		 mov	 edi, DWORD PTR [eax]

; 1958 : 		if (ptr == cppmap->end())

  0170d	3b f9		 cmp	 edi, ecx
  0170f	75 05		 jne	 SHORT $LN105@test_remov

; 1959 : 			abort();

  01711	e8 00 00 00 00	 call	 _abort
$LN105@test_remov:

; 1960 : 		obj = ptr->second;
; 1961 : 		cppmap->erase(ptr);

  01716	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  0171c	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  0171f	57		 push	 edi
  01720	8d 45 e0	 lea	 eax, DWORD PTR $T217151[ebp]
  01723	50		 push	 eax
  01724	51		 push	 ecx
  01725	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1962 : 
; 1963 : 		if (dereference) {
; 1964 : 			if (obj->value != key)

  0172a	39 33		 cmp	 DWORD PTR [ebx], esi
  0172c	74 05		 je	 SHORT $LN107@test_remov

; 1965 : 				abort();

  0172e	e8 00 00 00 00	 call	 _abort
$LN107@test_remov:

; 1951 : #endif
; 1952 : 
; 1953 : #ifdef USE_CPPMAP
; 1954 : 	START(DATA_CPPMAP) {

  01733	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01736	40		 inc	 eax
  01737	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  0173a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01740	0f 82 7a ff ff
	ff		 jb	 $LL108@test_remov
$LN106@test_remov:

; 1966 : 		}
; 1967 : 	} STOP();

  01746	8d 55 c4	 lea	 edx, DWORD PTR _t$222230[ebp]
  01749	52		 push	 edx
  0174a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01750	85 c0		 test	 eax, eax
  01752	75 11		 jne	 SHORT $LN1160@test_remov
  01754	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01758	66 0f 13 45 bc	 movlpd	 QWORD PTR $T222222[ebp], xmm0
  0175d	8b 7d c0	 mov	 edi, DWORD PTR $T222222[ebp+4]
  01760	8b 75 bc	 mov	 esi, DWORD PTR $T222222[ebp]
  01763	eb 54		 jmp	 SHORT $LN1161@test_remov
$LN1160@test_remov:
  01765	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0176b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01771	8b 45 c8	 mov	 eax, DWORD PTR _t$222230[ebp+4]
  01774	8b 4d c4	 mov	 ecx, DWORD PTR _t$222230[ebp]
  01777	56		 push	 esi
  01778	57		 push	 edi
  01779	50		 push	 eax
  0177a	51		 push	 ecx
  0177b	e8 00 00 00 00	 call	 __alldvrm
  01780	6a 00		 push	 0
  01782	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01787	53		 push	 ebx
  01788	51		 push	 ecx
  01789	89 45 dc	 mov	 DWORD PTR tv402[ebp], eax
  0178c	89 55 e0	 mov	 DWORD PTR tv402[ebp+4], edx
  0178f	e8 00 00 00 00	 call	 __allmul
  01794	56		 push	 esi
  01795	57		 push	 edi
  01796	52		 push	 edx
  01797	50		 push	 eax
  01798	e8 00 00 00 00	 call	 __alldiv
  0179d	6a 00		 push	 0
  0179f	8b fa		 mov	 edi, edx
  017a1	8b 55 e0	 mov	 edx, DWORD PTR tv402[ebp+4]
  017a4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  017a9	8b f0		 mov	 esi, eax
  017ab	8b 45 dc	 mov	 eax, DWORD PTR tv402[ebp]
  017ae	52		 push	 edx
  017af	50		 push	 eax
  017b0	e8 00 00 00 00	 call	 __allmul
  017b5	03 f0		 add	 esi, eax
  017b7	13 fa		 adc	 edi, edx
$LN1161@test_remov:
  017b9	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  017bf	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  017c5	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  017cb	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  017d1	75 64		 jne	 SHORT $LN1158@test_remov
  017d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  017da	75 24		 jne	 SHORT $LN1156@test_remov
  017dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  017e2	6a 00		 push	 0
  017e4	51		 push	 ecx
  017e5	57		 push	 edi
  017e6	56		 push	 esi
  017e7	e8 00 00 00 00	 call	 __aulldiv
  017ec	50		 push	 eax
  017ed	68 00 00 00 00	 push	 OFFSET $SG-102
  017f2	e8 00 00 00 00	 call	 _printf
  017f7	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  017fd	83 c4 08	 add	 esp, 8
$LN1156@test_remov:
  01800	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01806	6a 00		 push	 0
  01808	52		 push	 edx
  01809	57		 push	 edi
  0180a	56		 push	 esi
  0180b	e8 00 00 00 00	 call	 __aulldiv
  01810	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01816	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0181c	c1 e1 04	 shl	 ecx, 4
  0181f	03 cb		 add	 ecx, ebx
  01821	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01824	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0182a	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0182d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01830	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1158@test_remov:

; 1968 : #endif
; 1969 : 
; 1970 : #ifdef USE_CPPUNORDEREDMAP
; 1971 : 	START(DATA_CPPUNORDEREDMAP) {

  01837	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 14 ; the_start_data, 0000000eH
  01841	83 fb 0e	 cmp	 ebx, 14			; 0000000eH
  01844	0f 85 d2 01 00
	00		 jne	 $LN99@test_remov
  0184a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01851	75 2f		 jne	 SHORT $LN1165@test_remov
  01853	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  01859	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0185e	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01865	52		 push	 edx
  01866	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0186c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01873	51		 push	 ecx
  01874	50		 push	 eax
  01875	68 00 00 00 00	 push	 OFFSET $SG-101
  0187a	e8 00 00 00 00	 call	 _printf
  0187f	83 c4 10	 add	 esp, 16			; 00000010H
$LN1165@test_remov:
  01882	8d 4d cc	 lea	 ecx, DWORD PTR _t$222255[ebp]
  01885	51		 push	 ecx
  01886	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0188c	85 c0		 test	 eax, eax
  0188e	75 11		 jne	 SHORT $LN1171@test_remov
  01890	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01894	66 0f 13 45 bc	 movlpd	 QWORD PTR $T222248[ebp], xmm0
  01899	8b 7d c0	 mov	 edi, DWORD PTR $T222248[ebp+4]
  0189c	8b 75 bc	 mov	 esi, DWORD PTR $T222248[ebp]
  0189f	eb 54		 jmp	 SHORT $LN1172@test_remov
$LN1171@test_remov:
  018a1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  018a7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  018ad	8b 55 d0	 mov	 edx, DWORD PTR _t$222255[ebp+4]
  018b0	8b 45 cc	 mov	 eax, DWORD PTR _t$222255[ebp]
  018b3	56		 push	 esi
  018b4	57		 push	 edi
  018b5	52		 push	 edx
  018b6	50		 push	 eax
  018b7	e8 00 00 00 00	 call	 __alldvrm
  018bc	6a 00		 push	 0
  018be	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  018c3	53		 push	 ebx
  018c4	51		 push	 ecx
  018c5	89 45 dc	 mov	 DWORD PTR tv430[ebp], eax
  018c8	89 55 e0	 mov	 DWORD PTR tv430[ebp+4], edx
  018cb	e8 00 00 00 00	 call	 __allmul
  018d0	56		 push	 esi
  018d1	57		 push	 edi
  018d2	52		 push	 edx
  018d3	50		 push	 eax
  018d4	e8 00 00 00 00	 call	 __alldiv
  018d9	8b 4d e0	 mov	 ecx, DWORD PTR tv430[ebp+4]
  018dc	6a 00		 push	 0
  018de	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  018e3	8b fa		 mov	 edi, edx
  018e5	8b 55 dc	 mov	 edx, DWORD PTR tv430[ebp]
  018e8	51		 push	 ecx
  018e9	52		 push	 edx
  018ea	8b f0		 mov	 esi, eax
  018ec	e8 00 00 00 00	 call	 __allmul
  018f1	03 f0		 add	 esi, eax
  018f3	13 fa		 adc	 edi, edx
$LN1172@test_remov:
  018f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  018fc	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01902	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  01908	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0190f	0f 86 07 01 00
	00		 jbe	 $LN99@test_remov
  01915	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  0191b	eb 03 8d 49 00	 npad	 5
$LL101@test_remov:

; 1972 : 		unsigned key = REMOVE[i] + DELTA;

  01920	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  01923	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01926	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  01929	40		 inc	 eax

; 1973 : 		struct cpp_object* obj;
; 1974 : 		cppunorderedmap_t::iterator ptr = cppunorderedmap->find(key);

  0192a	8d 55 e8	 lea	 edx, DWORD PTR _ptr$152838[ebp]
  0192d	89 45 f4	 mov	 DWORD PTR _key$152836[ebp], eax
  01930	52		 push	 edx
  01931	8d 45 f4	 lea	 eax, DWORD PTR _key$152836[ebp]
  01934	8b cb		 mov	 ecx, ebx
  01936	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1975 : 		if (ptr == cppunorderedmap->end())

  0193b	8b 75 e8	 mov	 esi, DWORD PTR _ptr$152838[ebp]
  0193e	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  01941	75 0b		 jne	 SHORT $LN98@test_remov

; 1976 : 			abort();

  01943	e8 00 00 00 00	 call	 _abort
  01948	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN98@test_remov:

; 1977 : 		obj = ptr->second;

  0194e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01951	89 45 e0	 mov	 DWORD PTR _obj$152837[ebp], eax

; 1978 : 		cppunorderedmap->erase(ptr);

  01954	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01957	8b c8		 mov	 ecx, eax
  01959	c1 e1 06	 shl	 ecx, 6
  0195c	2b c1		 sub	 eax, ecx
  0195e	8b d0		 mov	 edx, eax
  01960	c1 ea 11	 shr	 edx, 17			; 00000011H
  01963	33 c2		 xor	 eax, edx
  01965	8b c8		 mov	 ecx, eax
  01967	c1 e1 09	 shl	 ecx, 9
  0196a	2b c1		 sub	 eax, ecx
  0196c	8b d0		 mov	 edx, eax
  0196e	c1 e2 04	 shl	 edx, 4
  01971	33 c2		 xor	 eax, edx
  01973	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0197a	2b c1		 sub	 eax, ecx
  0197c	8b d0		 mov	 edx, eax
  0197e	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  01981	33 c2		 xor	 eax, edx
  01983	8b 53 20	 mov	 edx, DWORD PTR [ebx+32]
  01986	8b c8		 mov	 ecx, eax
  01988	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  0198b	33 c8		 xor	 ecx, eax
  0198d	23 ca		 and	 ecx, edx
  0198f	39 4b 24	 cmp	 DWORD PTR [ebx+36], ecx
  01992	77 09		 ja	 SHORT $LN1206@test_remov
  01994	d1 ea		 shr	 edx, 1
  01996	83 c8 ff	 or	 eax, -1
  01999	2b c2		 sub	 eax, edx
  0199b	03 c8		 add	 ecx, eax
$LN1206@test_remov:
  0199d	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  019a0	39 74 ca 04	 cmp	 DWORD PTR [edx+ecx*8+4], esi
  019a4	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  019a7	75 1d		 jne	 SHORT $LN1229@test_remov
  019a9	39 30		 cmp	 DWORD PTR [eax], esi
  019ab	75 11		 jne	 SHORT $LN1228@test_remov
  019ad	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  019b0	89 10		 mov	 DWORD PTR [eax], edx
  019b2	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  019b5	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  019b8	89 54 c8 04	 mov	 DWORD PTR [eax+ecx*8+4], edx
  019bc	eb 10		 jmp	 SHORT $LN1225@test_remov
$LN1228@test_remov:
  019be	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  019c1	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  019c4	eb 08		 jmp	 SHORT $LN1225@test_remov
$LN1229@test_remov:
  019c6	39 30		 cmp	 DWORD PTR [eax], esi
  019c8	75 04		 jne	 SHORT $LN1225@test_remov
  019ca	8b 16		 mov	 edx, DWORD PTR [esi]
  019cc	89 10		 mov	 DWORD PTR [eax], edx
$LN1225@test_remov:
  019ce	3b 73 04	 cmp	 esi, DWORD PTR [ebx+4]
  019d1	74 21		 je	 SHORT $LN1302@test_remov
  019d3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  019d6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  019d8	89 08		 mov	 DWORD PTR [eax], ecx
  019da	8b 16		 mov	 edx, DWORD PTR [esi]
  019dc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  019df	56		 push	 esi
  019e0	89 42 04	 mov	 DWORD PTR [edx+4], eax
  019e3	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  019e8	83 c4 04	 add	 esp, 4
  019eb	ff 4b 08	 dec	 DWORD PTR [ebx+8]
  019ee	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN1302@test_remov:

; 1979 : 
; 1980 : 		if (dereference) {
; 1981 : 			if (obj->value != key)

  019f4	8b 4d f4	 mov	 ecx, DWORD PTR _key$152836[ebp]
  019f7	8b 55 e0	 mov	 edx, DWORD PTR _obj$152837[ebp]
  019fa	39 0a		 cmp	 DWORD PTR [edx], ecx
  019fc	74 0b		 je	 SHORT $LN100@test_remov

; 1982 : 				abort();

  019fe	e8 00 00 00 00	 call	 _abort
  01a03	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
$LN100@test_remov:

; 1968 : #endif
; 1969 : 
; 1970 : #ifdef USE_CPPUNORDEREDMAP
; 1971 : 	START(DATA_CPPUNORDEREDMAP) {

  01a09	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  01a0c	40		 inc	 eax
  01a0d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  01a10	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01a16	0f 82 04 ff ff
	ff		 jb	 $LL101@test_remov
$LN99@test_remov:

; 1983 : 		}
; 1984 : 	} STOP();

  01a1c	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1985 : #endif
; 1986 : 
; 1987 : 	START(DATA_UTHASH) {

  01a21	b8 08 00 00 00	 mov	 eax, 8
  01a26	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01a2b	85 c0		 test	 eax, eax
  01a2d	0f 84 ed 01 00
	00		 je	 $LN92@test_remov
  01a33	33 ff		 xor	 edi, edi
  01a35	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  01a38	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01a3e	0f 86 dc 01 00
	00		 jbe	 $LN92@test_remov
  01a44	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01a4a	8d 9b 00 00 00
	00		 npad	 6
$LL94@test_remov:

; 1988 : 		unsigned key = REMOVE[i] + DELTA;

  01a50	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01a53	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  01a56	41		 inc	 ecx

; 1989 : 		struct uthash_object* obj;
; 1990 : 		HASH_FIND_INT(uthash, &key, obj);  

  01a57	33 f6		 xor	 esi, esi
  01a59	89 4d f4	 mov	 DWORD PTR _key$152850[ebp], ecx
  01a5c	85 db		 test	 ebx, ebx
  01a5e	0f 84 ce 00 00
	00		 je	 $LN1395@test_remov
  01a64	0f be 45 f7	 movsx	 eax, BYTE PTR _key$152850[ebp+3]
  01a68	0f be 55 f6	 movsx	 edx, BYTE PTR _key$152850[ebp+2]
  01a6c	c1 e0 18	 shl	 eax, 24			; 00000018H
  01a6f	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01a74	c1 e2 10	 shl	 edx, 16			; 00000010H
  01a77	03 c2		 add	 eax, edx
  01a79	0f be d5	 movsx	 edx, ch
  01a7c	0f be c9	 movsx	 ecx, cl
  01a7f	c1 e2 08	 shl	 edx, 8
  01a82	03 d0		 add	 edx, eax
  01a84	03 d1		 add	 edx, ecx
  01a86	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  01a8c	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  01a92	8b c2		 mov	 eax, edx
  01a94	c1 e0 08	 shl	 eax, 8
  01a97	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  01a9c	2b ca		 sub	 ecx, edx
  01a9e	33 c8		 xor	 ecx, eax
  01aa0	8b f1		 mov	 esi, ecx
  01aa2	c1 ee 0d	 shr	 esi, 13			; 0000000dH
  01aa5	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  01aaa	2b c1		 sub	 eax, ecx
  01aac	2b c2		 sub	 eax, edx
  01aae	33 c6		 xor	 eax, esi
  01ab0	2b d1		 sub	 edx, ecx
  01ab2	2b d0		 sub	 edx, eax
  01ab4	8b f0		 mov	 esi, eax
  01ab6	c1 ee 0c	 shr	 esi, 12			; 0000000cH
  01ab9	33 d6		 xor	 edx, esi
  01abb	2b ca		 sub	 ecx, edx
  01abd	2b c8		 sub	 ecx, eax
  01abf	8b f2		 mov	 esi, edx
  01ac1	c1 e6 10	 shl	 esi, 16			; 00000010H
  01ac4	33 ce		 xor	 ecx, esi
  01ac6	2b c1		 sub	 eax, ecx
  01ac8	2b c2		 sub	 eax, edx
  01aca	8b f1		 mov	 esi, ecx
  01acc	c1 ee 05	 shr	 esi, 5
  01acf	33 c6		 xor	 eax, esi
  01ad1	2b d1		 sub	 edx, ecx
  01ad3	2b d0		 sub	 edx, eax
  01ad5	8b f0		 mov	 esi, eax
  01ad7	c1 ee 03	 shr	 esi, 3
  01ada	33 d6		 xor	 edx, esi
  01adc	2b ca		 sub	 ecx, edx
  01ade	2b c8		 sub	 ecx, eax
  01ae0	8b f2		 mov	 esi, edx
  01ae2	c1 e6 0a	 shl	 esi, 10			; 0000000aH
  01ae5	33 ce		 xor	 ecx, esi
  01ae7	8b 33		 mov	 esi, DWORD PTR [ebx]
  01ae9	2b c1		 sub	 eax, ecx
  01aeb	2b c2		 sub	 eax, edx
  01aed	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  01af0	33 c1		 xor	 eax, ecx
  01af2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  01af5	49		 dec	 ecx
  01af6	23 c1		 and	 eax, ecx
  01af8	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  01afb	8b 06		 mov	 eax, DWORD PTR [esi]
  01afd	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  01b00	85 c0		 test	 eax, eax
  01b02	74 2c		 je	 SHORT $LN50@test_remov
  01b04	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  01b07	2b c1		 sub	 eax, ecx
  01b09	8b f0		 mov	 esi, eax
  01b0b	85 f6		 test	 esi, esi
  01b0d	74 23		 je	 SHORT $LN1395@test_remov
  01b0f	b8 04 00 00 00	 mov	 eax, 4
$LL54@test_remov:
  01b14	39 46 18	 cmp	 DWORD PTR [esi+24], eax
  01b17	75 0a		 jne	 SHORT $LN51@test_remov
  01b19	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  01b1c	8b 12		 mov	 edx, DWORD PTR [edx]
  01b1e	3b 55 f4	 cmp	 edx, DWORD PTR _key$152850[ebp]
  01b21	74 1a		 je	 SHORT $LN44@test_remov
$LN51@test_remov:
  01b23	8b 76 10	 mov	 esi, DWORD PTR [esi+16]
  01b26	85 f6		 test	 esi, esi
  01b28	74 06		 je	 SHORT $LN50@test_remov
  01b2a	2b f1		 sub	 esi, ecx
  01b2c	75 e6		 jne	 SHORT $LL54@test_remov
  01b2e	eb 02		 jmp	 SHORT $LN1395@test_remov
$LN50@test_remov:
  01b30	33 f6		 xor	 esi, esi
$LN1395@test_remov:

; 1991 : 		if (!obj)
; 1992 : 			abort();

  01b32	e8 00 00 00 00	 call	 _abort
  01b37	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN44@test_remov:

; 1993 : 		HASH_DEL(uthash, obj);  

  01b3d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01b40	85 d2		 test	 edx, edx
  01b42	75 2a		 jne	 SHORT $LN41@test_remov
  01b44	39 56 08	 cmp	 DWORD PTR [esi+8], edx
  01b47	75 25		 jne	 SHORT $LN41@test_remov
  01b49	8b 03		 mov	 eax, DWORD PTR [ebx]
  01b4b	8b 08		 mov	 ecx, DWORD PTR [eax]
  01b4d	51		 push	 ecx
  01b4e	e8 00 00 00 00	 call	 _free
  01b53	8b 13		 mov	 edx, DWORD PTR [ebx]
  01b55	83 c4 04	 add	 esp, 4
  01b58	52		 push	 edx
  01b59	e8 00 00 00 00	 call	 _free
  01b5e	83 c4 04	 add	 esp, 4
  01b61	33 db		 xor	 ebx, ebx
  01b63	89 1d 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, ebx ; uthash
  01b69	e9 8f 00 00 00	 jmp	 $LN43@test_remov
$LN41@test_remov:
  01b6e	8b 03		 mov	 eax, DWORD PTR [ebx]
  01b70	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01b73	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  01b76	2b f9		 sub	 edi, ecx
  01b78	3b f7		 cmp	 esi, edi
  01b7a	75 05		 jne	 SHORT $LN39@test_remov
  01b7c	03 d1		 add	 edx, ecx
  01b7e	89 50 10	 mov	 DWORD PTR [eax+16], edx
$LN39@test_remov:
  01b81	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01b84	85 c0		 test	 eax, eax
  01b86	74 0e		 je	 SHORT $LN36@test_remov
  01b88	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01b8a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01b8d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  01b90	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  01b94	eb 09		 jmp	 SHORT $LN34@test_remov
$LN36@test_remov:
  01b96	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  01b99	89 1d 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, ebx ; uthash
$LN34@test_remov:
  01b9f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  01ba2	85 c0		 test	 eax, eax
  01ba4	74 0c		 je	 SHORT $LN32@test_remov
  01ba6	8b 13		 mov	 edx, DWORD PTR [ebx]
  01ba8	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  01bab	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  01bae	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN32@test_remov:
  01bb2	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  01bb4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01bb7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01bb9	48		 dec	 eax
  01bba	23 46 1c	 and	 eax, DWORD PTR [esi+28]
  01bbd	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01bc0	03 c0		 add	 eax, eax
  01bc2	03 c0		 add	 eax, eax
  01bc4	ff 4c 01 04	 dec	 DWORD PTR [ecx+eax+4]
  01bc8	8b 13		 mov	 edx, DWORD PTR [ebx]
  01bca	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  01bce	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01bd0	39 34 08	 cmp	 DWORD PTR [eax+ecx], esi
  01bd3	75 06		 jne	 SHORT $LN29@test_remov
  01bd5	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  01bd8	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
$LN29@test_remov:
  01bdb	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  01bde	85 c0		 test	 eax, eax
  01be0	74 06		 je	 SHORT $LN28@test_remov
  01be2	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  01be5	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN28@test_remov:
  01be8	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  01beb	85 c0		 test	 eax, eax
  01bed	74 06		 je	 SHORT $LN27@test_remov
  01bef	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  01bf2	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN27@test_remov:
  01bf5	8b 03		 mov	 eax, DWORD PTR [ebx]
  01bf7	ff 48 0c	 dec	 DWORD PTR [eax+12]
  01bfa	8b 7d f8	 mov	 edi, DWORD PTR _i$[ebp]
$LN43@test_remov:

; 1994 : 		if (dereference) {
; 1995 : 			if (obj->value != key)

  01bfd	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  01c00	3b 45 f4	 cmp	 eax, DWORD PTR _key$152850[ebp]
  01c03	74 0b		 je	 SHORT $LN93@test_remov

; 1996 : 				abort();

  01c05	e8 00 00 00 00	 call	 _abort
  01c0a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN93@test_remov:

; 1985 : #endif
; 1986 : 
; 1987 : 	START(DATA_UTHASH) {

  01c10	47		 inc	 edi
  01c11	89 7d f8	 mov	 DWORD PTR _i$[ebp], edi
  01c14	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01c1a	0f 82 30 fe ff
	ff		 jb	 $LL94@test_remov
$LN92@test_remov:

; 1997 : 		}
; 1998 : 	} STOP();

  01c20	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1999 : 
; 2000 : #ifdef USE_JUDY
; 2001 : 	START(DATA_JUDY) {

  01c25	b8 09 00 00 00	 mov	 eax, 9
  01c2a	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01c2f	85 c0		 test	 eax, eax
  01c31	74 6a		 je	 SHORT $LN21@test_remov
  01c33	33 ff		 xor	 edi, edi
  01c35	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01c3b	76 60		 jbe	 SHORT $LN21@test_remov
  01c3d	8d 49 00	 npad	 3
$LL23@test_remov:

; 2002 : 		Word_t key = REMOVE[i] + DELTA;

  01c40	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  01c43	8b 34 b9	 mov	 esi, DWORD PTR [ecx+edi*4]

; 2003 : 		struct judy_object* obj;
; 2004 : 		int r;
; 2005 : 		if (dereference) {
; 2006 : 			Pvoid_t PValue;
; 2007 : 			JLG(PValue, judy, key);

  01c46	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?judy@@3PAXA ; judy
  01c4c	6a 00		 push	 0
  01c4e	46		 inc	 esi
  01c4f	56		 push	 esi
  01c50	52		 push	 edx
  01c51	e8 00 00 00 00	 call	 _JudyLGet
  01c56	8b d8		 mov	 ebx, eax
  01c58	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2008 : 			if (!PValue)

  01c5b	85 db		 test	 ebx, ebx
  01c5d	75 05		 jne	 SHORT $LN19@test_remov

; 2009 : 				abort();

  01c5f	e8 00 00 00 00	 call	 _abort
$LN19@test_remov:

; 2010 : 			obj = *(struct judy_object**)PValue;

  01c64	8b 1b		 mov	 ebx, DWORD PTR [ebx]

; 2011 : 		}
; 2012 : 		JLD(r, judy, key);

  01c66	8d 45 a4	 lea	 eax, DWORD PTR _J_Error$152983[ebp]
  01c69	50		 push	 eax
  01c6a	56		 push	 esi
  01c6b	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  01c70	e8 00 00 00 00	 call	 _JudyLDel
  01c75	83 c4 0c	 add	 esp, 12			; 0000000cH
  01c78	83 f8 ff	 cmp	 eax, -1
  01c7b	0f 84 d9 00 00
	00		 je	 $LN1370@test_remov

; 2013 : 		if (r != 1)

  01c81	83 f8 01	 cmp	 eax, 1
  01c84	74 05		 je	 SHORT $LN17@test_remov

; 2014 : 			abort();

  01c86	e8 00 00 00 00	 call	 _abort
$LN17@test_remov:

; 2015 : 		if (dereference) {
; 2016 : 			if (obj->value != key)

  01c8b	39 33		 cmp	 DWORD PTR [ebx], esi
  01c8d	74 05		 je	 SHORT $LN22@test_remov

; 2017 : 				abort();

  01c8f	e8 00 00 00 00	 call	 _abort
$LN22@test_remov:

; 1999 : 
; 2000 : #ifdef USE_JUDY
; 2001 : 	START(DATA_JUDY) {

  01c94	47		 inc	 edi
  01c95	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01c9b	72 a3		 jb	 SHORT $LL23@test_remov
$LN21@test_remov:

; 2018 : 		}
; 2019 : 	} STOP();

  01c9d	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 2020 : #endif
; 2021 : 
; 2022 : #ifdef USE_JUDYARRAY
; 2023 : 	START(DATA_JUDYARRAY) {

  01ca2	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  01ca7	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01cac	85 c0		 test	 eax, eax
  01cae	74 4a		 je	 SHORT $LN11@test_remov
  01cb0	33 db		 xor	 ebx, ebx
  01cb2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01cb8	76 40		 jbe	 SHORT $LN11@test_remov
  01cba	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
  01cbd	8d 49 00	 npad	 3
$LL13@test_remov:

; 2024 : 		judyvalue key = REMOVE[i] + DELTA;

  01cc0	8b 04 9f	 mov	 eax, DWORD PTR [edi+ebx*4]

; 2025 : 		struct judyarray_object* obj;
; 2026 : 		JudySlot* pvalue;
; 2027 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01cc3	8d 4d f4	 lea	 ecx, DWORD PTR _key$152996[ebp]
  01cc6	40		 inc	 eax
  01cc7	51		 push	 ecx
  01cc8	89 45 f4	 mov	 DWORD PTR _key$152996[ebp], eax
  01ccb	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01cd0	8b f0		 mov	 esi, eax
  01cd2	83 c4 04	 add	 esp, 4

; 2028 : 		if (!pvalue)

  01cd5	85 f6		 test	 esi, esi
  01cd7	75 05		 jne	 SHORT $LN10@test_remov

; 2029 : 			abort();

  01cd9	e8 00 00 00 00	 call	 _abort
$LN10@test_remov:

; 2030 : 		obj = *(struct judyarray_object**)pvalue;

  01cde	8b 36		 mov	 esi, DWORD PTR [esi]

; 2031 : 		judy_del(judyarray);

  01ce0	e8 00 00 00 00	 call	 ?judy_del@@YAPAIPAUJudy@@@Z ; judy_del

; 2032 : 		if (dereference) {
; 2033 : 			if (obj->value != key)

  01ce5	8b 16		 mov	 edx, DWORD PTR [esi]
  01ce7	3b 55 f4	 cmp	 edx, DWORD PTR _key$152996[ebp]
  01cea	74 05		 je	 SHORT $LN12@test_remov

; 2034 : 				abort();

  01cec	e8 00 00 00 00	 call	 _abort
$LN12@test_remov:

; 2020 : #endif
; 2021 : 
; 2022 : #ifdef USE_JUDYARRAY
; 2023 : 	START(DATA_JUDYARRAY) {

  01cf1	43		 inc	 ebx
  01cf2	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01cf8	72 c6		 jb	 SHORT $LL13@test_remov
$LN11@test_remov:

; 2035 : 		}
; 2036 : 	} STOP();

  01cfa	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 2037 : #endif
; 2038 : 
; 2039 : 	START(DATA_NEDTRIE) {

  01cff	b8 06 00 00 00	 mov	 eax, 6
  01d04	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01d09	85 c0		 test	 eax, eax
  01d0b	74 41		 je	 SHORT $LN4@test_remov
  01d0d	33 ff		 xor	 edi, edi
  01d0f	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  01d15	76 37		 jbe	 SHORT $LN4@test_remov
$LL6@test_remov:

; 2040 : 		unsigned key = REMOVE[i] + DELTA;

  01d17	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01d1a	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  01d1d	46		 inc	 esi

; 2041 : 		struct nedtrie_object key_obj;
; 2042 : 		struct nedtrie_object* obj;
; 2043 : 		key_obj.value = key;
; 2044 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01d1e	8d 45 94	 lea	 eax, DWORD PTR _key_obj$153009[ebp]
  01d21	89 75 a8	 mov	 DWORD PTR _key_obj$153009[ebp+20], esi
  01d24	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z ; nedtrie_t_NEDTRIE_FIND
  01d29	8b d8		 mov	 ebx, eax

; 2045 : 		if (!obj)

  01d2b	85 db		 test	 ebx, ebx
  01d2d	75 05		 jne	 SHORT $LN3@test_remov

; 2046 : 			abort();

  01d2f	e8 00 00 00 00	 call	 _abort
$LN3@test_remov:

; 2047 : 		NEDTRIE_REMOVE(nedtrie_t, &nedtrie, obj);

  01d34	8b d3		 mov	 edx, ebx
  01d36	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_REMOVE

; 2048 : 		if (dereference) {
; 2049 : 			if (obj->value != key)

  01d3b	39 73 14	 cmp	 DWORD PTR [ebx+20], esi
  01d3e	74 05		 je	 SHORT $LN5@test_remov

; 2050 : 				abort();

  01d40	e8 00 00 00 00	 call	 _abort
$LN5@test_remov:

; 2037 : #endif
; 2038 : 
; 2039 : 	START(DATA_NEDTRIE) {

  01d45	47		 inc	 edi
  01d46	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  01d4c	72 c9		 jb	 SHORT $LL6@test_remov
$LN4@test_remov:

; 2051 : 		}
; 2052 : 	} STOP();

  01d4e	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 2053 : }

  01d53	5f		 pop	 edi
  01d54	5e		 pop	 esi
  01d55	5b		 pop	 ebx
  01d56	8b e5		 mov	 esp, ebp
  01d58	5d		 pop	 ebp
  01d59	c3		 ret	 0
$LN1370@test_remov:

; 2011 : 		}
; 2012 : 		JLD(r, judy, key);

  01d5a	8b 4d a8	 mov	 ecx, DWORD PTR _J_Error$152983[ebp+4]
  01d5d	8b 55 a4	 mov	 edx, DWORD PTR _J_Error$152983[ebp]
  01d60	51		 push	 ecx
  01d61	52		 push	 edx
  01d62	68 00 00 00 00	 push	 OFFSET $SG-115
  01d67	68 dc 07 00 00	 push	 2012			; 000007dcH
  01d6c	68 00 00 00 00	 push	 OFFSET $SG-116
  01d71	68 00 00 00 00	 push	 OFFSET $SG-117
  01d76	e8 00 00 00 00	 call	 ___iob_func
  01d7b	83 c0 40	 add	 eax, 64			; 00000040H
  01d7e	50		 push	 eax
  01d7f	e8 00 00 00 00	 call	 _fprintf
  01d84	83 c4 1c	 add	 esp, 28			; 0000001cH
  01d87	6a 01		 push	 1
  01d89	e8 00 00 00 00	 call	 _exit
$LN1472@test_remov:
$LN1469@test_remov:
  01d8e	cc		 int	 3
?test_remove@@YAXPAI@Z ENDP				; test_remove
_TEXT	ENDS
PUBLIC	?test_change@@YAXPAI0@Z				; test_change
; Function compile flags: /Ogtp
;	COMDAT ?test_change@@YAXPAI0@Z
_TEXT	SEGMENT
$T229033 = -188						; size = 12
$T229037 = -176						; size = 12
$T230150 = -164						; size = 20
$T229360 = -156						; size = 12
_t$223733 = -144					; size = 8
_pos$229352 = -136					; size = 8
_t$223705 = -128					; size = 8
_key_obj$152668 = -120					; size = 40
_J_Error$152642 = -104					; size = 24
_J_Error$152635 = -104					; size = 24
$T230027 = -96						; size = 16
$T229163 = -96						; size = 16
_result$230065 = -80					; size = 8
_pos$224907 = -80					; size = 8
$T223101 = -80						; size = 8
_ptr$152334 = -72					; size = 16
$T229720 = -68						; size = 12
$T229206 = -68						; size = 12
_pos$229155 = -56					; size = 8
_ptr$152306 = -56					; size = 8
$T230148 = -48						; size = 8
_t$223647 = -48						; size = 8
$T226447 = -44						; size = 4
$T223109 = -44						; size = 4
$T223106 = -44						; size = 4
_t$223671 = -40						; size = 8
__he_bkt_i$152601 = -36					; size = 4
_key$152400 = -36					; size = 4
_obj$152282 = -36					; size = 4
$T229029 = -28						; size = 4
_count$223465 = -28					; size = 4
__he_new_buckets$152604 = -28				; size = 4
_r$152271 = -28						; size = 4
_key$152243 = -28					; size = 4
_key$152234 = -28					; size = 4
tv8660 = -24						; size = 4
tv8477 = -24						; size = 4
tv8426 = -24						; size = 4
_key$152305 = -24					; size = 4
tv8169 = -20						; size = 4
_i$ = -16						; size = 4
tv8690 = -12						; size = 4
tv8557 = -12						; size = 4
tv8517 = -12						; size = 4
tv8384 = -12						; size = 4
tv8276 = -12						; size = 4
_key$152655 = -12					; size = 4
_key$152372 = -12					; size = 4
_key$152344 = -12					; size = 4
_key$152279 = -12					; size = 4
_obj$152272 = -12					; size = 4
tv4974 = -8						; size = 8
tv4882 = -8						; size = 8
tv4093 = -8						; size = 8
tv3982 = -8						; size = 8
tv3817 = -8						; size = 8
tv3419 = -8						; size = 8
tv3387 = -8						; size = 8
tv3035 = -8						; size = 8
tv2962 = -8						; size = 8
$T223724 = -8						; size = 8
$T223698 = -8						; size = 8
$T223665 = -8						; size = 8
$T223639 = -8						; size = 8
$T223574 = -8						; size = 8
_t$223581 = -8						; size = 8
$T223548 = -8						; size = 8
_t$223556 = -8						; size = 8
$T223518 = -8						; size = 8
_t$223525 = -8						; size = 8
$T223492 = -8						; size = 8
_t$223500 = -8						; size = 8
$T223361 = -8						; size = 8
_t$223368 = -8						; size = 8
$T223335 = -8						; size = 8
_t$223343 = -8						; size = 8
$T223263 = -8						; size = 8
_t$223270 = -8						; size = 8
tv595 = -8						; size = 8
tv575 = -8						; size = 8
$T227641 = -4						; size = 4
__he_hh_nxt$152603 = -4					; size = 4
_ptr$152373 = -4					; size = 4
_ptr$152345 = -4					; size = 4
_key$152333 = -4					; size = 4
_REMOVE$ = 8						; size = 4
_INSERT$ = 12						; size = 4
?test_change@@YAXPAI0@Z PROC				; test_change, COMDAT

; 1498 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  00009	53		 push	 ebx

; 1499 : 	unsigned i;
; 1500 : 
; 1501 : 	const unsigned DELTA = 1;
; 1502 : 
; 1503 : 	START(DATA_TREE) {

  0000a	b8 05 00 00 00	 mov	 eax, 5
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	0f 85 c6 00 00
	00		 jne	 $LN199@test_chang
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00029	75 2e		 jne	 SHORT $LN211@test_chang
  0002b	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00036	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  0003d	50		 push	 eax
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00043	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0004a	52		 push	 edx
  0004b	51		 push	 ecx
  0004c	68 00 00 00 00	 push	 OFFSET $SG-101
  00051	e8 00 00 00 00	 call	 _printf
  00056	83 c4 10	 add	 esp, 16			; 00000010H
$LN211@test_chang:
  00059	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005e	33 db		 xor	 ebx, ebx
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00065	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006b	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  00071	76 75		 jbe	 SHORT $LN199@test_chang
  00073	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00079	2b c7		 sub	 eax, edi
  0007b	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  0007e	8b ff		 npad	 2
$LL201@test_chang:

; 1504 : 		unsigned key = REMOVE[i];
; 1505 : 		struct rbt_object key_obj;
; 1506 : 		struct rbt_object* obj;
; 1507 : 		key_obj.value = REMOVE[i];
; 1508 : 		obj = rbt_search(&tree, &key_obj); 

  00080	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?tree@@3Urbtree_t@@A
  00086	8b 55 ec	 mov	 edx, DWORD PTR tv8169[ebp]
  00089	8b 0c 3a	 mov	 ecx, DWORD PTR [edx+edi]
  0008c	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  00092	74 27		 je	 SHORT $LN1541@test_chang
$LL221@test_chang:
  00094	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00097	3b c8		 cmp	 ecx, eax
  00099	7c 14		 jl	 SHORT $LN1544@test_chang
  0009b	7e 16		 jle	 SHORT $LN220@test_chang
  0009d	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000a0	83 e6 fe	 and	 esi, -2			; fffffffeH
$LN218@test_chang:
  000a3	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  000a9	75 e9		 jne	 SHORT $LL221@test_chang
  000ab	33 f6		 xor	 esi, esi

; 1509 : 		if (!obj)

  000ad	eb 14		 jmp	 SHORT $LN1563@test_chang
$LN1544@test_chang:

; 1504 : 		unsigned key = REMOVE[i];
; 1505 : 		struct rbt_object key_obj;
; 1506 : 		struct rbt_object* obj;
; 1507 : 		key_obj.value = REMOVE[i];
; 1508 : 		obj = rbt_search(&tree, &key_obj); 

  000af	8b 36		 mov	 esi, DWORD PTR [esi]
  000b1	eb f0		 jmp	 SHORT $LN218@test_chang
$LN220@test_chang:
  000b3	81 fe 04 00 00
	00		 cmp	 esi, OFFSET ?tree@@3Urbtree_t@@A+4
  000b9	75 04		 jne	 SHORT $LN217@test_chang
$LN1541@test_chang:
  000bb	33 f6		 xor	 esi, esi

; 1509 : 		if (!obj)

  000bd	eb 04		 jmp	 SHORT $LN1563@test_chang

; 1504 : 		unsigned key = REMOVE[i];
; 1505 : 		struct rbt_object key_obj;
; 1506 : 		struct rbt_object* obj;
; 1507 : 		key_obj.value = REMOVE[i];
; 1508 : 		obj = rbt_search(&tree, &key_obj); 

$LN217@test_chang:

; 1509 : 		if (!obj)

  000bf	85 f6		 test	 esi, esi
  000c1	75 05		 jne	 SHORT $LN198@test_chang
$LN1563@test_chang:

; 1510 : 			abort();

  000c3	e8 00 00 00 00	 call	 _abort
$LN198@test_chang:

; 1511 : 		rbt_remove(&tree, obj);

  000c8	8b d6		 mov	 edx, esi
  000ca	e8 00 00 00 00	 call	 ?rbt_remove@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_remove

; 1512 : 
; 1513 : 		key = INSERT[i] + DELTA;  

  000cf	8b 07		 mov	 eax, DWORD PTR [edi]
  000d1	40		 inc	 eax

; 1514 : 		obj->value = key;

  000d2	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 1515 : 		rbt_insert(&tree, obj);

  000d5	8b c6		 mov	 eax, esi
  000d7	e8 00 00 00 00	 call	 ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_insert
  000dc	43		 inc	 ebx
  000dd	83 c7 04	 add	 edi, 4
  000e0	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  000e6	72 98		 jb	 SHORT $LL201@test_chang
$LN199@test_chang:

; 1516 : 	} STOP();

  000e8	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1517 : 
; 1518 : 	START(DATA_HASHTABLE) {

  000ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_data@@3IA, 0 ; the_data
  000f4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 0 ; the_start_data
  000fe	0f 85 a8 01 00
	00		 jne	 $LN194@test_chang
  00104	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0010b	75 30		 jne	 SHORT $LN228@test_chang
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA
  00113	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00119	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  00120	51		 push	 ecx
  00121	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00127	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0012e	50		 push	 eax
  0012f	52		 push	 edx
  00130	68 00 00 00 00	 push	 OFFSET $SG-101
  00135	e8 00 00 00 00	 call	 _printf
  0013a	83 c4 10	 add	 esp, 16			; 00000010H
$LN228@test_chang:
  0013d	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  00142	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00149	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  0014e	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  00154	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0015b	0f 86 4b 01 00
	00		 jbe	 $LN194@test_chang
  00161	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  00164	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00167	2b c7		 sub	 eax, edi
  00169	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  0016c	eb 05		 jmp	 SHORT $LN196@test_chang
  0016e	8b ff		 npad	 2
$LL1611@test_chang:
  00170	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN196@test_chang:

; 1519 : 		unsigned key = REMOVE[i];

  00173	8b 14 38	 mov	 edx, DWORD PTR [eax+edi]

; 1520 : 		unsigned hash_key = hash(key);

  00176	8b ca		 mov	 ecx, edx
  00178	c1 e1 06	 shl	 ecx, 6
  0017b	8b c2		 mov	 eax, edx
  0017d	2b c1		 sub	 eax, ecx
  0017f	8b c8		 mov	 ecx, eax
  00181	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00184	33 c1		 xor	 eax, ecx
  00186	8b c8		 mov	 ecx, eax
  00188	c1 e1 09	 shl	 ecx, 9
  0018b	2b c1		 sub	 eax, ecx

; 1521 : 		struct hashtable_object* obj;
; 1522 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  0018d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  00193	8b c8		 mov	 ecx, eax
  00195	c1 e1 04	 shl	 ecx, 4
  00198	33 c1		 xor	 eax, ecx
  0019a	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001a1	2b c1		 sub	 eax, ecx
  001a3	8b c8		 mov	 ecx, eax
  001a5	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  001a8	33 c1		 xor	 eax, ecx
  001aa	8b c8		 mov	 ecx, eax
  001ac	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  001af	33 c8		 xor	 ecx, eax
  001b1	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  001b6	23 c1		 and	 eax, ecx
  001b8	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  001bb	8b 06		 mov	 eax, DWORD PTR [esi]
  001bd	85 c0		 test	 eax, eax
  001bf	74 13		 je	 SHORT $LN237@test_chang
$LL238@test_chang:
  001c1	39 48 0c	 cmp	 DWORD PTR [eax+12], ecx
  001c4	75 08		 jne	 SHORT $LN236@test_chang
  001c6	8b 58 08	 mov	 ebx, DWORD PTR [eax+8]
  001c9	3b 53 10	 cmp	 edx, DWORD PTR [ebx+16]
  001cc	74 0a		 je	 SHORT $LN1497@test_chang
$LN236@test_chang:
  001ce	8b 00		 mov	 eax, DWORD PTR [eax]
  001d0	85 c0		 test	 eax, eax
  001d2	75 ed		 jne	 SHORT $LL238@test_chang
$LN237@test_chang:
  001d4	33 f6		 xor	 esi, esi

; 1523 : 		if (!obj)

  001d6	eb 3b		 jmp	 SHORT $LN1546@test_chang
$LN1497@test_chang:

; 1521 : 		struct hashtable_object* obj;
; 1522 : 		obj = (struct hashtable_object*)tommy_hashtable_remove(&hashtable, tommy_hashtable_compare, &key, hash_key);

  001d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001da	8b 16		 mov	 edx, DWORD PTR [esi]
  001dc	85 c9		 test	 ecx, ecx
  001de	74 08		 je	 SHORT $LN247@test_chang
  001e0	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  001e3	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  001e6	eb 06		 jmp	 SHORT $LN246@test_chang
$LN247@test_chang:
  001e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001eb	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN246@test_chang:
  001ee	3b d0		 cmp	 edx, eax
  001f0	8b 10		 mov	 edx, DWORD PTR [eax]
  001f2	75 0d		 jne	 SHORT $LN245@test_chang
  001f4	89 16		 mov	 DWORD PTR [esi], edx
  001f6	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  001fc	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  001ff	eb 0e		 jmp	 SHORT $LN239@test_chang
$LN245@test_chang:
  00201	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00204	89 11		 mov	 DWORD PTR [ecx], edx
  00206	ff 0d 0c 00 00
	00		 dec	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  0020c	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
$LN239@test_chang:

; 1523 : 		if (!obj)

  0020f	85 f6		 test	 esi, esi
  00211	75 05		 jne	 SHORT $LN193@test_chang
$LN1546@test_chang:

; 1524 : 			abort();

  00213	e8 00 00 00 00	 call	 _abort
$LN193@test_chang:

; 1525 : 
; 1526 : 		key = INSERT[i] + DELTA;

  00218	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0021a	41		 inc	 ecx

; 1527 : 		hash_key = hash(key);

  0021b	8b d1		 mov	 edx, ecx
  0021d	c1 e2 06	 shl	 edx, 6
  00220	8b c1		 mov	 eax, ecx
  00222	2b c2		 sub	 eax, edx
  00224	8b d0		 mov	 edx, eax
  00226	c1 ea 11	 shr	 edx, 17			; 00000011H
  00229	33 c2		 xor	 eax, edx
  0022b	8b d0		 mov	 edx, eax
  0022d	c1 e2 09	 shl	 edx, 9
  00230	2b c2		 sub	 eax, edx
  00232	8b d0		 mov	 edx, eax
  00234	c1 e2 04	 shl	 edx, 4
  00237	33 c2		 xor	 eax, edx
  00239	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00240	2b c2		 sub	 eax, edx
  00242	8b d0		 mov	 edx, eax
  00244	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00247	33 c2		 xor	 eax, edx
  00249	8b d0		 mov	 edx, eax
  0024b	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0024e	33 d0		 xor	 edx, eax

; 1528 : 		obj->value = key;

  00250	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 1529 : 		tommy_hashtable_insert(&hashtable, &obj->node, obj, hash_key);

  00253	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00258	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0025e	23 c2		 and	 eax, edx
  00260	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00263	8b 01		 mov	 eax, DWORD PTR [ecx]
  00265	85 c0		 test	 eax, eax
  00267	74 16		 je	 SHORT $LN257@test_chang
  00269	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0026c	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0026f	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00272	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00275	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0027b	89 30		 mov	 DWORD PTR [eax], esi
  0027d	eb 0b		 jmp	 SHORT $LN264@test_chang
$LN257@test_chang:
  0027f	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00282	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00288	89 31		 mov	 DWORD PTR [ecx], esi
$LN264@test_chang:

; 1517 : 
; 1518 : 	START(DATA_HASHTABLE) {

  0028a	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0028d	40		 inc	 eax

; 1529 : 		tommy_hashtable_insert(&hashtable, &obj->node, obj, hash_key);

  0028e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00291	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00294	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  0029a	83 c7 04	 add	 edi, 4
  0029d	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  002a0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  002a6	0f 82 c4 fe ff
	ff		 jb	 $LL1611@test_chang
$LN194@test_chang:

; 1530 : 	} STOP();

  002ac	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1531 : 
; 1532 : 	START(DATA_HASHDYN) {

  002b1	b8 01 00 00 00	 mov	 eax, 1
  002b6	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  002bb	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  002c1	0f 85 de 01 00
	00		 jne	 $LN189@test_chang
  002c7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  002ce	75 30		 jne	 SHORT $LN266@test_chang
  002d0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  002d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  002dc	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  002e3	51		 push	 ecx
  002e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  002ea	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  002f1	50		 push	 eax
  002f2	52		 push	 edx
  002f3	68 00 00 00 00	 push	 OFFSET $SG-101
  002f8	e8 00 00 00 00	 call	 _printf
  002fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN266@test_chang:
  00300	8d 45 f8	 lea	 eax, DWORD PTR _t$223270[ebp]
  00303	50		 push	 eax
  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0030a	85 c0		 test	 eax, eax
  0030c	75 11		 jne	 SHORT $LN272@test_chang
  0030e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00312	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223263[ebp], xmm0
  00317	8b 5d fc	 mov	 ebx, DWORD PTR $T223263[ebp+4]
  0031a	8b 75 f8	 mov	 esi, DWORD PTR $T223263[ebp]
  0031d	eb 54		 jmp	 SHORT $LN273@test_chang
$LN272@test_chang:
  0031f	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00325	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0032b	8b 4d fc	 mov	 ecx, DWORD PTR _t$223270[ebp+4]
  0032e	8b 55 f8	 mov	 edx, DWORD PTR _t$223270[ebp]
  00331	56		 push	 esi
  00332	57		 push	 edi
  00333	51		 push	 ecx
  00334	52		 push	 edx
  00335	e8 00 00 00 00	 call	 __alldvrm
  0033a	6a 00		 push	 0
  0033c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00341	53		 push	 ebx
  00342	51		 push	 ecx
  00343	89 45 f8	 mov	 DWORD PTR tv4974[ebp], eax
  00346	89 55 fc	 mov	 DWORD PTR tv4974[ebp+4], edx
  00349	e8 00 00 00 00	 call	 __allmul
  0034e	56		 push	 esi
  0034f	57		 push	 edi
  00350	52		 push	 edx
  00351	50		 push	 eax
  00352	e8 00 00 00 00	 call	 __alldiv
  00357	8b 4d f8	 mov	 ecx, DWORD PTR tv4974[ebp]
  0035a	6a 00		 push	 0
  0035c	8b f0		 mov	 esi, eax
  0035e	8b 45 fc	 mov	 eax, DWORD PTR tv4974[ebp+4]
  00361	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00366	50		 push	 eax
  00367	51		 push	 ecx
  00368	8b da		 mov	 ebx, edx
  0036a	e8 00 00 00 00	 call	 __allmul
  0036f	03 f0		 add	 esi, eax
  00371	13 da		 adc	 ebx, edx
$LN273@test_chang:
  00373	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0037a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00380	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00386	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0038d	0f 86 12 01 00
	00		 jbe	 $LN189@test_chang
  00393	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  00396	8b 7d 08	 mov	 edi, DWORD PTR _REMOVE$[ebp]
  00399	2b fb		 sub	 edi, ebx
  0039b	eb 03 8d 49 00	 npad	 5
$LL191@test_chang:

; 1533 : 		unsigned key = REMOVE[i];

  003a0	8b 0c 1f	 mov	 ecx, DWORD PTR [edi+ebx]

; 1534 : 		unsigned hash_key = hash(key);

  003a3	8b d1		 mov	 edx, ecx
  003a5	89 4d e4	 mov	 DWORD PTR _key$152234[ebp], ecx
  003a8	c1 e2 06	 shl	 edx, 6
  003ab	2b ca		 sub	 ecx, edx
  003ad	8b c1		 mov	 eax, ecx
  003af	c1 e8 11	 shr	 eax, 17			; 00000011H
  003b2	33 c8		 xor	 ecx, eax
  003b4	8b d1		 mov	 edx, ecx
  003b6	c1 e2 09	 shl	 edx, 9
  003b9	2b ca		 sub	 ecx, edx
  003bb	8b c1		 mov	 eax, ecx
  003bd	c1 e0 04	 shl	 eax, 4
  003c0	33 c8		 xor	 ecx, eax
  003c2	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*8]
  003c9	2b ca		 sub	 ecx, edx
  003cb	8b c1		 mov	 eax, ecx
  003cd	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  003d0	33 c8		 xor	 ecx, eax
  003d2	8b c1		 mov	 eax, ecx
  003d4	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  003d7	33 c1		 xor	 eax, ecx

; 1535 : 		struct hashtable_object* obj;
; 1536 : 		obj = (struct hashtable_object*)tommy_hashdyn_remove(&hashdyn, tommy_hashtable_compare, &key, hash_key);

  003d9	8d 4d e4	 lea	 ecx, DWORD PTR _key$152234[ebp]
  003dc	51		 push	 ecx
  003dd	e8 00 00 00 00	 call	 _tommy_hashdyn_remove
  003e2	8b f0		 mov	 esi, eax
  003e4	83 c4 04	 add	 esp, 4

; 1537 : 		if (!obj)

  003e7	85 f6		 test	 esi, esi
  003e9	75 05		 jne	 SHORT $LN188@test_chang

; 1538 : 			abort();

  003eb	e8 00 00 00 00	 call	 _abort
$LN188@test_chang:

; 1539 : 
; 1540 : 		key = INSERT[i] + DELTA;

  003f0	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  003f2	41		 inc	 ecx

; 1541 : 		hash_key = hash(key);

  003f3	8b d1		 mov	 edx, ecx
  003f5	c1 e2 06	 shl	 edx, 6
  003f8	8b c1		 mov	 eax, ecx
  003fa	2b c2		 sub	 eax, edx
  003fc	8b d0		 mov	 edx, eax
  003fe	c1 ea 11	 shr	 edx, 17			; 00000011H
  00401	33 c2		 xor	 eax, edx
  00403	8b d0		 mov	 edx, eax
  00405	c1 e2 09	 shl	 edx, 9
  00408	2b c2		 sub	 eax, edx
  0040a	8b d0		 mov	 edx, eax
  0040c	c1 e2 04	 shl	 edx, 4
  0040f	33 c2		 xor	 eax, edx
  00411	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00418	2b c2		 sub	 eax, edx
  0041a	8b d0		 mov	 edx, eax
  0041c	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0041f	33 c2		 xor	 eax, edx
  00421	8b d0		 mov	 edx, eax
  00423	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00426	33 d0		 xor	 edx, eax

; 1542 : 		obj->value = key;

  00428	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 1543 : 		tommy_hashdyn_insert(&hashdyn, &obj->node, obj, hash_key);

  0042b	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  00430	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  00436	23 c2		 and	 eax, edx
  00438	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  0043b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0043d	85 c0		 test	 eax, eax
  0043f	74 16		 je	 SHORT $LN282@test_chang
  00441	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00444	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00447	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0044a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0044d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00453	89 30		 mov	 DWORD PTR [eax], esi
  00455	eb 0b		 jmp	 SHORT $LN289@test_chang
$LN282@test_chang:
  00457	89 76 04	 mov	 DWORD PTR [esi+4], esi
  0045a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00460	89 31		 mov	 DWORD PTR [ecx], esi
$LN289@test_chang:
  00462	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00465	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00468	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  0046d	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00473	40		 inc	 eax
  00474	d1 e9		 shr	 ecx, 1
  00476	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0047b	3b c1		 cmp	 eax, ecx
  0047d	72 10		 jb	 SHORT $LN190@test_chang
  0047f	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00485	42		 inc	 edx
  00486	52		 push	 edx
  00487	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0048c	83 c4 04	 add	 esp, 4
$LN190@test_chang:

; 1531 : 
; 1532 : 	START(DATA_HASHDYN) {

  0048f	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00492	40		 inc	 eax
  00493	83 c3 04	 add	 ebx, 4
  00496	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00499	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0049f	0f 82 fb fe ff
	ff		 jb	 $LL191@test_chang
$LN189@test_chang:

; 1544 : 	} STOP();

  004a5	8d 45 f8	 lea	 eax, DWORD PTR _t$223343[ebp]
  004a8	50		 push	 eax
  004a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  004af	85 c0		 test	 eax, eax
  004b1	75 11		 jne	 SHORT $LN298@test_chang
  004b3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  004b7	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223335[ebp], xmm0
  004bc	8b 5d fc	 mov	 ebx, DWORD PTR $T223335[ebp+4]
  004bf	8b 75 f8	 mov	 esi, DWORD PTR $T223335[ebp]
  004c2	eb 54		 jmp	 SHORT $LN299@test_chang
$LN298@test_chang:
  004c4	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  004ca	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  004d0	8b 4d fc	 mov	 ecx, DWORD PTR _t$223343[ebp+4]
  004d3	8b 55 f8	 mov	 edx, DWORD PTR _t$223343[ebp]
  004d6	56		 push	 esi
  004d7	57		 push	 edi
  004d8	51		 push	 ecx
  004d9	52		 push	 edx
  004da	e8 00 00 00 00	 call	 __alldvrm
  004df	6a 00		 push	 0
  004e1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004e6	53		 push	 ebx
  004e7	51		 push	 ecx
  004e8	89 45 f8	 mov	 DWORD PTR tv2962[ebp], eax
  004eb	89 55 fc	 mov	 DWORD PTR tv2962[ebp+4], edx
  004ee	e8 00 00 00 00	 call	 __allmul
  004f3	56		 push	 esi
  004f4	57		 push	 edi
  004f5	52		 push	 edx
  004f6	50		 push	 eax
  004f7	e8 00 00 00 00	 call	 __alldiv
  004fc	8b 4d f8	 mov	 ecx, DWORD PTR tv2962[ebp]
  004ff	6a 00		 push	 0
  00501	8b f0		 mov	 esi, eax
  00503	8b 45 fc	 mov	 eax, DWORD PTR tv2962[ebp+4]
  00506	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0050b	50		 push	 eax
  0050c	51		 push	 ecx
  0050d	8b da		 mov	 ebx, edx
  0050f	e8 00 00 00 00	 call	 __allmul
  00514	03 f0		 add	 esi, eax
  00516	13 da		 adc	 ebx, edx
$LN299@test_chang:
  00518	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  0051e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00524	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0052a	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00530	75 63		 jne	 SHORT $LN296@test_chang
  00532	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00539	75 24		 jne	 SHORT $LN294@test_chang
  0053b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00541	6a 00		 push	 0
  00543	52		 push	 edx
  00544	53		 push	 ebx
  00545	56		 push	 esi
  00546	e8 00 00 00 00	 call	 __aulldiv
  0054b	50		 push	 eax
  0054c	68 00 00 00 00	 push	 OFFSET $SG-102
  00551	e8 00 00 00 00	 call	 _printf
  00556	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  0055c	83 c4 08	 add	 esp, 8
$LN294@test_chang:
  0055f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00564	6a 00		 push	 0
  00566	50		 push	 eax
  00567	53		 push	 ebx
  00568	56		 push	 esi
  00569	e8 00 00 00 00	 call	 __aulldiv
  0056e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00574	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0057a	c1 e1 04	 shl	 ecx, 4
  0057d	03 cf		 add	 ecx, edi
  0057f	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00582	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00588	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0058b	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0058e	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN296@test_chang:

; 1545 : 
; 1546 : 	START(DATA_HASHLIN) {

  00595	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 2 ; the_start_data
  0059f	83 ff 02	 cmp	 edi, 2
  005a2	0f 85 13 02 00
	00		 jne	 $LN184@test_chang
  005a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  005af	75 2f		 jne	 SHORT $LN303@test_chang
  005b1	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  005b7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  005bc	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  005c3	52		 push	 edx
  005c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  005ca	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  005d1	51		 push	 ecx
  005d2	50		 push	 eax
  005d3	68 00 00 00 00	 push	 OFFSET $SG-101
  005d8	e8 00 00 00 00	 call	 _printf
  005dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN303@test_chang:
  005e0	8d 4d f8	 lea	 ecx, DWORD PTR _t$223368[ebp]
  005e3	51		 push	 ecx
  005e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  005ea	85 c0		 test	 eax, eax
  005ec	75 11		 jne	 SHORT $LN309@test_chang
  005ee	66 0f 57 c0	 xorpd	 xmm0, xmm0
  005f2	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223361[ebp], xmm0
  005f7	8b 5d fc	 mov	 ebx, DWORD PTR $T223361[ebp+4]
  005fa	8b 75 f8	 mov	 esi, DWORD PTR $T223361[ebp]
  005fd	eb 54		 jmp	 SHORT $LN310@test_chang
$LN309@test_chang:
  005ff	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00605	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0060b	8b 55 fc	 mov	 edx, DWORD PTR _t$223368[ebp+4]
  0060e	8b 45 f8	 mov	 eax, DWORD PTR _t$223368[ebp]
  00611	56		 push	 esi
  00612	57		 push	 edi
  00613	52		 push	 edx
  00614	50		 push	 eax
  00615	e8 00 00 00 00	 call	 __alldvrm
  0061a	6a 00		 push	 0
  0061c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00621	53		 push	 ebx
  00622	51		 push	 ecx
  00623	89 45 f8	 mov	 DWORD PTR tv3035[ebp], eax
  00626	89 55 fc	 mov	 DWORD PTR tv3035[ebp+4], edx
  00629	e8 00 00 00 00	 call	 __allmul
  0062e	56		 push	 esi
  0062f	57		 push	 edi
  00630	52		 push	 edx
  00631	50		 push	 eax
  00632	e8 00 00 00 00	 call	 __alldiv
  00637	8b 4d fc	 mov	 ecx, DWORD PTR tv3035[ebp+4]
  0063a	6a 00		 push	 0
  0063c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00641	8b da		 mov	 ebx, edx
  00643	8b 55 f8	 mov	 edx, DWORD PTR tv3035[ebp]
  00646	51		 push	 ecx
  00647	52		 push	 edx
  00648	8b f0		 mov	 esi, eax
  0064a	e8 00 00 00 00	 call	 __allmul
  0064f	03 f0		 add	 esi, eax
  00651	13 da		 adc	 ebx, edx
$LN310@test_chang:
  00653	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0065a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00660	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00666	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0066d	0f 86 48 01 00
	00		 jbe	 $LN184@test_chang
  00673	8b 45 0c	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00676	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  00679	8b f8		 mov	 edi, eax
  0067b	2b c8		 sub	 ecx, eax
  0067d	89 7d f4	 mov	 DWORD PTR tv8276[ebp], edi
  00680	89 4d ec	 mov	 DWORD PTR tv8169[ebp], ecx
  00683	eb 03		 jmp	 SHORT $LN186@test_chang
$LL1612@test_chang:
  00685	8b 4d ec	 mov	 ecx, DWORD PTR tv8169[ebp]
$LN186@test_chang:

; 1547 : 		unsigned key = REMOVE[i];

  00688	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]

; 1548 : 		unsigned hash_key = hash(key);

  0068b	8b c1		 mov	 eax, ecx
  0068d	c1 e0 06	 shl	 eax, 6
  00690	89 4d e4	 mov	 DWORD PTR _key$152243[ebp], ecx
  00693	2b c8		 sub	 ecx, eax
  00695	8b d1		 mov	 edx, ecx
  00697	c1 ea 11	 shr	 edx, 17			; 00000011H
  0069a	33 ca		 xor	 ecx, edx
  0069c	8b c1		 mov	 eax, ecx
  0069e	c1 e0 09	 shl	 eax, 9
  006a1	2b c8		 sub	 ecx, eax
  006a3	8b d1		 mov	 edx, ecx
  006a5	c1 e2 04	 shl	 edx, 4
  006a8	33 ca		 xor	 ecx, edx
  006aa	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  006b1	2b c8		 sub	 ecx, eax
  006b3	8b d1		 mov	 edx, ecx
  006b5	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  006b8	33 ca		 xor	 ecx, edx
  006ba	8b c1		 mov	 eax, ecx
  006bc	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  006bf	33 c1		 xor	 eax, ecx

; 1549 : 		struct hashtable_object* obj;
; 1550 : 		obj = (struct hashtable_object*)tommy_hashlin_remove(&hashlin, tommy_hashtable_compare, &key, hash_key);

  006c1	8d 4d e4	 lea	 ecx, DWORD PTR _key$152243[ebp]
  006c4	51		 push	 ecx
  006c5	e8 00 00 00 00	 call	 _tommy_hashlin_remove
  006ca	8b f0		 mov	 esi, eax
  006cc	83 c4 04	 add	 esp, 4

; 1551 : 		if (!obj)

  006cf	85 f6		 test	 esi, esi
  006d1	75 05		 jne	 SHORT $LN183@test_chang

; 1552 : 			abort();

  006d3	e8 00 00 00 00	 call	 _abort
$LN183@test_chang:

; 1553 : 
; 1554 : 		key = INSERT[i] + DELTA;

  006d8	8b 0f		 mov	 ecx, DWORD PTR [edi]
  006da	41		 inc	 ecx

; 1555 : 		hash_key = hash(key);

  006db	8b d1		 mov	 edx, ecx
  006dd	c1 e2 06	 shl	 edx, 6
  006e0	8b c1		 mov	 eax, ecx
  006e2	2b c2		 sub	 eax, edx
  006e4	8b d0		 mov	 edx, eax
  006e6	c1 ea 11	 shr	 edx, 17			; 00000011H
  006e9	33 c2		 xor	 eax, edx
  006eb	8b d0		 mov	 edx, eax
  006ed	c1 e2 09	 shl	 edx, 9
  006f0	2b c2		 sub	 eax, edx
  006f2	8b d0		 mov	 edx, eax
  006f4	c1 e2 04	 shl	 edx, 4
  006f7	33 c2		 xor	 eax, edx
  006f9	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00700	2b c2		 sub	 eax, edx
  00702	8b d0		 mov	 edx, eax
  00704	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00707	33 c2		 xor	 eax, edx
  00709	8b d0		 mov	 edx, eax
  0070b	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0070e	33 d0		 xor	 edx, eax

; 1556 : 		obj->value = key;

  00710	89 4e 10	 mov	 DWORD PTR [esi+16], ecx

; 1557 : 		tommy_hashlin_insert(&hashlin, &obj->node, obj, hash_key);

  00713	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0071a	74 1c		 je	 SHORT $LN318@test_chang
  0071c	a1 94 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00721	23 c2		 and	 eax, edx
  00723	3b 05 98 00 00
	00		 cmp	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  00729	72 0d		 jb	 SHORT $LN318@test_chang
  0072b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0072e	73 1c		 jae	 SHORT $LN327@test_chang
  00730	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00736	eb 2a		 jmp	 SHORT $LN1615@test_chang
$LN318@test_chang:
  00738	a1 88 00 00 00	 mov	 eax, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  0073d	23 c2		 and	 eax, edx
  0073f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00742	73 08		 jae	 SHORT $LN327@test_chang
  00744	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0074a	eb 16		 jmp	 SHORT $LN1615@test_chang
$LN327@test_chang:
  0074c	0f bd c8	 bsr	 ecx, eax
  0074f	bf 01 00 00 00	 mov	 edi, 1
  00754	d3 e7		 shl	 edi, cl
  00756	89 4d e4	 mov	 DWORD PTR _count$223465[ebp], ecx
  00759	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
  00760	2b c7		 sub	 eax, edi
$LN1615@test_chang:
  00762	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00765	8b c8		 mov	 ecx, eax
  00767	8b 01		 mov	 eax, DWORD PTR [ecx]
  00769	85 c0		 test	 eax, eax
  0076b	74 16		 je	 SHORT $LN333@test_chang
  0076d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00770	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00773	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00776	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00779	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0077f	89 30		 mov	 DWORD PTR [eax], esi
  00781	eb 0b		 jmp	 SHORT $LN340@test_chang
$LN333@test_chang:
  00783	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00786	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0078c	89 31		 mov	 DWORD PTR [ecx], esi
$LN340@test_chang:
  0078e	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00791	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00794	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  0079a	e8 00 00 00 00	 call	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
  0079f	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  007a2	8b 7d f4	 mov	 edi, DWORD PTR tv8276[ebp]
  007a5	40		 inc	 eax
  007a6	83 c7 04	 add	 edi, 4
  007a9	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  007ac	89 7d f4	 mov	 DWORD PTR tv8276[ebp], edi
  007af	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  007b5	0f 82 ca fe ff
	ff		 jb	 $LL1612@test_chang
$LN184@test_chang:

; 1558 : 	} STOP();

  007bb	8d 4d f8	 lea	 ecx, DWORD PTR _t$223500[ebp]
  007be	51		 push	 ecx
  007bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  007c5	85 c0		 test	 eax, eax
  007c7	75 11		 jne	 SHORT $LN346@test_chang
  007c9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  007cd	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223492[ebp], xmm0
  007d2	8b 5d fc	 mov	 ebx, DWORD PTR $T223492[ebp+4]
  007d5	8b 75 f8	 mov	 esi, DWORD PTR $T223492[ebp]
  007d8	eb 54		 jmp	 SHORT $LN347@test_chang
$LN346@test_chang:
  007da	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  007e0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  007e6	8b 55 fc	 mov	 edx, DWORD PTR _t$223500[ebp+4]
  007e9	8b 45 f8	 mov	 eax, DWORD PTR _t$223500[ebp]
  007ec	56		 push	 esi
  007ed	57		 push	 edi
  007ee	52		 push	 edx
  007ef	50		 push	 eax
  007f0	e8 00 00 00 00	 call	 __alldvrm
  007f5	6a 00		 push	 0
  007f7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  007fc	53		 push	 ebx
  007fd	51		 push	 ecx
  007fe	89 45 f8	 mov	 DWORD PTR tv3387[ebp], eax
  00801	89 55 fc	 mov	 DWORD PTR tv3387[ebp+4], edx
  00804	e8 00 00 00 00	 call	 __allmul
  00809	56		 push	 esi
  0080a	57		 push	 edi
  0080b	52		 push	 edx
  0080c	50		 push	 eax
  0080d	e8 00 00 00 00	 call	 __alldiv
  00812	8b 4d fc	 mov	 ecx, DWORD PTR tv3387[ebp+4]
  00815	6a 00		 push	 0
  00817	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0081c	8b da		 mov	 ebx, edx
  0081e	8b 55 f8	 mov	 edx, DWORD PTR tv3387[ebp]
  00821	51		 push	 ecx
  00822	52		 push	 edx
  00823	8b f0		 mov	 esi, eax
  00825	e8 00 00 00 00	 call	 __allmul
  0082a	03 f0		 add	 esi, eax
  0082c	13 da		 adc	 ebx, edx
$LN347@test_chang:
  0082e	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00834	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  0083a	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00840	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00846	75 63		 jne	 SHORT $LN344@test_chang
  00848	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0084f	75 23		 jne	 SHORT $LN342@test_chang
  00851	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00856	6a 00		 push	 0
  00858	50		 push	 eax
  00859	53		 push	 ebx
  0085a	56		 push	 esi
  0085b	e8 00 00 00 00	 call	 __aulldiv
  00860	50		 push	 eax
  00861	68 00 00 00 00	 push	 OFFSET $SG-102
  00866	e8 00 00 00 00	 call	 _printf
  0086b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00871	83 c4 08	 add	 esp, 8
$LN342@test_chang:
  00874	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  0087a	6a 00		 push	 0
  0087c	51		 push	 ecx
  0087d	53		 push	 ebx
  0087e	56		 push	 esi
  0087f	e8 00 00 00 00	 call	 __aulldiv
  00884	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  0088a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00890	c1 e2 04	 shl	 edx, 4
  00893	03 d7		 add	 edx, edi
  00895	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00898	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  0089b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  008a1	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  008a4	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN344@test_chang:

; 1559 : 
; 1560 : 	START(DATA_TRIE) {

  008ab	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 3 ; the_start_data
  008b5	83 ff 03	 cmp	 edi, 3
  008b8	0f 85 36 01 00
	00		 jne	 $LN179@test_chang
  008be	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  008c5	75 2e		 jne	 SHORT $LN351@test_chang
  008c7	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  008cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  008d2	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  008d9	50		 push	 eax
  008da	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  008df	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  008e6	52		 push	 edx
  008e7	51		 push	 ecx
  008e8	68 00 00 00 00	 push	 OFFSET $SG-101
  008ed	e8 00 00 00 00	 call	 _printf
  008f2	83 c4 10	 add	 esp, 16			; 00000010H
$LN351@test_chang:
  008f5	8d 55 f8	 lea	 edx, DWORD PTR _t$223525[ebp]
  008f8	52		 push	 edx
  008f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  008ff	85 c0		 test	 eax, eax
  00901	75 11		 jne	 SHORT $LN357@test_chang
  00903	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00907	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223518[ebp], xmm0
  0090c	8b 5d fc	 mov	 ebx, DWORD PTR $T223518[ebp+4]
  0090f	8b 75 f8	 mov	 esi, DWORD PTR $T223518[ebp]
  00912	eb 54		 jmp	 SHORT $LN358@test_chang
$LN357@test_chang:
  00914	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0091a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00920	8b 45 fc	 mov	 eax, DWORD PTR _t$223525[ebp+4]
  00923	8b 4d f8	 mov	 ecx, DWORD PTR _t$223525[ebp]
  00926	56		 push	 esi
  00927	57		 push	 edi
  00928	50		 push	 eax
  00929	51		 push	 ecx
  0092a	e8 00 00 00 00	 call	 __alldvrm
  0092f	6a 00		 push	 0
  00931	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00936	53		 push	 ebx
  00937	51		 push	 ecx
  00938	89 45 f8	 mov	 DWORD PTR tv3419[ebp], eax
  0093b	89 55 fc	 mov	 DWORD PTR tv3419[ebp+4], edx
  0093e	e8 00 00 00 00	 call	 __allmul
  00943	56		 push	 esi
  00944	57		 push	 edi
  00945	52		 push	 edx
  00946	50		 push	 eax
  00947	e8 00 00 00 00	 call	 __alldiv
  0094c	6a 00		 push	 0
  0094e	8b da		 mov	 ebx, edx
  00950	8b 55 fc	 mov	 edx, DWORD PTR tv3419[ebp+4]
  00953	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00958	8b f0		 mov	 esi, eax
  0095a	8b 45 f8	 mov	 eax, DWORD PTR tv3419[ebp]
  0095d	52		 push	 edx
  0095e	50		 push	 eax
  0095f	e8 00 00 00 00	 call	 __allmul
  00964	03 f0		 add	 esi, eax
  00966	13 da		 adc	 ebx, edx
$LN358@test_chang:
  00968	33 ff		 xor	 edi, edi
  0096a	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00970	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00976	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  0097c	76 76		 jbe	 SHORT $LN179@test_chang
  0097e	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  00981	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00984	2b c3		 sub	 eax, ebx
  00986	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  00989	8d a4 24 00 00
	00 00		 npad	 7
$LL181@test_chang:

; 1561 : 		unsigned key = REMOVE[i];

  00990	8b 4d ec	 mov	 ecx, DWORD PTR tv8169[ebp]
  00993	8b 04 19	 mov	 eax, DWORD PTR [ecx+ebx]

; 1562 : 		struct trie_object* obj;
; 1563 : 		obj = (struct trie_object*)tommy_trie_remove(&trie, key);

  00996	8b d0		 mov	 edx, eax
  00998	c1 ea 1c	 shr	 edx, 28			; 0000001cH
  0099b	8d 14 95 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[edx*4]
  009a2	e8 00 00 00 00	 call	 ?trie_bucket_remove_existing@@YAPAUtommy_node_struct@@PAUtommy_trie_struct@@IPAPAU1@PAU1@I@Z ; trie_bucket_remove_existing
  009a7	85 c0		 test	 eax, eax
  009a9	75 04		 jne	 SHORT $LN360@test_chang
  009ab	33 f6		 xor	 esi, esi
  009ad	eb 0d		 jmp	 SHORT $LN1550@test_chang
$LN360@test_chang:
  009af	ff 0d 40 00 00
	00		 dec	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  009b5	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 1564 : 		if (!obj)

  009b8	85 f6		 test	 esi, esi
  009ba	75 05		 jne	 SHORT $LN178@test_chang
$LN1550@test_chang:

; 1565 : 			abort();

  009bc	e8 00 00 00 00	 call	 _abort
$LN178@test_chang:

; 1566 : 
; 1567 : 		key = INSERT[i] + DELTA;

  009c1	8b 03		 mov	 eax, DWORD PTR [ebx]
  009c3	40		 inc	 eax

; 1568 : 		obj->value = key;
; 1569 : 		tommy_trie_insert(&trie, &obj->node, obj, key);

  009c4	50		 push	 eax
  009c5	89 46 10	 mov	 DWORD PTR [esi+16], eax
  009c8	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  009cb	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  009ce	8d 04 85 00 00
	00 00		 lea	 eax, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  009d5	56		 push	 esi
  009d6	50		 push	 eax
  009d7	89 76 08	 mov	 DWORD PTR [esi+8], esi
  009da	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  009df	ff 05 40 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  009e5	47		 inc	 edi
  009e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e9	83 c3 04	 add	 ebx, 4
  009ec	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  009f2	72 9c		 jb	 SHORT $LL181@test_chang
$LN179@test_chang:

; 1570 : 	} STOP();

  009f4	8d 4d f8	 lea	 ecx, DWORD PTR _t$223556[ebp]
  009f7	51		 push	 ecx
  009f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  009fe	85 c0		 test	 eax, eax
  00a00	75 11		 jne	 SHORT $LN369@test_chang
  00a02	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00a06	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223548[ebp], xmm0
  00a0b	8b 5d fc	 mov	 ebx, DWORD PTR $T223548[ebp+4]
  00a0e	8b 75 f8	 mov	 esi, DWORD PTR $T223548[ebp]
  00a11	eb 54		 jmp	 SHORT $LN370@test_chang
$LN369@test_chang:
  00a13	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00a19	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00a1f	8b 55 fc	 mov	 edx, DWORD PTR _t$223556[ebp+4]
  00a22	8b 45 f8	 mov	 eax, DWORD PTR _t$223556[ebp]
  00a25	56		 push	 esi
  00a26	57		 push	 edi
  00a27	52		 push	 edx
  00a28	50		 push	 eax
  00a29	e8 00 00 00 00	 call	 __alldvrm
  00a2e	6a 00		 push	 0
  00a30	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a35	53		 push	 ebx
  00a36	51		 push	 ecx
  00a37	89 45 f8	 mov	 DWORD PTR tv4882[ebp], eax
  00a3a	89 55 fc	 mov	 DWORD PTR tv4882[ebp+4], edx
  00a3d	e8 00 00 00 00	 call	 __allmul
  00a42	56		 push	 esi
  00a43	57		 push	 edi
  00a44	52		 push	 edx
  00a45	50		 push	 eax
  00a46	e8 00 00 00 00	 call	 __alldiv
  00a4b	8b 4d fc	 mov	 ecx, DWORD PTR tv4882[ebp+4]
  00a4e	6a 00		 push	 0
  00a50	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a55	8b da		 mov	 ebx, edx
  00a57	8b 55 f8	 mov	 edx, DWORD PTR tv4882[ebp]
  00a5a	51		 push	 ecx
  00a5b	52		 push	 edx
  00a5c	8b f0		 mov	 esi, eax
  00a5e	e8 00 00 00 00	 call	 __allmul
  00a63	03 f0		 add	 esi, eax
  00a65	13 da		 adc	 ebx, edx
$LN370@test_chang:
  00a67	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00a6d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00a73	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00a79	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00a7f	75 63		 jne	 SHORT $LN367@test_chang
  00a81	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00a88	75 23		 jne	 SHORT $LN365@test_chang
  00a8a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00a8f	6a 00		 push	 0
  00a91	50		 push	 eax
  00a92	53		 push	 ebx
  00a93	56		 push	 esi
  00a94	e8 00 00 00 00	 call	 __aulldiv
  00a99	50		 push	 eax
  00a9a	68 00 00 00 00	 push	 OFFSET $SG-102
  00a9f	e8 00 00 00 00	 call	 _printf
  00aa4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00aaa	83 c4 08	 add	 esp, 8
$LN365@test_chang:
  00aad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00ab3	6a 00		 push	 0
  00ab5	51		 push	 ecx
  00ab6	53		 push	 ebx
  00ab7	56		 push	 esi
  00ab8	e8 00 00 00 00	 call	 __aulldiv
  00abd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  00ac3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00ac9	c1 e2 04	 shl	 edx, 4
  00acc	03 d7		 add	 edx, edi
  00ace	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  00ad1	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  00ad4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00ada	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  00add	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN367@test_chang:

; 1571 : 
; 1572 : 	START(DATA_TRIE_INPLACE) {

  00ae4	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 4 ; the_start_data
  00aee	83 ff 04	 cmp	 edi, 4
  00af1	0f 85 9e 01 00
	00		 jne	 $LN174@test_chang
  00af7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00afe	75 2e		 jne	 SHORT $LN374@test_chang
  00b00	a1 10 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  00b05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00b0b	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00b12	50		 push	 eax
  00b13	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00b18	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00b1f	52		 push	 edx
  00b20	51		 push	 ecx
  00b21	68 00 00 00 00	 push	 OFFSET $SG-101
  00b26	e8 00 00 00 00	 call	 _printf
  00b2b	83 c4 10	 add	 esp, 16			; 00000010H
$LN374@test_chang:
  00b2e	8d 55 f8	 lea	 edx, DWORD PTR _t$223581[ebp]
  00b31	52		 push	 edx
  00b32	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00b38	85 c0		 test	 eax, eax
  00b3a	75 11		 jne	 SHORT $LN380@test_chang
  00b3c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00b40	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223574[ebp], xmm0
  00b45	8b 7d fc	 mov	 edi, DWORD PTR $T223574[ebp+4]
  00b48	8b 75 f8	 mov	 esi, DWORD PTR $T223574[ebp]
  00b4b	eb 54		 jmp	 SHORT $LN381@test_chang
$LN380@test_chang:
  00b4d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00b53	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00b59	8b 45 fc	 mov	 eax, DWORD PTR _t$223581[ebp+4]
  00b5c	8b 4d f8	 mov	 ecx, DWORD PTR _t$223581[ebp]
  00b5f	56		 push	 esi
  00b60	57		 push	 edi
  00b61	50		 push	 eax
  00b62	51		 push	 ecx
  00b63	e8 00 00 00 00	 call	 __alldvrm
  00b68	6a 00		 push	 0
  00b6a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b6f	53		 push	 ebx
  00b70	51		 push	 ecx
  00b71	89 45 f8	 mov	 DWORD PTR tv3817[ebp], eax
  00b74	89 55 fc	 mov	 DWORD PTR tv3817[ebp+4], edx
  00b77	e8 00 00 00 00	 call	 __allmul
  00b7c	56		 push	 esi
  00b7d	57		 push	 edi
  00b7e	52		 push	 edx
  00b7f	50		 push	 eax
  00b80	e8 00 00 00 00	 call	 __alldiv
  00b85	6a 00		 push	 0
  00b87	8b fa		 mov	 edi, edx
  00b89	8b 55 fc	 mov	 edx, DWORD PTR tv3817[ebp+4]
  00b8c	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00b91	8b f0		 mov	 esi, eax
  00b93	8b 45 f8	 mov	 eax, DWORD PTR tv3817[ebp]
  00b96	52		 push	 edx
  00b97	50		 push	 eax
  00b98	e8 00 00 00 00	 call	 __allmul
  00b9d	03 f0		 add	 esi, eax
  00b9f	13 fa		 adc	 edi, edx
$LN381@test_chang:
  00ba1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00ba8	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00bae	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  00bb4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00bbb	0f 86 d4 00 00
	00		 jbe	 $LN174@test_chang
  00bc1	8b 45 0c	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00bc4	8b 4d 08	 mov	 ecx, DWORD PTR _REMOVE$[ebp]
  00bc7	8b f8		 mov	 edi, eax
  00bc9	2b c8		 sub	 ecx, eax
  00bcb	89 7d f4	 mov	 DWORD PTR tv8384[ebp], edi
  00bce	89 4d ec	 mov	 DWORD PTR tv8169[ebp], ecx
  00bd1	eb 03		 jmp	 SHORT $LN176@test_chang
$LL1613@test_chang:
  00bd3	8b 4d ec	 mov	 ecx, DWORD PTR tv8169[ebp]
$LN176@test_chang:

; 1573 : 		unsigned key = REMOVE[i];

  00bd6	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]

; 1574 : 		struct trie_inplace_object* obj;
; 1575 : 		obj = (struct trie_inplace_object*)tommy_trie_inplace_remove(&trie_inplace, key);

  00bd9	8b ca		 mov	 ecx, edx
  00bdb	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  00bde	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  00be5	50		 push	 eax
  00be6	e8 00 00 00 00	 call	 ?trie_inplace_bucket_remove@@YAPAUtommy_trie_inplace_node_struct@@IPAPAU1@PAU1@I@Z ; trie_inplace_bucket_remove
  00beb	83 c4 04	 add	 esp, 4
  00bee	85 c0		 test	 eax, eax
  00bf0	75 04		 jne	 SHORT $LN383@test_chang
  00bf2	33 f6		 xor	 esi, esi
  00bf4	eb 0d		 jmp	 SHORT $LN1552@test_chang
$LN383@test_chang:
  00bf6	ff 0d 00 01 00
	00		 dec	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00bfc	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 1576 : 		if (!obj)

  00bff	85 f6		 test	 esi, esi
  00c01	75 05		 jne	 SHORT $LN173@test_chang
$LN1552@test_chang:

; 1577 : 			abort();

  00c03	e8 00 00 00 00	 call	 _abort
$LN173@test_chang:

; 1578 : 
; 1579 : 		key = INSERT[i] + DELTA;

  00c08	8b 07		 mov	 eax, DWORD PTR [edi]
  00c0a	40		 inc	 eax

; 1580 : 		obj->value = key;
; 1581 : 		tommy_trie_inplace_insert(&trie_inplace, &obj->node, obj, key);

  00c0b	8b c8		 mov	 ecx, eax
  00c0d	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  00c10	89 46 20	 mov	 DWORD PTR [esi+32], eax
  00c13	89 76 08	 mov	 DWORD PTR [esi+8], esi
  00c16	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00c19	66 0f ef c0	 pxor	 xmm0, xmm0
  00c1d	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
  00c22	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  00c29	66 0f d6 46 18	 movq	 QWORD PTR [esi+24], xmm0
  00c2e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00c30	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00c35	85 d2		 test	 edx, edx
  00c37	74 19		 je	 SHORT $LN1540@test_chang
$LN394@test_chang:
  00c39	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  00c3c	74 21		 je	 SHORT $LN392@test_chang
  00c3e	8b f8		 mov	 edi, eax
  00c40	d3 ef		 shr	 edi, cl
  00c42	83 e9 02	 sub	 ecx, 2
  00c45	83 e7 03	 and	 edi, 3
  00c48	8d 5c ba 10	 lea	 ebx, DWORD PTR [edx+edi*4+16]
  00c4c	8b 13		 mov	 edx, DWORD PTR [ebx]
  00c4e	85 d2		 test	 edx, edx
  00c50	75 e7		 jne	 SHORT $LN394@test_chang
$LN1540@test_chang:
  00c52	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00c55	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00c5b	89 33		 mov	 DWORD PTR [ebx], esi
  00c5d	eb 14		 jmp	 SHORT $LN399@test_chang
$LN392@test_chang:
  00c5f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00c62	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00c65	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00c68	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00c6b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00c71	89 31		 mov	 DWORD PTR [ecx], esi
$LN399@test_chang:

; 1571 : 
; 1572 : 	START(DATA_TRIE_INPLACE) {

  00c73	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00c76	8b 7d f4	 mov	 edi, DWORD PTR tv8384[ebp]

; 1580 : 		obj->value = key;
; 1581 : 		tommy_trie_inplace_insert(&trie_inplace, &obj->node, obj, key);

  00c79	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00c7f	40		 inc	 eax
  00c80	83 c7 04	 add	 edi, 4
  00c83	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00c86	89 7d f4	 mov	 DWORD PTR tv8384[ebp], edi
  00c89	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00c8f	0f 82 3e ff ff
	ff		 jb	 $LL1613@test_chang
$LN174@test_chang:

; 1582 : 	} STOP();

  00c95	8d 55 d0	 lea	 edx, DWORD PTR _t$223647[ebp]
  00c98	52		 push	 edx
  00c99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00c9f	85 c0		 test	 eax, eax
  00ca1	75 11		 jne	 SHORT $LN405@test_chang
  00ca3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ca7	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223639[ebp], xmm0
  00cac	8b 5d fc	 mov	 ebx, DWORD PTR $T223639[ebp+4]
  00caf	8b 75 f8	 mov	 esi, DWORD PTR $T223639[ebp]
  00cb2	eb 54		 jmp	 SHORT $LN406@test_chang
$LN405@test_chang:
  00cb4	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00cba	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00cc0	8b 45 d4	 mov	 eax, DWORD PTR _t$223647[ebp+4]
  00cc3	8b 4d d0	 mov	 ecx, DWORD PTR _t$223647[ebp]
  00cc6	56		 push	 esi
  00cc7	57		 push	 edi
  00cc8	50		 push	 eax
  00cc9	51		 push	 ecx
  00cca	e8 00 00 00 00	 call	 __alldvrm
  00ccf	6a 00		 push	 0
  00cd1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00cd6	53		 push	 ebx
  00cd7	51		 push	 ecx
  00cd8	89 45 f8	 mov	 DWORD PTR tv3982[ebp], eax
  00cdb	89 55 fc	 mov	 DWORD PTR tv3982[ebp+4], edx
  00cde	e8 00 00 00 00	 call	 __allmul
  00ce3	56		 push	 esi
  00ce4	57		 push	 edi
  00ce5	52		 push	 edx
  00ce6	50		 push	 eax
  00ce7	e8 00 00 00 00	 call	 __alldiv
  00cec	6a 00		 push	 0
  00cee	8b da		 mov	 ebx, edx
  00cf0	8b 55 fc	 mov	 edx, DWORD PTR tv3982[ebp+4]
  00cf3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00cf8	8b f0		 mov	 esi, eax
  00cfa	8b 45 f8	 mov	 eax, DWORD PTR tv3982[ebp]
  00cfd	52		 push	 edx
  00cfe	50		 push	 eax
  00cff	e8 00 00 00 00	 call	 __allmul
  00d04	03 f0		 add	 esi, eax
  00d06	13 da		 adc	 ebx, edx
$LN406@test_chang:
  00d08	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  00d0e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00d14	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00d1a	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00d20	75 64		 jne	 SHORT $LN403@test_chang
  00d22	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d29	75 24		 jne	 SHORT $LN401@test_chang
  00d2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00d31	6a 00		 push	 0
  00d33	51		 push	 ecx
  00d34	53		 push	 ebx
  00d35	56		 push	 esi
  00d36	e8 00 00 00 00	 call	 __aulldiv
  00d3b	50		 push	 eax
  00d3c	68 00 00 00 00	 push	 OFFSET $SG-102
  00d41	e8 00 00 00 00	 call	 _printf
  00d46	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  00d4c	83 c4 08	 add	 esp, 8
$LN401@test_chang:
  00d4f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00d55	6a 00		 push	 0
  00d57	52		 push	 edx
  00d58	53		 push	 ebx
  00d59	56		 push	 esi
  00d5a	e8 00 00 00 00	 call	 __aulldiv
  00d5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00d65	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00d6b	c1 e1 04	 shl	 ecx, 4
  00d6e	03 cf		 add	 ecx, edi
  00d70	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d79	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00d7c	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d7f	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN403@test_chang:

; 1583 : 
; 1584 : 	START(DATA_KHASH) {

  00d86	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 7 ; the_start_data
  00d90	83 ff 07	 cmp	 edi, 7
  00d93	0f 85 f0 01 00
	00		 jne	 $LN169@test_chang
  00d99	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00da0	75 2f		 jne	 SHORT $LN410@test_chang
  00da2	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00da8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00dad	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00db4	52		 push	 edx
  00db5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00dbb	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00dc2	51		 push	 ecx
  00dc3	50		 push	 eax
  00dc4	68 00 00 00 00	 push	 OFFSET $SG-101
  00dc9	e8 00 00 00 00	 call	 _printf
  00dce	83 c4 10	 add	 esp, 16			; 00000010H
$LN410@test_chang:
  00dd1	8d 4d d8	 lea	 ecx, DWORD PTR _t$223671[ebp]
  00dd4	51		 push	 ecx
  00dd5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00ddb	85 c0		 test	 eax, eax
  00ddd	75 11		 jne	 SHORT $LN416@test_chang
  00ddf	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00de3	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223665[ebp], xmm0
  00de8	8b 5d fc	 mov	 ebx, DWORD PTR $T223665[ebp+4]
  00deb	8b 75 f8	 mov	 esi, DWORD PTR $T223665[ebp]
  00dee	eb 54		 jmp	 SHORT $LN417@test_chang
$LN416@test_chang:
  00df0	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00df6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00dfc	8b 55 dc	 mov	 edx, DWORD PTR _t$223671[ebp+4]
  00dff	8b 45 d8	 mov	 eax, DWORD PTR _t$223671[ebp]
  00e02	56		 push	 esi
  00e03	57		 push	 edi
  00e04	52		 push	 edx
  00e05	50		 push	 eax
  00e06	e8 00 00 00 00	 call	 __alldvrm
  00e0b	6a 00		 push	 0
  00e0d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e12	53		 push	 ebx
  00e13	51		 push	 ecx
  00e14	89 45 f8	 mov	 DWORD PTR tv4093[ebp], eax
  00e17	89 55 fc	 mov	 DWORD PTR tv4093[ebp+4], edx
  00e1a	e8 00 00 00 00	 call	 __allmul
  00e1f	56		 push	 esi
  00e20	57		 push	 edi
  00e21	52		 push	 edx
  00e22	50		 push	 eax
  00e23	e8 00 00 00 00	 call	 __alldiv
  00e28	8b 4d fc	 mov	 ecx, DWORD PTR tv4093[ebp+4]
  00e2b	6a 00		 push	 0
  00e2d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e32	8b da		 mov	 ebx, edx
  00e34	8b 55 f8	 mov	 edx, DWORD PTR tv4093[ebp]
  00e37	51		 push	 ecx
  00e38	52		 push	 edx
  00e39	8b f0		 mov	 esi, eax
  00e3b	e8 00 00 00 00	 call	 __allmul
  00e40	03 f0		 add	 esi, eax
  00e42	13 da		 adc	 ebx, edx
$LN417@test_chang:
  00e44	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00e4b	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  00e51	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00e57	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e5e	0f 86 25 01 00
	00		 jbe	 $LN169@test_chang
  00e64	8b 75 0c	 mov	 esi, DWORD PTR _INSERT$[ebp]
  00e67	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  00e6a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00e70	2b c6		 sub	 eax, esi
  00e72	89 75 e8	 mov	 DWORD PTR tv8426[ebp], esi
  00e75	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  00e78	eb 09		 jmp	 SHORT $LN171@test_chang
  00e7a	8d 9b 00 00 00
	00		 npad	 6
$LL1587@test_chang:
  00e80	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN171@test_chang:

; 1585 : 		unsigned key = REMOVE[i];
; 1586 : 		unsigned hash_key = hash(key);

  00e83	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00e86	8b c8		 mov	 ecx, eax
  00e88	c1 e1 06	 shl	 ecx, 6
  00e8b	2b c1		 sub	 eax, ecx
  00e8d	8b d0		 mov	 edx, eax
  00e8f	c1 ea 11	 shr	 edx, 17			; 00000011H
  00e92	33 c2		 xor	 eax, edx
  00e94	8b c8		 mov	 ecx, eax
  00e96	c1 e1 09	 shl	 ecx, 9
  00e99	2b c1		 sub	 eax, ecx
  00e9b	8b d0		 mov	 edx, eax
  00e9d	c1 e2 04	 shl	 edx, 4
  00ea0	33 c2		 xor	 eax, edx
  00ea2	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00ea9	2b c1		 sub	 eax, ecx
  00eab	8b d0		 mov	 edx, eax
  00ead	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00eb0	33 c2		 xor	 eax, edx
  00eb2	8b c8		 mov	 ecx, eax
  00eb4	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  00eb7	33 c8		 xor	 ecx, eax

; 1587 : 		khiter_t k;
; 1588 : 		int r;
; 1589 : 		struct khash_object* obj;
; 1590 : 		k = kh_get(word, khash, hash_key);

  00eb9	51		 push	 ecx
  00eba	e8 00 00 00 00	 call	 ?kh_get_word@@YAIPAUkh_word_t@@I@Z ; kh_get_word
  00ebf	8b f0		 mov	 esi, eax
  00ec1	83 c4 04	 add	 esp, 4

; 1591 : 		if (k == kh_end(khash))

  00ec4	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00ec6	75 0b		 jne	 SHORT $LN168@test_chang

; 1592 : 			abort();

  00ec8	e8 00 00 00 00	 call	 _abort
  00ecd	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
$LN168@test_chang:

; 1593 : 		obj = kh_value(khash, k);

  00ed3	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00ed6	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  00ed9	89 45 f4	 mov	 DWORD PTR _obj$152272[ebp], eax

; 1594 : 		kh_del(word, khash, k);

  00edc	3b 33		 cmp	 esi, DWORD PTR [ebx]
  00ede	74 27		 je	 SHORT $LN421@test_chang
  00ee0	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  00ee3	8b ce		 mov	 ecx, esi
  00ee5	c1 e9 04	 shr	 ecx, 4
  00ee8	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  00eeb	83 e6 0f	 and	 esi, 15			; 0000000fH
  00eee	8d 3c 8a	 lea	 edi, DWORD PTR [edx+ecx*4]
  00ef1	03 f6		 add	 esi, esi
  00ef3	8b ce		 mov	 ecx, esi
  00ef5	d3 e8		 shr	 eax, cl
  00ef7	a8 03		 test	 al, 3
  00ef9	75 0c		 jne	 SHORT $LN421@test_chang
  00efb	ba 01 00 00 00	 mov	 edx, 1
  00f00	d3 e2		 shl	 edx, cl
  00f02	09 17		 or	 DWORD PTR [edi], edx
  00f04	ff 4b 04	 dec	 DWORD PTR [ebx+4]
$LN421@test_chang:

; 1595 : 
; 1596 : 		key = INSERT[i] + DELTA;

  00f07	8b 75 e8	 mov	 esi, DWORD PTR tv8426[ebp]
  00f0a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00f0c	41		 inc	 ecx

; 1597 : 		hash_key = hash(key);

  00f0d	8b d1		 mov	 edx, ecx
  00f0f	c1 e2 06	 shl	 edx, 6
  00f12	8b c1		 mov	 eax, ecx
  00f14	2b c2		 sub	 eax, edx
  00f16	8b d0		 mov	 edx, eax
  00f18	c1 ea 11	 shr	 edx, 17			; 00000011H
  00f1b	33 c2		 xor	 eax, edx
  00f1d	8b d0		 mov	 edx, eax
  00f1f	c1 e2 09	 shl	 edx, 9
  00f22	2b c2		 sub	 eax, edx
  00f24	8b d0		 mov	 edx, eax
  00f26	c1 e2 04	 shl	 edx, 4
  00f29	33 c2		 xor	 eax, edx
  00f2b	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00f32	2b c2		 sub	 eax, edx
  00f34	8b d0		 mov	 edx, eax
  00f36	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00f39	33 c2		 xor	 eax, edx

; 1598 : 		obj->value = key;

  00f3b	8b 55 f4	 mov	 edx, DWORD PTR _obj$152272[ebp]
  00f3e	89 0a		 mov	 DWORD PTR [edx], ecx
  00f40	8b d0		 mov	 edx, eax

; 1599 : 		k = kh_put(word, khash, hash_key, &r);

  00f42	8d 4d e4	 lea	 ecx, DWORD PTR _r$152271[ebp]
  00f45	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00f48	51		 push	 ecx
  00f49	33 d0		 xor	 edx, eax
  00f4b	52		 push	 edx
  00f4c	e8 00 00 00 00	 call	 ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ; kh_put_word
  00f51	83 c4 08	 add	 esp, 8

; 1600 : 		if (!r)

  00f54	83 7d e4 00	 cmp	 DWORD PTR _r$152271[ebp], 0
  00f58	8b f8		 mov	 edi, eax
  00f5a	75 05		 jne	 SHORT $LN167@test_chang

; 1601 : 			abort();

  00f5c	e8 00 00 00 00	 call	 _abort
$LN167@test_chang:

; 1602 : 		kh_value(khash, k) = obj;

  00f61	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00f67	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00f6a	8b 4d f4	 mov	 ecx, DWORD PTR _obj$152272[ebp]
  00f6d	89 0c b8	 mov	 DWORD PTR [eax+edi*4], ecx
  00f70	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00f73	40		 inc	 eax
  00f74	83 c6 04	 add	 esi, 4
  00f77	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00f7a	89 75 e8	 mov	 DWORD PTR tv8426[ebp], esi
  00f7d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00f83	0f 82 f7 fe ff
	ff		 jb	 $LL1587@test_chang
$LN169@test_chang:

; 1603 : 	} STOP();

  00f89	8d 55 80	 lea	 edx, DWORD PTR _t$223705[ebp]
  00f8c	52		 push	 edx
  00f8d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00f93	85 c0		 test	 eax, eax
  00f95	75 11		 jne	 SHORT $LN430@test_chang
  00f97	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00f9b	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223698[ebp], xmm0
  00fa0	8b 5d fc	 mov	 ebx, DWORD PTR $T223698[ebp+4]
  00fa3	8b 75 f8	 mov	 esi, DWORD PTR $T223698[ebp]
  00fa6	eb 54		 jmp	 SHORT $LN431@test_chang
$LN430@test_chang:
  00fa8	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  00fae	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  00fb4	8b 45 84	 mov	 eax, DWORD PTR _t$223705[ebp+4]
  00fb7	8b 4d 80	 mov	 ecx, DWORD PTR _t$223705[ebp]
  00fba	56		 push	 esi
  00fbb	57		 push	 edi
  00fbc	50		 push	 eax
  00fbd	51		 push	 ecx
  00fbe	e8 00 00 00 00	 call	 __alldvrm
  00fc3	6a 00		 push	 0
  00fc5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fca	53		 push	 ebx
  00fcb	51		 push	 ecx
  00fcc	89 45 f8	 mov	 DWORD PTR tv575[ebp], eax
  00fcf	89 55 fc	 mov	 DWORD PTR tv575[ebp+4], edx
  00fd2	e8 00 00 00 00	 call	 __allmul
  00fd7	56		 push	 esi
  00fd8	57		 push	 edi
  00fd9	52		 push	 edx
  00fda	50		 push	 eax
  00fdb	e8 00 00 00 00	 call	 __alldiv
  00fe0	6a 00		 push	 0
  00fe2	8b da		 mov	 ebx, edx
  00fe4	8b 55 fc	 mov	 edx, DWORD PTR tv575[ebp+4]
  00fe7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00fec	8b f0		 mov	 esi, eax
  00fee	8b 45 f8	 mov	 eax, DWORD PTR tv575[ebp]
  00ff1	52		 push	 edx
  00ff2	50		 push	 eax
  00ff3	e8 00 00 00 00	 call	 __allmul
  00ff8	03 f0		 add	 esi, eax
  00ffa	13 da		 adc	 ebx, edx
$LN431@test_chang:
  00ffc	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  01002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  01008	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0100e	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01014	75 64		 jne	 SHORT $LN428@test_chang
  01016	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0101d	75 24		 jne	 SHORT $LN426@test_chang
  0101f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  01025	6a 00		 push	 0
  01027	51		 push	 ecx
  01028	53		 push	 ebx
  01029	56		 push	 esi
  0102a	e8 00 00 00 00	 call	 __aulldiv
  0102f	50		 push	 eax
  01030	68 00 00 00 00	 push	 OFFSET $SG-102
  01035	e8 00 00 00 00	 call	 _printf
  0103a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  01040	83 c4 08	 add	 esp, 8
$LN426@test_chang:
  01043	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01049	6a 00		 push	 0
  0104b	52		 push	 edx
  0104c	53		 push	 ebx
  0104d	56		 push	 esi
  0104e	e8 00 00 00 00	 call	 __aulldiv
  01053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01059	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0105f	c1 e1 04	 shl	 ecx, 4
  01062	03 cf		 add	 ecx, edi
  01064	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01067	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0106d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01070	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01073	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN428@test_chang:

; 1604 : 
; 1605 : #ifdef USE_CGOOGLEDENSEHASH
; 1606 : 	START(DATA_CGOOGLE) {
; 1607 : 		unsigned key = REMOVE[i];
; 1608 : 		HTItem* ptr;
; 1609 : 		struct google_object* obj;
; 1610 : 		u_long ptr_value;
; 1611 : 		ptr = HashFind(cgoogledensehash, key);
; 1612 : 		if (!ptr)
; 1613 : 			abort();
; 1614 : 		obj = (void*)ptr->data;
; 1615 : 		HashDeleteLast(cgoogledensehash);
; 1616 : 
; 1617 : 		key = INSERT[i] + DELTA;
; 1618 : 		obj->value = key;
; 1619 : 		ptr_value = (u_long)obj;
; 1620 : 		ptr = HashInsert(cgoogledensehash, key, ptr_value);
; 1621 : 		if (!ptr)
; 1622 : 			abort();
; 1623 : 	} STOP();
; 1624 : #endif
; 1625 : 
; 1626 : #ifdef USE_GOOGLEDENSEHASH
; 1627 : 	START(DATA_GOOGLEDENSEHASH) {

  0107a	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 11 ; the_start_data, 0000000bH
  01084	83 ff 0b	 cmp	 edi, 11			; 0000000bH
  01087	0f 85 72 03 00
	00		 jne	 $LN163@test_chang
  0108d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01094	75 2f		 jne	 SHORT $LN435@test_chang
  01096	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  0109c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  010a1	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  010a8	52		 push	 edx
  010a9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  010af	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  010b6	51		 push	 ecx
  010b7	50		 push	 eax
  010b8	68 00 00 00 00	 push	 OFFSET $SG-101
  010bd	e8 00 00 00 00	 call	 _printf
  010c2	83 c4 10	 add	 esp, 16			; 00000010H
$LN435@test_chang:
  010c5	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _t$223733[ebp]
  010cb	51		 push	 ecx
  010cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  010d2	85 c0		 test	 eax, eax
  010d4	75 11		 jne	 SHORT $LN441@test_chang
  010d6	66 0f 57 c0	 xorpd	 xmm0, xmm0
  010da	66 0f 13 45 f8	 movlpd	 QWORD PTR $T223724[ebp], xmm0
  010df	8b 7d fc	 mov	 edi, DWORD PTR $T223724[ebp+4]
  010e2	8b 75 f8	 mov	 esi, DWORD PTR $T223724[ebp]
  010e5	eb 5a		 jmp	 SHORT $LN442@test_chang
$LN441@test_chang:
  010e7	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  010ed	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  010f3	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _t$223733[ebp+4]
  010f9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _t$223733[ebp]
  010ff	56		 push	 esi
  01100	57		 push	 edi
  01101	52		 push	 edx
  01102	50		 push	 eax
  01103	e8 00 00 00 00	 call	 __alldvrm
  01108	6a 00		 push	 0
  0110a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0110f	53		 push	 ebx
  01110	51		 push	 ecx
  01111	89 45 f8	 mov	 DWORD PTR tv595[ebp], eax
  01114	89 55 fc	 mov	 DWORD PTR tv595[ebp+4], edx
  01117	e8 00 00 00 00	 call	 __allmul
  0111c	56		 push	 esi
  0111d	57		 push	 edi
  0111e	52		 push	 edx
  0111f	50		 push	 eax
  01120	e8 00 00 00 00	 call	 __alldiv
  01125	8b 4d fc	 mov	 ecx, DWORD PTR tv595[ebp+4]
  01128	6a 00		 push	 0
  0112a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0112f	8b fa		 mov	 edi, edx
  01131	8b 55 f8	 mov	 edx, DWORD PTR tv595[ebp]
  01134	51		 push	 ecx
  01135	52		 push	 edx
  01136	8b f0		 mov	 esi, eax
  01138	e8 00 00 00 00	 call	 __allmul
  0113d	03 f0		 add	 esi, eax
  0113f	13 fa		 adc	 edi, edx
$LN442@test_chang:
  01141	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01148	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  0114e	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  01154	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0115b	0f 86 9e 02 00
	00		 jbe	 $LN163@test_chang
  01161	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  01164	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01167	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  0116d	2b c1		 sub	 eax, ecx
  0116f	89 4d e8	 mov	 DWORD PTR tv8477[ebp], ecx
  01172	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  01175	eb 03		 jmp	 SHORT $LN165@test_chang
$LL1584@test_chang:
  01177	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN165@test_chang:

; 1628 : 		unsigned key = REMOVE[i];

  0117a	8b 4d e8	 mov	 ecx, DWORD PTR tv8477[ebp]
  0117d	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]

; 1629 : 		googledensehash_t::iterator ptr = googledensehash->find(key);

  01180	8b 4f 24	 mov	 ecx, DWORD PTR [edi+36]
  01183	2b 4f 20	 sub	 ecx, DWORD PTR [edi+32]
  01186	89 55 f4	 mov	 DWORD PTR _key$152279[ebp], edx
  01189	75 2f		 jne	 SHORT $LN448@test_chang
  0118b	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  0118e	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  01191	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  01194	8b f1		 mov	 esi, ecx
  01196	3b f1		 cmp	 esi, ecx
  01198	74 63		 je	 SHORT $LN562@test_chang
  0119a	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  0119d	8d 49 00	 npad	 3
$LL460@test_chang:
  011a0	8b 06		 mov	 eax, DWORD PTR [esi]
  011a2	3b d8		 cmp	 ebx, eax
  011a4	74 0b		 je	 SHORT $LN458@test_chang
  011a6	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  011aa	76 51		 jbe	 SHORT $LN562@test_chang
  011ac	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  011af	75 4c		 jne	 SHORT $LN562@test_chang
$LN458@test_chang:
  011b1	83 c6 08	 add	 esi, 8
  011b4	3b f1		 cmp	 esi, ecx
  011b6	75 e8		 jne	 SHORT $LL460@test_chang
  011b8	eb 43		 jmp	 SHORT $LN562@test_chang
$LN448@test_chang:
  011ba	8d 4d b0	 lea	 ecx, DWORD PTR _pos$224907[ebp]
  011bd	51		 push	 ecx
  011be	8d 45 f4	 lea	 eax, DWORD PTR _key$152279[ebp]
  011c1	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  011c6	8b 45 b0	 mov	 eax, DWORD PTR _pos$224907[ebp]
  011c9	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  011cc	83 f8 ff	 cmp	 eax, -1
  011cf	75 29		 jne	 SHORT $LN447@test_chang
  011d1	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  011d4	8d 0c c2	 lea	 ecx, DWORD PTR [edx+eax*8]
  011d7	8b f1		 mov	 esi, ecx
  011d9	3b f1		 cmp	 esi, ecx
  011db	74 20		 je	 SHORT $LN562@test_chang
  011dd	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
$LL512@test_chang:
  011e0	8b 06		 mov	 eax, DWORD PTR [esi]
  011e2	3b d8		 cmp	 ebx, eax
  011e4	74 0b		 je	 SHORT $LN510@test_chang
  011e6	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  011ea	76 11		 jbe	 SHORT $LN562@test_chang
  011ec	39 47 1c	 cmp	 DWORD PTR [edi+28], eax
  011ef	75 0c		 jne	 SHORT $LN562@test_chang
$LN510@test_chang:
  011f1	83 c6 08	 add	 esi, 8
  011f4	3b f1		 cmp	 esi, ecx
  011f6	75 e8		 jne	 SHORT $LL512@test_chang
  011f8	eb 03		 jmp	 SHORT $LN562@test_chang
$LN447@test_chang:
  011fa	8d 34 c2	 lea	 esi, DWORD PTR [edx+eax*8]
$LN562@test_chang:

; 1630 : 		struct google_object* obj;
; 1631 : 		if (ptr == googledensehash->end())

  011fd	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  01200	8d 14 ca	 lea	 edx, DWORD PTR [edx+ecx*8]
  01203	8b c2		 mov	 eax, edx
  01205	3b c2		 cmp	 eax, edx
  01207	74 20		 je	 SHORT $LN653@test_chang
  01209	8d a4 24 00 00
	00 00		 npad	 7
$LL616@test_chang:
  01210	8b 08		 mov	 ecx, DWORD PTR [eax]
  01212	39 4f 2c	 cmp	 DWORD PTR [edi+44], ecx
  01215	74 0b		 je	 SHORT $LN614@test_chang
  01217	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0121b	76 0c		 jbe	 SHORT $LN653@test_chang
  0121d	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  01220	75 07		 jne	 SHORT $LN653@test_chang
$LN614@test_chang:
  01222	83 c0 08	 add	 eax, 8
  01225	3b c2		 cmp	 eax, edx
  01227	75 e7		 jne	 SHORT $LL616@test_chang
$LN653@test_chang:
  01229	3b f0		 cmp	 esi, eax
  0122b	75 0b		 jne	 SHORT $LN162@test_chang

; 1632 : 			abort();

  0122d	e8 00 00 00 00	 call	 _abort
  01232	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN162@test_chang:

; 1633 : 		obj = ptr->second;

  01238	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 1634 : 		googledensehash->erase(ptr);

  0123b	8b 47 28	 mov	 eax, DWORD PTR [edi+40]
  0123e	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  01241	89 55 dc	 mov	 DWORD PTR _obj$152282[ebp], edx
  01244	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  01247	8b c2		 mov	 eax, edx
  01249	3b c2		 cmp	 eax, edx
  0124b	74 1b		 je	 SHORT $LN717@test_chang
  0124d	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
$LL680@test_chang:
  01250	8b 08		 mov	 ecx, DWORD PTR [eax]
  01252	3b d9		 cmp	 ebx, ecx
  01254	74 0b		 je	 SHORT $LN678@test_chang
  01256	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  0125a	76 0c		 jbe	 SHORT $LN717@test_chang
  0125c	39 4f 1c	 cmp	 DWORD PTR [edi+28], ecx
  0125f	75 07		 jne	 SHORT $LN717@test_chang
$LN678@test_chang:
  01261	83 c0 08	 add	 eax, 8
  01264	3b c2		 cmp	 eax, edx
  01266	75 e8		 jne	 SHORT $LL680@test_chang
$LN717@test_chang:
  01268	3b f0		 cmp	 esi, eax
  0126a	74 2d		 je	 SHORT $LN757@test_chang
  0126c	83 7f 20 00	 cmp	 DWORD PTR [edi+32], 0
  01270	76 0e		 jbe	 SHORT $LN741@test_chang
  01272	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01275	3b 16		 cmp	 edx, DWORD PTR [esi]
  01277	75 07		 jne	 SHORT $LN741@test_chang
  01279	b8 01 00 00 00	 mov	 eax, 1
  0127e	eb 02		 jmp	 SHORT $LN742@test_chang
$LN741@test_chang:
  01280	33 c0		 xor	 eax, eax
$LN742@test_chang:
  01282	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  01285	89 0e		 mov	 DWORD PTR [esi], ecx
  01287	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0128e	84 c0		 test	 al, al
  01290	75 07		 jne	 SHORT $LN757@test_chang
  01292	ff 47 20	 inc	 DWORD PTR [edi+32]
  01295	c6 47 10 01	 mov	 BYTE PTR [edi+16], 1
$LN757@test_chang:

; 1635 : 
; 1636 : 		key = INSERT[i] + DELTA;

  01299	8b 55 e8	 mov	 edx, DWORD PTR tv8477[ebp]
  0129c	8b 1a		 mov	 ebx, DWORD PTR [edx]

; 1637 : 		obj->value = key;

  0129e	8b 45 dc	 mov	 eax, DWORD PTR _obj$152282[ebp]
  012a1	43		 inc	 ebx

; 1638 : 		(*googledensehash)[key] = obj;

  012a2	8d 4d c8	 lea	 ecx, DWORD PTR _pos$229155[ebp]
  012a5	89 18		 mov	 DWORD PTR [eax], ebx
  012a7	51		 push	 ecx
  012a8	8d 45 f4	 lea	 eax, DWORD PTR _key$152279[ebp]
  012ab	89 5d f4	 mov	 DWORD PTR _key$152279[ebp], ebx
  012ae	8b f7		 mov	 esi, edi
  012b0	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  012b5	8b 45 c8	 mov	 eax, DWORD PTR _pos$229155[ebp]
  012b8	83 f8 ff	 cmp	 eax, -1
  012bb	74 0b		 je	 SHORT $LN764@test_chang
  012bd	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  012c0	8d 34 c2	 lea	 esi, DWORD PTR [edx+eax*8]
  012c3	e9 1a 01 00 00	 jmp	 $LN761@test_chang
$LN764@test_chang:
  012c8	57		 push	 edi
  012c9	b8 01 00 00 00	 mov	 eax, 1
  012ce	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
  012d3	84 c0		 test	 al, al
  012d5	0f 84 b3 00 00
	00		 je	 $LN762@test_chang
  012db	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _pos$229352[ebp]
  012e1	50		 push	 eax
  012e2	8d 45 e4	 lea	 eax, DWORD PTR $T229029[ebp]
  012e5	8b fe		 mov	 edi, esi
  012e7	89 5d e4	 mov	 DWORD PTR $T229029[ebp], ebx
  012ea	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  012ef	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _pos$229352[ebp]
  012f5	83 f9 ff	 cmp	 ecx, -1
  012f8	74 1c		 je	 SHORT $LN798@test_chang
  012fa	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  012fd	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  01300	89 b5 44 ff ff
	ff		 mov	 DWORD PTR $T229033[ebp], esi
  01306	89 8d 48 ff ff
	ff		 mov	 DWORD PTR $T229033[ebp+4], ecx
  0130c	f3 0f 7e 85 44
	ff ff ff	 movq	 xmm0, QWORD PTR $T229033[ebp]
  01314	eb 65		 jmp	 SHORT $LN1616@test_chang
$LN798@test_chang:
  01316	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  01319	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0131c	2b c8		 sub	 ecx, eax
  0131e	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  01324	0f 83 10 01 00
	00		 jae	 $LN1498@test_chang
  0132a	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _pos$229352[ebp+4]
  01330	85 c0		 test	 eax, eax
  01332	74 11		 je	 SHORT $LN870@test_chang
  01334	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  01337	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0133a	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  0133d	75 06		 jne	 SHORT $LN870@test_chang
  0133f	48		 dec	 eax
  01340	89 46 20	 mov	 DWORD PTR [esi+32], eax
  01343	eb 07		 jmp	 SHORT $LN869@test_chang
$LN870@test_chang:
  01345	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  01348	40		 inc	 eax
  01349	89 46 24	 mov	 DWORD PTR [esi+36], eax
$LN869@test_chang:
  0134c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0134f	03 c9		 add	 ecx, ecx
  01351	03 c9		 add	 ecx, ecx
  01353	03 c9		 add	 ecx, ecx
  01355	03 c1		 add	 eax, ecx
  01357	74 09		 je	 SHORT $LN956@test_chang
  01359	89 18		 mov	 DWORD PTR [eax], ebx
  0135b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN956@test_chang:
  01362	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  01365	03 c8		 add	 ecx, eax
  01367	89 b5 50 ff ff
	ff		 mov	 DWORD PTR $T229037[ebp], esi
  0136d	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T229037[ebp+4], ecx
  01373	f3 0f 7e 85 50
	ff ff ff	 movq	 xmm0, QWORD PTR $T229037[ebp]
$LN1616@test_chang:
  0137b	8b 56 28	 mov	 edx, DWORD PTR [esi+40]
  0137e	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  01381	66 0f d6 45 a0	 movq	 QWORD PTR $T229163[ebp], xmm0
  01386	8b 75 a4	 mov	 esi, DWORD PTR $T229163[ebp+4]
  01389	89 45 a8	 mov	 DWORD PTR $T229163[ebp+8], eax
  0138c	eb 4e		 jmp	 SHORT $LN1617@test_chang
$LN762@test_chang:
  0138e	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  01391	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  01394	2b c8		 sub	 ecx, eax
  01396	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  0139c	0f 83 c9 00 00
	00		 jae	 $LN1499@test_chang
  013a2	8b 4d cc	 mov	 ecx, DWORD PTR _pos$229155[ebp+4]
  013a5	85 c0		 test	 eax, eax
  013a7	74 11		 je	 SHORT $LN1061@test_chang
  013a9	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  013ac	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  013af	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  013b2	75 06		 jne	 SHORT $LN1061@test_chang
  013b4	48		 dec	 eax
  013b5	89 46 20	 mov	 DWORD PTR [esi+32], eax
  013b8	eb 07		 jmp	 SHORT $LN1060@test_chang
$LN1061@test_chang:
  013ba	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  013bd	40		 inc	 eax
  013be	89 46 24	 mov	 DWORD PTR [esi+36], eax
$LN1060@test_chang:
  013c1	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  013c4	03 c9		 add	 ecx, ecx
  013c6	03 c9		 add	 ecx, ecx
  013c8	03 c9		 add	 ecx, ecx
  013ca	03 c1		 add	 eax, ecx
  013cc	74 09		 je	 SHORT $LN1147@test_chang
  013ce	89 18		 mov	 DWORD PTR [eax], ebx
  013d0	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN1147@test_chang:
  013d7	8b 76 34	 mov	 esi, DWORD PTR [esi+52]
  013da	03 f1		 add	 esi, ecx
$LN1617@test_chang:
  013dc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN761@test_chang:
  013e2	8b 45 dc	 mov	 eax, DWORD PTR _obj$152282[ebp]
  013e5	83 45 e8 04	 add	 DWORD PTR tv8477[ebp], 4
  013e9	89 46 04	 mov	 DWORD PTR [esi+4], eax
  013ec	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  013ef	40		 inc	 eax
  013f0	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  013f3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  013f9	0f 82 78 fd ff
	ff		 jb	 $LL1584@test_chang
$LN163@test_chang:

; 1639 : 	} STOP();

  013ff	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1640 : #endif
; 1641 : 
; 1642 : #ifdef USE_GOOGLEBTREE
; 1643 : 	START(DATA_GOOGLEBTREE) {

  01404	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  01409	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  0140e	85 c0		 test	 eax, eax
  01410	0f 84 6d 01 00
	00		 je	 $LN158@test_chang
  01416	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  0141d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01424	0f 86 59 01 00
	00		 jbe	 $LN158@test_chang
  0142a	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  0142d	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01430	2b c1		 sub	 eax, ecx
  01432	89 4d f4	 mov	 DWORD PTR tv8517[ebp], ecx
  01435	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  01438	eb 5c		 jmp	 SHORT $LN160@test_chang
$LN1498@test_chang:

; 1638 : 		(*googledensehash)[key] = obj;

  0143a	8d 4d d4	 lea	 ecx, DWORD PTR $T226447[ebp]
  0143d	51		 push	 ecx
  0143e	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T229360[ebp]
  01444	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T226447[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  0144b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  01450	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  01455	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T229360[ebp]
  0145b	52		 push	 edx
  0145c	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T229360[ebp], OFFSET ??_7length_error@std@@6B@
  01466	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1619@test_chang:
$LN1499@test_chang:
  0146b	8d 45 fc	 lea	 eax, DWORD PTR $T227641[ebp]
  0146e	50		 push	 eax
  0146f	8d 4d bc	 lea	 ecx, DWORD PTR $T229206[ebp]
  01472	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T227641[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  01479	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0147e	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  01483	8d 4d bc	 lea	 ecx, DWORD PTR $T229206[ebp]
  01486	51		 push	 ecx
  01487	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T229206[ebp], OFFSET ??_7length_error@std@@6B@
  0148e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1620@test_chang:
$LL1581@test_chang:

; 1640 : #endif
; 1641 : 
; 1642 : #ifdef USE_GOOGLEBTREE
; 1643 : 	START(DATA_GOOGLEBTREE) {

  01493	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN160@test_chang:

; 1644 : 		unsigned key = REMOVE[i];

  01496	8b 55 f4	 mov	 edx, DWORD PTR tv8517[ebp]
  01499	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]

; 1645 : 		googlebtree_t::iterator ptr = googlebtree->find(key);

  0149c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  014a2	83 ec 08	 sub	 esp, 8
  014a5	89 45 e8	 mov	 DWORD PTR _key$152305[ebp], eax
  014a8	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  014aa	8b f4		 mov	 esi, esp
  014ac	83 ec 08	 sub	 esp, 8
  014af	8b c4		 mov	 eax, esp
  014b1	8d 7d e8	 lea	 edi, DWORD PTR _key$152305[ebp]
  014b4	89 08		 mov	 DWORD PTR [eax], ecx
  014b6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  014bd	e8 00 00 00 00	 call	 ??$internal_find_unique@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@ABE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@1@ABIU21@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_find_unique<btree::btree_iterator<btree::btree_node<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >,std::pair<unsigned int const ,google_object *> &,std::pair<unsigned int const ,google_object *> *> >
  014c2	8d 45 c8	 lea	 eax, DWORD PTR _ptr$152306[ebp]
  014c5	8b d3		 mov	 edx, ebx
  014c7	e8 00 00 00 00	 call	 ?internal_end@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@AAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::internal_end

; 1646 : 		struct google_object* obj;
; 1647 : 		if (ptr == googlebtree->end())

  014cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  014ce	85 c0		 test	 eax, eax
  014d0	74 0d		 je	 SHORT $LN1225@test_chang
  014d2	80 38 00	 cmp	 BYTE PTR [eax], 0
  014d5	75 08		 jne	 SHORT $LN1225@test_chang
  014d7	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  014dd	eb 02		 jmp	 SHORT $LN1237@test_chang
$LN1225@test_chang:
  014df	8b c8		 mov	 ecx, eax
$LN1237@test_chang:
  014e1	85 c9		 test	 ecx, ecx
  014e3	74 1d		 je	 SHORT $LN1221@test_chang
  014e5	85 c0		 test	 eax, eax
  014e7	74 11		 je	 SHORT $LN1241@test_chang
  014e9	80 38 00	 cmp	 BYTE PTR [eax], 0
  014ec	75 0c		 jne	 SHORT $LN1241@test_chang
  014ee	8b 88 80 01 00
	00		 mov	 ecx, DWORD PTR [eax+384]
  014f4	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  014f8	eb 0a		 jmp	 SHORT $LN1222@test_chang
$LN1241@test_chang:
  014fa	8b c8		 mov	 ecx, eax
  014fc	0f b6 49 03	 movzx	 ecx, BYTE PTR [ecx+3]
  01500	eb 02		 jmp	 SHORT $LN1222@test_chang
$LN1221@test_chang:
  01502	33 c9		 xor	 ecx, ecx
$LN1222@test_chang:
  01504	85 c0		 test	 eax, eax
  01506	74 0b		 je	 SHORT $LN1259@test_chang
  01508	80 38 00	 cmp	 BYTE PTR [eax], 0
  0150b	75 06		 jne	 SHORT $LN1259@test_chang
  0150d	8b 80 80 01 00
	00		 mov	 eax, DWORD PTR [eax+384]
$LN1259@test_chang:
  01513	8b 75 c8	 mov	 esi, DWORD PTR _ptr$152306[ebp]
  01516	8b 7d cc	 mov	 edi, DWORD PTR _ptr$152306[ebp+4]
  01519	3b f0		 cmp	 esi, eax
  0151b	75 09		 jne	 SHORT $LN157@test_chang
  0151d	3b f9		 cmp	 edi, ecx
  0151f	75 05		 jne	 SHORT $LN157@test_chang

; 1648 : 			abort();

  01521	e8 00 00 00 00	 call	 _abort
$LN157@test_chang:

; 1649 : 		obj = ptr->second;

  01526	8b 5c fe 0c	 mov	 ebx, DWORD PTR [esi+edi*8+12]

; 1650 : 		googlebtree->erase(ptr);

  0152a	83 ec 08	 sub	 esp, 8
  0152d	8b c4		 mov	 eax, esp
  0152f	8d 55 b0	 lea	 edx, DWORD PTR $T223101[ebp]
  01532	89 30		 mov	 DWORD PTR [eax], esi
  01534	89 78 04	 mov	 DWORD PTR [eax+4], edi
  01537	a1 00 00 00 00	 mov	 eax, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0153c	52		 push	 edx
  0153d	50		 push	 eax
  0153e	e8 00 00 00 00	 call	 ?erase@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@2@U32@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::erase

; 1651 : 
; 1652 : 		key = INSERT[i] + DELTA;

  01543	8b 4d f4	 mov	 ecx, DWORD PTR tv8517[ebp]
  01546	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1653 : 		obj->value = key;
; 1654 : 		(*googlebtree)[key] = obj;

  01548	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  0154e	40		 inc	 eax
  0154f	89 45 e8	 mov	 DWORD PTR _key$152305[ebp], eax
  01552	8d 55 e8	 lea	 edx, DWORD PTR _key$152305[ebp]
  01555	89 03		 mov	 DWORD PTR [ebx], eax
  01557	52		 push	 edx
  01558	8b c2		 mov	 eax, edx
  0155a	50		 push	 eax
  0155b	8d 75 bc	 lea	 esi, DWORD PTR $T229720[ebp]
  0155e	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  01563	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01566	8b 10		 mov	 edx, DWORD PTR [eax]
  01568	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0156b	83 45 f4 04	 add	 DWORD PTR tv8517[ebp], 4
  0156f	40		 inc	 eax
  01570	89 5c ca 0c	 mov	 DWORD PTR [edx+ecx*8+12], ebx
  01574	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  01577	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0157d	0f 82 10 ff ff
	ff		 jb	 $LL1581@test_chang
$LN158@test_chang:

; 1655 : 	} STOP();

  01583	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1656 : #endif
; 1657 : 
; 1658 : #ifdef USE_STXBTREE
; 1659 : 	START(DATA_STXBTREE) {

  01588	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0158d	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01592	85 c0		 test	 eax, eax
  01594	0f 84 15 01 00
	00		 je	 $LN153@test_chang
  0159a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  015a1	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  015a8	0f 86 01 01 00
	00		 jbe	 $LN153@test_chang
  015ae	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  015b1	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  015b4	2b c1		 sub	 eax, ecx
  015b6	89 4d f4	 mov	 DWORD PTR tv8557[ebp], ecx
  015b9	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  015bc	eb 05		 jmp	 SHORT $LN155@test_chang
  015be	8b ff		 npad	 2
$LL1582@test_chang:
  015c0	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN155@test_chang:

; 1660 : 		unsigned key = REMOVE[i];

  015c3	8b 4d f4	 mov	 ecx, DWORD PTR tv8557[ebp]
  015c6	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]

; 1661 : 		stxbtree_t::iterator ptr = stxbtree->find(key);

  015c9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  015cf	8d 45 b8	 lea	 eax, DWORD PTR _ptr$152334[ebp]
  015d2	50		 push	 eax
  015d3	56		 push	 esi
  015d4	8d 45 fc	 lea	 eax, DWORD PTR _key$152333[ebp]
  015d7	89 55 fc	 mov	 DWORD PTR _key$152333[ebp], edx
  015da	e8 00 00 00 00	 call	 ?find@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@QAE?AViterator@12@ABI@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::find

; 1662 : 		struct stx_object* obj;
; 1663 : 		if (ptr == stxbtree->end())

  015df	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  015e2	85 c0		 test	 eax, eax
  015e4	74 06		 je	 SHORT $LN1303@test_chang
  015e6	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  015ea	eb 02		 jmp	 SHORT $LN1304@test_chang
$LN1303@test_chang:
  015ec	33 c9		 xor	 ecx, ecx
$LN1304@test_chang:
  015ee	8b 5d b8	 mov	 ebx, DWORD PTR _ptr$152334[ebp]
  015f1	3b c3		 cmp	 eax, ebx
  015f3	75 11		 jne	 SHORT $LN152@test_chang
  015f5	66 3b 4d bc	 cmp	 cx, WORD PTR _ptr$152334[ebp+4]
  015f9	75 0b		 jne	 SHORT $LN152@test_chang

; 1664 : 			abort();

  015fb	e8 00 00 00 00	 call	 _abort
  01600	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN152@test_chang:

; 1665 : 		obj = ptr->second;

  01606	66 8b 55 bc	 mov	 dx, WORD PTR _ptr$152334[ebp+4]
  0160a	0f b7 c2	 movzx	 eax, dx
  0160d	8b 4c 83 0c	 mov	 ecx, DWORD PTR [ebx+eax*4+12]
  01611	8b bc 83 8c 00
	00 00		 mov	 edi, DWORD PTR [ebx+eax*4+140]

; 1666 : 		stxbtree->erase(ptr);

  01618	8b 06		 mov	 eax, DWORD PTR [esi]
  0161a	89 4d c0	 mov	 DWORD PTR _ptr$152334[ebp+8], ecx
  0161d	89 7d c4	 mov	 DWORD PTR _ptr$152334[ebp+12], edi
  01620	89 5d a0	 mov	 DWORD PTR $T230027[ebp], ebx
  01623	66 89 55 a4	 mov	 WORD PTR $T230027[ebp+4], dx
  01627	89 4d a8	 mov	 DWORD PTR $T230027[ebp+8], ecx
  0162a	89 7d ac	 mov	 DWORD PTR $T230027[ebp+12], edi
  0162d	85 c0		 test	 eax, eax
  0162f	74 2b		 je	 SHORT $LN1370@test_chang
  01631	6a 00		 push	 0
  01633	6a 00		 push	 0
  01635	6a 00		 push	 0
  01637	6a 00		 push	 0
  01639	6a 00		 push	 0
  0163b	6a 00		 push	 0
  0163d	50		 push	 eax
  0163e	8d 4d a0	 lea	 ecx, DWORD PTR $T230027[ebp]
  01641	51		 push	 ecx
  01642	8d 55 b0	 lea	 edx, DWORD PTR _result$230065[ebp]
  01645	52		 push	 edx
  01646	8b ce		 mov	 ecx, esi
  01648	e8 00 00 00 00	 call	 ?erase_iter_descend@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AUresult_t@12@ABViterator@12@PAUnode@12@11PAUinner_node@12@22I@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::erase_iter_descend
  0164d	f6 45 b0 01	 test	 BYTE PTR _result$230065[ebp], 1
  01651	75 03		 jne	 SHORT $LN1569@test_chang
  01653	ff 4e 0c	 dec	 DWORD PTR [esi+12]
$LN1569@test_chang:
  01656	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
$LN1370@test_chang:

; 1667 : 
; 1668 : 		key = INSERT[i] + DELTA;

  0165c	8b 5d f4	 mov	 ebx, DWORD PTR tv8557[ebp]
  0165f	8b 03		 mov	 eax, DWORD PTR [ebx]
  01661	40		 inc	 eax

; 1669 : 		obj->value = key;

  01662	89 07		 mov	 DWORD PTR [edi], eax

; 1670 : 		(*stxbtree)[key] = obj;

  01664	89 45 d0	 mov	 DWORD PTR $T230148[ebp], eax
  01667	8d 45 d4	 lea	 eax, DWORD PTR $T230148[ebp+4]
  0166a	50		 push	 eax
  0166b	8d 4d d0	 lea	 ecx, DWORD PTR $T230148[ebp]
  0166e	51		 push	 ecx
  0166f	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR $T230150[ebp]
  01675	52		 push	 edx
  01676	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T230148[ebp+4], 0
  0167d	e8 00 00 00 00	 call	 ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
  01682	0f b7 85 60 ff
	ff ff		 movzx	 eax, WORD PTR $T230150[ebp+4]
  01689	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T230150[ebp]
  0168f	89 bc 81 8c 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+140], edi
  01696	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  01699	40		 inc	 eax
  0169a	83 c3 04	 add	 ebx, 4
  0169d	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  016a0	89 5d f4	 mov	 DWORD PTR tv8557[ebp], ebx
  016a3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  016a9	0f 82 11 ff ff
	ff		 jb	 $LL1582@test_chang
$LN153@test_chang:

; 1671 : 	} STOP();

  016af	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1672 : #endif
; 1673 : 
; 1674 : #ifdef USE_CPPMAP
; 1675 : 	START(DATA_CPPMAP) {

  016b4	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  016b9	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  016be	85 c0		 test	 eax, eax
  016c0	0f 84 7c 00 00
	00		 je	 $LN148@test_chang
  016c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  016cd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  016d4	76 6c		 jbe	 SHORT $LN148@test_chang
  016d6	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  016d9	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  016dc	2b c7		 sub	 eax, edi
  016de	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  016e1	eb 03		 jmp	 SHORT $LN150@test_chang
$LL1589@test_chang:
  016e3	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN150@test_chang:

; 1676 : 		unsigned key = REMOVE[i];

  016e6	8b 14 38	 mov	 edx, DWORD PTR [eax+edi]

; 1677 : 		cppmap_t::iterator ptr = cppmap->find(key);

  016e9	8d 45 f4	 lea	 eax, DWORD PTR _key$152344[ebp]
  016ec	50		 push	 eax
  016ed	8d 45 fc	 lea	 eax, DWORD PTR _ptr$152345[ebp]
  016f0	89 55 f4	 mov	 DWORD PTR _key$152344[ebp], edx
  016f3	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::find

; 1678 : 		struct cpp_object* obj;
; 1679 : 		if (ptr == cppmap->end())

  016f8	8b 5d fc	 mov	 ebx, DWORD PTR _ptr$152345[ebp]
  016fb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  01701	3b 59 04	 cmp	 ebx, DWORD PTR [ecx+4]
  01704	75 05		 jne	 SHORT $LN147@test_chang

; 1680 : 			abort();

  01706	e8 00 00 00 00	 call	 _abort
$LN147@test_chang:

; 1681 : 		obj = ptr->second;
; 1682 : 		cppmap->erase(ptr);

  0170b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  01710	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  01713	53		 push	 ebx
  01714	8d 55 d4	 lea	 edx, DWORD PTR $T223106[ebp]
  01717	52		 push	 edx
  01718	50		 push	 eax
  01719	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1683 : 
; 1684 : 		key = INSERT[i] + DELTA;

  0171e	8b 07		 mov	 eax, DWORD PTR [edi]
  01720	40		 inc	 eax

; 1685 : 		obj->value = key;
; 1686 : 		(*cppmap)[key] = obj;

  01721	8d 55 f4	 lea	 edx, DWORD PTR _key$152344[ebp]
  01724	89 45 f4	 mov	 DWORD PTR _key$152344[ebp], eax
  01727	89 06		 mov	 DWORD PTR [esi], eax
  01729	e8 00 00 00 00	 call	 ??A?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@QAEAAPAUcpp_object@@ABI@Z ; std::map<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
  0172e	89 30		 mov	 DWORD PTR [eax], esi
  01730	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  01733	40		 inc	 eax
  01734	83 c7 04	 add	 edi, 4
  01737	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  0173a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01740	72 a1		 jb	 SHORT $LL1589@test_chang
$LN148@test_chang:

; 1687 : 	} STOP();

  01742	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1688 : #endif
; 1689 : 
; 1690 : #ifdef USE_CPPUNORDEREDMAP
; 1691 : 	START(DATA_CPPUNORDEREDMAP) {

  01747	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  0174c	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01751	85 c0		 test	 eax, eax
  01753	0f 84 82 00 00
	00		 je	 $LN143@test_chang
  01759	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01760	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01767	76 72		 jbe	 SHORT $LN143@test_chang
  01769	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  0176c	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  0176f	2b c7		 sub	 eax, edi
  01771	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  01774	eb 0d		 jmp	 SHORT $LN145@test_chang
  01776	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL1592@test_chang:
  01780	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN145@test_chang:

; 1692 : 		unsigned key = REMOVE[i];

  01783	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]

; 1693 : 		cppunorderedmap_t::iterator ptr = cppunorderedmap->find(key);

  01786	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  0178c	8d 55 fc	 lea	 edx, DWORD PTR _ptr$152373[ebp]
  0178f	89 4d f4	 mov	 DWORD PTR _key$152372[ebp], ecx
  01792	52		 push	 edx
  01793	8d 45 f4	 lea	 eax, DWORD PTR _key$152372[ebp]
  01796	8b ce		 mov	 ecx, esi
  01798	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound

; 1694 : 		struct cpp_object* obj;
; 1695 : 		if (ptr == cppunorderedmap->end())

  0179d	8b 5d fc	 mov	 ebx, DWORD PTR _ptr$152373[ebp]
  017a0	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  017a3	75 05		 jne	 SHORT $LN142@test_chang

; 1696 : 			abort();

  017a5	e8 00 00 00 00	 call	 _abort
$LN142@test_chang:

; 1697 : 		obj = ptr->second;

  017aa	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 1698 : 		cppunorderedmap->erase(ptr);

  017ad	53		 push	 ebx
  017ae	8d 45 d4	 lea	 eax, DWORD PTR $T223109[ebp]
  017b1	50		 push	 eax
  017b2	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::erase

; 1699 : 
; 1700 : 		key = INSERT[i] + DELTA;

  017b7	8b 07		 mov	 eax, DWORD PTR [edi]
  017b9	40		 inc	 eax
  017ba	89 45 f4	 mov	 DWORD PTR _key$152372[ebp], eax

; 1701 : 		obj->value = key;

  017bd	89 06		 mov	 DWORD PTR [esi], eax

; 1702 : 		(*cppunorderedmap)[key] = obj;

  017bf	8d 45 f4	 lea	 eax, DWORD PTR _key$152372[ebp]
  017c2	e8 00 00 00 00	 call	 ??A?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@QAEAAPAUcpp_object@@ABI@Z ; std::tr1::unordered_map<unsigned int,cpp_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::operator[]
  017c7	89 30		 mov	 DWORD PTR [eax], esi
  017c9	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  017cc	40		 inc	 eax
  017cd	83 c7 04	 add	 edi, 4
  017d0	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  017d3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  017d9	72 a5		 jb	 SHORT $LL1592@test_chang
$LN143@test_chang:

; 1703 : 	} STOP();

  017db	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1704 : #endif
; 1705 : 
; 1706 : 	START(DATA_UTHASH) {

  017e0	b8 08 00 00 00	 mov	 eax, 8
  017e5	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  017ea	85 c0		 test	 eax, eax
  017ec	0f 84 ee 04 00
	00		 je	 $LN138@test_chang
  017f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  017f9	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01800	0f 86 da 04 00
	00		 jbe	 $LN138@test_chang
  01806	8b 4d 0c	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  01809	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  0180c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01812	2b c1		 sub	 eax, ecx
  01814	89 4d f4	 mov	 DWORD PTR tv8690[ebp], ecx
  01817	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  0181a	eb 07		 jmp	 SHORT $LN140@test_chang
  0181c	8d 64 24 00	 npad	 4
$LL1576@test_chang:
  01820	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN140@test_chang:

; 1707 : 		unsigned key = REMOVE[i];

  01823	8b 4d f4	 mov	 ecx, DWORD PTR tv8690[ebp]
  01826	8b 1c 08	 mov	 ebx, DWORD PTR [eax+ecx]

; 1708 : 		struct uthash_object* obj;
; 1709 : 		HASH_FIND_INT(uthash, &key, obj);

  01829	33 ff		 xor	 edi, edi
  0182b	89 5d dc	 mov	 DWORD PTR _key$152400[ebp], ebx
  0182e	85 f6		 test	 esi, esi
  01830	0f 84 cb 00 00
	00		 je	 $LN1539@test_chang
  01836	0f be 45 df	 movsx	 eax, BYTE PTR _key$152400[ebp+3]
  0183a	0f be 55 de	 movsx	 edx, BYTE PTR _key$152400[ebp+2]
  0183e	c1 e0 18	 shl	 eax, 24			; 00000018H
  01841	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01846	c1 e2 10	 shl	 edx, 16			; 00000010H
  01849	03 c2		 add	 eax, edx
  0184b	0f be cf	 movsx	 ecx, bh
  0184e	c1 e1 08	 shl	 ecx, 8
  01851	03 c1		 add	 eax, ecx
  01853	0f be d3	 movsx	 edx, bl
  01856	03 d0		 add	 edx, eax
  01858	81 c2 54 c7 da
	62		 add	 edx, 1658505044		; 62dac754H
  0185e	81 f2 6d f7 07
	00		 xor	 edx, 522093		; 0007f76dH
  01864	8b c2		 mov	 eax, edx
  01866	c1 e0 08	 shl	 eax, 8
  01869	b9 c6 ba 49 9f	 mov	 ecx, -1622558010	; 9f49bac6H
  0186e	2b ca		 sub	 ecx, edx
  01870	33 c8		 xor	 ecx, eax
  01872	8b f9		 mov	 edi, ecx
  01874	c1 ef 0d	 shr	 edi, 13			; 0000000dH
  01877	b8 f3 be ed fe	 mov	 eax, -17973517		; feedbef3H
  0187c	2b c1		 sub	 eax, ecx
  0187e	2b c2		 sub	 eax, edx
  01880	33 c7		 xor	 eax, edi
  01882	2b d1		 sub	 edx, ecx
  01884	2b d0		 sub	 edx, eax
  01886	8b f8		 mov	 edi, eax
  01888	c1 ef 0c	 shr	 edi, 12			; 0000000cH
  0188b	33 d7		 xor	 edx, edi
  0188d	2b ca		 sub	 ecx, edx
  0188f	2b c8		 sub	 ecx, eax
  01891	8b fa		 mov	 edi, edx
  01893	c1 e7 10	 shl	 edi, 16			; 00000010H
  01896	33 cf		 xor	 ecx, edi
  01898	2b c1		 sub	 eax, ecx
  0189a	2b c2		 sub	 eax, edx
  0189c	8b f9		 mov	 edi, ecx
  0189e	c1 ef 05	 shr	 edi, 5
  018a1	33 c7		 xor	 eax, edi
  018a3	2b d1		 sub	 edx, ecx
  018a5	2b d0		 sub	 edx, eax
  018a7	8b f8		 mov	 edi, eax
  018a9	c1 ef 03	 shr	 edi, 3
  018ac	33 d7		 xor	 edx, edi
  018ae	2b ca		 sub	 ecx, edx
  018b0	2b c8		 sub	 ecx, eax
  018b2	8b fa		 mov	 edi, edx
  018b4	c1 e7 0a	 shl	 edi, 10			; 0000000aH
  018b7	33 cf		 xor	 ecx, edi
  018b9	8b 3e		 mov	 edi, DWORD PTR [esi]
  018bb	2b c1		 sub	 eax, ecx
  018bd	2b c2		 sub	 eax, edx
  018bf	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  018c2	33 c1		 xor	 eax, ecx
  018c4	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  018c7	49		 dec	 ecx
  018c8	23 c1		 and	 eax, ecx
  018ca	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  018cd	8b 07		 mov	 eax, DWORD PTR [edi]
  018cf	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  018d2	85 c0		 test	 eax, eax
  018d4	74 29		 je	 SHORT $LN96@test_chang
  018d6	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  018d9	2b c1		 sub	 eax, ecx
  018db	8b f8		 mov	 edi, eax
  018dd	85 ff		 test	 edi, edi
  018df	74 20		 je	 SHORT $LN1539@test_chang
  018e1	b8 04 00 00 00	 mov	 eax, 4
$LL100@test_chang:
  018e6	39 47 18	 cmp	 DWORD PTR [edi+24], eax
  018e9	75 07		 jne	 SHORT $LN97@test_chang
  018eb	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  018ee	39 1a		 cmp	 DWORD PTR [edx], ebx
  018f0	74 1a		 je	 SHORT $LN90@test_chang
$LN97@test_chang:
  018f2	8b 7f 10	 mov	 edi, DWORD PTR [edi+16]
  018f5	85 ff		 test	 edi, edi
  018f7	74 06		 je	 SHORT $LN96@test_chang
  018f9	2b f9		 sub	 edi, ecx
  018fb	75 e9		 jne	 SHORT $LL100@test_chang
  018fd	eb 02		 jmp	 SHORT $LN1539@test_chang
$LN96@test_chang:
  018ff	33 ff		 xor	 edi, edi
$LN1539@test_chang:

; 1710 : 		if (!obj)
; 1711 : 			abort();

  01901	e8 00 00 00 00	 call	 _abort
  01906	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
$LN90@test_chang:

; 1712 : 		HASH_DEL(uthash, obj);

  0190c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0190f	85 d2		 test	 edx, edx
  01911	75 2a		 jne	 SHORT $LN87@test_chang
  01913	39 57 08	 cmp	 DWORD PTR [edi+8], edx
  01916	75 25		 jne	 SHORT $LN87@test_chang
  01918	8b 06		 mov	 eax, DWORD PTR [esi]
  0191a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0191c	51		 push	 ecx
  0191d	e8 00 00 00 00	 call	 _free
  01922	8b 16		 mov	 edx, DWORD PTR [esi]
  01924	83 c4 04	 add	 esp, 4
  01927	52		 push	 edx
  01928	e8 00 00 00 00	 call	 _free
  0192d	83 c4 04	 add	 esp, 4
  01930	33 f6		 xor	 esi, esi
  01932	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  01938	e9 8c 00 00 00	 jmp	 $LN89@test_chang
$LN87@test_chang:
  0193d	8b 06		 mov	 eax, DWORD PTR [esi]
  0193f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01942	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  01945	2b d9		 sub	 ebx, ecx
  01947	3b fb		 cmp	 edi, ebx
  01949	75 05		 jne	 SHORT $LN85@test_chang
  0194b	03 d1		 add	 edx, ecx
  0194d	89 50 10	 mov	 DWORD PTR [eax+16], edx
$LN85@test_chang:
  01950	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  01953	85 c0		 test	 eax, eax
  01955	74 0e		 je	 SHORT $LN82@test_chang
  01957	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01959	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0195c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0195f	89 4c 02 08	 mov	 DWORD PTR [edx+eax+8], ecx
  01963	eb 09		 jmp	 SHORT $LN80@test_chang
$LN82@test_chang:
  01965	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  01968	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
$LN80@test_chang:
  0196e	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  01971	85 c0		 test	 eax, eax
  01973	74 0c		 je	 SHORT $LN78@test_chang
  01975	8b 16		 mov	 edx, DWORD PTR [esi]
  01977	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0197a	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0197d	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN78@test_chang:
  01981	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01983	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01986	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01988	48		 dec	 eax
  01989	23 47 1c	 and	 eax, DWORD PTR [edi+28]
  0198c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0198f	03 c0		 add	 eax, eax
  01991	03 c0		 add	 eax, eax
  01993	ff 4c 01 04	 dec	 DWORD PTR [ecx+eax+4]
  01997	8b 16		 mov	 edx, DWORD PTR [esi]
  01999	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  0199d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0199f	39 3c 08	 cmp	 DWORD PTR [eax+ecx], edi
  019a2	75 06		 jne	 SHORT $LN75@test_chang
  019a4	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  019a7	89 14 08	 mov	 DWORD PTR [eax+ecx], edx
$LN75@test_chang:
  019aa	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  019ad	85 c0		 test	 eax, eax
  019af	74 06		 je	 SHORT $LN74@test_chang
  019b1	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  019b4	89 48 10	 mov	 DWORD PTR [eax+16], ecx
$LN74@test_chang:
  019b7	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  019ba	85 c0		 test	 eax, eax
  019bc	74 06		 je	 SHORT $LN73@test_chang
  019be	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  019c1	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN73@test_chang:
  019c4	8b 06		 mov	 eax, DWORD PTR [esi]
  019c6	ff 48 0c	 dec	 DWORD PTR [eax+12]
$LN89@test_chang:

; 1713 : 
; 1714 : 		key = INSERT[i] + DELTA;

  019c9	8b 45 f4	 mov	 eax, DWORD PTR tv8690[ebp]
  019cc	8b 00		 mov	 eax, DWORD PTR [eax]
  019ce	40		 inc	 eax

; 1715 : 		obj->value = key;

  019cf	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  019d2	89 03		 mov	 DWORD PTR [ebx], eax

; 1716 : 		HASH_ADD_INT(uthash, value, obj);

  019d4	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  019db	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  019de	c7 47 18 04 00
	00 00		 mov	 DWORD PTR [edi+24], 4
  019e5	85 f6		 test	 esi, esi
  019e7	0f 85 89 00 00
	00		 jne	 $LN69@test_chang
  019ed	8b f7		 mov	 esi, edi
  019ef	6a 2c		 push	 44			; 0000002cH
  019f1	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  019f7	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  019fe	e8 00 00 00 00	 call	 _malloc
  01a03	83 c4 04	 add	 esp, 4
  01a06	89 07		 mov	 DWORD PTR [edi], eax
  01a08	85 c0		 test	 eax, eax
  01a0a	0f 84 bb 03 00
	00		 je	 $LN1501@test_chang
  01a10	6a 2c		 push	 44			; 0000002cH
  01a12	6a 00		 push	 0
  01a14	50		 push	 eax
  01a15	e8 00 00 00 00	 call	 _memset
  01a1a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01a1c	89 79 10	 mov	 DWORD PTR [ecx+16], edi
  01a1f	8b 17		 mov	 edx, DWORD PTR [edi]
  01a21	c7 42 04 20 00
	00 00		 mov	 DWORD PTR [edx+4], 32	; 00000020H
  01a28	8b 07		 mov	 eax, DWORD PTR [edi]
  01a2a	c7 40 08 05 00
	00 00		 mov	 DWORD PTR [eax+8], 5
  01a31	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01a33	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a36	68 80 01 00 00	 push	 384			; 00000180H
  01a3b	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  01a42	e8 00 00 00 00	 call	 _malloc
  01a47	8b 17		 mov	 edx, DWORD PTR [edi]
  01a49	89 02		 mov	 DWORD PTR [edx], eax
  01a4b	8b 07		 mov	 eax, DWORD PTR [edi]
  01a4d	83 c4 04	 add	 esp, 4
  01a50	83 38 00	 cmp	 DWORD PTR [eax], 0
  01a53	0f 84 72 03 00
	00		 je	 $LN1501@test_chang
  01a59	8b 00		 mov	 eax, DWORD PTR [eax]
  01a5b	68 80 01 00 00	 push	 384			; 00000180H
  01a60	6a 00		 push	 0
  01a62	50		 push	 eax
  01a63	e8 00 00 00 00	 call	 _memset
  01a68	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01a6a	83 c4 0c	 add	 esp, 12			; 0000000cH
  01a6d	c7 41 28 e1 1f
	11 a0		 mov	 DWORD PTR [ecx+40], -1609490463 ; a0111fe1H
  01a74	eb 18		 jmp	 SHORT $LN63@test_chang
$LN69@test_chang:
  01a76	8b 16		 mov	 edx, DWORD PTR [esi]
  01a78	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  01a7b	89 78 08	 mov	 DWORD PTR [eax+8], edi
  01a7e	8b 06		 mov	 eax, DWORD PTR [esi]
  01a80	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01a83	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  01a86	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  01a89	8b 16		 mov	 edx, DWORD PTR [esi]
  01a8b	89 7a 10	 mov	 DWORD PTR [edx+16], edi
$LN63@test_chang:
  01a8e	8b 06		 mov	 eax, DWORD PTR [esi]
  01a90	ff 40 0c	 inc	 DWORD PTR [eax+12]
  01a93	8b 06		 mov	 eax, DWORD PTR [esi]
  01a95	89 07		 mov	 DWORD PTR [edi], eax
  01a97	ba f3 be ed fe	 mov	 edx, -17973517		; feedbef3H
  01a9c	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01a9f	0f be 43 03	 movsx	 eax, BYTE PTR [ebx+3]
  01aa3	0f be 4b 02	 movsx	 ecx, BYTE PTR [ebx+2]
  01aa7	c1 e0 18	 shl	 eax, 24			; 00000018H
  01aaa	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01aad	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01ab2	03 c1		 add	 eax, ecx
  01ab4	0f be 4b 01	 movsx	 ecx, BYTE PTR [ebx+1]
  01ab8	c1 e1 08	 shl	 ecx, 8
  01abb	03 c1		 add	 eax, ecx
  01abd	0f be 0b	 movsx	 ecx, BYTE PTR [ebx]
  01ac0	03 c8		 add	 ecx, eax
  01ac2	81 c1 54 c7 da
	62		 add	 ecx, 1658505044		; 62dac754H
  01ac8	81 f1 6d f7 07
	00		 xor	 ecx, 522093		; 0007f76dH
  01ace	8b d9		 mov	 ebx, ecx
  01ad0	c1 e3 08	 shl	 ebx, 8
  01ad3	b8 c6 ba 49 9f	 mov	 eax, -1622558010	; 9f49bac6H
  01ad8	2b c1		 sub	 eax, ecx
  01ada	33 c3		 xor	 eax, ebx
  01adc	2b d0		 sub	 edx, eax
  01ade	2b d1		 sub	 edx, ecx
  01ae0	8b d8		 mov	 ebx, eax
  01ae2	c1 eb 0d	 shr	 ebx, 13			; 0000000dH
  01ae5	33 d3		 xor	 edx, ebx
  01ae7	2b ca		 sub	 ecx, edx
  01ae9	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01aec	2b c8		 sub	 ecx, eax
  01aee	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  01af1	33 ca		 xor	 ecx, edx
  01af3	2b c1		 sub	 eax, ecx
  01af5	2b 47 1c	 sub	 eax, DWORD PTR [edi+28]
  01af8	8b d1		 mov	 edx, ecx
  01afa	c1 e2 10	 shl	 edx, 16			; 00000010H
  01afd	33 c2		 xor	 eax, edx
  01aff	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01b02	2b d0		 sub	 edx, eax
  01b04	2b d1		 sub	 edx, ecx
  01b06	8b d8		 mov	 ebx, eax
  01b08	c1 eb 05	 shr	 ebx, 5
  01b0b	33 d3		 xor	 edx, ebx
  01b0d	2b ca		 sub	 ecx, edx
  01b0f	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01b12	2b c8		 sub	 ecx, eax
  01b14	c1 ea 03	 shr	 edx, 3
  01b17	33 ca		 xor	 ecx, edx
  01b19	2b c1		 sub	 eax, ecx
  01b1b	2b 47 1c	 sub	 eax, DWORD PTR [edi+28]
  01b1e	8b d1		 mov	 edx, ecx
  01b20	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  01b23	33 c2		 xor	 eax, edx
  01b25	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01b28	2b d0		 sub	 edx, eax
  01b2a	2b d1		 sub	 edx, ecx
  01b2c	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  01b2f	33 d0		 xor	 edx, eax
  01b31	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01b34	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01b36	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01b39	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01b3b	48		 dec	 eax
  01b3c	23 c2		 and	 eax, edx
  01b3e	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01b41	03 c0		 add	 eax, eax
  01b43	03 c0		 add	 eax, eax
  01b45	ff 44 01 04	 inc	 DWORD PTR [ecx+eax+4]
  01b49	8b 16		 mov	 edx, DWORD PTR [esi]
  01b4b	8d 4c 01 04	 lea	 ecx, DWORD PTR [ecx+eax+4]
  01b4f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01b51	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]
  01b54	89 57 10	 mov	 DWORD PTR [edi+16], edx
  01b57	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  01b5e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01b60	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b62	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01b65	85 c9		 test	 ecx, ecx
  01b67	74 03		 je	 SHORT $LN35@test_chang
  01b69	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
$LN35@test_chang:
  01b6c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01b6e	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b70	89 3c 10	 mov	 DWORD PTR [eax+edx], edi
  01b73	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01b75	8b 11		 mov	 edx, DWORD PTR [ecx]
  01b77	8b 4c 10 08	 mov	 ecx, DWORD PTR [eax+edx+8]
  01b7b	8d 4c 89 05	 lea	 ecx, DWORD PTR [ecx+ecx*4+5]
  01b7f	03 c9		 add	 ecx, ecx
  01b81	39 4c 10 04	 cmp	 DWORD PTR [eax+edx+4], ecx
  01b85	0f 82 3e 01 00
	00		 jb	 $LN31@test_chang
  01b8b	8b 07		 mov	 eax, DWORD PTR [edi]
  01b8d	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  01b91	0f 84 32 01 00
	00		 je	 $LN31@test_chang
  01b97	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01b9a	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  01b9d	03 db		 add	 ebx, ebx
  01b9f	03 db		 add	 ebx, ebx
  01ba1	03 db		 add	 ebx, ebx
  01ba3	53		 push	 ebx
  01ba4	e8 00 00 00 00	 call	 _malloc
  01ba9	83 c4 04	 add	 esp, 4
  01bac	89 45 e4	 mov	 DWORD PTR __he_new_buckets$152604[ebp], eax
  01baf	85 c0		 test	 eax, eax
  01bb1	0f 84 14 02 00
	00		 je	 $LN1501@test_chang
  01bb7	53		 push	 ebx
  01bb8	6a 00		 push	 0
  01bba	50		 push	 eax
  01bbb	e8 00 00 00 00	 call	 _memset
  01bc0	8b 07		 mov	 eax, DWORD PTR [edi]
  01bc2	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01bc5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01bc8	41		 inc	 ecx
  01bc9	8b da		 mov	 ebx, edx
  01bcb	d3 eb		 shr	 ebx, cl
  01bcd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01bd0	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  01bd4	23 ca		 and	 ecx, edx
  01bd6	83 c4 0c	 add	 esp, 12			; 0000000cH
  01bd9	f7 d9		 neg	 ecx
  01bdb	1b c9		 sbb	 ecx, ecx
  01bdd	f7 d9		 neg	 ecx
  01bdf	03 d9		 add	 ebx, ecx
  01be1	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  01be4	8b 17		 mov	 edx, DWORD PTR [edi]
  01be6	33 c0		 xor	 eax, eax
  01be8	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  01beb	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01bed	89 45 dc	 mov	 DWORD PTR __he_bkt_i$152601[ebp], eax
  01bf0	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  01bf3	0f 86 86 00 00
	00		 jbe	 $LN27@test_chang
  01bf9	89 45 e8	 mov	 DWORD PTR tv8660[ebp], eax
  01bfc	8d 64 24 00	 npad	 4
$LL29@test_chang:
  01c00	8b 17		 mov	 edx, DWORD PTR [edi]
  01c02	8b 02		 mov	 eax, DWORD PTR [edx]
  01c04	8b 4d e8	 mov	 ecx, DWORD PTR tv8660[ebp]
  01c07	8b 1c 01	 mov	 ebx, DWORD PTR [ecx+eax]
  01c0a	85 db		 test	 ebx, ebx
  01c0c	74 5f		 je	 SHORT $LN28@test_chang
  01c0e	8b ff		 npad	 2
$LL26@test_chang:
  01c10	8b 07		 mov	 eax, DWORD PTR [edi]
  01c12	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  01c15	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  01c18	8d 44 00 ff	 lea	 eax, DWORD PTR [eax+eax-1]
  01c1c	23 43 1c	 and	 eax, DWORD PTR [ebx+28]
  01c1f	89 55 fc	 mov	 DWORD PTR __he_hh_nxt$152603[ebp], edx
  01c22	8b 55 e4	 mov	 edx, DWORD PTR __he_new_buckets$152604[ebp]
  01c25	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  01c28	ff 44 8a 04	 inc	 DWORD PTR [edx+ecx*4+4]
  01c2c	8b 07		 mov	 eax, DWORD PTR [edi]
  01c2e	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]
  01c31	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  01c34	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  01c37	76 16		 jbe	 SHORT $LN21@test_chang
  01c39	ff 40 1c	 inc	 DWORD PTR [eax+28]
  01c3c	8b 37		 mov	 esi, DWORD PTR [edi]
  01c3e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01c41	33 d2		 xor	 edx, edx
  01c43	f7 76 18	 div	 DWORD PTR [esi+24]
  01c46	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01c4c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN21@test_chang:
  01c4f	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  01c56	8b 01		 mov	 eax, DWORD PTR [ecx]
  01c58	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  01c5b	8b 01		 mov	 eax, DWORD PTR [ecx]
  01c5d	85 c0		 test	 eax, eax
  01c5f	74 03		 je	 SHORT $LN20@test_chang
  01c61	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
$LN20@test_chang:
  01c64	89 19		 mov	 DWORD PTR [ecx], ebx
  01c66	8b 5d fc	 mov	 ebx, DWORD PTR __he_hh_nxt$152603[ebp]
  01c69	85 db		 test	 ebx, ebx
  01c6b	75 a3		 jne	 SHORT $LL26@test_chang
$LN28@test_chang:
  01c6d	8b 45 dc	 mov	 eax, DWORD PTR __he_bkt_i$152601[ebp]
  01c70	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01c72	83 45 e8 0c	 add	 DWORD PTR tv8660[ebp], 12 ; 0000000cH
  01c76	40		 inc	 eax
  01c77	89 45 dc	 mov	 DWORD PTR __he_bkt_i$152601[ebp], eax
  01c7a	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  01c7d	72 81		 jb	 SHORT $LL29@test_chang
$LN27@test_chang:
  01c7f	8b 17		 mov	 edx, DWORD PTR [edi]
  01c81	8b 02		 mov	 eax, DWORD PTR [edx]
  01c83	50		 push	 eax
  01c84	e8 00 00 00 00	 call	 _free
  01c89	8b 07		 mov	 eax, DWORD PTR [edi]
  01c8b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01c8e	03 c9		 add	 ecx, ecx
  01c90	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01c93	8b 07		 mov	 eax, DWORD PTR [edi]
  01c95	8b 4d e4	 mov	 ecx, DWORD PTR __he_new_buckets$152604[ebp]
  01c98	ba 01 00 00 00	 mov	 edx, 1
  01c9d	01 50 08	 add	 DWORD PTR [eax+8], edx
  01ca0	8b 07		 mov	 eax, DWORD PTR [edi]
  01ca2	89 08		 mov	 DWORD PTR [eax], ecx
  01ca4	8b 07		 mov	 eax, DWORD PTR [edi]
  01ca6	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01ca9	d1 e9		 shr	 ecx, 1
  01cab	83 c4 04	 add	 esp, 4
  01cae	39 48 1c	 cmp	 DWORD PTR [eax+28], ecx
  01cb1	76 07		 jbe	 SHORT $LN205@test_chang
  01cb3	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01cb6	03 ca		 add	 ecx, edx
  01cb8	eb 02		 jmp	 SHORT $LN206@test_chang
$LN205@test_chang:
  01cba	33 c9		 xor	 ecx, ecx
$LN206@test_chang:
  01cbc	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  01cbf	8b 3f		 mov	 edi, DWORD PTR [edi]
  01cc1	39 57 20	 cmp	 DWORD PTR [edi+32], edx
  01cc4	76 03		 jbe	 SHORT $LN31@test_chang
  01cc6	89 57 24	 mov	 DWORD PTR [edi+36], edx
$LN31@test_chang:

; 1704 : #endif
; 1705 : 
; 1706 : 	START(DATA_UTHASH) {

  01cc9	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  01ccc	83 45 f4 04	 add	 DWORD PTR tv8690[ebp], 4
  01cd0	40		 inc	 eax
  01cd1	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  01cd4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01cda	0f 82 40 fb ff
	ff		 jb	 $LL1576@test_chang
$LN138@test_chang:

; 1717 : 	} STOP();

  01ce0	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1718 : 
; 1719 : #ifdef USE_JUDY
; 1720 : 	START(DATA_JUDY) {

  01ce5	b8 09 00 00 00	 mov	 eax, 9
  01cea	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01cef	85 c0		 test	 eax, eax
  01cf1	0f 84 a2 00 00
	00		 je	 $LN15@test_chang
  01cf7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01cfe	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01d05	0f 86 8e 00 00
	00		 jbe	 $LN15@test_chang
  01d0b	8b 5d 0c	 mov	 ebx, DWORD PTR _INSERT$[ebp]
  01d0e	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01d11	2b c3		 sub	 eax, ebx
  01d13	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  01d16	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL17@test_chang:

; 1721 : 		Word_t key = REMOVE[i];

  01d20	8b 55 ec	 mov	 edx, DWORD PTR tv8169[ebp]
  01d23	8b 3c 1a	 mov	 edi, DWORD PTR [edx+ebx]

; 1722 : 		struct judy_object* obj;
; 1723 : 		int r;
; 1724 : 		Pvoid_t PValue;
; 1725 : 		JLG(PValue, judy, key);

  01d26	a1 00 00 00 00	 mov	 eax, DWORD PTR ?judy@@3PAXA ; judy
  01d2b	6a 00		 push	 0
  01d2d	57		 push	 edi
  01d2e	50		 push	 eax
  01d2f	e8 00 00 00 00	 call	 _JudyLGet
  01d34	8b f0		 mov	 esi, eax
  01d36	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1726 : 		if (!PValue)

  01d39	85 f6		 test	 esi, esi
  01d3b	75 05		 jne	 SHORT $LN14@test_chang

; 1727 : 			abort();

  01d3d	e8 00 00 00 00	 call	 _abort
$LN14@test_chang:

; 1728 : 		obj = *(struct judy_object**)PValue;

  01d42	8b 36		 mov	 esi, DWORD PTR [esi]

; 1729 : 		JLD(r, judy, key);

  01d44	8d 4d 98	 lea	 ecx, DWORD PTR _J_Error$152635[ebp]
  01d47	51		 push	 ecx
  01d48	57		 push	 edi
  01d49	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  01d4e	e8 00 00 00 00	 call	 _JudyLDel
  01d53	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d56	83 f8 ff	 cmp	 eax, -1
  01d59	74 77		 je	 SHORT $LN1504@test_chang

; 1730 : 		if (r != 1)

  01d5b	83 f8 01	 cmp	 eax, 1
  01d5e	74 05		 je	 SHORT $LN12@test_chang

; 1731 : 			abort();

  01d60	e8 00 00 00 00	 call	 _abort
$LN12@test_chang:

; 1732 : 
; 1733 : 		key = INSERT[i] + DELTA;

  01d65	8b 03		 mov	 eax, DWORD PTR [ebx]

; 1734 : 		obj->value = key;
; 1735 : 		JLI(PValue, judy, key);

  01d67	8d 55 98	 lea	 edx, DWORD PTR _J_Error$152642[ebp]
  01d6a	40		 inc	 eax
  01d6b	52		 push	 edx
  01d6c	50		 push	 eax
  01d6d	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  01d72	89 06		 mov	 DWORD PTR [esi], eax
  01d74	e8 00 00 00 00	 call	 _JudyLIns
  01d79	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d7c	83 f8 ff	 cmp	 eax, -1
  01d7f	0f 84 81 00 00
	00		 je	 $LN1505@test_chang

; 1736 : 		*(struct judy_object**)PValue = obj;

  01d85	89 30		 mov	 DWORD PTR [eax], esi
  01d87	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  01d8a	40		 inc	 eax
  01d8b	83 c3 04	 add	 ebx, 4
  01d8e	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  01d91	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01d97	72 87		 jb	 SHORT $LL17@test_chang
$LN15@test_chang:

; 1737 : 	} STOP();

  01d99	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1738 : #endif
; 1739 : 
; 1740 : #ifdef USE_JUDYARRAY
; 1741 : 	START(DATA_JUDYARRAY) {

  01d9e	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  01da3	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01da8	85 c0		 test	 eax, eax
  01daa	0f 84 bd 00 00
	00		 je	 $LN7@test_chang
  01db0	33 db		 xor	 ebx, ebx
  01db2	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01db8	0f 86 af 00 00
	00		 jbe	 $LN7@test_chang
  01dbe	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  01dc1	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01dc4	2b c7		 sub	 eax, edi
  01dc6	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
  01dc9	eb 5c		 jmp	 SHORT $LN9@test_chang
$LN1501@test_chang:

; 1716 : 		HASH_ADD_INT(uthash, value, obj);

  01dcb	6a ff		 push	 -1
  01dcd	e8 00 00 00 00	 call	 _exit
$LN1621@test_chang:
$LN1504@test_chang:

; 1729 : 		JLD(r, judy, key);

  01dd2	8b 45 9c	 mov	 eax, DWORD PTR _J_Error$152635[ebp+4]
  01dd5	8b 4d 98	 mov	 ecx, DWORD PTR _J_Error$152635[ebp]
  01dd8	50		 push	 eax
  01dd9	51		 push	 ecx
  01dda	68 00 00 00 00	 push	 OFFSET $SG-109
  01ddf	68 c1 06 00 00	 push	 1729			; 000006c1H
  01de4	68 00 00 00 00	 push	 OFFSET $SG-110
  01de9	68 00 00 00 00	 push	 OFFSET $SG-111
$LN1618@test_chang:
  01dee	e8 00 00 00 00	 call	 ___iob_func
  01df3	83 c0 40	 add	 eax, 64			; 00000040H
  01df6	50		 push	 eax
  01df7	e8 00 00 00 00	 call	 _fprintf
  01dfc	83 c4 1c	 add	 esp, 28			; 0000001cH
  01dff	6a 01		 push	 1
  01e01	e8 00 00 00 00	 call	 _exit
$LN1622@test_chang:
$LN1505@test_chang:

; 1734 : 		obj->value = key;
; 1735 : 		JLI(PValue, judy, key);

  01e06	8b 55 9c	 mov	 edx, DWORD PTR _J_Error$152642[ebp+4]
  01e09	8b 45 98	 mov	 eax, DWORD PTR _J_Error$152642[ebp]
  01e0c	52		 push	 edx
  01e0d	50		 push	 eax
  01e0e	68 00 00 00 00	 push	 OFFSET $SG-112
  01e13	68 c7 06 00 00	 push	 1735			; 000006c7H
  01e18	68 00 00 00 00	 push	 OFFSET $SG-113
  01e1d	68 00 00 00 00	 push	 OFFSET $SG-114
  01e22	eb ca		 jmp	 SHORT $LN1618@test_chang
$LL1594@test_chang:

; 1738 : #endif
; 1739 : 
; 1740 : #ifdef USE_JUDYARRAY
; 1741 : 	START(DATA_JUDYARRAY) {

  01e24	8b 45 ec	 mov	 eax, DWORD PTR tv8169[ebp]
$LN9@test_chang:

; 1742 : 		judyvalue key = REMOVE[i];

  01e27	8b 0c 38	 mov	 ecx, DWORD PTR [eax+edi]

; 1743 : 		struct judyarray_object* obj;
; 1744 : 		JudySlot* pvalue;
; 1745 : 		pvalue = judy_slot(judyarray, (uchar*)&key, 0);

  01e2a	8d 55 f4	 lea	 edx, DWORD PTR _key$152655[ebp]
  01e2d	52		 push	 edx
  01e2e	89 4d f4	 mov	 DWORD PTR _key$152655[ebp], ecx
  01e31	e8 00 00 00 00	 call	 ?judy_slot@@YAPAIPAUJudy@@PAEI@Z ; judy_slot
  01e36	8b f0		 mov	 esi, eax
  01e38	83 c4 04	 add	 esp, 4

; 1746 : 		if (!pvalue)

  01e3b	85 f6		 test	 esi, esi
  01e3d	75 05		 jne	 SHORT $LN6@test_chang

; 1747 : 			abort();

  01e3f	e8 00 00 00 00	 call	 _abort
$LN6@test_chang:

; 1748 : 		obj = *(struct judyarray_object**)pvalue;

  01e44	8b 36		 mov	 esi, DWORD PTR [esi]

; 1749 : 		judy_del(judyarray);

  01e46	e8 00 00 00 00	 call	 ?judy_del@@YAPAIPAUJudy@@@Z ; judy_del

; 1750 : 
; 1751 : 		key = INSERT[i] + DELTA;

  01e4b	8b 07		 mov	 eax, DWORD PTR [edi]
  01e4d	40		 inc	 eax
  01e4e	89 45 f4	 mov	 DWORD PTR _key$152655[ebp], eax

; 1752 : 		obj->value = key;

  01e51	89 06		 mov	 DWORD PTR [esi], eax

; 1753 : 		pvalue = judy_cell(judyarray, (uchar*)&key, 0);

  01e53	8d 45 f4	 lea	 eax, DWORD PTR _key$152655[ebp]
  01e56	50		 push	 eax
  01e57	e8 00 00 00 00	 call	 ?judy_cell@@YAPAIPAUJudy@@PAEI@Z ; judy_cell
  01e5c	43		 inc	 ebx
  01e5d	83 c4 04	 add	 esp, 4
  01e60	83 c7 04	 add	 edi, 4

; 1754 : 		*(struct judyarray_object**)pvalue = obj;

  01e63	89 30		 mov	 DWORD PTR [eax], esi
  01e65	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01e6b	72 b7		 jb	 SHORT $LL1594@test_chang
$LN7@test_chang:

; 1755 : 	} STOP();

  01e6d	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1756 : #endif
; 1757 : 
; 1758 : 	START(DATA_NEDTRIE) {

  01e72	b8 06 00 00 00	 mov	 eax, 6
  01e77	e8 00 00 00 00	 call	 ?start@@YAHI@Z		; start
  01e7c	85 c0		 test	 eax, eax
  01e7e	74 4f		 je	 SHORT $LN2@test_chang
  01e80	33 db		 xor	 ebx, ebx
  01e82	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  01e88	76 45		 jbe	 SHORT $LN2@test_chang
  01e8a	8b 7d 0c	 mov	 edi, DWORD PTR _INSERT$[ebp]
  01e8d	8b 45 08	 mov	 eax, DWORD PTR _REMOVE$[ebp]
  01e90	2b c7		 sub	 eax, edi
  01e92	89 45 ec	 mov	 DWORD PTR tv8169[ebp], eax
$LL4@test_chang:

; 1759 : 		unsigned key = REMOVE[i];
; 1760 : 		struct nedtrie_object key_obj;
; 1761 : 		struct nedtrie_object* obj;
; 1762 : 		key_obj.value = key;

  01e95	8b 4d ec	 mov	 ecx, DWORD PTR tv8169[ebp]
  01e98	8b 14 39	 mov	 edx, DWORD PTR [ecx+edi]

; 1763 : 		obj = NEDTRIE_FIND(nedtrie_t, &nedtrie, &key_obj);

  01e9b	8d 45 88	 lea	 eax, DWORD PTR _key_obj$152668[ebp]
  01e9e	89 55 9c	 mov	 DWORD PTR _key_obj$152668[ebp+20], edx
  01ea1	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_FIND@@YAPAUnedtrie_object@@PIAUnedtrie_t@@PIAU1@@Z ; nedtrie_t_NEDTRIE_FIND
  01ea6	8b f0		 mov	 esi, eax

; 1764 : 		if (!obj)

  01ea8	85 f6		 test	 esi, esi
  01eaa	75 05		 jne	 SHORT $LN1@test_chang

; 1765 : 			abort();

  01eac	e8 00 00 00 00	 call	 _abort
$LN1@test_chang:

; 1766 : 		NEDTRIE_REMOVE(nedtrie_t, &nedtrie, obj);

  01eb1	8b d6		 mov	 edx, esi
  01eb3	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_REMOVE@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_REMOVE

; 1767 : 
; 1768 : 		key = INSERT[i] + DELTA;

  01eb8	8b 07		 mov	 eax, DWORD PTR [edi]
  01eba	40		 inc	 eax

; 1769 : 		obj->value = key;

  01ebb	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1770 : 		NEDTRIE_INSERT(nedtrie_t, &nedtrie, obj);

  01ebe	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_INSERT
  01ec3	43		 inc	 ebx
  01ec4	83 c7 04	 add	 edi, 4
  01ec7	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01ecd	72 c6		 jb	 SHORT $LL4@test_chang
$LN2@test_chang:

; 1771 : 	} STOP();

  01ecf	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 1772 : }

  01ed4	5f		 pop	 edi
  01ed5	5e		 pop	 esi
  01ed6	5b		 pop	 ebx
  01ed7	8b e5		 mov	 esp, ebp
  01ed9	5d		 pop	 ebp
  01eda	c3		 ret	 0
$LN1614@test_chang:
?test_change@@YAXPAI0@Z ENDP				; test_change
_TEXT	ENDS
PUBLIC	?test_insert@@YAXPAI@Z				; test_insert
; Function compile flags: /Ogtp
;	COMDAT ?test_insert@@YAXPAI@Z
_TEXT	SEGMENT
$T234086 = -148						; size = 12
$T234277 = -136						; size = 12
$T234269 = -124						; size = 12
$T234472 = -112						; size = 12
$T234033 = -112						; size = 12
_J_Error$150741 = -100					; size = 24
$T234603 = -96						; size = 20
$T233995 = -92						; size = 16
$T235540 = -76						; size = 8
_t$230986 = -76						; size = 8
_t$230960 = -68						; size = 8
_t$230664 = -68						; size = 8
tv7059 = -64						; size = 4
__Where$235564 = -64					; size = 4
__he_bkt_i$150709 = -64					; size = 4
_t$230870 = -60						; size = 8
_t$230819 = -60						; size = 8
tv7175 = -56						; size = 4
tv7146 = -56						; size = 4
$T234260 = -56						; size = 4
_count$230757 = -56					; size = 4
__he_new_buckets$150712 = -56				; size = 4
_key$150593 = -56					; size = 4
_r$150587 = -56						; size = 4
_t$230936 = -52						; size = 8
_t$230845 = -52						; size = 8
_t$230794 = -52						; size = 8
_t$230639 = -52						; size = 8
_t$230568 = -52						; size = 8
$T235650 = -48						; size = 4
$T234912 = -48						; size = 4
$T231470 = -48						; size = 4
_t$235830 = -44						; size = 8
_t$235738 = -44						; size = 8
_t$235692 = -44						; size = 8
_t$235036 = -44						; size = 8
_t$234673 = -44						; size = 8
_t$234520 = -44						; size = 8
_t$234450 = -44						; size = 8
_t$231010 = -44						; size = 8
_t$235805 = -36						; size = 8
_t$235784 = -36						; size = 8
_t$235713 = -36						; size = 8
_t$235667 = -36						; size = 8
_t$235012 = -36						; size = 8
_t$234648 = -36						; size = 8
_t$234498 = -36						; size = 8
_t$234426 = -36						; size = 8
_pos$234078 = -36					; size = 8
tv7192 = -28						; size = 4
tv7163 = -28						; size = 4
tv7134 = -28						; size = 4
tv7105 = -28						; size = 4
tv7076 = -28						; size = 4
tv7047 = -28						; size = 4
tv6815 = -28						; size = 4
_count$230750 = -24					; size = 4
_key$150599 = -24					; size = 4
_i$ = -24						; size = 4
$T235843 = -20						; size = 8
_t$235851 = -20						; size = 8
$T235823 = -20						; size = 8
$T235797 = -20						; size = 8
$T235777 = -20						; size = 8
$T235751 = -20						; size = 8
_t$235759 = -20						; size = 8
$T235731 = -20						; size = 8
$T235705 = -20						; size = 8
$T235685 = -20						; size = 8
$T235659 = -20						; size = 8
$T235538 = -20						; size = 8
$T235027 = -20						; size = 8
$T235001 = -20						; size = 8
$T234909 = -20						; size = 8
$T234666 = -20						; size = 8
$T234640 = -20						; size = 8
$T234513 = -20						; size = 8
$T234487 = -20						; size = 8
$T234441 = -20						; size = 8
$T234415 = -20						; size = 8
_pos$233988 = -20					; size = 8
tv4529 = -12						; size = 8
tv4477 = -12						; size = 8
tv4431 = -12						; size = 8
tv4357 = -12						; size = 8
tv4335 = -12						; size = 8
tv4328 = -12						; size = 8
tv3943 = -12						; size = 8
tv3924 = -12						; size = 8
tv3891 = -12						; size = 8
tv3834 = -12						; size = 8
tv3226 = -12						; size = 8
tv3193 = -12						; size = 8
tv3168 = -12						; size = 8
tv3110 = -12						; size = 8
tv2870 = -12						; size = 8
$T234601 = -12						; size = 8
tv2100 = -12						; size = 8
tv1742 = -12						; size = 8
tv1710 = -12						; size = 8
$T231001 = -12						; size = 8
tv1395 = -12						; size = 8
tv1326 = -12						; size = 8
tv1300 = -12						; size = 8
$T230975 = -12						; size = 8
$T230951 = -12						; size = 8
$T230925 = -12						; size = 8
$T230864 = -12						; size = 8
$T230838 = -12						; size = 8
tv1114 = -12						; size = 8
tv1041 = -12						; size = 8
tv974 = -12						; size = 8
$T230812 = -12						; size = 8
$T230786 = -12						; size = 8
$T230657 = -12						; size = 8
$T230631 = -12						; size = 8
tv922 = -12						; size = 8
tv869 = -12						; size = 8
$T230561 = -12						; size = 8
tv215 = -12						; size = 8
tv181 = -12						; size = 8
tv7088 = -8						; size = 4
$T234993 = -8						; size = 4
$T232664 = -8						; size = 4
_key$150754 = -8					; size = 4
__he_hh_nxt$150711 = -8					; size = 4
_key$150617 = -8					; size = 4
_INSERT$ = 8						; size = 4
?test_insert@@YAXPAI@Z PROC				; test_insert, COMDAT

; 945  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	53		 push	 ebx

; 946  : 	unsigned i;
; 947  : 
; 948  : 	START(DATA_TREE) {

  0000a	b8 05 00 00 00	 mov	 eax, 5
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  00016	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  0001c	75 71		 jne	 SHORT $LN117@test_inser
  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00025	75 2e		 jne	 SHORT $LN125@test_inser
  00027	a1 14 00 00 00	 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA+20
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  00032	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[ecx*4]
  00039	50		 push	 eax
  0003a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  0003f	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  00046	52		 push	 edx
  00047	51		 push	 ecx
  00048	68 00 00 00 00	 push	 OFFSET $SG-101
  0004d	e8 00 00 00 00	 call	 _printf
  00052	83 c4 10	 add	 esp, 16			; 00000010H
$LN125@test_inser:
  00055	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  0005a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00060	33 f6		 xor	 esi, esi
  00062	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  00067	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  0006d	85 db		 test	 ebx, ebx
  0006f	74 1e		 je	 SHORT $LN117@test_inser
  00071	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?RBTREE@@3PAUrbt_object@@A ; RBTREE
$LL119@test_inser:

; 949  : 		unsigned key = INSERT[i];
; 950  : 		RBTREE[i].value = key;

  00077	8b 55 08	 mov	 edx, DWORD PTR _INSERT$[ebp]
  0007a	8b 04 b2	 mov	 eax, DWORD PTR [edx+esi*4]
  0007d	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 951  : 		rbt_insert(&tree, &RBTREE[i]);

  00080	8b c7		 mov	 eax, edi
  00082	e8 00 00 00 00	 call	 ?rbt_insert@@YAXPAUrbtree_t@@PAUrbt_object@@@Z ; rbt_insert
  00087	46		 inc	 esi
  00088	83 c7 1c	 add	 edi, 28			; 0000001cH
  0008b	3b f3		 cmp	 esi, ebx
  0008d	72 e8		 jb	 SHORT $LL119@test_inser
$LN117@test_inser:

; 952  : 	} STOP();

  0008f	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 953  : 
; 954  : 	START(DATA_HASHTABLE) {

  00094	33 db		 xor	 ebx, ebx
  00096	89 1d 00 00 00
	00		 mov	 DWORD PTR ?the_start_data@@3IA, ebx ; the_start_data
  0009c	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, ebx ; the_data
  000a2	0f 85 e9 00 00
	00		 jne	 $LN113@test_inser
  000a8	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_log@@3HA, ebx ; the_log
  000ae	75 30		 jne	 SHORT $LN131@test_inser
  000b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA
  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  000bc	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  000c3	51		 push	 ecx
  000c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  000ca	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  000d1	50		 push	 eax
  000d2	52		 push	 edx
  000d3	68 00 00 00 00	 push	 OFFSET $SG-101
  000d8	e8 00 00 00 00	 call	 _printf
  000dd	83 c4 10	 add	 esp, 16			; 00000010H
$LN131@test_inser:
  000e0	e8 00 00 00 00	 call	 ?nano@@YA_KXZ		; nano
  000e5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_max@@3IA ; the_max
  000eb	a3 00 00 00 00	 mov	 DWORD PTR ?the_time@@3_KA, eax
  000f0	89 15 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edx
  000f6	3b f3		 cmp	 esi, ebx
  000f8	0f 86 93 00 00
	00		 jbe	 $LN113@test_inser
  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?HASHTABLE@@3PAUhashtable_object@@A ; HASHTABLE
$LL115@test_inser:

; 955  : 		unsigned key = INSERT[i];

  00104	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00107	8b 3c 98	 mov	 edi, DWORD PTR [eax+ebx*4]

; 956  : 		unsigned hash_key = hash(key);

  0010a	8b d7		 mov	 edx, edi
  0010c	c1 e2 06	 shl	 edx, 6
  0010f	8b c7		 mov	 eax, edi
  00111	2b c2		 sub	 eax, edx
  00113	8b d0		 mov	 edx, eax
  00115	c1 ea 11	 shr	 edx, 17			; 00000011H
  00118	33 c2		 xor	 eax, edx
  0011a	8b d0		 mov	 edx, eax
  0011c	c1 e2 09	 shl	 edx, 9
  0011f	2b c2		 sub	 eax, edx
  00121	8b d0		 mov	 edx, eax
  00123	c1 e2 04	 shl	 edx, 4
  00126	33 c2		 xor	 eax, edx
  00128	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0012f	2b c2		 sub	 eax, edx
  00131	8b d0		 mov	 edx, eax
  00133	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00136	33 c2		 xor	 eax, edx
  00138	8b d0		 mov	 edx, eax
  0013a	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  0013d	33 d0		 xor	 edx, eax

; 957  : 		HASHTABLE[i].value = key;

  0013f	89 79 10	 mov	 DWORD PTR [ecx+16], edi

; 958  : 		tommy_hashtable_insert(&hashtable, &HASHTABLE[i].node, &HASHTABLE[i], hash_key);

  00142	a1 08 00 00 00	 mov	 eax, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+8
  00147	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A
  0014d	23 c2		 and	 eax, edx
  0014f	8d 3c 87	 lea	 edi, DWORD PTR [edi+eax*4]
  00152	8b 07		 mov	 eax, DWORD PTR [edi]
  00154	85 c0		 test	 eax, eax
  00156	74 16		 je	 SHORT $LN142@test_inser
  00158	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  0015b	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0015e	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00161	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00164	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0016a	89 08		 mov	 DWORD PTR [eax], ecx
  0016c	eb 0b		 jmp	 SHORT $LN149@test_inser
$LN142@test_inser:
  0016e	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  00171	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00177	89 0f		 mov	 DWORD PTR [edi], ecx
$LN149@test_inser:
  00179	89 49 08	 mov	 DWORD PTR [ecx+8], ecx
  0017c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0017f	ff 05 0c 00 00
	00		 inc	 DWORD PTR ?hashtable@@3Utommy_hashtable_struct@@A+12
  00185	43		 inc	 ebx
  00186	83 c1 24	 add	 ecx, 36			; 00000024H
  00189	3b de		 cmp	 ebx, esi
  0018b	0f 82 73 ff ff
	ff		 jb	 $LL115@test_inser
$LN113@test_inser:

; 959  : 	} STOP();

  00191	e8 00 00 00 00	 call	 ?stop@@YAXXZ		; stop

; 960  : 
; 961  : 	START(DATA_HASHDYN) {

  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	a3 00 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, eax ; the_start_data
  001a0	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_data@@3IA, eax ; the_data
  001a6	0f 85 82 01 00
	00		 jne	 $LN109@test_inser
  001ac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  001b3	75 30		 jne	 SHORT $LN151@test_inser
  001b5	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA+4
  001bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  001c1	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[edx*4]
  001c8	51		 push	 ecx
  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  001cf	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  001d6	50		 push	 eax
  001d7	52		 push	 edx
  001d8	68 00 00 00 00	 push	 OFFSET $SG-101
  001dd	e8 00 00 00 00	 call	 _printf
  001e2	83 c4 10	 add	 esp, 16			; 00000010H
$LN151@test_inser:
  001e5	8d 45 cc	 lea	 eax, DWORD PTR _t$230568[ebp]
  001e8	50		 push	 eax
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  001ef	85 c0		 test	 eax, eax
  001f1	75 11		 jne	 SHORT $LN157@test_inser
  001f3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001f7	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230561[ebp], xmm0
  001fc	8b 5d f8	 mov	 ebx, DWORD PTR $T230561[ebp+4]
  001ff	8b 7d f4	 mov	 edi, DWORD PTR $T230561[ebp]
  00202	eb 54		 jmp	 SHORT $LN158@test_inser
$LN157@test_inser:
  00204	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0020a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00210	8b 4d d0	 mov	 ecx, DWORD PTR _t$230568[ebp+4]
  00213	8b 55 cc	 mov	 edx, DWORD PTR _t$230568[ebp]
  00216	57		 push	 edi
  00217	56		 push	 esi
  00218	51		 push	 ecx
  00219	52		 push	 edx
  0021a	e8 00 00 00 00	 call	 __alldvrm
  0021f	6a 00		 push	 0
  00221	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00226	53		 push	 ebx
  00227	51		 push	 ecx
  00228	89 45 f4	 mov	 DWORD PTR tv3168[ebp], eax
  0022b	89 55 f8	 mov	 DWORD PTR tv3168[ebp+4], edx
  0022e	e8 00 00 00 00	 call	 __allmul
  00233	57		 push	 edi
  00234	56		 push	 esi
  00235	52		 push	 edx
  00236	50		 push	 eax
  00237	e8 00 00 00 00	 call	 __alldiv
  0023c	8b 4d f4	 mov	 ecx, DWORD PTR tv3168[ebp]
  0023f	6a 00		 push	 0
  00241	8b f8		 mov	 edi, eax
  00243	8b 45 f8	 mov	 eax, DWORD PTR tv3168[ebp+4]
  00246	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0024b	50		 push	 eax
  0024c	51		 push	 ecx
  0024d	8b da		 mov	 ebx, edx
  0024f	e8 00 00 00 00	 call	 __allmul
  00254	03 f8		 add	 edi, eax
  00256	13 da		 adc	 ebx, edx
$LN158@test_inser:
  00258	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0025e	33 db		 xor	 ebx, ebx
  00260	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00266	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  0026c	0f 86 bc 00 00
	00		 jbe	 $LN109@test_inser
  00272	33 f6		 xor	 esi, esi
$LL111@test_inser:

; 962  : 		unsigned key = INSERT[i];

  00274	8b 55 08	 mov	 edx, DWORD PTR _INSERT$[ebp]
  00277	8b 14 9a	 mov	 edx, DWORD PTR [edx+ebx*4]

; 963  : 		unsigned hash_key = hash(key);

  0027a	8b ca		 mov	 ecx, edx
  0027c	c1 e1 06	 shl	 ecx, 6
  0027f	8b c2		 mov	 eax, edx
  00281	2b c1		 sub	 eax, ecx
  00283	8b c8		 mov	 ecx, eax
  00285	c1 e9 11	 shr	 ecx, 17			; 00000011H
  00288	33 c1		 xor	 eax, ecx
  0028a	8b c8		 mov	 ecx, eax
  0028c	c1 e1 09	 shl	 ecx, 9
  0028f	2b c1		 sub	 eax, ecx
  00291	8b c8		 mov	 ecx, eax
  00293	c1 e1 04	 shl	 ecx, 4
  00296	33 c1		 xor	 eax, ecx
  00298	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0029f	2b c1		 sub	 eax, ecx
  002a1	8b c8		 mov	 ecx, eax
  002a3	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  002a6	33 c1		 xor	 eax, ecx
  002a8	8b c8		 mov	 ecx, eax
  002aa	c1 e9 0f	 shr	 ecx, 15			; 0000000fH
  002ad	33 c8		 xor	 ecx, eax

; 964  : 		HASHDYN[i].value = key;

  002af	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHDYN@@3PAUhashtable_object@@A ; HASHDYN
  002b4	03 c6		 add	 eax, esi
  002b6	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 965  : 		tommy_hashdyn_insert(&hashdyn, &HASHDYN[i].node, &HASHDYN[i], hash_key);

  002b9	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+12
  002bf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A
  002c5	23 d1		 and	 edx, ecx
  002c7	8d 3c 97	 lea	 edi, DWORD PTR [edi+edx*4]
  002ca	8b 17		 mov	 edx, DWORD PTR [edi]
  002cc	85 d2		 test	 edx, edx
  002ce	74 16		 je	 SHORT $LN165@test_inser
  002d0	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  002d3	89 78 04	 mov	 DWORD PTR [eax+4], edi
  002d6	89 42 04	 mov	 DWORD PTR [edx+4], eax
  002d9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  002dc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002e2	89 02		 mov	 DWORD PTR [edx], eax
  002e4	eb 0b		 jmp	 SHORT $LN172@test_inser
$LN165@test_inser:
  002e6	89 40 04	 mov	 DWORD PTR [eax+4], eax
  002e9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  002ef	89 07		 mov	 DWORD PTR [edi], eax
$LN172@test_inser:
  002f1	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  002f4	89 40 08	 mov	 DWORD PTR [eax+8], eax
  002f7	a1 10 00 00 00	 mov	 eax, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16
  002fc	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+8
  00302	40		 inc	 eax
  00303	d1 e9		 shr	 ecx, 1
  00305	a3 10 00 00 00	 mov	 DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+16, eax
  0030a	3b c1		 cmp	 eax, ecx
  0030c	72 10		 jb	 SHORT $LN110@test_inser
  0030e	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?hashdyn@@3Utommy_hashdyn_struct@@A+4
  00314	42		 inc	 edx
  00315	52		 push	 edx
  00316	e8 00 00 00 00	 call	 ?tommy_hashdyn_resize@@YAXPAUtommy_hashdyn_struct@@I@Z ; tommy_hashdyn_resize
  0031b	83 c4 04	 add	 esp, 4
$LN110@test_inser:

; 960  : 
; 961  : 	START(DATA_HASHDYN) {

  0031e	43		 inc	 ebx
  0031f	83 c6 24	 add	 esi, 36			; 00000024H
  00322	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  00328	0f 82 46 ff ff
	ff		 jb	 $LL111@test_inser
$LN109@test_inser:

; 966  : 	} STOP();

  0032e	8d 45 cc	 lea	 eax, DWORD PTR _t$230639[ebp]
  00331	50		 push	 eax
  00332	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00338	85 c0		 test	 eax, eax
  0033a	75 11		 jne	 SHORT $LN181@test_inser
  0033c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00340	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230631[ebp], xmm0
  00345	8b 5d f8	 mov	 ebx, DWORD PTR $T230631[ebp+4]
  00348	8b 7d f4	 mov	 edi, DWORD PTR $T230631[ebp]
  0034b	eb 54		 jmp	 SHORT $LN182@test_inser
$LN181@test_inser:
  0034d	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00353	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00359	8b 4d d0	 mov	 ecx, DWORD PTR _t$230639[ebp+4]
  0035c	8b 55 cc	 mov	 edx, DWORD PTR _t$230639[ebp]
  0035f	57		 push	 edi
  00360	56		 push	 esi
  00361	51		 push	 ecx
  00362	52		 push	 edx
  00363	e8 00 00 00 00	 call	 __alldvrm
  00368	6a 00		 push	 0
  0036a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0036f	53		 push	 ebx
  00370	51		 push	 ecx
  00371	89 45 f4	 mov	 DWORD PTR tv4529[ebp], eax
  00374	89 55 f8	 mov	 DWORD PTR tv4529[ebp+4], edx
  00377	e8 00 00 00 00	 call	 __allmul
  0037c	57		 push	 edi
  0037d	56		 push	 esi
  0037e	52		 push	 edx
  0037f	50		 push	 eax
  00380	e8 00 00 00 00	 call	 __alldiv
  00385	8b 4d f4	 mov	 ecx, DWORD PTR tv4529[ebp]
  00388	6a 00		 push	 0
  0038a	8b f8		 mov	 edi, eax
  0038c	8b 45 f8	 mov	 eax, DWORD PTR tv4529[ebp+4]
  0038f	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00394	50		 push	 eax
  00395	51		 push	 ecx
  00396	8b da		 mov	 ebx, edx
  00398	e8 00 00 00 00	 call	 __allmul
  0039d	03 f8		 add	 edi, eax
  0039f	13 da		 adc	 ebx, edx
$LN182@test_inser:
  003a1	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  003a7	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  003ad	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  003b3	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  003b9	75 63		 jne	 SHORT $LN179@test_inser
  003bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  003c2	75 24		 jne	 SHORT $LN177@test_inser
  003c4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  003ca	6a 00		 push	 0
  003cc	52		 push	 edx
  003cd	53		 push	 ebx
  003ce	57		 push	 edi
  003cf	e8 00 00 00 00	 call	 __aulldiv
  003d4	50		 push	 eax
  003d5	68 00 00 00 00	 push	 OFFSET $SG-102
  003da	e8 00 00 00 00	 call	 _printf
  003df	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  003e5	83 c4 08	 add	 esp, 8
$LN177@test_inser:
  003e8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  003ed	6a 00		 push	 0
  003ef	50		 push	 eax
  003f0	53		 push	 ebx
  003f1	57		 push	 edi
  003f2	e8 00 00 00 00	 call	 __aulldiv
  003f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  003fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00403	c1 e1 04	 shl	 ecx, 4
  00406	03 ce		 add	 ecx, esi
  00408	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0040b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00411	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00414	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00417	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN179@test_inser:

; 967  : 
; 968  : 	START(DATA_HASHLIN) {

  0041e	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 2 ; the_start_data
  00428	83 fe 02	 cmp	 esi, 2
  0042b	0f 85 c9 01 00
	00		 jne	 $LN105@test_inser
  00431	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00438	75 2f		 jne	 SHORT $LN186@test_inser
  0043a	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+8
  00440	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00445	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0044c	52		 push	 edx
  0044d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00453	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0045a	51		 push	 ecx
  0045b	50		 push	 eax
  0045c	68 00 00 00 00	 push	 OFFSET $SG-101
  00461	e8 00 00 00 00	 call	 _printf
  00466	83 c4 10	 add	 esp, 16			; 00000010H
$LN186@test_inser:
  00469	8d 4d bc	 lea	 ecx, DWORD PTR _t$230664[ebp]
  0046c	51		 push	 ecx
  0046d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00473	85 c0		 test	 eax, eax
  00475	75 11		 jne	 SHORT $LN192@test_inser
  00477	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0047b	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230657[ebp], xmm0
  00480	8b 5d f8	 mov	 ebx, DWORD PTR $T230657[ebp+4]
  00483	8b 7d f4	 mov	 edi, DWORD PTR $T230657[ebp]
  00486	eb 54		 jmp	 SHORT $LN193@test_inser
$LN192@test_inser:
  00488	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0048e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00494	8b 55 c0	 mov	 edx, DWORD PTR _t$230664[ebp+4]
  00497	8b 45 bc	 mov	 eax, DWORD PTR _t$230664[ebp]
  0049a	57		 push	 edi
  0049b	56		 push	 esi
  0049c	52		 push	 edx
  0049d	50		 push	 eax
  0049e	e8 00 00 00 00	 call	 __alldvrm
  004a3	6a 00		 push	 0
  004a5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004aa	53		 push	 ebx
  004ab	51		 push	 ecx
  004ac	89 45 f4	 mov	 DWORD PTR tv869[ebp], eax
  004af	89 55 f8	 mov	 DWORD PTR tv869[ebp+4], edx
  004b2	e8 00 00 00 00	 call	 __allmul
  004b7	57		 push	 edi
  004b8	56		 push	 esi
  004b9	52		 push	 edx
  004ba	50		 push	 eax
  004bb	e8 00 00 00 00	 call	 __alldiv
  004c0	8b 4d f8	 mov	 ecx, DWORD PTR tv869[ebp+4]
  004c3	6a 00		 push	 0
  004c5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  004ca	8b da		 mov	 ebx, edx
  004cc	8b 55 f4	 mov	 edx, DWORD PTR tv869[ebp]
  004cf	51		 push	 ecx
  004d0	52		 push	 edx
  004d1	8b f8		 mov	 edi, eax
  004d3	e8 00 00 00 00	 call	 __allmul
  004d8	03 f8		 add	 edi, eax
  004da	13 da		 adc	 ebx, edx
$LN193@test_inser:
  004dc	33 f6		 xor	 esi, esi
  004de	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  004e4	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  004ea	89 75 e8	 mov	 DWORD PTR _i$[ebp], esi
  004ed	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  004f3	0f 86 01 01 00
	00		 jbe	 $LN105@test_inser
  004f9	89 75 e4	 mov	 DWORD PTR tv6815[ebp], esi
  004fc	8d 64 24 00	 npad	 4
$LL107@test_inser:

; 969  : 		unsigned key = INSERT[i];

  00500	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00503	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]

; 970  : 		unsigned hash_key = hash(key);

  00506	8b d1		 mov	 edx, ecx
  00508	c1 e2 06	 shl	 edx, 6
  0050b	8b c1		 mov	 eax, ecx
  0050d	2b c2		 sub	 eax, edx
  0050f	8b d0		 mov	 edx, eax
  00511	c1 ea 11	 shr	 edx, 17			; 00000011H
  00514	33 c2		 xor	 eax, edx
  00516	8b d0		 mov	 edx, eax
  00518	c1 e2 09	 shl	 edx, 9
  0051b	2b c2		 sub	 eax, edx
  0051d	8b d0		 mov	 edx, eax
  0051f	c1 e2 04	 shl	 edx, 4
  00522	33 c2		 xor	 eax, edx
  00524	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  0052b	2b c2		 sub	 eax, edx
  0052d	8b d0		 mov	 edx, eax
  0052f	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00532	33 c2		 xor	 eax, edx
  00534	8b d0		 mov	 edx, eax
  00536	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00539	33 d0		 xor	 edx, eax

; 971  : 		HASHLIN[i].value = key;

  0053b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?HASHLIN@@3PAUhashtable_object@@A ; HASHLIN
  00540	03 45 e4	 add	 eax, DWORD PTR tv6815[ebp]
  00543	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 972  : 		tommy_hashlin_insert(&hashlin, &HASHLIN[i].node, &HASHLIN[i], hash_key);

  00546	83 3d 9c 00 00
	00 00		 cmp	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+156, 0
  0054d	74 2e		 je	 SHORT $LN199@test_inser
  0054f	8b 3d 94 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+148
  00555	23 fa		 and	 edi, edx
  00557	3b 3d 98 00 00
	00		 cmp	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+152
  0055d	72 1e		 jb	 SHORT $LN199@test_inser
  0055f	83 ff 40	 cmp	 edi, 64			; 00000040H
  00562	73 08		 jae	 SHORT $LN203@test_inser
  00564	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  0056a	eb 3f		 jmp	 SHORT $LN1267@test_inser
$LN203@test_inser:
  0056c	0f bd cf	 bsr	 ecx, edi
  0056f	bb 01 00 00 00	 mov	 ebx, 1
  00574	d3 e3		 shl	 ebx, cl
  00576	89 4d e8	 mov	 DWORD PTR _count$230750[ebp], ecx
  00579	2b fb		 sub	 edi, ebx
  0057b	eb 27		 jmp	 SHORT $LN1268@test_inser
$LN199@test_inser:
  0057d	8b 3d 88 00 00
	00		 mov	 edi, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+136
  00583	23 fa		 and	 edi, edx
  00585	83 ff 40	 cmp	 edi, 64			; 00000040H
  00588	73 08		 jae	 SHORT $LN208@test_inser
  0058a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A
  00590	eb 19		 jmp	 SHORT $LN1267@test_inser
$LN208@test_inser:
  00592	0f bd cf	 bsr	 ecx, edi
  00595	be 01 00 00 00	 mov	 esi, 1
  0059a	d3 e6		 shl	 esi, cl
  0059c	89 4d c8	 mov	 DWORD PTR _count$230757[ebp], ecx
  0059f	2b fe		 sub	 edi, esi
  005a1	8b 75 e8	 mov	 esi, DWORD PTR _i$[ebp]
$LN1268@test_inser:
  005a4	8b 0c 8d ec ff
	ff ff		 mov	 ecx, DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A[ecx*4-20]
$LN1267@test_inser:
  005ab	8d 3c b9	 lea	 edi, DWORD PTR [ecx+edi*4]
  005ae	8b 0f		 mov	 ecx, DWORD PTR [edi]
  005b0	85 c9		 test	 ecx, ecx
  005b2	74 16		 je	 SHORT $LN214@test_inser
  005b4	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  005b7	89 78 04	 mov	 DWORD PTR [eax+4], edi
  005ba	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  005bd	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  005c0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005c6	89 01		 mov	 DWORD PTR [ecx], eax
  005c8	eb 0b		 jmp	 SHORT $LN221@test_inser
$LN214@test_inser:
  005ca	89 40 04	 mov	 DWORD PTR [eax+4], eax
  005cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  005d3	89 07		 mov	 DWORD PTR [edi], eax
$LN221@test_inser:
  005d5	89 40 08	 mov	 DWORD PTR [eax+8], eax
  005d8	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  005db	ff 05 a0 00 00
	00		 inc	 DWORD PTR ?hashlin@@3Utommy_hashlin_struct@@A+160
  005e1	e8 00 00 00 00	 call	 ?hashlin_grow_step@@YAXPAUtommy_hashlin_struct@@@Z ; hashlin_grow_step
  005e6	83 45 e4 24	 add	 DWORD PTR tv6815[ebp], 36 ; 00000024H
  005ea	46		 inc	 esi
  005eb	89 75 e8	 mov	 DWORD PTR _i$[ebp], esi
  005ee	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  005f4	0f 82 06 ff ff
	ff		 jb	 $LL107@test_inser
$LN105@test_inser:

; 973  : 	} STOP();

  005fa	8d 55 cc	 lea	 edx, DWORD PTR _t$230794[ebp]
  005fd	52		 push	 edx
  005fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00604	85 c0		 test	 eax, eax
  00606	75 11		 jne	 SHORT $LN227@test_inser
  00608	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0060c	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230786[ebp], xmm0
  00611	8b 5d f8	 mov	 ebx, DWORD PTR $T230786[ebp+4]
  00614	8b 7d f4	 mov	 edi, DWORD PTR $T230786[ebp]
  00617	eb 54		 jmp	 SHORT $LN228@test_inser
$LN227@test_inser:
  00619	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0061f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00625	8b 45 d0	 mov	 eax, DWORD PTR _t$230794[ebp+4]
  00628	8b 4d cc	 mov	 ecx, DWORD PTR _t$230794[ebp]
  0062b	57		 push	 edi
  0062c	56		 push	 esi
  0062d	50		 push	 eax
  0062e	51		 push	 ecx
  0062f	e8 00 00 00 00	 call	 __alldvrm
  00634	6a 00		 push	 0
  00636	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0063b	53		 push	 ebx
  0063c	51		 push	 ecx
  0063d	89 45 f4	 mov	 DWORD PTR tv922[ebp], eax
  00640	89 55 f8	 mov	 DWORD PTR tv922[ebp+4], edx
  00643	e8 00 00 00 00	 call	 __allmul
  00648	57		 push	 edi
  00649	56		 push	 esi
  0064a	52		 push	 edx
  0064b	50		 push	 eax
  0064c	e8 00 00 00 00	 call	 __alldiv
  00651	6a 00		 push	 0
  00653	8b da		 mov	 ebx, edx
  00655	8b 55 f8	 mov	 edx, DWORD PTR tv922[ebp+4]
  00658	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0065d	8b f8		 mov	 edi, eax
  0065f	8b 45 f4	 mov	 eax, DWORD PTR tv922[ebp]
  00662	52		 push	 edx
  00663	50		 push	 eax
  00664	e8 00 00 00 00	 call	 __allmul
  00669	03 f8		 add	 edi, eax
  0066b	13 da		 adc	 ebx, edx
$LN228@test_inser:
  0066d	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00673	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00679	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  0067f	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00685	75 64		 jne	 SHORT $LN225@test_inser
  00687	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0068e	75 24		 jne	 SHORT $LN223@test_inser
  00690	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00696	6a 00		 push	 0
  00698	51		 push	 ecx
  00699	53		 push	 ebx
  0069a	57		 push	 edi
  0069b	e8 00 00 00 00	 call	 __aulldiv
  006a0	50		 push	 eax
  006a1	68 00 00 00 00	 push	 OFFSET $SG-102
  006a6	e8 00 00 00 00	 call	 _printf
  006ab	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  006b1	83 c4 08	 add	 esp, 8
$LN223@test_inser:
  006b4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  006ba	6a 00		 push	 0
  006bc	52		 push	 edx
  006bd	53		 push	 ebx
  006be	57		 push	 edi
  006bf	e8 00 00 00 00	 call	 __aulldiv
  006c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  006ca	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  006d0	c1 e1 04	 shl	 ecx, 4
  006d3	03 ce		 add	 ecx, esi
  006d5	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  006d8	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  006de	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  006e1	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  006e4	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN225@test_inser:

; 974  : 
; 975  : 	START(DATA_TRIE) {

  006eb	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 3 ; the_start_data
  006f5	83 fe 03	 cmp	 esi, 3
  006f8	0f 85 01 01 00
	00		 jne	 $LN101@test_inser
  006fe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00705	75 2f		 jne	 SHORT $LN232@test_inser
  00707	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+12
  0070d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00712	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00719	52		 push	 edx
  0071a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00720	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00727	51		 push	 ecx
  00728	50		 push	 eax
  00729	68 00 00 00 00	 push	 OFFSET $SG-101
  0072e	e8 00 00 00 00	 call	 _printf
  00733	83 c4 10	 add	 esp, 16			; 00000010H
$LN232@test_inser:
  00736	8d 4d c4	 lea	 ecx, DWORD PTR _t$230819[ebp]
  00739	51		 push	 ecx
  0073a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00740	85 c0		 test	 eax, eax
  00742	75 11		 jne	 SHORT $LN238@test_inser
  00744	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00748	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230812[ebp], xmm0
  0074d	8b 5d f8	 mov	 ebx, DWORD PTR $T230812[ebp+4]
  00750	8b 7d f4	 mov	 edi, DWORD PTR $T230812[ebp]
  00753	eb 54		 jmp	 SHORT $LN239@test_inser
$LN238@test_inser:
  00755	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0075b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00761	8b 55 c8	 mov	 edx, DWORD PTR _t$230819[ebp+4]
  00764	8b 45 c4	 mov	 eax, DWORD PTR _t$230819[ebp]
  00767	57		 push	 edi
  00768	56		 push	 esi
  00769	52		 push	 edx
  0076a	50		 push	 eax
  0076b	e8 00 00 00 00	 call	 __alldvrm
  00770	6a 00		 push	 0
  00772	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00777	53		 push	 ebx
  00778	51		 push	 ecx
  00779	89 45 f4	 mov	 DWORD PTR tv974[ebp], eax
  0077c	89 55 f8	 mov	 DWORD PTR tv974[ebp+4], edx
  0077f	e8 00 00 00 00	 call	 __allmul
  00784	57		 push	 edi
  00785	56		 push	 esi
  00786	52		 push	 edx
  00787	50		 push	 eax
  00788	e8 00 00 00 00	 call	 __alldiv
  0078d	8b 4d f8	 mov	 ecx, DWORD PTR tv974[ebp+4]
  00790	6a 00		 push	 0
  00792	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00797	8b da		 mov	 ebx, edx
  00799	8b 55 f4	 mov	 edx, DWORD PTR tv974[ebp]
  0079c	51		 push	 ecx
  0079d	52		 push	 edx
  0079e	8b f8		 mov	 edi, eax
  007a0	e8 00 00 00 00	 call	 __allmul
  007a5	03 f8		 add	 edi, eax
  007a7	13 da		 adc	 ebx, edx
$LN239@test_inser:
  007a9	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  007af	33 ff		 xor	 edi, edi
  007b1	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  007b7	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  007bd	76 40		 jbe	 SHORT $LN101@test_inser
  007bf	8b 75 08	 mov	 esi, DWORD PTR _INSERT$[ebp]
  007c2	33 db		 xor	 ebx, ebx
$LL103@test_inser:

; 976  : 		unsigned key = INSERT[i];

  007c4	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]

; 977  : 		TRIE[i].value = key;

  007c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?TRIE@@3PAUtrie_object@@A ; TRIE
  007cd	03 cb		 add	 ecx, ebx
  007cf	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 978  : 		tommy_trie_insert(&trie, &TRIE[i].node, &TRIE[i], key);

  007d2	50		 push	 eax
  007d3	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  007d6	c1 e8 1c	 shr	 eax, 28			; 0000001cH
  007d9	51		 push	 ecx
  007da	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR ?trie@@3Utommy_trie_struct@@A[eax*4]
  007e1	52		 push	 edx
  007e2	89 49 08	 mov	 DWORD PTR [ecx+8], ecx
  007e5	e8 00 00 00 00	 call	 ?trie_bucket_insert@@YAXPAUtommy_trie_struct@@IPAPAUtommy_node_struct@@PAU2@I@Z ; trie_bucket_insert
  007ea	ff 05 40 00 00
	00		 inc	 DWORD PTR ?trie@@3Utommy_trie_struct@@A+64
  007f0	47		 inc	 edi
  007f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  007f4	83 c3 24	 add	 ebx, 36			; 00000024H
  007f7	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  007fd	72 c5		 jb	 SHORT $LL103@test_inser
$LN101@test_inser:

; 979  : 	} STOP();

  007ff	8d 45 cc	 lea	 eax, DWORD PTR _t$230845[ebp]
  00802	50		 push	 eax
  00803	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00809	85 c0		 test	 eax, eax
  0080b	75 11		 jne	 SHORT $LN247@test_inser
  0080d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00811	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230838[ebp], xmm0
  00816	8b 5d f8	 mov	 ebx, DWORD PTR $T230838[ebp+4]
  00819	8b 7d f4	 mov	 edi, DWORD PTR $T230838[ebp]
  0081c	eb 54		 jmp	 SHORT $LN248@test_inser
$LN247@test_inser:
  0081e	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00824	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  0082a	8b 4d d0	 mov	 ecx, DWORD PTR _t$230845[ebp+4]
  0082d	8b 55 cc	 mov	 edx, DWORD PTR _t$230845[ebp]
  00830	57		 push	 edi
  00831	56		 push	 esi
  00832	51		 push	 ecx
  00833	52		 push	 edx
  00834	e8 00 00 00 00	 call	 __alldvrm
  00839	6a 00		 push	 0
  0083b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00840	53		 push	 ebx
  00841	51		 push	 ecx
  00842	89 45 f4	 mov	 DWORD PTR tv3943[ebp], eax
  00845	89 55 f8	 mov	 DWORD PTR tv3943[ebp+4], edx
  00848	e8 00 00 00 00	 call	 __allmul
  0084d	57		 push	 edi
  0084e	56		 push	 esi
  0084f	52		 push	 edx
  00850	50		 push	 eax
  00851	e8 00 00 00 00	 call	 __alldiv
  00856	8b 4d f4	 mov	 ecx, DWORD PTR tv3943[ebp]
  00859	6a 00		 push	 0
  0085b	8b f8		 mov	 edi, eax
  0085d	8b 45 f8	 mov	 eax, DWORD PTR tv3943[ebp+4]
  00860	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00865	50		 push	 eax
  00866	51		 push	 ecx
  00867	8b da		 mov	 ebx, edx
  00869	e8 00 00 00 00	 call	 __allmul
  0086e	03 f8		 add	 edi, eax
  00870	13 da		 adc	 ebx, edx
$LN248@test_inser:
  00872	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00878	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  0087e	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00884	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  0088a	75 63		 jne	 SHORT $LN245@test_inser
  0088c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00893	75 24		 jne	 SHORT $LN243@test_inser
  00895	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0089b	6a 00		 push	 0
  0089d	52		 push	 edx
  0089e	53		 push	 ebx
  0089f	57		 push	 edi
  008a0	e8 00 00 00 00	 call	 __aulldiv
  008a5	50		 push	 eax
  008a6	68 00 00 00 00	 push	 OFFSET $SG-102
  008ab	e8 00 00 00 00	 call	 _printf
  008b0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  008b6	83 c4 08	 add	 esp, 8
$LN243@test_inser:
  008b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  008be	6a 00		 push	 0
  008c0	50		 push	 eax
  008c1	53		 push	 ebx
  008c2	57		 push	 edi
  008c3	e8 00 00 00 00	 call	 __aulldiv
  008c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  008ce	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  008d4	c1 e1 04	 shl	 ecx, 4
  008d7	03 ce		 add	 ecx, esi
  008d9	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  008dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  008e2	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  008e5	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  008e8	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN245@test_inser:

; 980  : 
; 981  : 	START(DATA_TRIE_INPLACE) {

  008ef	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 4 ; the_start_data
  008f9	83 fe 04	 cmp	 esi, 4
  008fc	0f 85 58 01 00
	00		 jne	 $LN97@test_inser
  00902	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00909	75 2f		 jne	 SHORT $LN252@test_inser
  0090b	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+16
  00911	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00916	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0091d	52		 push	 edx
  0091e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00924	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0092b	51		 push	 ecx
  0092c	50		 push	 eax
  0092d	68 00 00 00 00	 push	 OFFSET $SG-101
  00932	e8 00 00 00 00	 call	 _printf
  00937	83 c4 10	 add	 esp, 16			; 00000010H
$LN252@test_inser:
  0093a	8d 4d c4	 lea	 ecx, DWORD PTR _t$230870[ebp]
  0093d	51		 push	 ecx
  0093e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00944	85 c0		 test	 eax, eax
  00946	75 11		 jne	 SHORT $LN258@test_inser
  00948	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0094c	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230864[ebp], xmm0
  00951	8b 5d f8	 mov	 ebx, DWORD PTR $T230864[ebp+4]
  00954	8b 7d f4	 mov	 edi, DWORD PTR $T230864[ebp]
  00957	eb 54		 jmp	 SHORT $LN259@test_inser
$LN258@test_inser:
  00959	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  0095f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00965	8b 55 c8	 mov	 edx, DWORD PTR _t$230870[ebp+4]
  00968	8b 45 c4	 mov	 eax, DWORD PTR _t$230870[ebp]
  0096b	57		 push	 edi
  0096c	56		 push	 esi
  0096d	52		 push	 edx
  0096e	50		 push	 eax
  0096f	e8 00 00 00 00	 call	 __alldvrm
  00974	6a 00		 push	 0
  00976	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0097b	53		 push	 ebx
  0097c	51		 push	 ecx
  0097d	89 45 f4	 mov	 DWORD PTR tv1041[ebp], eax
  00980	89 55 f8	 mov	 DWORD PTR tv1041[ebp+4], edx
  00983	e8 00 00 00 00	 call	 __allmul
  00988	57		 push	 edi
  00989	56		 push	 esi
  0098a	52		 push	 edx
  0098b	50		 push	 eax
  0098c	e8 00 00 00 00	 call	 __alldiv
  00991	8b 4d f8	 mov	 ecx, DWORD PTR tv1041[ebp+4]
  00994	6a 00		 push	 0
  00996	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0099b	8b da		 mov	 ebx, edx
  0099d	8b 55 f4	 mov	 edx, DWORD PTR tv1041[ebp]
  009a0	51		 push	 ecx
  009a1	52		 push	 edx
  009a2	8b f8		 mov	 edi, eax
  009a4	e8 00 00 00 00	 call	 __allmul
  009a9	03 f8		 add	 edi, eax
  009ab	13 da		 adc	 ebx, edx
$LN259@test_inser:
  009ad	33 c9		 xor	 ecx, ecx
  009af	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  009b5	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  009bb	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
  009be	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ecx ; the_max
  009c4	0f 86 90 00 00
	00		 jbe	 $LN97@test_inser
  009ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?TRIE_INPLACE@@3PAUtrie_inplace_object@@A ; TRIE_INPLACE
  009cf	90		 npad	 1
$LL99@test_inser:

; 982  : 		unsigned key = INSERT[i];

  009d0	8b 55 08	 mov	 edx, DWORD PTR _INSERT$[ebp]
  009d3	8b 3c 8a	 mov	 edi, DWORD PTR [edx+ecx*4]

; 983  : 		TRIE_INPLACE[i].value = key;

  009d6	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 984  : 		tommy_trie_inplace_insert(&trie_inplace, &TRIE_INPLACE[i].node, &TRIE_INPLACE[i], key);

  009d9	8b cf		 mov	 ecx, edi
  009db	c1 e9 1a	 shr	 ecx, 26			; 0000001aH
  009de	89 40 08	 mov	 DWORD PTR [eax+8], eax
  009e1	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  009e4	66 0f ef c0	 pxor	 xmm0, xmm0
  009e8	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
  009ed	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A[ecx*4]
  009f4	66 0f d6 40 18	 movq	 QWORD PTR [eax+24], xmm0
  009f9	8b 13		 mov	 edx, DWORD PTR [ebx]
  009fb	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00a00	85 d2		 test	 edx, edx
  00a02	74 19		 je	 SHORT $LN1203@test_inser
$LN269@test_inser:
  00a04	39 7a 0c	 cmp	 DWORD PTR [edx+12], edi
  00a07	74 21		 je	 SHORT $LN267@test_inser
  00a09	8b f7		 mov	 esi, edi
  00a0b	d3 ee		 shr	 esi, cl
  00a0d	83 e9 02	 sub	 ecx, 2
  00a10	83 e6 03	 and	 esi, 3
  00a13	8d 5c b2 10	 lea	 ebx, DWORD PTR [edx+esi*4+16]
  00a17	8b 13		 mov	 edx, DWORD PTR [ebx]
  00a19	85 d2		 test	 edx, edx
  00a1b	75 e7		 jne	 SHORT $LN269@test_inser
$LN1203@test_inser:
  00a1d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00a20	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00a26	89 03		 mov	 DWORD PTR [ebx], eax
  00a28	eb 14		 jmp	 SHORT $LN274@test_inser
$LN267@test_inser:
  00a2a	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00a2d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00a30	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00a33	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00a36	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00a3c	89 02		 mov	 DWORD PTR [edx], eax
$LN274@test_inser:
  00a3e	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  00a41	ff 05 00 01 00
	00		 inc	 DWORD PTR ?trie_inplace@@3Utommy_trie_inplace_struct@@A+256
  00a47	41		 inc	 ecx
  00a48	83 c0 34	 add	 eax, 52			; 00000034H
  00a4b	89 4d e8	 mov	 DWORD PTR _i$[ebp], ecx
  00a4e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00a54	0f 82 76 ff ff
	ff		 jb	 $LL99@test_inser
$LN97@test_inser:

; 985  : 	} STOP();

  00a5a	8d 45 cc	 lea	 eax, DWORD PTR _t$230936[ebp]
  00a5d	50		 push	 eax
  00a5e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00a64	85 c0		 test	 eax, eax
  00a66	75 11		 jne	 SHORT $LN280@test_inser
  00a68	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00a6c	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230925[ebp], xmm0
  00a71	8b 5d f8	 mov	 ebx, DWORD PTR $T230925[ebp+4]
  00a74	8b 7d f4	 mov	 edi, DWORD PTR $T230925[ebp]
  00a77	eb 54		 jmp	 SHORT $LN281@test_inser
$LN280@test_inser:
  00a79	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00a7f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00a85	8b 4d d0	 mov	 ecx, DWORD PTR _t$230936[ebp+4]
  00a88	8b 55 cc	 mov	 edx, DWORD PTR _t$230936[ebp]
  00a8b	57		 push	 edi
  00a8c	56		 push	 esi
  00a8d	51		 push	 ecx
  00a8e	52		 push	 edx
  00a8f	e8 00 00 00 00	 call	 __alldvrm
  00a94	6a 00		 push	 0
  00a96	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00a9b	53		 push	 ebx
  00a9c	51		 push	 ecx
  00a9d	89 45 f4	 mov	 DWORD PTR tv3924[ebp], eax
  00aa0	89 55 f8	 mov	 DWORD PTR tv3924[ebp+4], edx
  00aa3	e8 00 00 00 00	 call	 __allmul
  00aa8	57		 push	 edi
  00aa9	56		 push	 esi
  00aaa	52		 push	 edx
  00aab	50		 push	 eax
  00aac	e8 00 00 00 00	 call	 __alldiv
  00ab1	8b 4d f4	 mov	 ecx, DWORD PTR tv3924[ebp]
  00ab4	6a 00		 push	 0
  00ab6	8b f8		 mov	 edi, eax
  00ab8	8b 45 f8	 mov	 eax, DWORD PTR tv3924[ebp+4]
  00abb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00ac0	50		 push	 eax
  00ac1	51		 push	 ecx
  00ac2	8b da		 mov	 ebx, edx
  00ac4	e8 00 00 00 00	 call	 __allmul
  00ac9	03 f8		 add	 edi, eax
  00acb	13 da		 adc	 ebx, edx
$LN281@test_inser:
  00acd	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00ad3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00ad9	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00adf	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00ae5	75 63		 jne	 SHORT $LN278@test_inser
  00ae7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00aee	75 24		 jne	 SHORT $LN276@test_inser
  00af0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00af6	6a 00		 push	 0
  00af8	52		 push	 edx
  00af9	53		 push	 ebx
  00afa	57		 push	 edi
  00afb	e8 00 00 00 00	 call	 __aulldiv
  00b00	50		 push	 eax
  00b01	68 00 00 00 00	 push	 OFFSET $SG-102
  00b06	e8 00 00 00 00	 call	 _printf
  00b0b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00b11	83 c4 08	 add	 esp, 8
$LN276@test_inser:
  00b14	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00b19	6a 00		 push	 0
  00b1b	50		 push	 eax
  00b1c	53		 push	 ebx
  00b1d	57		 push	 edi
  00b1e	e8 00 00 00 00	 call	 __aulldiv
  00b23	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00b29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00b2f	c1 e1 04	 shl	 ecx, 4
  00b32	03 ce		 add	 ecx, esi
  00b34	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00b37	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00b3d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00b40	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00b43	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN278@test_inser:

; 986  : 
; 987  : 	/* for khash we hash the key because internally khash doesn't use any hash for integer keys */
; 988  : 	START(DATA_KHASH) {

  00b4a	c7 05 00 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 7 ; the_start_data
  00b54	83 fe 07	 cmp	 esi, 7
  00b57	0f 85 46 01 00
	00		 jne	 $LN93@test_inser
  00b5d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00b64	75 2f		 jne	 SHORT $LN285@test_inser
  00b66	8b 15 1c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+28
  00b6c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00b71	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00b78	52		 push	 edx
  00b79	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00b7f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00b86	51		 push	 ecx
  00b87	50		 push	 eax
  00b88	68 00 00 00 00	 push	 OFFSET $SG-101
  00b8d	e8 00 00 00 00	 call	 _printf
  00b92	83 c4 10	 add	 esp, 16			; 00000010H
$LN285@test_inser:
  00b95	8d 4d bc	 lea	 ecx, DWORD PTR _t$230960[ebp]
  00b98	51		 push	 ecx
  00b99	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00b9f	85 c0		 test	 eax, eax
  00ba1	75 11		 jne	 SHORT $LN291@test_inser
  00ba3	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ba7	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230951[ebp], xmm0
  00bac	8b 5d f8	 mov	 ebx, DWORD PTR $T230951[ebp+4]
  00baf	8b 7d f4	 mov	 edi, DWORD PTR $T230951[ebp]
  00bb2	eb 54		 jmp	 SHORT $LN292@test_inser
$LN291@test_inser:
  00bb4	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00bba	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00bc0	8b 55 c0	 mov	 edx, DWORD PTR _t$230960[ebp+4]
  00bc3	8b 45 bc	 mov	 eax, DWORD PTR _t$230960[ebp]
  00bc6	57		 push	 edi
  00bc7	56		 push	 esi
  00bc8	52		 push	 edx
  00bc9	50		 push	 eax
  00bca	e8 00 00 00 00	 call	 __alldvrm
  00bcf	6a 00		 push	 0
  00bd1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00bd6	53		 push	 ebx
  00bd7	51		 push	 ecx
  00bd8	89 45 f4	 mov	 DWORD PTR tv1114[ebp], eax
  00bdb	89 55 f8	 mov	 DWORD PTR tv1114[ebp+4], edx
  00bde	e8 00 00 00 00	 call	 __allmul
  00be3	57		 push	 edi
  00be4	56		 push	 esi
  00be5	52		 push	 edx
  00be6	50		 push	 eax
  00be7	e8 00 00 00 00	 call	 __alldiv
  00bec	8b 4d f8	 mov	 ecx, DWORD PTR tv1114[ebp+4]
  00bef	6a 00		 push	 0
  00bf1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00bf6	8b da		 mov	 ebx, edx
  00bf8	8b 55 f4	 mov	 edx, DWORD PTR tv1114[ebp]
  00bfb	51		 push	 ecx
  00bfc	52		 push	 edx
  00bfd	8b f8		 mov	 edi, eax
  00bff	e8 00 00 00 00	 call	 __allmul
  00c04	03 f8		 add	 edi, eax
  00c06	13 da		 adc	 ebx, edx
$LN292@test_inser:
  00c08	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00c0e	33 ff		 xor	 edi, edi
  00c10	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00c16	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  00c1c	0f 86 81 00 00
	00		 jbe	 $LN93@test_inser
  00c22	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  00c28	33 db		 xor	 ebx, ebx
$LN95@test_inser:

; 989  : 		unsigned key = INSERT[i];

  00c2a	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00c2d	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]

; 990  : 		unsigned hash_key = hash(key);

  00c30	8b f1		 mov	 esi, ecx
  00c32	c1 e6 06	 shl	 esi, 6
  00c35	8b c1		 mov	 eax, ecx
  00c37	2b c6		 sub	 eax, esi
  00c39	8b f0		 mov	 esi, eax
  00c3b	c1 ee 11	 shr	 esi, 17			; 00000011H
  00c3e	33 c6		 xor	 eax, esi
  00c40	8b f0		 mov	 esi, eax
  00c42	c1 e6 09	 shl	 esi, 9
  00c45	2b c6		 sub	 eax, esi
  00c47	8b f0		 mov	 esi, eax
  00c49	c1 e6 04	 shl	 esi, 4
  00c4c	33 c6		 xor	 eax, esi
  00c4e	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  00c55	2b c6		 sub	 eax, esi
  00c57	8b f0		 mov	 esi, eax

; 991  : 		khiter_t k;
; 992  : 		int r;
; 993  : 		KHASH[i].value = key;

  00c59	89 0c 13	 mov	 DWORD PTR [ebx+edx], ecx
  00c5c	c1 e6 0a	 shl	 esi, 10			; 0000000aH
  00c5f	33 c6		 xor	 eax, esi
  00c61	8b d0		 mov	 edx, eax

; 994  : 		k = kh_put(word, khash, hash_key, &r);

  00c63	8d 4d c8	 lea	 ecx, DWORD PTR _r$150587[ebp]
  00c66	c1 ea 0f	 shr	 edx, 15			; 0000000fH
  00c69	51		 push	 ecx
  00c6a	33 d0		 xor	 edx, eax
  00c6c	52		 push	 edx
  00c6d	e8 00 00 00 00	 call	 ?kh_put_word@@YAIPAUkh_word_t@@IPAH@Z ; kh_put_word
  00c72	83 c4 08	 add	 esp, 8

; 995  : 		if (!r)

  00c75	83 7d c8 00	 cmp	 DWORD PTR _r$150587[ebp], 0
  00c79	8b f0		 mov	 esi, eax
  00c7b	75 05		 jne	 SHORT $LN92@test_inser

; 996  : 			abort();

  00c7d	e8 00 00 00 00	 call	 _abort
$LN92@test_inser:

; 997  : 		kh_value(khash, k) = &KHASH[i];

  00c82	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?KHASH@@3PAUkhash_object@@A ; KHASH
  00c88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?khash@@3PAUkh_word_t@@A ; khash
  00c8e	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00c91	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  00c94	47		 inc	 edi
  00c95	83 c3 14	 add	 ebx, 20			; 00000014H
  00c98	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax
  00c9b	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  00ca1	72 87		 jb	 SHORT $LN95@test_inser
$LN93@test_inser:

; 998  : 	} STOP();

  00ca3	8d 55 b4	 lea	 edx, DWORD PTR _t$230986[ebp]
  00ca6	52		 push	 edx
  00ca7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00cad	85 c0		 test	 eax, eax
  00caf	75 11		 jne	 SHORT $LN300@test_inser
  00cb1	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00cb5	66 0f 13 45 f4	 movlpd	 QWORD PTR $T230975[ebp], xmm0
  00cba	8b 5d f8	 mov	 ebx, DWORD PTR $T230975[ebp+4]
  00cbd	8b 7d f4	 mov	 edi, DWORD PTR $T230975[ebp]
  00cc0	eb 54		 jmp	 SHORT $LN301@test_inser
$LN300@test_inser:
  00cc2	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00cc8	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00cce	8b 45 b8	 mov	 eax, DWORD PTR _t$230986[ebp+4]
  00cd1	8b 4d b4	 mov	 ecx, DWORD PTR _t$230986[ebp]
  00cd4	57		 push	 edi
  00cd5	56		 push	 esi
  00cd6	50		 push	 eax
  00cd7	51		 push	 ecx
  00cd8	e8 00 00 00 00	 call	 __alldvrm
  00cdd	6a 00		 push	 0
  00cdf	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00ce4	53		 push	 ebx
  00ce5	51		 push	 ecx
  00ce6	89 45 f4	 mov	 DWORD PTR tv181[ebp], eax
  00ce9	89 55 f8	 mov	 DWORD PTR tv181[ebp+4], edx
  00cec	e8 00 00 00 00	 call	 __allmul
  00cf1	57		 push	 edi
  00cf2	56		 push	 esi
  00cf3	52		 push	 edx
  00cf4	50		 push	 eax
  00cf5	e8 00 00 00 00	 call	 __alldiv
  00cfa	6a 00		 push	 0
  00cfc	8b da		 mov	 ebx, edx
  00cfe	8b 55 f8	 mov	 edx, DWORD PTR tv181[ebp+4]
  00d01	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00d06	8b f8		 mov	 edi, eax
  00d08	8b 45 f4	 mov	 eax, DWORD PTR tv181[ebp]
  00d0b	52		 push	 edx
  00d0c	50		 push	 eax
  00d0d	e8 00 00 00 00	 call	 __allmul
  00d12	03 f8		 add	 edi, eax
  00d14	13 da		 adc	 ebx, edx
$LN301@test_inser:
  00d16	2b 3d 00 00 00
	00		 sub	 edi, DWORD PTR ?the_time@@3_KA
  00d1c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00d22	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  00d28	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  00d2e	75 64		 jne	 SHORT $LN298@test_inser
  00d30	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00d37	75 24		 jne	 SHORT $LN296@test_inser
  00d39	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00d3f	6a 00		 push	 0
  00d41	51		 push	 ecx
  00d42	53		 push	 ebx
  00d43	57		 push	 edi
  00d44	e8 00 00 00 00	 call	 __aulldiv
  00d49	50		 push	 eax
  00d4a	68 00 00 00 00	 push	 OFFSET $SG-102
  00d4f	e8 00 00 00 00	 call	 _printf
  00d54	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?the_data@@3IA ; the_data
  00d5a	83 c4 08	 add	 esp, 8
$LN296@test_inser:
  00d5d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  00d63	6a 00		 push	 0
  00d65	52		 push	 edx
  00d66	53		 push	 ebx
  00d67	57		 push	 edi
  00d68	e8 00 00 00 00	 call	 __aulldiv
  00d6d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  00d73	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00d79	c1 e1 04	 shl	 ecx, 4
  00d7c	03 ce		 add	 ecx, esi
  00d7e	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d81	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  00d87	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  00d8a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  00d8d	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN298@test_inser:

; 999  : 
; 1000 : #ifdef USE_CGOOGLEDENSEHASH
; 1001 : 	START(DATA_CGOOGLE) {
; 1002 : 		unsigned key = INSERT[i];
; 1003 : 		HTItem* r;
; 1004 : 		u_long ptr_value = (u_long)&GOOGLE[i];
; 1005 : 		GOOGLE[i].value = key;
; 1006 : 		r = HashInsert(cgoogledensehash, key, ptr_value);
; 1007 : 		if (!r)
; 1008 : 			abort();
; 1009 : 	} STOP();
; 1010 : #endif
; 1011 : 
; 1012 : #ifdef USE_GOOGLEDENSEHASH
; 1013 : 	START(DATA_GOOGLEDENSEHASH) {

  00d94	c7 05 00 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 11 ; the_start_data, 0000000bH
  00d9e	83 fe 0b	 cmp	 esi, 11			; 0000000bH
  00da1	0f 85 39 02 00
	00		 jne	 $LN88@test_inser
  00da7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  00dae	75 2f		 jne	 SHORT $LN305@test_inser
  00db0	8b 15 2c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+44
  00db6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  00dbb	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00dc2	52		 push	 edx
  00dc3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00dc9	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  00dd0	51		 push	 ecx
  00dd1	50		 push	 eax
  00dd2	68 00 00 00 00	 push	 OFFSET $SG-101
  00dd7	e8 00 00 00 00	 call	 _printf
  00ddc	83 c4 10	 add	 esp, 16			; 00000010H
$LN305@test_inser:
  00ddf	8d 4d d4	 lea	 ecx, DWORD PTR _t$231010[ebp]
  00de2	51		 push	 ecx
  00de3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00de9	85 c0		 test	 eax, eax
  00deb	75 11		 jne	 SHORT $LN311@test_inser
  00ded	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00df1	66 0f 13 45 f4	 movlpd	 QWORD PTR $T231001[ebp], xmm0
  00df6	8b 5d f8	 mov	 ebx, DWORD PTR $T231001[ebp+4]
  00df9	8b 7d f4	 mov	 edi, DWORD PTR $T231001[ebp]
  00dfc	eb 54		 jmp	 SHORT $LN312@test_inser
$LN311@test_inser:
  00dfe	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR _win_frequency+4
  00e04	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _win_frequency
  00e0a	8b 55 d8	 mov	 edx, DWORD PTR _t$231010[ebp+4]
  00e0d	8b 45 d4	 mov	 eax, DWORD PTR _t$231010[ebp]
  00e10	57		 push	 edi
  00e11	56		 push	 esi
  00e12	52		 push	 edx
  00e13	50		 push	 eax
  00e14	e8 00 00 00 00	 call	 __alldvrm
  00e19	6a 00		 push	 0
  00e1b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e20	53		 push	 ebx
  00e21	51		 push	 ecx
  00e22	89 45 f4	 mov	 DWORD PTR tv3891[ebp], eax
  00e25	89 55 f8	 mov	 DWORD PTR tv3891[ebp+4], edx
  00e28	e8 00 00 00 00	 call	 __allmul
  00e2d	57		 push	 edi
  00e2e	56		 push	 esi
  00e2f	52		 push	 edx
  00e30	50		 push	 eax
  00e31	e8 00 00 00 00	 call	 __alldiv
  00e36	8b 4d f8	 mov	 ecx, DWORD PTR tv3891[ebp+4]
  00e39	6a 00		 push	 0
  00e3b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  00e40	8b da		 mov	 ebx, edx
  00e42	8b 55 f4	 mov	 edx, DWORD PTR tv3891[ebp]
  00e45	51		 push	 ecx
  00e46	52		 push	 edx
  00e47	8b f8		 mov	 edi, eax
  00e49	e8 00 00 00 00	 call	 __allmul
  00e4e	03 f8		 add	 edi, eax
  00e50	13 da		 adc	 ebx, edx
$LN312@test_inser:
  00e52	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  00e59	89 3d 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, edi
  00e5f	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  00e65	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e6c	0f 86 6e 01 00
	00		 jbe	 $LN88@test_inser
  00e72	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
  00e78	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv7047[ebp], 0
  00e7f	90		 npad	 1
$LL90@test_inser:

; 1014 : 		unsigned key = INSERT[i];

  00e80	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  00e83	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  00e86	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]

; 1015 : 		struct google_object* obj = &GOOGLE[i];

  00e89	8b 45 e4	 mov	 eax, DWORD PTR tv7047[ebp]
  00e8c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE

; 1016 : 		GOOGLE[i].value = key;
; 1017 : 		(*googledensehash)[key] = obj;

  00e92	8d 4d ec	 lea	 ecx, DWORD PTR _pos$233988[ebp]
  00e95	89 45 c0	 mov	 DWORD PTR tv7059[ebp], eax
  00e98	89 30		 mov	 DWORD PTR [eax], esi
  00e9a	51		 push	 ecx
  00e9b	8d 45 c8	 lea	 eax, DWORD PTR _key$150593[ebp]
  00e9e	89 75 c8	 mov	 DWORD PTR _key$150593[ebp], esi
  00ea1	8b df		 mov	 ebx, edi
  00ea3	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00ea8	8b 45 ec	 mov	 eax, DWORD PTR _pos$233988[ebp]
  00eab	83 f8 ff	 cmp	 eax, -1
  00eae	74 0b		 je	 SHORT $LN319@test_inser
  00eb0	8b 57 34	 mov	 edx, DWORD PTR [edi+52]
  00eb3	8d 1c c2	 lea	 ebx, DWORD PTR [edx+eax*8]
  00eb6	e9 08 01 00 00	 jmp	 $LN316@test_inser
$LN319@test_inser:
  00ebb	57		 push	 edi
  00ebc	b8 01 00 00 00	 mov	 eax, 1
  00ec1	e8 00 00 00 00	 call	 ?resize_delta@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@AAE_NI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::resize_delta
  00ec6	84 c0		 test	 al, al
  00ec8	0f 84 a1 00 00
	00		 je	 $LN317@test_inser
  00ece	8d 45 dc	 lea	 eax, DWORD PTR _pos$234078[ebp]
  00ed1	50		 push	 eax
  00ed2	8d 45 c8	 lea	 eax, DWORD PTR $T234260[ebp]
  00ed5	8b fb		 mov	 edi, ebx
  00ed7	89 75 c8	 mov	 DWORD PTR $T234260[ebp], esi
  00eda	e8 00 00 00 00	 call	 ?find_position@?$dense_hashtable@U?$pair@$$CBIPAUgoogle_object@@@std@@IVcpp_tommy_inthash_u32@@USelectKey@?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@USetKey@56@U?$equal_to@I@2@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@6@@google@@ABE?AU?$pair@II@std@@ABI@Z ; google::dense_hashtable<std::pair<unsigned int const ,google_object *>,unsigned int,cpp_tommy_inthash_u32,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SelectKey,google::dense_hash_map<unsigned int,google_object *,cpp_tommy_inthash_u32,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::SetKey,std::equal_to<unsigned int>,google::libc_allocator_with_realloc<std::pair<unsigned int const ,google_object *> > >::find_position
  00edf	8b 4d dc	 mov	 ecx, DWORD PTR _pos$234078[ebp]
  00ee2	83 f9 ff	 cmp	 ecx, -1
  00ee5	74 13		 je	 SHORT $LN353@test_inser
  00ee7	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00eea	8d 0c c8	 lea	 ecx, DWORD PTR [eax+ecx*8]
  00eed	89 5d 84	 mov	 DWORD PTR $T234269[ebp], ebx
  00ef0	89 4d 88	 mov	 DWORD PTR $T234269[ebp+4], ecx
  00ef3	f3 0f 7e 45 84	 movq	 xmm0, QWORD PTR $T234269[ebp]
  00ef8	eb 62		 jmp	 SHORT $LN1269@test_inser
$LN353@test_inser:
  00efa	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00efd	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00f00	2b c8		 sub	 ecx, eax
  00f02	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00f08	0f 83 f4 00 00
	00		 jae	 $LN1170@test_inser
  00f0e	8b 4d e0	 mov	 ecx, DWORD PTR _pos$234078[ebp+4]
  00f11	85 c0		 test	 eax, eax
  00f13	74 11		 je	 SHORT $LN425@test_inser
  00f15	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00f18	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00f1b	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00f1e	75 06		 jne	 SHORT $LN425@test_inser
  00f20	48		 dec	 eax
  00f21	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00f24	eb 07		 jmp	 SHORT $LN424@test_inser
$LN425@test_inser:
  00f26	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00f29	40		 inc	 eax
  00f2a	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN424@test_inser:
  00f2d	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00f30	03 c9		 add	 ecx, ecx
  00f32	03 c9		 add	 ecx, ecx
  00f34	03 c9		 add	 ecx, ecx
  00f36	03 c1		 add	 eax, ecx
  00f38	74 09		 je	 SHORT $LN511@test_inser
  00f3a	89 30		 mov	 DWORD PTR [eax], esi
  00f3c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN511@test_inser:
  00f43	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00f46	03 c8		 add	 ecx, eax
  00f48	89 9d 78 ff ff
	ff		 mov	 DWORD PTR $T234277[ebp], ebx
  00f4e	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T234277[ebp+4], ecx
  00f54	f3 0f 7e 85 78
	ff ff ff	 movq	 xmm0, QWORD PTR $T234277[ebp]
$LN1269@test_inser:
  00f5c	8b 53 28	 mov	 edx, DWORD PTR [ebx+40]
  00f5f	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
  00f62	66 0f d6 45 a4	 movq	 QWORD PTR $T233995[ebp], xmm0
  00f67	8b 5d a8	 mov	 ebx, DWORD PTR $T233995[ebp+4]
  00f6a	89 45 ac	 mov	 DWORD PTR $T233995[ebp+8], eax
  00f6d	eb 4e		 jmp	 SHORT $LN1270@test_inser
$LN317@test_inser:
  00f6f	8b 4b 24	 mov	 ecx, DWORD PTR [ebx+36]
  00f72	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  00f75	2b c8		 sub	 ecx, eax
  00f77	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00f7d	0f 83 b0 00 00
	00		 jae	 $LN1171@test_inser
  00f83	8b 4d f0	 mov	 ecx, DWORD PTR _pos$233988[ebp+4]
  00f86	85 c0		 test	 eax, eax
  00f88	74 11		 je	 SHORT $LN616@test_inser
  00f8a	8b 53 34	 mov	 edx, DWORD PTR [ebx+52]
  00f8d	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00f90	3b 3c ca	 cmp	 edi, DWORD PTR [edx+ecx*8]
  00f93	75 06		 jne	 SHORT $LN616@test_inser
  00f95	48		 dec	 eax
  00f96	89 43 20	 mov	 DWORD PTR [ebx+32], eax
  00f99	eb 07		 jmp	 SHORT $LN615@test_inser
$LN616@test_inser:
  00f9b	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00f9e	40		 inc	 eax
  00f9f	89 43 24	 mov	 DWORD PTR [ebx+36], eax
$LN615@test_inser:
  00fa2	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00fa5	03 c9		 add	 ecx, ecx
  00fa7	03 c9		 add	 ecx, ecx
  00fa9	03 c9		 add	 ecx, ecx
  00fab	03 c1		 add	 eax, ecx
  00fad	74 09		 je	 SHORT $LN702@test_inser
  00faf	89 30		 mov	 DWORD PTR [eax], esi
  00fb1	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN702@test_inser:
  00fb8	8b 5b 34	 mov	 ebx, DWORD PTR [ebx+52]
  00fbb	03 d9		 add	 ebx, ecx
$LN1270@test_inser:
  00fbd	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googledensehash@@3PAV?$dense_hash_map@IPAUgoogle_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$libc_allocator_with_realloc@U?$pair@$$CBIPAUgoogle_object@@@std@@@google@@@google@@A ; googledensehash
$LN316@test_inser:
  00fc3	8b 45 c0	 mov	 eax, DWORD PTR tv7059[ebp]
  00fc6	83 45 e4 14	 add	 DWORD PTR tv7047[ebp], 20 ; 00000014H
  00fca	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00fcd	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  00fd0	40		 inc	 eax
  00fd1	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  00fd4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  00fda	0f 82 a0 fe ff
	ff		 jb	 $LL90@test_inser
$LN88@test_inser:

; 1018 : 	} STOP();

  00fe0	8d 55 dc	 lea	 edx, DWORD PTR _t$234426[ebp]
  00fe3	52		 push	 edx
  00fe4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  00fea	85 c0		 test	 eax, eax
  00fec	75 6d		 jne	 SHORT $LN768@test_inser
  00fee	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00ff2	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234415[ebp], xmm0
  00ff7	8b 7d f0	 mov	 edi, DWORD PTR $T234415[ebp+4]
  00ffa	8b 75 ec	 mov	 esi, DWORD PTR $T234415[ebp]
  00ffd	e9 ad 00 00 00	 jmp	 $LN769@test_inser
$LN1170@test_inser:

; 1016 : 		GOOGLE[i].value = key;
; 1017 : 		(*googledensehash)[key] = obj;

  01002	8d 4d d0	 lea	 ecx, DWORD PTR $T231470[ebp]
  01005	51		 push	 ecx
  01006	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T234086[ebp]
  0100c	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T231470[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  01013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  01018	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0101d	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR $T234086[ebp]
  01023	52		 push	 edx
  01024	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T234086[ebp], OFFSET ??_7length_error@std@@6B@
  0102e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1271@test_inser:
$LN1171@test_inser:
  01033	8d 45 f8	 lea	 eax, DWORD PTR $T232664[ebp]
  01036	50		 push	 eax
  01037	8d 4d 90	 lea	 ecx, DWORD PTR $T234033[ebp]
  0103a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T232664[ebp], OFFSET ??_C@_0BA@CGMABIOM@insert?5overflow?$AA@
  01041	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  01046	68 00 00 00 00	 push	 OFFSET __TI3?AVlength_error@std@@
  0104b	8d 4d 90	 lea	 ecx, DWORD PTR $T234033[ebp]
  0104e	51		 push	 ecx
  0104f	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T234033[ebp], OFFSET ??_7length_error@std@@6B@
  01056	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1272@test_inser:

; 1018 : 	} STOP();

$LN768@test_inser:
  0105b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01061	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01067	8b 45 e0	 mov	 eax, DWORD PTR _t$234426[ebp+4]
  0106a	8b 4d dc	 mov	 ecx, DWORD PTR _t$234426[ebp]
  0106d	56		 push	 esi
  0106e	57		 push	 edi
  0106f	50		 push	 eax
  01070	51		 push	 ecx
  01071	e8 00 00 00 00	 call	 __alldvrm
  01076	6a 00		 push	 0
  01078	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0107d	53		 push	 ebx
  0107e	51		 push	 ecx
  0107f	89 45 f4	 mov	 DWORD PTR tv1300[ebp], eax
  01082	89 55 f8	 mov	 DWORD PTR tv1300[ebp+4], edx
  01085	e8 00 00 00 00	 call	 __allmul
  0108a	56		 push	 esi
  0108b	57		 push	 edi
  0108c	52		 push	 edx
  0108d	50		 push	 eax
  0108e	e8 00 00 00 00	 call	 __alldiv
  01093	6a 00		 push	 0
  01095	8b fa		 mov	 edi, edx
  01097	8b 55 f8	 mov	 edx, DWORD PTR tv1300[ebp+4]
  0109a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0109f	8b f0		 mov	 esi, eax
  010a1	8b 45 f4	 mov	 eax, DWORD PTR tv1300[ebp]
  010a4	52		 push	 edx
  010a5	50		 push	 eax
  010a6	e8 00 00 00 00	 call	 __allmul
  010ab	03 f0		 add	 esi, eax
  010ad	13 fa		 adc	 edi, edx
$LN769@test_inser:
  010af	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  010b5	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  010bb	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  010c1	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  010c7	75 64		 jne	 SHORT $LN766@test_inser
  010c9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  010d0	75 24		 jne	 SHORT $LN764@test_inser
  010d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  010d8	6a 00		 push	 0
  010da	51		 push	 ecx
  010db	57		 push	 edi
  010dc	56		 push	 esi
  010dd	e8 00 00 00 00	 call	 __aulldiv
  010e2	50		 push	 eax
  010e3	68 00 00 00 00	 push	 OFFSET $SG-102
  010e8	e8 00 00 00 00	 call	 _printf
  010ed	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  010f3	83 c4 08	 add	 esp, 8
$LN764@test_inser:
  010f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  010fc	6a 00		 push	 0
  010fe	52		 push	 edx
  010ff	57		 push	 edi
  01100	56		 push	 esi
  01101	e8 00 00 00 00	 call	 __aulldiv
  01106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0110c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01112	c1 e1 04	 shl	 ecx, 4
  01115	03 cb		 add	 ecx, ebx
  01117	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0111a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01120	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01123	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01126	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN766@test_inser:

; 1019 : #endif
; 1020 : 
; 1021 : #ifdef USE_GOOGLEBTREE
; 1022 : 	START(DATA_GOOGLEBTREE) {

  0112d	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 12 ; the_start_data, 0000000cH
  01137	83 fb 0c	 cmp	 ebx, 12			; 0000000cH
  0113a	0f 85 09 01 00
	00		 jne	 $LN84@test_inser
  01140	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01147	75 2f		 jne	 SHORT $LN773@test_inser
  01149	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+48
  0114f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01154	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0115b	52		 push	 edx
  0115c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01162	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01169	51		 push	 ecx
  0116a	50		 push	 eax
  0116b	68 00 00 00 00	 push	 OFFSET $SG-101
  01170	e8 00 00 00 00	 call	 _printf
  01175	83 c4 10	 add	 esp, 16			; 00000010H
$LN773@test_inser:
  01178	8d 4d d4	 lea	 ecx, DWORD PTR _t$234450[ebp]
  0117b	51		 push	 ecx
  0117c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01182	85 c0		 test	 eax, eax
  01184	75 11		 jne	 SHORT $LN779@test_inser
  01186	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0118a	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234441[ebp], xmm0
  0118f	8b 7d f0	 mov	 edi, DWORD PTR $T234441[ebp+4]
  01192	8b 75 ec	 mov	 esi, DWORD PTR $T234441[ebp]
  01195	eb 54		 jmp	 SHORT $LN780@test_inser
$LN779@test_inser:
  01197	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0119d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  011a3	8b 55 d8	 mov	 edx, DWORD PTR _t$234450[ebp+4]
  011a6	8b 45 d4	 mov	 eax, DWORD PTR _t$234450[ebp]
  011a9	56		 push	 esi
  011aa	57		 push	 edi
  011ab	52		 push	 edx
  011ac	50		 push	 eax
  011ad	e8 00 00 00 00	 call	 __alldvrm
  011b2	6a 00		 push	 0
  011b4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  011b9	53		 push	 ebx
  011ba	51		 push	 ecx
  011bb	89 45 f4	 mov	 DWORD PTR tv1326[ebp], eax
  011be	89 55 f8	 mov	 DWORD PTR tv1326[ebp+4], edx
  011c1	e8 00 00 00 00	 call	 __allmul
  011c6	56		 push	 esi
  011c7	57		 push	 edi
  011c8	52		 push	 edx
  011c9	50		 push	 eax
  011ca	e8 00 00 00 00	 call	 __alldiv
  011cf	8b 4d f8	 mov	 ecx, DWORD PTR tv1326[ebp+4]
  011d2	6a 00		 push	 0
  011d4	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  011d9	8b fa		 mov	 edi, edx
  011db	8b 55 f4	 mov	 edx, DWORD PTR tv1326[ebp]
  011de	51		 push	 ecx
  011df	52		 push	 edx
  011e0	8b f0		 mov	 esi, eax
  011e2	e8 00 00 00 00	 call	 __allmul
  011e7	03 f0		 add	 esi, eax
  011e9	13 fa		 adc	 edi, edx
$LN780@test_inser:
  011eb	33 db		 xor	 ebx, ebx
  011ed	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  011f3	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  011f9	39 1d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, ebx ; the_max
  011ff	76 48		 jbe	 SHORT $LN84@test_inser
  01201	89 5d e4	 mov	 DWORD PTR tv7076[ebp], ebx
$LN86@test_inser:

; 1023 : 		unsigned key = INSERT[i];
; 1024 : 		struct google_object* obj = &GOOGLE[i];

  01204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GOOGLE@@3PAUgoogle_object@@A ; GOOGLE
  0120a	03 4d e4	 add	 ecx, DWORD PTR tv7076[ebp]
  0120d	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  01210	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]

; 1025 : 		GOOGLE[i].value = key;
; 1026 : 		(*googlebtree)[key] = obj;

  01213	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?googlebtree@@3PAV?$btree_map@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@A ; googlebtree
  01219	89 45 e8	 mov	 DWORD PTR _key$150599[ebp], eax
  0121c	89 01		 mov	 DWORD PTR [ecx], eax
  0121e	8d 45 e8	 lea	 eax, DWORD PTR _key$150599[ebp]
  01221	89 4d f8	 mov	 DWORD PTR tv7088[ebp], ecx
  01224	50		 push	 eax
  01225	8b c8		 mov	 ecx, eax
  01227	51		 push	 ecx
  01228	8d 75 90	 lea	 esi, DWORD PTR $T234472[ebp]
  0122b	e8 00 00 00 00	 call	 ??$insert_unique@Ugenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@btree@@@?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@QAE?AU?$pair@U?$btree_iterator@V?$btree_node@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@btree@@@btree@@AAU?$pair@$$CBIPAUgoogle_object@@@std@@PAU34@@btree@@_N@std@@ABIUgenerate_value@?$btree_map_container@V?$btree@U?$btree_map_params@IPAUgoogle_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUgoogle_object@@@std@@@3@$0BAA@@0@@btree@@@1@@Z ; btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> >::insert_unique<btree::btree_map_container<btree::btree<btree::btree_map_params<unsigned int,google_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,google_object *> >,256> > >::generate_value>
  01230	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  01233	8b 00		 mov	 eax, DWORD PTR [eax]
  01235	8b 4d f8	 mov	 ecx, DWORD PTR tv7088[ebp]
  01238	83 45 e4 14	 add	 DWORD PTR tv7076[ebp], 20 ; 00000014H
  0123c	43		 inc	 ebx
  0123d	89 4c d0 0c	 mov	 DWORD PTR [eax+edx*8+12], ecx
  01241	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01247	72 bb		 jb	 SHORT $LN86@test_inser
$LN84@test_inser:

; 1027 : 	} STOP();

  01249	8d 55 dc	 lea	 edx, DWORD PTR _t$234498[ebp]
  0124c	52		 push	 edx
  0124d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01253	85 c0		 test	 eax, eax
  01255	75 11		 jne	 SHORT $LN794@test_inser
  01257	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0125b	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234487[ebp], xmm0
  01260	8b 7d f0	 mov	 edi, DWORD PTR $T234487[ebp+4]
  01263	8b 75 ec	 mov	 esi, DWORD PTR $T234487[ebp]
  01266	eb 54		 jmp	 SHORT $LN795@test_inser
$LN794@test_inser:
  01268	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  0126e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01274	8b 45 e0	 mov	 eax, DWORD PTR _t$234498[ebp+4]
  01277	8b 4d dc	 mov	 ecx, DWORD PTR _t$234498[ebp]
  0127a	56		 push	 esi
  0127b	57		 push	 edi
  0127c	50		 push	 eax
  0127d	51		 push	 ecx
  0127e	e8 00 00 00 00	 call	 __alldvrm
  01283	6a 00		 push	 0
  01285	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0128a	53		 push	 ebx
  0128b	51		 push	 ecx
  0128c	89 45 f4	 mov	 DWORD PTR tv215[ebp], eax
  0128f	89 55 f8	 mov	 DWORD PTR tv215[ebp+4], edx
  01292	e8 00 00 00 00	 call	 __allmul
  01297	56		 push	 esi
  01298	57		 push	 edi
  01299	52		 push	 edx
  0129a	50		 push	 eax
  0129b	e8 00 00 00 00	 call	 __alldiv
  012a0	6a 00		 push	 0
  012a2	8b fa		 mov	 edi, edx
  012a4	8b 55 f8	 mov	 edx, DWORD PTR tv215[ebp+4]
  012a7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  012ac	8b f0		 mov	 esi, eax
  012ae	8b 45 f4	 mov	 eax, DWORD PTR tv215[ebp]
  012b1	52		 push	 edx
  012b2	50		 push	 eax
  012b3	e8 00 00 00 00	 call	 __allmul
  012b8	03 f0		 add	 esi, eax
  012ba	13 fa		 adc	 edi, edx
$LN795@test_inser:
  012bc	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  012c2	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  012c8	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  012ce	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  012d4	75 64		 jne	 SHORT $LN792@test_inser
  012d6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  012dd	75 24		 jne	 SHORT $LN790@test_inser
  012df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  012e5	6a 00		 push	 0
  012e7	51		 push	 ecx
  012e8	57		 push	 edi
  012e9	56		 push	 esi
  012ea	e8 00 00 00 00	 call	 __aulldiv
  012ef	50		 push	 eax
  012f0	68 00 00 00 00	 push	 OFFSET $SG-102
  012f5	e8 00 00 00 00	 call	 _printf
  012fa	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  01300	83 c4 08	 add	 esp, 8
$LN790@test_inser:
  01303	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01309	6a 00		 push	 0
  0130b	52		 push	 edx
  0130c	57		 push	 edi
  0130d	56		 push	 esi
  0130e	e8 00 00 00 00	 call	 __aulldiv
  01313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01319	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0131f	c1 e1 04	 shl	 ecx, 4
  01322	03 cb		 add	 ecx, ebx
  01324	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01327	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  0132d	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01330	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01333	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN792@test_inser:

; 1028 : #endif
; 1029 : 
; 1030 : #ifdef USE_STXBTREE
; 1031 : 	START(DATA_STXBTREE) {

  0133a	c7 05 00 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 13 ; the_start_data, 0000000dH
  01344	83 fb 0d	 cmp	 ebx, 13			; 0000000dH
  01347	0f 85 11 01 00
	00		 jne	 $LN80@test_inser
  0134d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01354	75 2f		 jne	 SHORT $LN799@test_inser
  01356	8b 15 34 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+52
  0135c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01361	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01368	52		 push	 edx
  01369	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0136f	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01376	51		 push	 ecx
  01377	50		 push	 eax
  01378	68 00 00 00 00	 push	 OFFSET $SG-101
  0137d	e8 00 00 00 00	 call	 _printf
  01382	83 c4 10	 add	 esp, 16			; 00000010H
$LN799@test_inser:
  01385	8d 4d d4	 lea	 ecx, DWORD PTR _t$234520[ebp]
  01388	51		 push	 ecx
  01389	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0138f	85 c0		 test	 eax, eax
  01391	75 11		 jne	 SHORT $LN805@test_inser
  01393	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01397	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234513[ebp], xmm0
  0139c	8b 7d f0	 mov	 edi, DWORD PTR $T234513[ebp+4]
  0139f	8b 75 ec	 mov	 esi, DWORD PTR $T234513[ebp]
  013a2	eb 54		 jmp	 SHORT $LN806@test_inser
$LN805@test_inser:
  013a4	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  013aa	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  013b0	8b 55 d8	 mov	 edx, DWORD PTR _t$234520[ebp+4]
  013b3	8b 45 d4	 mov	 eax, DWORD PTR _t$234520[ebp]
  013b6	56		 push	 esi
  013b7	57		 push	 edi
  013b8	52		 push	 edx
  013b9	50		 push	 eax
  013ba	e8 00 00 00 00	 call	 __alldvrm
  013bf	6a 00		 push	 0
  013c1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013c6	53		 push	 ebx
  013c7	51		 push	 ecx
  013c8	89 45 f4	 mov	 DWORD PTR tv3834[ebp], eax
  013cb	89 55 f8	 mov	 DWORD PTR tv3834[ebp+4], edx
  013ce	e8 00 00 00 00	 call	 __allmul
  013d3	56		 push	 esi
  013d4	57		 push	 edi
  013d5	52		 push	 edx
  013d6	50		 push	 eax
  013d7	e8 00 00 00 00	 call	 __alldiv
  013dc	8b 4d f8	 mov	 ecx, DWORD PTR tv3834[ebp+4]
  013df	6a 00		 push	 0
  013e1	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  013e6	8b fa		 mov	 edi, edx
  013e8	8b 55 f4	 mov	 edx, DWORD PTR tv3834[ebp]
  013eb	51		 push	 ecx
  013ec	52		 push	 edx
  013ed	8b f0		 mov	 esi, eax
  013ef	e8 00 00 00 00	 call	 __allmul
  013f4	03 f0		 add	 esi, eax
  013f6	13 fa		 adc	 edi, edx
$LN806@test_inser:
  013f8	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  013fe	33 ff		 xor	 edi, edi
  01400	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01406	39 3d 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, edi ; the_max
  0140c	76 50		 jbe	 SHORT $LN80@test_inser
  0140e	89 7d e4	 mov	 DWORD PTR tv7105[ebp], edi
$LN82@test_inser:

; 1032 : 		unsigned key = INSERT[i];
; 1033 : 		struct stx_object* obj = &STX[i];

  01411	8b 5d e4	 mov	 ebx, DWORD PTR tv7105[ebp]
  01414	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  01417	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0141a	03 1d 00 00 00
	00		 add	 ebx, DWORD PTR ?STX@@3PAUstx_object@@A ; STX

; 1034 : 		STX[i].value = key;
; 1035 : 		(*stxbtree)[key] = obj;

  01420	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?stxbtree@@3PAV?$btree_map@IPAUstx_object@@U?$less@I@std@@U?$btree_default_map_traits@IPAUstx_object@@@stx@@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@@stx@@A ; stxbtree
  01426	89 03		 mov	 DWORD PTR [ebx], eax
  01428	89 45 f4	 mov	 DWORD PTR $T234601[ebp], eax
  0142b	8d 45 f8	 lea	 eax, DWORD PTR $T234601[ebp+4]
  0142e	50		 push	 eax
  0142f	8d 4d f4	 lea	 ecx, DWORD PTR $T234601[ebp]
  01432	51		 push	 ecx
  01433	8d 55 a0	 lea	 edx, DWORD PTR $T234603[ebp]
  01436	52		 push	 edx
  01437	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T234601[ebp+4], 0
  0143e	e8 00 00 00 00	 call	 ?insert_start@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@AAE?AU?$pair@Viterator@?$btree@IPAUstx_object@@U?$pair@IPAUstx_object@@@std@@U?$less@I@3@U?$btree_default_map_traits@IPAUstx_object@@@stx@@$0A@V?$allocator@U?$pair@IPAUstx_object@@@std@@@3@$0A@@stx@@_N@std@@ABIABQAUstx_object@@@Z ; stx::btree<unsigned int,stx_object *,std::pair<unsigned int,stx_object *>,std::less<unsigned int>,stx::btree_default_map_traits<unsigned int,stx_object *>,0,std::allocator<std::pair<unsigned int,stx_object *> >,0>::insert_start
  01443	0f b7 45 a4	 movzx	 eax, WORD PTR $T234603[ebp+4]
  01447	8b 4d a0	 mov	 ecx, DWORD PTR $T234603[ebp]
  0144a	83 45 e4 14	 add	 DWORD PTR tv7105[ebp], 20 ; 00000014H
  0144e	47		 inc	 edi
  0144f	89 9c 81 8c 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+140], ebx
  01456	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_max@@3IA ; the_max
  0145c	72 b3		 jb	 SHORT $LN82@test_inser
$LN80@test_inser:

; 1036 : 	} STOP();

  0145e	8d 55 dc	 lea	 edx, DWORD PTR _t$234648[ebp]
  01461	52		 push	 edx
  01462	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01468	85 c0		 test	 eax, eax
  0146a	75 11		 jne	 SHORT $LN840@test_inser
  0146c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01470	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234640[ebp], xmm0
  01475	8b 5d f0	 mov	 ebx, DWORD PTR $T234640[ebp+4]
  01478	8b 75 ec	 mov	 esi, DWORD PTR $T234640[ebp]
  0147b	eb 54		 jmp	 SHORT $LN841@test_inser
$LN840@test_inser:
  0147d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01483	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01489	8b 45 e0	 mov	 eax, DWORD PTR _t$234648[ebp+4]
  0148c	8b 4d dc	 mov	 ecx, DWORD PTR _t$234648[ebp]
  0148f	56		 push	 esi
  01490	57		 push	 edi
  01491	50		 push	 eax
  01492	51		 push	 ecx
  01493	e8 00 00 00 00	 call	 __alldvrm
  01498	6a 00		 push	 0
  0149a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0149f	53		 push	 ebx
  014a0	51		 push	 ecx
  014a1	89 45 f4	 mov	 DWORD PTR tv1395[ebp], eax
  014a4	89 55 f8	 mov	 DWORD PTR tv1395[ebp+4], edx
  014a7	e8 00 00 00 00	 call	 __allmul
  014ac	56		 push	 esi
  014ad	57		 push	 edi
  014ae	52		 push	 edx
  014af	50		 push	 eax
  014b0	e8 00 00 00 00	 call	 __alldiv
  014b5	6a 00		 push	 0
  014b7	8b da		 mov	 ebx, edx
  014b9	8b 55 f8	 mov	 edx, DWORD PTR tv1395[ebp+4]
  014bc	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  014c1	8b f0		 mov	 esi, eax
  014c3	8b 45 f4	 mov	 eax, DWORD PTR tv1395[ebp]
  014c6	52		 push	 edx
  014c7	50		 push	 eax
  014c8	e8 00 00 00 00	 call	 __allmul
  014cd	03 f0		 add	 esi, eax
  014cf	13 da		 adc	 ebx, edx
$LN841@test_inser:
  014d1	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  014d7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  014dd	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  014e3	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  014e9	75 64		 jne	 SHORT $LN838@test_inser
  014eb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  014f2	75 24		 jne	 SHORT $LN836@test_inser
  014f4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  014fa	6a 00		 push	 0
  014fc	51		 push	 ecx
  014fd	53		 push	 ebx
  014fe	56		 push	 esi
  014ff	e8 00 00 00 00	 call	 __aulldiv
  01504	50		 push	 eax
  01505	68 00 00 00 00	 push	 OFFSET $SG-102
  0150a	e8 00 00 00 00	 call	 _printf
  0150f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  01515	83 c4 08	 add	 esp, 8
$LN836@test_inser:
  01518	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0151e	6a 00		 push	 0
  01520	52		 push	 edx
  01521	53		 push	 ebx
  01522	56		 push	 esi
  01523	e8 00 00 00 00	 call	 __aulldiv
  01528	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0152e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01534	c1 e1 04	 shl	 ecx, 4
  01537	03 cf		 add	 ecx, edi
  01539	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0153c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01542	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01545	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01548	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN838@test_inser:

; 1037 : #endif
; 1038 : 
; 1039 : #ifdef USE_CPPMAP
; 1040 : 	START(DATA_CPPMAP) {

  0154f	c7 05 00 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 15 ; the_start_data, 0000000fH
  01559	83 ff 0f	 cmp	 edi, 15			; 0000000fH
  0155c	0f 85 61 01 00
	00		 jne	 $LN76@test_inser
  01562	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01569	75 2f		 jne	 SHORT $LN845@test_inser
  0156b	8b 15 3c 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+60
  01571	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01576	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0157d	52		 push	 edx
  0157e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01584	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0158b	51		 push	 ecx
  0158c	50		 push	 eax
  0158d	68 00 00 00 00	 push	 OFFSET $SG-101
  01592	e8 00 00 00 00	 call	 _printf
  01597	83 c4 10	 add	 esp, 16			; 00000010H
$LN845@test_inser:
  0159a	8d 4d d4	 lea	 ecx, DWORD PTR _t$234673[ebp]
  0159d	51		 push	 ecx
  0159e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  015a4	85 c0		 test	 eax, eax
  015a6	75 11		 jne	 SHORT $LN851@test_inser
  015a8	66 0f 57 c0	 xorpd	 xmm0, xmm0
  015ac	66 0f 13 45 ec	 movlpd	 QWORD PTR $T234666[ebp], xmm0
  015b1	8b 5d f0	 mov	 ebx, DWORD PTR $T234666[ebp+4]
  015b4	8b 75 ec	 mov	 esi, DWORD PTR $T234666[ebp]
  015b7	eb 54		 jmp	 SHORT $LN852@test_inser
$LN851@test_inser:
  015b9	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  015bf	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  015c5	8b 55 d8	 mov	 edx, DWORD PTR _t$234673[ebp+4]
  015c8	8b 45 d4	 mov	 eax, DWORD PTR _t$234673[ebp]
  015cb	56		 push	 esi
  015cc	57		 push	 edi
  015cd	52		 push	 edx
  015ce	50		 push	 eax
  015cf	e8 00 00 00 00	 call	 __alldvrm
  015d4	6a 00		 push	 0
  015d6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015db	53		 push	 ebx
  015dc	51		 push	 ecx
  015dd	89 45 f4	 mov	 DWORD PTR tv4477[ebp], eax
  015e0	89 55 f8	 mov	 DWORD PTR tv4477[ebp+4], edx
  015e3	e8 00 00 00 00	 call	 __allmul
  015e8	56		 push	 esi
  015e9	57		 push	 edi
  015ea	52		 push	 edx
  015eb	50		 push	 eax
  015ec	e8 00 00 00 00	 call	 __alldiv
  015f1	8b 4d f8	 mov	 ecx, DWORD PTR tv4477[ebp+4]
  015f4	6a 00		 push	 0
  015f6	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  015fb	8b da		 mov	 ebx, edx
  015fd	8b 55 f4	 mov	 edx, DWORD PTR tv4477[ebp]
  01600	51		 push	 ecx
  01601	52		 push	 edx
  01602	8b f0		 mov	 esi, eax
  01604	e8 00 00 00 00	 call	 __allmul
  01609	03 f0		 add	 esi, eax
  0160b	13 da		 adc	 ebx, edx
$LN852@test_inser:
  0160d	33 c0		 xor	 eax, eax
  0160f	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01615	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0161b	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  0161e	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  01624	0f 86 99 00 00
	00		 jbe	 $LN76@test_inser
  0162a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  01630	89 45 e4	 mov	 DWORD PTR tv7134[ebp], eax
$LL78@test_inser:

; 1041 : 		unsigned key = INSERT[i];

  01633	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  01636	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]

; 1042 : 		struct cpp_object* obj = &CPP[i];

  01639	8b 7d e4	 mov	 edi, DWORD PTR tv7134[ebp]
  0163c	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP
  01642	8b 14 88	 mov	 edx, DWORD PTR [eax+ecx*4]

; 1043 : 		CPP[i].value = key;

  01645	89 17		 mov	 DWORD PTR [edi], edx

; 1044 : 		(*cppmap)[key] = obj;

  01647	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0164a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0164d	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  01651	89 7d c8	 mov	 DWORD PTR tv7146[ebp], edi
  01654	89 75 f8	 mov	 DWORD PTR $T234993[ebp], esi
  01657	8b d9		 mov	 ebx, ecx
  01659	75 19		 jne	 SHORT $LN862@test_inser
  0165b	eb 03 8d 49 00	 npad	 5
$LL863@test_inser:
  01660	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  01663	73 05		 jae	 SHORT $LN861@test_inser
  01665	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  01668	eb 04		 jmp	 SHORT $LN860@test_inser
$LN861@test_inser:
  0166a	8b d8		 mov	 ebx, eax
  0166c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN860@test_inser:
  0166e	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  01672	74 ec		 je	 SHORT $LL863@test_inser
$LN862@test_inser:
  01674	3b d9		 cmp	 ebx, ecx
  01676	74 05		 je	 SHORT $LN854@test_inser
  01678	3b 53 0c	 cmp	 edx, DWORD PTR [ebx+12]
  0167b	73 2c		 jae	 SHORT $LN855@test_inser
$LN854@test_inser:
  0167d	8d 7d ec	 lea	 edi, DWORD PTR $T234909[ebp]
  01680	89 55 ec	 mov	 DWORD PTR $T234909[ebp], edx
  01683	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T234909[ebp+4], 0
  0168a	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  0168f	8b 55 f8	 mov	 edx, DWORD PTR $T234993[ebp]
  01692	50		 push	 eax
  01693	53		 push	 ebx
  01694	52		 push	 edx
  01695	8d 7d d0	 lea	 edi, DWORD PTR $T234912[ebp]
  01698	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@std@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,cpp_object *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  0169d	8b 5d d0	 mov	 ebx, DWORD PTR $T234912[ebp]
  016a0	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppmap@@3PAV?$map@IPAUcpp_object@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@@std@@A ; cppmap
  016a6	8b 7d c8	 mov	 edi, DWORD PTR tv7146[ebp]
$LN855@test_inser:

; 1037 : #endif
; 1038 : 
; 1039 : #ifdef USE_CPPMAP
; 1040 : 	START(DATA_CPPMAP) {

  016a9	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  016ac	83 45 e4 14	 add	 DWORD PTR tv7134[ebp], 20 ; 00000014H
  016b0	40		 inc	 eax

; 1044 : 		(*cppmap)[key] = obj;

  016b1	89 7b 10	 mov	 DWORD PTR [ebx+16], edi
  016b4	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  016b7	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  016bd	0f 82 70 ff ff
	ff		 jb	 $LL78@test_inser
$LN76@test_inser:

; 1045 : 	} STOP();

  016c3	8d 45 dc	 lea	 eax, DWORD PTR _t$235012[ebp]
  016c6	50		 push	 eax
  016c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  016cd	85 c0		 test	 eax, eax
  016cf	75 11		 jne	 SHORT $LN936@test_inser
  016d1	66 0f 57 c0	 xorpd	 xmm0, xmm0
  016d5	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235001[ebp], xmm0
  016da	8b 5d f0	 mov	 ebx, DWORD PTR $T235001[ebp+4]
  016dd	8b 75 ec	 mov	 esi, DWORD PTR $T235001[ebp]
  016e0	eb 54		 jmp	 SHORT $LN937@test_inser
$LN936@test_inser:
  016e2	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  016e8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  016ee	8b 4d e0	 mov	 ecx, DWORD PTR _t$235012[ebp+4]
  016f1	8b 55 dc	 mov	 edx, DWORD PTR _t$235012[ebp]
  016f4	56		 push	 esi
  016f5	57		 push	 edi
  016f6	51		 push	 ecx
  016f7	52		 push	 edx
  016f8	e8 00 00 00 00	 call	 __alldvrm
  016fd	6a 00		 push	 0
  016ff	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01704	53		 push	 ebx
  01705	51		 push	 ecx
  01706	89 45 f4	 mov	 DWORD PTR tv1710[ebp], eax
  01709	89 55 f8	 mov	 DWORD PTR tv1710[ebp+4], edx
  0170c	e8 00 00 00 00	 call	 __allmul
  01711	56		 push	 esi
  01712	57		 push	 edi
  01713	52		 push	 edx
  01714	50		 push	 eax
  01715	e8 00 00 00 00	 call	 __alldiv
  0171a	8b 4d f4	 mov	 ecx, DWORD PTR tv1710[ebp]
  0171d	6a 00		 push	 0
  0171f	8b f0		 mov	 esi, eax
  01721	8b 45 f8	 mov	 eax, DWORD PTR tv1710[ebp+4]
  01724	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01729	50		 push	 eax
  0172a	51		 push	 ecx
  0172b	8b da		 mov	 ebx, edx
  0172d	e8 00 00 00 00	 call	 __allmul
  01732	03 f0		 add	 esi, eax
  01734	13 da		 adc	 ebx, edx
$LN937@test_inser:
  01736	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  0173c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  01742	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  01748	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  0174e	75 63		 jne	 SHORT $LN934@test_inser
  01750	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01757	75 24		 jne	 SHORT $LN932@test_inser
  01759	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0175f	6a 00		 push	 0
  01761	52		 push	 edx
  01762	53		 push	 ebx
  01763	56		 push	 esi
  01764	e8 00 00 00 00	 call	 __aulldiv
  01769	50		 push	 eax
  0176a	68 00 00 00 00	 push	 OFFSET $SG-102
  0176f	e8 00 00 00 00	 call	 _printf
  01774	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  0177a	83 c4 08	 add	 esp, 8
$LN932@test_inser:
  0177d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01782	6a 00		 push	 0
  01784	50		 push	 eax
  01785	53		 push	 ebx
  01786	56		 push	 esi
  01787	e8 00 00 00 00	 call	 __aulldiv
  0178c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01792	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01798	c1 e1 04	 shl	 ecx, 4
  0179b	03 cf		 add	 ecx, edi
  0179d	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  017a0	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  017a6	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  017a9	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  017ac	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN934@test_inser:

; 1046 : #endif
; 1047 : 
; 1048 : #ifdef USE_CPPUNORDEREDMAP
; 1049 : 	START(DATA_CPPUNORDEREDMAP) {

  017b3	c7 05 00 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 14 ; the_start_data, 0000000eH
  017bd	83 ff 0e	 cmp	 edi, 14			; 0000000eH
  017c0	0f 85 7b 01 00
	00		 jne	 $LN72@test_inser
  017c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  017cd	75 2f		 jne	 SHORT $LN941@test_inser
  017cf	8b 15 38 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+56
  017d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  017da	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  017e1	52		 push	 edx
  017e2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  017e8	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  017ef	51		 push	 ecx
  017f0	50		 push	 eax
  017f1	68 00 00 00 00	 push	 OFFSET $SG-101
  017f6	e8 00 00 00 00	 call	 _printf
  017fb	83 c4 10	 add	 esp, 16			; 00000010H
$LN941@test_inser:
  017fe	8d 4d d4	 lea	 ecx, DWORD PTR _t$235036[ebp]
  01801	51		 push	 ecx
  01802	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01808	85 c0		 test	 eax, eax
  0180a	75 11		 jne	 SHORT $LN947@test_inser
  0180c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01810	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235027[ebp], xmm0
  01815	8b 5d f0	 mov	 ebx, DWORD PTR $T235027[ebp+4]
  01818	8b 75 ec	 mov	 esi, DWORD PTR $T235027[ebp]
  0181b	eb 54		 jmp	 SHORT $LN948@test_inser
$LN947@test_inser:
  0181d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01823	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01829	8b 55 d8	 mov	 edx, DWORD PTR _t$235036[ebp+4]
  0182c	8b 45 d4	 mov	 eax, DWORD PTR _t$235036[ebp]
  0182f	56		 push	 esi
  01830	57		 push	 edi
  01831	52		 push	 edx
  01832	50		 push	 eax
  01833	e8 00 00 00 00	 call	 __alldvrm
  01838	6a 00		 push	 0
  0183a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0183f	53		 push	 ebx
  01840	51		 push	 ecx
  01841	89 45 f4	 mov	 DWORD PTR tv1742[ebp], eax
  01844	89 55 f8	 mov	 DWORD PTR tv1742[ebp+4], edx
  01847	e8 00 00 00 00	 call	 __allmul
  0184c	56		 push	 esi
  0184d	57		 push	 edi
  0184e	52		 push	 edx
  0184f	50		 push	 eax
  01850	e8 00 00 00 00	 call	 __alldiv
  01855	8b 4d f8	 mov	 ecx, DWORD PTR tv1742[ebp+4]
  01858	6a 00		 push	 0
  0185a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0185f	8b da		 mov	 ebx, edx
  01861	8b 55 f4	 mov	 edx, DWORD PTR tv1742[ebp]
  01864	51		 push	 ecx
  01865	52		 push	 edx
  01866	8b f0		 mov	 esi, eax
  01868	e8 00 00 00 00	 call	 __allmul
  0186d	03 f0		 add	 esi, eax
  0186f	13 da		 adc	 ebx, edx
$LN948@test_inser:
  01871	33 c0		 xor	 eax, eax
  01873	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01879	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0187f	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  01882	39 05 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, eax ; the_max
  01888	0f 86 b3 00 00
	00		 jbe	 $LN72@test_inser
  0188e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  01894	89 45 e4	 mov	 DWORD PTR tv7163[ebp], eax
$LL74@test_inser:

; 1050 : 		unsigned key = INSERT[i];

  01897	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  0189a	8b 4d e8	 mov	 ecx, DWORD PTR _i$[ebp]
  0189d	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]

; 1051 : 		struct cpp_object* obj = &CPP[i];

  018a0	8b 45 e4	 mov	 eax, DWORD PTR tv7163[ebp]
  018a3	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?CPP@@3PAUcpp_object@@A ; CPP

; 1052 : 		CPP[i].value = key;
; 1053 : 		(*cppunorderedmap)[key] = obj;

  018a9	8d 4d c0	 lea	 ecx, DWORD PTR __Where$235564[ebp]
  018ac	89 45 c8	 mov	 DWORD PTR tv7175[ebp], eax
  018af	89 18		 mov	 DWORD PTR [eax], ebx
  018b1	51		 push	 ecx
  018b2	8d 45 f8	 lea	 eax, DWORD PTR _key$150617[ebp]
  018b5	8b ce		 mov	 ecx, esi
  018b7	89 5d f8	 mov	 DWORD PTR _key$150617[ebp], ebx
  018ba	89 75 d0	 mov	 DWORD PTR $T235650[ebp], esi
  018bd	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@ABI@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::lower_bound
  018c2	8b 45 c0	 mov	 eax, DWORD PTR __Where$235564[ebp]
  018c5	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  018c8	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  018cb	75 57		 jne	 SHORT $LN950@test_inser
  018cd	8b 17		 mov	 edx, DWORD PTR [edi]
  018cf	89 5d ec	 mov	 DWORD PTR $T235538[ebp], ebx
  018d2	8b 1a		 mov	 ebx, DWORD PTR [edx]
  018d4	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  018d7	50		 push	 eax
  018d8	53		 push	 ebx
  018d9	8d 75 ec	 lea	 esi, DWORD PTR $T235538[ebp]
  018dc	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T235538[ebp+4], 0
  018e3	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@$$CBIPAUcpp_object@@@std@@@?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@QAEPAU_Node@?$_List_nod@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@1@PAU231@0$$QAU?$pair@$$CBIPAUcpp_object@@@1@@Z ; std::_List_val<std::pair<unsigned int const ,cpp_object *>,std::allocator<std::pair<unsigned int const ,cpp_object *> > >::_Buynode<std::pair<unsigned int const ,cpp_object *> >
  018e8	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  018eb	ba fe ff ff 1f	 mov	 edx, 536870910		; 1ffffffeH
  018f0	2b d1		 sub	 edx, ecx
  018f2	83 fa 01	 cmp	 edx, 1
  018f5	72 69		 jb	 SHORT $LN1172@test_inser
  018f7	41		 inc	 ecx
  018f8	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  018fb	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  018fe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01901	89 01		 mov	 DWORD PTR [ecx], eax
  01903	8b 17		 mov	 edx, DWORD PTR [edi]
  01905	8b 02		 mov	 eax, DWORD PTR [edx]
  01907	8b 55 d0	 mov	 edx, DWORD PTR $T235650[ebp]
  0190a	50		 push	 eax
  0190b	8d 4d b4	 lea	 ecx, DWORD PTR $T235540[ebp]
  0190e	51		 push	 ecx
  0190f	83 c0 08	 add	 eax, 8
  01912	52		 push	 edx
  01913	e8 00 00 00 00	 call	 ?_Insert@?$_Hash@V?$_Umap_traits@IPAUcpp_object@@V?$_Hash_compare@IVcpp_tommy_inthash_u32@@U?$equal_to@I@std@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@3@$0A@@tr1@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@std@@_N@2@ABU?$pair@$$CBIPAUcpp_object@@@2@V?$_List_iterator@V?$_List_val@U?$pair@$$CBIPAUcpp_object@@@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@2@@std@@@2@@Z ; std::_Hash<std::tr1::_Umap_traits<unsigned int,cpp_object *,std::_Hash_compare<unsigned int,cpp_tommy_inthash_u32,std::equal_to<unsigned int> >,std::allocator<std::pair<unsigned int const ,cpp_object *> >,0> >::_Insert
  01918	8b 45 b4	 mov	 eax, DWORD PTR $T235540[ebp]
  0191b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?cppunorderedmap@@3PAV?$unordered_map@IPAUcpp_object@@Vcpp_tommy_inthash_u32@@U?$equal_to@I@std@@V?$allocator@U?$pair@$$CBIPAUcpp_object@@@std@@@4@@tr1@std@@A ; cppunorderedmap
  01921	89 45 c0	 mov	 DWORD PTR __Where$235564[ebp], eax
$LN950@test_inser:
  01924	8b 4d c8	 mov	 ecx, DWORD PTR tv7175[ebp]
  01927	83 45 e4 14	 add	 DWORD PTR tv7163[ebp], 20 ; 00000014H
  0192b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0192e	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01931	40		 inc	 eax
  01932	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  01935	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  0193b	0f 82 56 ff ff
	ff		 jb	 $LL74@test_inser
$LN72@test_inser:

; 1054 : 	} STOP();

  01941	8d 55 dc	 lea	 edx, DWORD PTR _t$235667[ebp]
  01944	52		 push	 edx
  01945	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0194b	85 c0		 test	 eax, eax
  0194d	75 1b		 jne	 SHORT $LN1066@test_inser
  0194f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01953	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235659[ebp], xmm0
  01958	8b 5d f0	 mov	 ebx, DWORD PTR $T235659[ebp+4]
  0195b	8b 75 ec	 mov	 esi, DWORD PTR $T235659[ebp]
  0195e	eb 5e		 jmp	 SHORT $LN1067@test_inser
$LN1172@test_inser:

; 1052 : 		CPP[i].value = key;
; 1053 : 		(*cppunorderedmap)[key] = obj;

  01960	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  01965	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1273@test_inser:

; 1054 : 	} STOP();

$LN1066@test_inser:
  0196a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01970	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01976	8b 45 e0	 mov	 eax, DWORD PTR _t$235667[ebp+4]
  01979	8b 4d dc	 mov	 ecx, DWORD PTR _t$235667[ebp]
  0197c	56		 push	 esi
  0197d	57		 push	 edi
  0197e	50		 push	 eax
  0197f	51		 push	 ecx
  01980	e8 00 00 00 00	 call	 __alldvrm
  01985	6a 00		 push	 0
  01987	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0198c	53		 push	 ebx
  0198d	51		 push	 ecx
  0198e	89 45 f4	 mov	 DWORD PTR tv2100[ebp], eax
  01991	89 55 f8	 mov	 DWORD PTR tv2100[ebp+4], edx
  01994	e8 00 00 00 00	 call	 __allmul
  01999	56		 push	 esi
  0199a	57		 push	 edi
  0199b	52		 push	 edx
  0199c	50		 push	 eax
  0199d	e8 00 00 00 00	 call	 __alldiv
  019a2	6a 00		 push	 0
  019a4	8b da		 mov	 ebx, edx
  019a6	8b 55 f8	 mov	 edx, DWORD PTR tv2100[ebp+4]
  019a9	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  019ae	8b f0		 mov	 esi, eax
  019b0	8b 45 f4	 mov	 eax, DWORD PTR tv2100[ebp]
  019b3	52		 push	 edx
  019b4	50		 push	 eax
  019b5	e8 00 00 00 00	 call	 __allmul
  019ba	03 f0		 add	 esi, eax
  019bc	13 da		 adc	 ebx, edx
$LN1067@test_inser:
  019be	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  019c4	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  019ca	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  019d0	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  019d6	75 64		 jne	 SHORT $LN1064@test_inser
  019d8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  019df	75 24		 jne	 SHORT $LN1062@test_inser
  019e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  019e7	6a 00		 push	 0
  019e9	51		 push	 ecx
  019ea	53		 push	 ebx
  019eb	56		 push	 esi
  019ec	e8 00 00 00 00	 call	 __aulldiv
  019f1	50		 push	 eax
  019f2	68 00 00 00 00	 push	 OFFSET $SG-102
  019f7	e8 00 00 00 00	 call	 _printf
  019fc	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  01a02	83 c4 08	 add	 esp, 8
$LN1062@test_inser:
  01a05	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01a0b	6a 00		 push	 0
  01a0d	52		 push	 edx
  01a0e	53		 push	 ebx
  01a0f	56		 push	 esi
  01a10	e8 00 00 00 00	 call	 __aulldiv
  01a15	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01a1b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01a21	c1 e1 04	 shl	 ecx, 4
  01a24	03 cf		 add	 ecx, edi
  01a26	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01a29	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01a2f	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01a32	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01a35	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1064@test_inser:

; 1055 : #endif
; 1056 : 
; 1057 : 	START(DATA_UTHASH) {

  01a3c	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 8 ; the_start_data
  01a46	83 ff 08	 cmp	 edi, 8
  01a49	0f 85 e9 03 00
	00		 jne	 $LN68@test_inser
  01a4f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01a56	75 2f		 jne	 SHORT $LN1071@test_inser
  01a58	8b 15 20 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+32
  01a5e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01a63	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01a6a	52		 push	 edx
  01a6b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01a71	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01a78	51		 push	 ecx
  01a79	50		 push	 eax
  01a7a	68 00 00 00 00	 push	 OFFSET $SG-101
  01a7f	e8 00 00 00 00	 call	 _printf
  01a84	83 c4 10	 add	 esp, 16			; 00000010H
$LN1071@test_inser:
  01a87	8d 4d d4	 lea	 ecx, DWORD PTR _t$235692[ebp]
  01a8a	51		 push	 ecx
  01a8b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01a91	85 c0		 test	 eax, eax
  01a93	75 11		 jne	 SHORT $LN1077@test_inser
  01a95	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01a99	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235685[ebp], xmm0
  01a9e	8b 5d f0	 mov	 ebx, DWORD PTR $T235685[ebp+4]
  01aa1	8b 75 ec	 mov	 esi, DWORD PTR $T235685[ebp]
  01aa4	eb 54		 jmp	 SHORT $LN1078@test_inser
$LN1077@test_inser:
  01aa6	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01aac	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01ab2	8b 55 d8	 mov	 edx, DWORD PTR _t$235692[ebp+4]
  01ab5	8b 45 d4	 mov	 eax, DWORD PTR _t$235692[ebp]
  01ab8	56		 push	 esi
  01ab9	57		 push	 edi
  01aba	52		 push	 edx
  01abb	50		 push	 eax
  01abc	e8 00 00 00 00	 call	 __alldvrm
  01ac1	6a 00		 push	 0
  01ac3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ac8	53		 push	 ebx
  01ac9	51		 push	 ecx
  01aca	89 45 f4	 mov	 DWORD PTR tv4431[ebp], eax
  01acd	89 55 f8	 mov	 DWORD PTR tv4431[ebp+4], edx
  01ad0	e8 00 00 00 00	 call	 __allmul
  01ad5	56		 push	 esi
  01ad6	57		 push	 edi
  01ad7	52		 push	 edx
  01ad8	50		 push	 eax
  01ad9	e8 00 00 00 00	 call	 __alldiv
  01ade	8b 4d f8	 mov	 ecx, DWORD PTR tv4431[ebp+4]
  01ae1	6a 00		 push	 0
  01ae3	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ae8	8b da		 mov	 ebx, edx
  01aea	8b 55 f4	 mov	 edx, DWORD PTR tv4431[ebp]
  01aed	51		 push	 ecx
  01aee	52		 push	 edx
  01aef	8b f0		 mov	 esi, eax
  01af1	e8 00 00 00 00	 call	 __allmul
  01af6	03 f0		 add	 esi, eax
  01af8	13 da		 adc	 ebx, edx
$LN1078@test_inser:
  01afa	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_max@@3IA, 0 ; the_max
  01b01	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  01b07	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  01b0d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  01b14	0f 86 1e 03 00
	00		 jbe	 $LN68@test_inser
  01b1a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?UTHASH@@3PAUuthash_object@@A ; UTHASH
  01b20	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01b26	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
$LN70@test_inser:

; 1058 : 		unsigned key = INSERT[i];
; 1059 : 		struct uthash_object* obj = &UTHASH[i];
; 1060 : 		obj->value = key;

  01b29	8b 4d 08	 mov	 ecx, DWORD PTR _INSERT$[ebp]
  01b2c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  01b2f	8d 5f 20	 lea	 ebx, DWORD PTR [edi+32]
  01b32	89 13		 mov	 DWORD PTR [ebx], edx

; 1061 : 		HASH_ADD_INT(uthash, value, obj);

  01b34	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  01b3b	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  01b3e	c7 47 18 04 00
	00 00		 mov	 DWORD PTR [edi+24], 4
  01b45	85 f6		 test	 esi, esi
  01b47	0f 85 89 00 00
	00		 jne	 $LN64@test_inser
  01b4d	8b f7		 mov	 esi, edi
  01b4f	6a 2c		 push	 44			; 0000002cH
  01b51	89 35 00 00 00
	00		 mov	 DWORD PTR ?uthash@@3PAUuthash_object@@A, esi ; uthash
  01b57	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  01b5e	e8 00 00 00 00	 call	 _malloc
  01b63	83 c4 04	 add	 esp, 4
  01b66	89 07		 mov	 DWORD PTR [edi], eax
  01b68	85 c0		 test	 eax, eax
  01b6a	0f 84 e7 02 00
	00		 je	 $LN1173@test_inser
  01b70	6a 2c		 push	 44			; 0000002cH
  01b72	6a 00		 push	 0
  01b74	50		 push	 eax
  01b75	e8 00 00 00 00	 call	 _memset
  01b7a	8b 07		 mov	 eax, DWORD PTR [edi]
  01b7c	89 78 10	 mov	 DWORD PTR [eax+16], edi
  01b7f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01b81	c7 41 04 20 00
	00 00		 mov	 DWORD PTR [ecx+4], 32	; 00000020H
  01b88	8b 17		 mov	 edx, DWORD PTR [edi]
  01b8a	c7 42 08 05 00
	00 00		 mov	 DWORD PTR [edx+8], 5
  01b91	8b 07		 mov	 eax, DWORD PTR [edi]
  01b93	83 c4 0c	 add	 esp, 12			; 0000000cH
  01b96	68 80 01 00 00	 push	 384			; 00000180H
  01b9b	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
  01ba2	e8 00 00 00 00	 call	 _malloc
  01ba7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01ba9	89 01		 mov	 DWORD PTR [ecx], eax
  01bab	8b 07		 mov	 eax, DWORD PTR [edi]
  01bad	83 c4 04	 add	 esp, 4
  01bb0	83 38 00	 cmp	 DWORD PTR [eax], 0
  01bb3	0f 84 9e 02 00
	00		 je	 $LN1173@test_inser
  01bb9	8b 10		 mov	 edx, DWORD PTR [eax]
  01bbb	68 80 01 00 00	 push	 384			; 00000180H
  01bc0	6a 00		 push	 0
  01bc2	52		 push	 edx
  01bc3	e8 00 00 00 00	 call	 _memset
  01bc8	8b 07		 mov	 eax, DWORD PTR [edi]
  01bca	83 c4 0c	 add	 esp, 12			; 0000000cH
  01bcd	c7 40 28 e1 1f
	11 a0		 mov	 DWORD PTR [eax+40], -1609490463 ; a0111fe1H
  01bd4	eb 18		 jmp	 SHORT $LN58@test_inser
$LN64@test_inser:
  01bd6	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01bd8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  01bdb	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  01bde	8b 06		 mov	 eax, DWORD PTR [esi]
  01be0	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  01be3	2b 48 14	 sub	 ecx, DWORD PTR [eax+20]
  01be6	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  01be9	8b 16		 mov	 edx, DWORD PTR [esi]
  01beb	89 7a 10	 mov	 DWORD PTR [edx+16], edi
$LN58@test_inser:
  01bee	8b 06		 mov	 eax, DWORD PTR [esi]
  01bf0	ff 40 0c	 inc	 DWORD PTR [eax+12]
  01bf3	8b 06		 mov	 eax, DWORD PTR [esi]
  01bf5	89 07		 mov	 DWORD PTR [edi], eax
  01bf7	ba f3 be ed fe	 mov	 edx, -17973517		; feedbef3H
  01bfc	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01bff	0f be 47 23	 movsx	 eax, BYTE PTR [edi+35]
  01c03	0f be 4f 22	 movsx	 ecx, BYTE PTR [edi+34]
  01c07	c1 e0 18	 shl	 eax, 24			; 00000018H
  01c0a	c1 e1 10	 shl	 ecx, 16			; 00000010H
  01c0d	2d 47 86 c8 61	 sub	 eax, 1640531527		; 61c88647H
  01c12	03 c1		 add	 eax, ecx
  01c14	0f be 4f 21	 movsx	 ecx, BYTE PTR [edi+33]
  01c18	c1 e1 08	 shl	 ecx, 8
  01c1b	03 c1		 add	 eax, ecx
  01c1d	0f be 0b	 movsx	 ecx, BYTE PTR [ebx]
  01c20	03 c8		 add	 ecx, eax
  01c22	81 c1 54 c7 da
	62		 add	 ecx, 1658505044		; 62dac754H
  01c28	81 f1 6d f7 07
	00		 xor	 ecx, 522093		; 0007f76dH
  01c2e	8b d9		 mov	 ebx, ecx
  01c30	c1 e3 08	 shl	 ebx, 8
  01c33	b8 c6 ba 49 9f	 mov	 eax, -1622558010	; 9f49bac6H
  01c38	2b c1		 sub	 eax, ecx
  01c3a	33 c3		 xor	 eax, ebx
  01c3c	2b d0		 sub	 edx, eax
  01c3e	2b d1		 sub	 edx, ecx
  01c40	8b d8		 mov	 ebx, eax
  01c42	c1 eb 0d	 shr	 ebx, 13			; 0000000dH
  01c45	33 d3		 xor	 edx, ebx
  01c47	2b ca		 sub	 ecx, edx
  01c49	2b c8		 sub	 ecx, eax
  01c4b	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01c4e	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  01c51	33 ca		 xor	 ecx, edx
  01c53	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01c56	2b c2		 sub	 eax, edx
  01c58	2b c1		 sub	 eax, ecx
  01c5a	8b d9		 mov	 ebx, ecx
  01c5c	c1 e3 10	 shl	 ebx, 16			; 00000010H
  01c5f	33 c3		 xor	 eax, ebx
  01c61	2b d0		 sub	 edx, eax
  01c63	2b d1		 sub	 edx, ecx
  01c65	8b d8		 mov	 ebx, eax
  01c67	c1 eb 05	 shr	 ebx, 5
  01c6a	33 d3		 xor	 edx, ebx
  01c6c	2b ca		 sub	 ecx, edx
  01c6e	2b c8		 sub	 ecx, eax
  01c70	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01c73	c1 ea 03	 shr	 edx, 3
  01c76	33 ca		 xor	 ecx, edx
  01c78	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]
  01c7b	2b c2		 sub	 eax, edx
  01c7d	2b c1		 sub	 eax, ecx
  01c7f	8b d9		 mov	 ebx, ecx
  01c81	c1 e3 0a	 shl	 ebx, 10			; 0000000aH
  01c84	33 c3		 xor	 eax, ebx
  01c86	2b d0		 sub	 edx, eax
  01c88	2b d1		 sub	 edx, ecx
  01c8a	c1 e8 0f	 shr	 eax, 15			; 0000000fH
  01c8d	33 d0		 xor	 edx, eax
  01c8f	89 57 1c	 mov	 DWORD PTR [edi+28], edx
  01c92	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01c94	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01c97	48		 dec	 eax
  01c98	23 c2		 and	 eax, edx
  01c9a	8b 11		 mov	 edx, DWORD PTR [ecx]
  01c9c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01c9f	03 c0		 add	 eax, eax
  01ca1	03 c0		 add	 eax, eax
  01ca3	ff 44 10 04	 inc	 DWORD PTR [eax+edx+4]
  01ca7	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  01cab	8b 0e		 mov	 ecx, DWORD PTR [esi]
  01cad	8b 11		 mov	 edx, DWORD PTR [ecx]
  01caf	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  01cb2	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  01cb5	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
  01cbc	8b 16		 mov	 edx, DWORD PTR [esi]
  01cbe	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01cc0	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  01cc3	85 c9		 test	 ecx, ecx
  01cc5	74 03		 je	 SHORT $LN30@test_inser
  01cc7	89 79 0c	 mov	 DWORD PTR [ecx+12], edi
$LN30@test_inser:
  01cca	8b 16		 mov	 edx, DWORD PTR [esi]
  01ccc	8b 0a		 mov	 ecx, DWORD PTR [edx]
  01cce	89 3c 08	 mov	 DWORD PTR [eax+ecx], edi
  01cd1	8b 16		 mov	 edx, DWORD PTR [esi]
  01cd3	03 02		 add	 eax, DWORD PTR [edx]
  01cd5	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01cd8	8d 54 89 05	 lea	 edx, DWORD PTR [ecx+ecx*4+5]
  01cdc	03 d2		 add	 edx, edx
  01cde	39 50 04	 cmp	 DWORD PTR [eax+4], edx
  01ce1	0f 82 3b 01 00
	00		 jb	 $LN26@test_inser
  01ce7	8b 07		 mov	 eax, DWORD PTR [edi]
  01ce9	83 78 24 01	 cmp	 DWORD PTR [eax+36], 1
  01ced	0f 84 2f 01 00
	00		 je	 $LN26@test_inser
  01cf3	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  01cf6	8d 1c 5b	 lea	 ebx, DWORD PTR [ebx+ebx*2]
  01cf9	03 db		 add	 ebx, ebx
  01cfb	03 db		 add	 ebx, ebx
  01cfd	03 db		 add	 ebx, ebx
  01cff	53		 push	 ebx
  01d00	e8 00 00 00 00	 call	 _malloc
  01d05	83 c4 04	 add	 esp, 4
  01d08	89 45 c8	 mov	 DWORD PTR __he_new_buckets$150712[ebp], eax
  01d0b	85 c0		 test	 eax, eax
  01d0d	0f 84 44 01 00
	00		 je	 $LN1173@test_inser
  01d13	53		 push	 ebx
  01d14	6a 00		 push	 0
  01d16	50		 push	 eax
  01d17	e8 00 00 00 00	 call	 _memset
  01d1c	8b 07		 mov	 eax, DWORD PTR [edi]
  01d1e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  01d21	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  01d24	41		 inc	 ecx
  01d25	8b da		 mov	 ebx, edx
  01d27	d3 eb		 shr	 ebx, cl
  01d29	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01d2c	8d 4c 09 ff	 lea	 ecx, DWORD PTR [ecx+ecx-1]
  01d30	23 ca		 and	 ecx, edx
  01d32	83 c4 0c	 add	 esp, 12			; 0000000cH
  01d35	f7 d9		 neg	 ecx
  01d37	1b c9		 sbb	 ecx, ecx
  01d39	f7 d9		 neg	 ecx
  01d3b	03 d9		 add	 ebx, ecx
  01d3d	89 58 18	 mov	 DWORD PTR [eax+24], ebx
  01d40	8b 17		 mov	 edx, DWORD PTR [edi]
  01d42	33 db		 xor	 ebx, ebx
  01d44	89 5a 1c	 mov	 DWORD PTR [edx+28], ebx
  01d47	8b 07		 mov	 eax, DWORD PTR [edi]
  01d49	89 5d c0	 mov	 DWORD PTR __he_bkt_i$150709[ebp], ebx
  01d4c	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  01d4f	0f 86 83 00 00
	00		 jbe	 $LN22@test_inser
  01d55	89 5d e4	 mov	 DWORD PTR tv7192[ebp], ebx
$LL24@test_inser:
  01d58	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01d5a	8b 11		 mov	 edx, DWORD PTR [ecx]
  01d5c	8b 45 e4	 mov	 eax, DWORD PTR tv7192[ebp]
  01d5f	8b 1c 10	 mov	 ebx, DWORD PTR [eax+edx]
  01d62	85 db		 test	 ebx, ebx
  01d64	74 5e		 je	 SHORT $LN23@test_inser
$LN21@test_inser:
  01d66	8b 17		 mov	 edx, DWORD PTR [edi]
  01d68	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  01d6b	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  01d6e	8d 44 00 ff	 lea	 eax, DWORD PTR [eax+eax-1]
  01d72	23 43 1c	 and	 eax, DWORD PTR [ebx+28]
  01d75	89 4d f8	 mov	 DWORD PTR __he_hh_nxt$150711[ebp], ecx
  01d78	8b 4d c8	 mov	 ecx, DWORD PTR __he_new_buckets$150712[ebp]
  01d7b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  01d7e	ff 44 81 04	 inc	 DWORD PTR [ecx+eax*4+4]
  01d82	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  01d86	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  01d89	8b 07		 mov	 eax, DWORD PTR [edi]
  01d8b	3b 50 18	 cmp	 edx, DWORD PTR [eax+24]
  01d8e	76 16		 jbe	 SHORT $LN16@test_inser
  01d90	ff 40 1c	 inc	 DWORD PTR [eax+28]
  01d93	8b 37		 mov	 esi, DWORD PTR [edi]
  01d95	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01d98	33 d2		 xor	 edx, edx
  01d9a	f7 76 18	 div	 DWORD PTR [esi+24]
  01d9d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?uthash@@3PAUuthash_object@@A ; uthash
  01da3	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN16@test_inser:
  01da6	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], 0
  01dad	8b 11		 mov	 edx, DWORD PTR [ecx]
  01daf	89 53 10	 mov	 DWORD PTR [ebx+16], edx
  01db2	8b 01		 mov	 eax, DWORD PTR [ecx]
  01db4	85 c0		 test	 eax, eax
  01db6	74 03		 je	 SHORT $LN15@test_inser
  01db8	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
$LN15@test_inser:
  01dbb	89 19		 mov	 DWORD PTR [ecx], ebx
  01dbd	8b 5d f8	 mov	 ebx, DWORD PTR __he_hh_nxt$150711[ebp]
  01dc0	85 db		 test	 ebx, ebx
  01dc2	75 a2		 jne	 SHORT $LN21@test_inser
$LN23@test_inser:
  01dc4	8b 45 c0	 mov	 eax, DWORD PTR __he_bkt_i$150709[ebp]
  01dc7	8b 0f		 mov	 ecx, DWORD PTR [edi]
  01dc9	83 45 e4 0c	 add	 DWORD PTR tv7192[ebp], 12 ; 0000000cH
  01dcd	40		 inc	 eax
  01dce	89 45 c0	 mov	 DWORD PTR __he_bkt_i$150709[ebp], eax
  01dd1	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  01dd4	72 82		 jb	 SHORT $LL24@test_inser
  01dd6	33 db		 xor	 ebx, ebx
$LN22@test_inser:
  01dd8	8b 17		 mov	 edx, DWORD PTR [edi]
  01dda	8b 02		 mov	 eax, DWORD PTR [edx]
  01ddc	50		 push	 eax
  01ddd	e8 00 00 00 00	 call	 _free
  01de2	8b 07		 mov	 eax, DWORD PTR [edi]
  01de4	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01de7	03 c9		 add	 ecx, ecx
  01de9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  01dec	8b 07		 mov	 eax, DWORD PTR [edi]
  01dee	8b 4d c8	 mov	 ecx, DWORD PTR __he_new_buckets$150712[ebp]
  01df1	ba 01 00 00 00	 mov	 edx, 1
  01df6	01 50 08	 add	 DWORD PTR [eax+8], edx
  01df9	8b 07		 mov	 eax, DWORD PTR [edi]
  01dfb	89 08		 mov	 DWORD PTR [eax], ecx
  01dfd	8b 07		 mov	 eax, DWORD PTR [edi]
  01dff	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01e02	d1 e9		 shr	 ecx, 1
  01e04	83 c4 04	 add	 esp, 4
  01e07	39 48 1c	 cmp	 DWORD PTR [eax+28], ecx
  01e0a	76 07		 jbe	 SHORT $LN123@test_inser
  01e0c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01e0f	03 ca		 add	 ecx, edx
  01e11	eb 02		 jmp	 SHORT $LN124@test_inser
$LN123@test_inser:
  01e13	33 c9		 xor	 ecx, ecx
$LN124@test_inser:
  01e15	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  01e18	8b 07		 mov	 eax, DWORD PTR [edi]
  01e1a	39 50 20	 cmp	 DWORD PTR [eax+32], edx
  01e1d	76 03		 jbe	 SHORT $LN26@test_inser
  01e1f	89 50 24	 mov	 DWORD PTR [eax+36], edx
$LN26@test_inser:

; 1055 : #endif
; 1056 : 
; 1057 : 	START(DATA_UTHASH) {

  01e22	8b 45 e8	 mov	 eax, DWORD PTR _i$[ebp]
  01e25	40		 inc	 eax
  01e26	83 c7 34	 add	 edi, 52			; 00000034H
  01e29	89 45 e8	 mov	 DWORD PTR _i$[ebp], eax
  01e2c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?the_max@@3IA ; the_max
  01e32	0f 82 f1 fc ff
	ff		 jb	 $LN70@test_inser
$LN68@test_inser:

; 1062 : 	} STOP();

  01e38	8d 55 dc	 lea	 edx, DWORD PTR _t$235713[ebp]
  01e3b	52		 push	 edx
  01e3c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01e42	85 c0		 test	 eax, eax
  01e44	75 18		 jne	 SHORT $LN1084@test_inser
  01e46	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01e4a	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235705[ebp], xmm0
  01e4f	8b 7d f0	 mov	 edi, DWORD PTR $T235705[ebp+4]
  01e52	8b 75 ec	 mov	 esi, DWORD PTR $T235705[ebp]
  01e55	eb 5b		 jmp	 SHORT $LN1085@test_inser
$LN1173@test_inser:

; 1061 : 		HASH_ADD_INT(uthash, value, obj);

  01e57	6a ff		 push	 -1
  01e59	e8 00 00 00 00	 call	 _exit
$LN1274@test_inser:

; 1062 : 	} STOP();

$LN1084@test_inser:
  01e5e	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01e64	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01e6a	8b 45 e0	 mov	 eax, DWORD PTR _t$235713[ebp+4]
  01e6d	8b 4d dc	 mov	 ecx, DWORD PTR _t$235713[ebp]
  01e70	56		 push	 esi
  01e71	57		 push	 edi
  01e72	50		 push	 eax
  01e73	51		 push	 ecx
  01e74	e8 00 00 00 00	 call	 __alldvrm
  01e79	6a 00		 push	 0
  01e7b	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01e80	53		 push	 ebx
  01e81	51		 push	 ecx
  01e82	89 45 f4	 mov	 DWORD PTR tv2870[ebp], eax
  01e85	89 55 f8	 mov	 DWORD PTR tv2870[ebp+4], edx
  01e88	e8 00 00 00 00	 call	 __allmul
  01e8d	56		 push	 esi
  01e8e	57		 push	 edi
  01e8f	52		 push	 edx
  01e90	50		 push	 eax
  01e91	e8 00 00 00 00	 call	 __alldiv
  01e96	6a 00		 push	 0
  01e98	8b fa		 mov	 edi, edx
  01e9a	8b 55 f8	 mov	 edx, DWORD PTR tv2870[ebp+4]
  01e9d	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01ea2	8b f0		 mov	 esi, eax
  01ea4	8b 45 f4	 mov	 eax, DWORD PTR tv2870[ebp]
  01ea7	52		 push	 edx
  01ea8	50		 push	 eax
  01ea9	e8 00 00 00 00	 call	 __allmul
  01eae	03 f0		 add	 esi, eax
  01eb0	13 fa		 adc	 edi, edx
$LN1085@test_inser:
  01eb2	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  01eb8	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  01ebe	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  01ec4	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  01eca	75 64		 jne	 SHORT $LN1082@test_inser
  01ecc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01ed3	75 24		 jne	 SHORT $LN1080@test_inser
  01ed5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  01edb	6a 00		 push	 0
  01edd	51		 push	 ecx
  01ede	57		 push	 edi
  01edf	56		 push	 esi
  01ee0	e8 00 00 00 00	 call	 __aulldiv
  01ee5	50		 push	 eax
  01ee6	68 00 00 00 00	 push	 OFFSET $SG-102
  01eeb	e8 00 00 00 00	 call	 _printf
  01ef0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_data@@3IA ; the_data
  01ef6	83 c4 08	 add	 esp, 8
$LN1080@test_inser:
  01ef9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  01eff	6a 00		 push	 0
  01f01	52		 push	 edx
  01f02	57		 push	 edi
  01f03	56		 push	 esi
  01f04	e8 00 00 00 00	 call	 __aulldiv
  01f09	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  01f0f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01f15	c1 e1 04	 shl	 ecx, 4
  01f18	03 cb		 add	 ecx, ebx
  01f1a	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01f1d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  01f23	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  01f26	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  01f29	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1082@test_inser:

; 1063 : 
; 1064 : 	START(DATA_NEDTRIE) {

  01f30	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 6 ; the_start_data
  01f3a	83 fb 06	 cmp	 ebx, 6
  01f3d	0f 85 df 00 00
	00		 jne	 $LN10@test_inser
  01f43	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  01f4a	75 2f		 jne	 SHORT $LN1089@test_inser
  01f4c	8b 15 18 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+24
  01f52	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  01f57	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  01f5e	52		 push	 edx
  01f5f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  01f65	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  01f6c	51		 push	 ecx
  01f6d	50		 push	 eax
  01f6e	68 00 00 00 00	 push	 OFFSET $SG-101
  01f73	e8 00 00 00 00	 call	 _printf
  01f78	83 c4 10	 add	 esp, 16			; 00000010H
$LN1089@test_inser:
  01f7b	8d 4d d4	 lea	 ecx, DWORD PTR _t$235738[ebp]
  01f7e	51		 push	 ecx
  01f7f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  01f85	85 c0		 test	 eax, eax
  01f87	75 11		 jne	 SHORT $LN1095@test_inser
  01f89	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01f8d	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235731[ebp], xmm0
  01f92	8b 7d f0	 mov	 edi, DWORD PTR $T235731[ebp+4]
  01f95	8b 75 ec	 mov	 esi, DWORD PTR $T235731[ebp]
  01f98	eb 54		 jmp	 SHORT $LN1096@test_inser
$LN1095@test_inser:
  01f9a	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  01fa0	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  01fa6	8b 55 d8	 mov	 edx, DWORD PTR _t$235738[ebp+4]
  01fa9	8b 45 d4	 mov	 eax, DWORD PTR _t$235738[ebp]
  01fac	56		 push	 esi
  01fad	57		 push	 edi
  01fae	52		 push	 edx
  01faf	50		 push	 eax
  01fb0	e8 00 00 00 00	 call	 __alldvrm
  01fb5	6a 00		 push	 0
  01fb7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01fbc	53		 push	 ebx
  01fbd	51		 push	 ecx
  01fbe	89 45 f4	 mov	 DWORD PTR tv4357[ebp], eax
  01fc1	89 55 f8	 mov	 DWORD PTR tv4357[ebp+4], edx
  01fc4	e8 00 00 00 00	 call	 __allmul
  01fc9	56		 push	 esi
  01fca	57		 push	 edi
  01fcb	52		 push	 edx
  01fcc	50		 push	 eax
  01fcd	e8 00 00 00 00	 call	 __alldiv
  01fd2	8b 4d f8	 mov	 ecx, DWORD PTR tv4357[ebp+4]
  01fd5	6a 00		 push	 0
  01fd7	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  01fdc	8b fa		 mov	 edi, edx
  01fde	8b 55 f4	 mov	 edx, DWORD PTR tv4357[ebp]
  01fe1	51		 push	 ecx
  01fe2	52		 push	 edx
  01fe3	8b f0		 mov	 esi, eax
  01fe5	e8 00 00 00 00	 call	 __allmul
  01fea	03 f0		 add	 esi, eax
  01fec	13 fa		 adc	 edi, edx
$LN1096@test_inser:
  01fee	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?the_max@@3IA ; the_max
  01ff4	89 3d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, edi
  01ffa	33 ff		 xor	 edi, edi
  01ffc	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  02002	85 db		 test	 ebx, ebx
  02004	74 1c		 je	 SHORT $LN10@test_inser
  02006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?NEDTRIE@@3PAUnedtrie_object@@A ; NEDTRIE
$LN12@test_inser:

; 1065 : 		unsigned key = INSERT[i];
; 1066 : 		NEDTRIE[i].value = key;

  0200c	8b 45 08	 mov	 eax, DWORD PTR _INSERT$[ebp]
  0200f	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  02012	89 4e 14	 mov	 DWORD PTR [esi+20], ecx

; 1067 : 		NEDTRIE_INSERT(nedtrie_t, &nedtrie, &NEDTRIE[i]);

  02015	e8 00 00 00 00	 call	 ?nedtrie_t_NEDTRIE_INSERT@@YAXPIAUnedtrie_t@@PIAUnedtrie_object@@@Z ; nedtrie_t_NEDTRIE_INSERT
  0201a	47		 inc	 edi
  0201b	83 c6 28	 add	 esi, 40			; 00000028H
  0201e	3b fb		 cmp	 edi, ebx
  02020	72 ea		 jb	 SHORT $LN12@test_inser
$LN10@test_inser:

; 1068 : 	} STOP();

  02022	8d 55 ec	 lea	 edx, DWORD PTR _t$235759[ebp]
  02025	52		 push	 edx
  02026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  0202c	85 c0		 test	 eax, eax
  0202e	75 11		 jne	 SHORT $LN1102@test_inser
  02030	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02034	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235751[ebp], xmm0
  02039	8b 5d f0	 mov	 ebx, DWORD PTR $T235751[ebp+4]
  0203c	8b 75 ec	 mov	 esi, DWORD PTR $T235751[ebp]
  0203f	eb 54		 jmp	 SHORT $LN1103@test_inser
$LN1102@test_inser:
  02041	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  02047	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  0204d	8b 45 f0	 mov	 eax, DWORD PTR _t$235759[ebp+4]
  02050	8b 4d ec	 mov	 ecx, DWORD PTR _t$235759[ebp]
  02053	56		 push	 esi
  02054	57		 push	 edi
  02055	50		 push	 eax
  02056	51		 push	 ecx
  02057	e8 00 00 00 00	 call	 __alldvrm
  0205c	6a 00		 push	 0
  0205e	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  02063	53		 push	 ebx
  02064	51		 push	 ecx
  02065	89 45 f4	 mov	 DWORD PTR tv3110[ebp], eax
  02068	89 55 f8	 mov	 DWORD PTR tv3110[ebp+4], edx
  0206b	e8 00 00 00 00	 call	 __allmul
  02070	56		 push	 esi
  02071	57		 push	 edi
  02072	52		 push	 edx
  02073	50		 push	 eax
  02074	e8 00 00 00 00	 call	 __alldiv
  02079	6a 00		 push	 0
  0207b	8b da		 mov	 ebx, edx
  0207d	8b 55 f8	 mov	 edx, DWORD PTR tv3110[ebp+4]
  02080	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  02085	8b f0		 mov	 esi, eax
  02087	8b 45 f4	 mov	 eax, DWORD PTR tv3110[ebp]
  0208a	52		 push	 edx
  0208b	50		 push	 eax
  0208c	e8 00 00 00 00	 call	 __allmul
  02091	03 f0		 add	 esi, eax
  02093	13 da		 adc	 ebx, edx
$LN1103@test_inser:
  02095	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  0209b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  020a1	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  020a7	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  020ad	75 64		 jne	 SHORT $LN1100@test_inser
  020af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  020b6	75 24		 jne	 SHORT $LN1098@test_inser
  020b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  020be	6a 00		 push	 0
  020c0	51		 push	 ecx
  020c1	53		 push	 ebx
  020c2	56		 push	 esi
  020c3	e8 00 00 00 00	 call	 __aulldiv
  020c8	50		 push	 eax
  020c9	68 00 00 00 00	 push	 OFFSET $SG-102
  020ce	e8 00 00 00 00	 call	 _printf
  020d3	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  020d9	83 c4 08	 add	 esp, 8
$LN1098@test_inser:
  020dc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  020e2	6a 00		 push	 0
  020e4	52		 push	 edx
  020e5	53		 push	 ebx
  020e6	56		 push	 esi
  020e7	e8 00 00 00 00	 call	 __aulldiv
  020ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  020f2	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  020f8	c1 e1 04	 shl	 ecx, 4
  020fb	03 cf		 add	 ecx, edi
  020fd	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  02100	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  02106	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  02109	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0210c	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1100@test_inser:

; 1069 : 
; 1070 : #ifdef USE_JUDY
; 1071 : 	START(DATA_JUDY) {

  02113	c7 05 00 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 9 ; the_start_data
  0211d	83 ff 09	 cmp	 edi, 9
  02120	0f 85 00 01 00
	00		 jne	 $LN6@test_inser
  02126	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  0212d	75 2f		 jne	 SHORT $LN1107@test_inser
  0212f	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+36
  02135	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  0213a	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  02141	52		 push	 edx
  02142	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  02148	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0214f	51		 push	 ecx
  02150	50		 push	 eax
  02151	68 00 00 00 00	 push	 OFFSET $SG-101
  02156	e8 00 00 00 00	 call	 _printf
  0215b	83 c4 10	 add	 esp, 16			; 00000010H
$LN1107@test_inser:
  0215e	8d 4d dc	 lea	 ecx, DWORD PTR _t$235784[ebp]
  02161	51		 push	 ecx
  02162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  02168	85 c0		 test	 eax, eax
  0216a	75 11		 jne	 SHORT $LN1113@test_inser
  0216c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02170	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235777[ebp], xmm0
  02175	8b 5d f0	 mov	 ebx, DWORD PTR $T235777[ebp+4]
  02178	8b 75 ec	 mov	 esi, DWORD PTR $T235777[ebp]
  0217b	eb 54		 jmp	 SHORT $LN1114@test_inser
$LN1113@test_inser:
  0217d	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  02183	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  02189	8b 55 e0	 mov	 edx, DWORD PTR _t$235784[ebp+4]
  0218c	8b 45 dc	 mov	 eax, DWORD PTR _t$235784[ebp]
  0218f	56		 push	 esi
  02190	57		 push	 edi
  02191	52		 push	 edx
  02192	50		 push	 eax
  02193	e8 00 00 00 00	 call	 __alldvrm
  02198	6a 00		 push	 0
  0219a	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0219f	53		 push	 ebx
  021a0	51		 push	 ecx
  021a1	89 45 f4	 mov	 DWORD PTR tv3193[ebp], eax
  021a4	89 55 f8	 mov	 DWORD PTR tv3193[ebp+4], edx
  021a7	e8 00 00 00 00	 call	 __allmul
  021ac	56		 push	 esi
  021ad	57		 push	 edi
  021ae	52		 push	 edx
  021af	50		 push	 eax
  021b0	e8 00 00 00 00	 call	 __alldiv
  021b5	8b 4d f8	 mov	 ecx, DWORD PTR tv3193[ebp+4]
  021b8	6a 00		 push	 0
  021ba	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  021bf	8b da		 mov	 ebx, edx
  021c1	8b 55 f4	 mov	 edx, DWORD PTR tv3193[ebp]
  021c4	51		 push	 ecx
  021c5	52		 push	 edx
  021c6	8b f0		 mov	 esi, eax
  021c8	e8 00 00 00 00	 call	 __allmul
  021cd	03 f0		 add	 esi, eax
  021cf	13 da		 adc	 ebx, edx
$LN1114@test_inser:
  021d1	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  021d7	33 f6		 xor	 esi, esi
  021d9	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  021df	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  021e5	76 3f		 jbe	 SHORT $LN6@test_inser
  021e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  021ed	8b 7d 08	 mov	 edi, DWORD PTR _INSERT$[ebp]
  021f0	33 db		 xor	 ebx, ebx
$LL8@test_inser:

; 1072 : 		unsigned key = INSERT[i];

  021f2	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]

; 1073 : 		Pvoid_t PValue;
; 1074 : 		JUDY[i].value = key;

  021f5	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax

; 1075 : 		JLI(PValue, judy, key);

  021f8	8d 4d 9c	 lea	 ecx, DWORD PTR _J_Error$150741[ebp]
  021fb	51		 push	 ecx
  021fc	50		 push	 eax
  021fd	68 00 00 00 00	 push	 OFFSET ?judy@@3PAXA	; judy
  02202	e8 00 00 00 00	 call	 _JudyLIns
  02207	83 c4 0c	 add	 esp, 12			; 0000000cH
  0220a	83 f8 ff	 cmp	 eax, -1
  0220d	74 39		 je	 SHORT $LN1176@test_inser

; 1076 : 		*(struct judy_object**)PValue = &JUDY[i];

  0220f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDY@@3PAUjudy_object@@A ; JUDY
  02215	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  02218	46		 inc	 esi
  02219	83 c3 14	 add	 ebx, 20			; 00000014H
  0221c	89 10		 mov	 DWORD PTR [eax], edx
  0221e	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  02224	72 cc		 jb	 SHORT $LL8@test_inser
$LN6@test_inser:

; 1077 : 	} STOP();

  02226	8d 55 dc	 lea	 edx, DWORD PTR _t$235805[ebp]
  02229	52		 push	 edx
  0222a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  02230	85 c0		 test	 eax, eax
  02232	75 48		 jne	 SHORT $LN1120@test_inser
  02234	66 0f 57 c0	 xorpd	 xmm0, xmm0
  02238	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235797[ebp], xmm0
  0223d	8b 5d f0	 mov	 ebx, DWORD PTR $T235797[ebp+4]
  02240	8b 75 ec	 mov	 esi, DWORD PTR $T235797[ebp]
  02243	e9 88 00 00 00	 jmp	 $LN1121@test_inser
$LN1176@test_inser:

; 1075 : 		JLI(PValue, judy, key);

  02248	8b 45 a0	 mov	 eax, DWORD PTR _J_Error$150741[ebp+4]
  0224b	8b 4d 9c	 mov	 ecx, DWORD PTR _J_Error$150741[ebp]
  0224e	50		 push	 eax
  0224f	51		 push	 ecx
  02250	68 00 00 00 00	 push	 OFFSET $SG-106
  02255	68 33 04 00 00	 push	 1075			; 00000433H
  0225a	68 00 00 00 00	 push	 OFFSET $SG-107
  0225f	68 00 00 00 00	 push	 OFFSET $SG-108
  02264	e8 00 00 00 00	 call	 ___iob_func
  02269	83 c0 40	 add	 eax, 64			; 00000040H
  0226c	50		 push	 eax
  0226d	e8 00 00 00 00	 call	 _fprintf
  02272	83 c4 1c	 add	 esp, 28			; 0000001cH
  02275	6a 01		 push	 1
  02277	e8 00 00 00 00	 call	 _exit
$LN1275@test_inser:

; 1077 : 	} STOP();

$LN1120@test_inser:
  0227c	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  02282	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  02288	8b 45 e0	 mov	 eax, DWORD PTR _t$235805[ebp+4]
  0228b	8b 4d dc	 mov	 ecx, DWORD PTR _t$235805[ebp]
  0228e	56		 push	 esi
  0228f	57		 push	 edi
  02290	50		 push	 eax
  02291	51		 push	 ecx
  02292	e8 00 00 00 00	 call	 __alldvrm
  02297	6a 00		 push	 0
  02299	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0229e	53		 push	 ebx
  0229f	51		 push	 ecx
  022a0	89 45 f4	 mov	 DWORD PTR tv3226[ebp], eax
  022a3	89 55 f8	 mov	 DWORD PTR tv3226[ebp+4], edx
  022a6	e8 00 00 00 00	 call	 __allmul
  022ab	56		 push	 esi
  022ac	57		 push	 edi
  022ad	52		 push	 edx
  022ae	50		 push	 eax
  022af	e8 00 00 00 00	 call	 __alldiv
  022b4	6a 00		 push	 0
  022b6	8b da		 mov	 ebx, edx
  022b8	8b 55 f8	 mov	 edx, DWORD PTR tv3226[ebp+4]
  022bb	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  022c0	8b f0		 mov	 esi, eax
  022c2	8b 45 f4	 mov	 eax, DWORD PTR tv3226[ebp]
  022c5	52		 push	 edx
  022c6	50		 push	 eax
  022c7	e8 00 00 00 00	 call	 __allmul
  022cc	03 f0		 add	 esi, eax
  022ce	13 da		 adc	 ebx, edx
$LN1121@test_inser:
  022d0	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  022d6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  022dc	1b 1d 04 00 00
	00		 sbb	 ebx, DWORD PTR ?the_time@@3_KA+4
  022e2	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?the_start_data@@3IA ; the_start_data
  022e8	75 64		 jne	 SHORT $LN1118@test_inser
  022ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  022f1	75 24		 jne	 SHORT $LN1116@test_inser
  022f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  022f9	6a 00		 push	 0
  022fb	51		 push	 ecx
  022fc	53		 push	 ebx
  022fd	56		 push	 esi
  022fe	e8 00 00 00 00	 call	 __aulldiv
  02303	50		 push	 eax
  02304	68 00 00 00 00	 push	 OFFSET $SG-102
  02309	e8 00 00 00 00	 call	 _printf
  0230e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?the_data@@3IA ; the_data
  02314	83 c4 08	 add	 esp, 8
$LN1116@test_inser:
  02317	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_max@@3IA ; the_max
  0231d	6a 00		 push	 0
  0231f	52		 push	 edx
  02320	53		 push	 ebx
  02321	56		 push	 esi
  02322	e8 00 00 00 00	 call	 __aulldiv
  02327	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_retry@@3IA ; the_retry
  0232d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  02333	c1 e1 04	 shl	 ecx, 4
  02336	03 cf		 add	 ecx, edi
  02338	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  0233b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_operation@@3IA ; the_operation
  02341	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  02344	8d 0c 4a	 lea	 ecx, DWORD PTR [edx+ecx*2]
  02347	89 04 8d 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[ecx*4], eax
$LN1118@test_inser:

; 1078 : #endif
; 1079 : 
; 1080 : #ifdef USE_JUDYARRAY
; 1081 : 	START(DATA_JUDYARRAY) {

  0234e	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?the_start_data@@3IA, 10 ; the_start_data, 0000000aH
  02358	83 ff 0a	 cmp	 edi, 10			; 0000000aH
  0235b	0f 85 fb 00 00
	00		 jne	 $LN1@test_inser
  02361	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  02368	75 2f		 jne	 SHORT $LN1125@test_inser
  0236a	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA+40
  02370	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  02375	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  0237c	52		 push	 edx
  0237d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  02383	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR ?ORDER_NAME@@3PAPBDA[edx*4]
  0238a	51		 push	 ecx
  0238b	50		 push	 eax
  0238c	68 00 00 00 00	 push	 OFFSET $SG-101
  02391	e8 00 00 00 00	 call	 _printf
  02396	83 c4 10	 add	 esp, 16			; 00000010H
$LN1125@test_inser:
  02399	8d 4d d4	 lea	 ecx, DWORD PTR _t$235830[ebp]
  0239c	51		 push	 ecx
  0239d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  023a3	85 c0		 test	 eax, eax
  023a5	75 11		 jne	 SHORT $LN1131@test_inser
  023a7	66 0f 57 c0	 xorpd	 xmm0, xmm0
  023ab	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235823[ebp], xmm0
  023b0	8b 5d f0	 mov	 ebx, DWORD PTR $T235823[ebp+4]
  023b3	8b 75 ec	 mov	 esi, DWORD PTR $T235823[ebp]
  023b6	eb 54		 jmp	 SHORT $LN1132@test_inser
$LN1131@test_inser:
  023b8	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  023be	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  023c4	8b 55 d8	 mov	 edx, DWORD PTR _t$235830[ebp+4]
  023c7	8b 45 d4	 mov	 eax, DWORD PTR _t$235830[ebp]
  023ca	56		 push	 esi
  023cb	57		 push	 edi
  023cc	52		 push	 edx
  023cd	50		 push	 eax
  023ce	e8 00 00 00 00	 call	 __alldvrm
  023d3	6a 00		 push	 0
  023d5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  023da	53		 push	 ebx
  023db	51		 push	 ecx
  023dc	89 45 f4	 mov	 DWORD PTR tv4335[ebp], eax
  023df	89 55 f8	 mov	 DWORD PTR tv4335[ebp+4], edx
  023e2	e8 00 00 00 00	 call	 __allmul
  023e7	56		 push	 esi
  023e8	57		 push	 edi
  023e9	52		 push	 edx
  023ea	50		 push	 eax
  023eb	e8 00 00 00 00	 call	 __alldiv
  023f0	8b 4d f8	 mov	 ecx, DWORD PTR tv4335[ebp+4]
  023f3	6a 00		 push	 0
  023f5	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  023fa	8b da		 mov	 ebx, edx
  023fc	8b 55 f4	 mov	 edx, DWORD PTR tv4335[ebp]
  023ff	51		 push	 ecx
  02400	52		 push	 edx
  02401	8b f0		 mov	 esi, eax
  02403	e8 00 00 00 00	 call	 __allmul
  02408	03 f0		 add	 esi, eax
  0240a	13 da		 adc	 ebx, edx
$LN1132@test_inser:
  0240c	89 35 00 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA, esi
  02412	33 f6		 xor	 esi, esi
  02414	89 1d 04 00 00
	00		 mov	 DWORD PTR ?the_time@@3_KA+4, ebx
  0241a	39 35 00 00 00
	00		 cmp	 DWORD PTR ?the_max@@3IA, esi ; the_max
  02420	76 3a		 jbe	 SHORT $LN1@test_inser
  02422	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  02428	8b 7d 08	 mov	 edi, DWORD PTR _INSERT$[ebp]
  0242b	33 db		 xor	 ebx, ebx
  0242d	8d 49 00	 npad	 3
$LL3@test_inser:

; 1082 : 		judyvalue key = INSERT[i];

  02430	8b 04 b7	 mov	 eax, DWORD PTR [edi+esi*4]
  02433	89 45 f8	 mov	 DWORD PTR _key$150754[ebp], eax

; 1083 : 		JudySlot* pvalue;
; 1084 : 		JUDYARRAY[i].value = key;

  02436	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax

; 1085 : 		pvalue = judy_cell(judyarray, (uchar*)&key, 0);

  02439	8d 45 f8	 lea	 eax, DWORD PTR _key$150754[ebp]
  0243c	50		 push	 eax
  0243d	e8 00 00 00 00	 call	 ?judy_cell@@YAPAIPAUJudy@@PAEI@Z ; judy_cell

; 1086 : 		*(struct judyarray_object**)pvalue = &JUDYARRAY[i];

  02442	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?JUDYARRAY@@3PAUjudyarray_object@@A ; JUDYARRAY
  02448	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
  0244b	46		 inc	 esi
  0244c	83 c4 04	 add	 esp, 4
  0244f	83 c3 14	 add	 ebx, 20			; 00000014H
  02452	89 10		 mov	 DWORD PTR [eax], edx
  02454	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?the_max@@3IA ; the_max
  0245a	72 d4		 jb	 SHORT $LL3@test_inser
$LN1@test_inser:

; 1087 : 	} STOP();

  0245c	8d 45 ec	 lea	 eax, DWORD PTR _t$235851[ebp]
  0245f	50		 push	 eax
  02460	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceCounter@4
  02466	85 c0		 test	 eax, eax
  02468	75 11		 jne	 SHORT $LN1138@test_inser
  0246a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0246e	66 0f 13 45 ec	 movlpd	 QWORD PTR $T235843[ebp], xmm0
  02473	8b 7d f0	 mov	 edi, DWORD PTR $T235843[ebp+4]
  02476	8b 75 ec	 mov	 esi, DWORD PTR $T235843[ebp]
  02479	eb 54		 jmp	 SHORT $LN1139@test_inser
$LN1138@test_inser:
  0247b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR _win_frequency+4
  02481	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _win_frequency
  02487	8b 4d f0	 mov	 ecx, DWORD PTR _t$235851[ebp+4]
  0248a	8b 55 ec	 mov	 edx, DWORD PTR _t$235851[ebp]
  0248d	56		 push	 esi
  0248e	57		 push	 edi
  0248f	51		 push	 ecx
  02490	52		 push	 edx
  02491	e8 00 00 00 00	 call	 __alldvrm
  02496	6a 00		 push	 0
  02498	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  0249d	53		 push	 ebx
  0249e	51		 push	 ecx
  0249f	89 45 f4	 mov	 DWORD PTR tv4328[ebp], eax
  024a2	89 55 f8	 mov	 DWORD PTR tv4328[ebp+4], edx
  024a5	e8 00 00 00 00	 call	 __allmul
  024aa	56		 push	 esi
  024ab	57		 push	 edi
  024ac	52		 push	 edx
  024ad	50		 push	 eax
  024ae	e8 00 00 00 00	 call	 __alldiv
  024b3	8b 4d f4	 mov	 ecx, DWORD PTR tv4328[ebp]
  024b6	6a 00		 push	 0
  024b8	8b f0		 mov	 esi, eax
  024ba	8b 45 f8	 mov	 eax, DWORD PTR tv4328[ebp+4]
  024bd	68 00 ca 9a 3b	 push	 1000000000		; 3b9aca00H
  024c2	50		 push	 eax
  024c3	51		 push	 ecx
  024c4	8b fa		 mov	 edi, edx
  024c6	e8 00 00 00 00	 call	 __allmul
  024cb	03 f0		 add	 esi, eax
  024cd	13 fa		 adc	 edi, edx
$LN1139@test_inser:
  024cf	2b 35 00 00 00
	00		 sub	 esi, DWORD PTR ?the_time@@3_KA
  024d5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_data@@3IA ; the_data
  024db	1b 3d 04 00 00
	00		 sbb	 edi, DWORD PTR ?the_time@@3_KA+4
  024e1	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?the_start_data@@3IA ; the_start_data
  024e7	75 61		 jne	 SHORT $LN1136@test_inser
  024e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  024f0	75 1d		 jne	 SHORT $LN1134@test_inser
  024f2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_max@@3IA ; the_max
  024f7	6a 00		 push	 0
  024f9	50		 push	 eax
  024fa	57		 push	 edi
  024fb	56		 push	 esi
  024fc	e8 00 00 00 00	 call	 __aulldiv
  02501	50		 push	 eax
  02502	68 00 00 00 00	 push	 OFFSET $SG-102
  02507	e8 00 00 00 00	 call	 _printf
  0250c	83 c4 08	 add	 esp, 8
$LN1134@test_inser:
  0250f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  02515	6a 00		 push	 0
  02517	51		 push	 ecx
  02518	57		 push	 edi
  02519	56		 push	 esi
  0251a	e8 00 00 00 00	 call	 __aulldiv
  0251f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_retry@@3IA ; the_retry
  02525	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  0252b	c1 e2 04	 shl	 edx, 4
  0252e	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?the_data@@3IA ; the_data
  02534	8d 0c 51	 lea	 ecx, DWORD PTR [ecx+edx*2]
  02537	8d 14 49	 lea	 edx, DWORD PTR [ecx+ecx*2]
  0253a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  02540	8d 14 51	 lea	 edx, DWORD PTR [ecx+edx*2]
  02543	89 04 95 00 00
	00 00		 mov	 DWORD PTR ?LOG@@3PAY2BA@15IA[edx*4], eax
$LN1136@test_inser:

; 1088 : #endif
; 1089 : }

  0254a	5f		 pop	 edi
  0254b	5e		 pop	 esi
  0254c	5b		 pop	 ebx
  0254d	8b e5		 mov	 esp, ebp
  0254f	5d		 pop	 ebp
  02550	c3		 ret	 0
$LN1266@test_inser:
?test_insert@@YAXPAI@Z ENDP				; test_insert
_TEXT	ENDS
PUBLIC	?test_operation@@YAXPAI0@Z			; test_operation
; Function compile flags: /Ogtp
;	COMDAT ?test_operation@@YAXPAI0@Z
_TEXT	SEGMENT
?test_operation@@YAXPAI0@Z PROC				; test_operation, COMDAT
; _INSERT$ = edi
; _SEARCH$ = esi

; 2145 : {

  00000	51		 push	 ecx

; 2146 : 	cache_clear();

  00001	33 c0		 xor	 eax, eax
  00003	eb 0b 8d a4 24
	00 00 00 00 8d
	64 24 00	 npad	 13
$LL5@test_opera:
  00010	fe 80 00 00 00
	00		 inc	 BYTE PTR ?CACHE@@3PAEA[eax]
  00016	83 c0 20	 add	 eax, 32			; 00000020H
  00019	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0001e	72 f0		 jb	 SHORT $LL5@test_opera
  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 2147 : 
; 2148 : 	OPERATION(OPERATION_INSERT);
; 2149 : 	test_insert(INSERT);

  00028	57		 push	 edi
  00029	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 0 ; the_operation
  00033	e8 00 00 00 00	 call	 ?test_insert@@YAXPAI@Z	; test_insert
  00038	83 c4 04	 add	 esp, 4

; 2150 : 
; 2151 : 	OPERATION(OPERATION_CHANGE);
; 2152 : 	test_change(SEARCH, INSERT);

  0003b	57		 push	 edi
  0003c	56		 push	 esi
  0003d	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 4 ; the_operation
  00047	e8 00 00 00 00	 call	 ?test_change@@YAXPAI0@Z	; test_change

; 2153 : 
; 2154 : 	OPERATION(OPERATION_HIT);
; 2155 : 	test_hit(SEARCH);

  0004c	56		 push	 esi
  0004d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 1 ; the_operation
  00057	e8 00 00 00 00	 call	 ?test_hit@@YAXPAI@Z	; test_hit
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2156 : 
; 2157 : 	OPERATION(OPERATION_MISS);
; 2158 : 	test_miss(SEARCH);

  0005f	56		 push	 esi
  00060	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 2 ; the_operation
  0006a	e8 00 00 00 00	 call	 ?test_miss@@YAXPAI@Z	; test_miss
  0006f	83 c4 04	 add	 esp, 4

; 2159 : 
; 2160 : 	OPERATION(OPERATION_SIZE);

  00072	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 3 ; the_operation

; 2161 : 	test_size();

  0007c	e8 00 00 00 00	 call	 ?test_size@@YAXXZ	; test_size

; 2162 : 
; 2163 : 	OPERATION(OPERATION_REMOVE);
; 2164 : 	test_remove(SEARCH);

  00081	56		 push	 esi
  00082	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, 5 ; the_operation
  0008c	e8 00 00 00 00	 call	 ?test_remove@@YAXPAI@Z	; test_remove
  00091	83 c4 04	 add	 esp, 4
  00094	59		 pop	 ecx

; 2165 : }

  00095	c3		 ret	 0
?test_operation@@YAXPAI0@Z ENDP				; test_operation
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@408f400000000000
PUBLIC	?test@@YAXIIHH@Z				; test
EXTRN	___libm_sse2_pow:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?test@@YAXIIHH@Z
_TEXT	SEGMENT
_buf$236024 = -160					; size = 128
_buf$236012 = -160					; size = 128
_f$ = -32						; size = 8
_b$ = -24						; size = 8
tv604 = -16						; size = 8
tv606 = -12						; size = 4
_retry$153105 = -4					; size = 4
tv609 = -2						; size = 2
_size$ = 8						; size = 4
_data$ = 12						; size = 4
_log$ = 16						; size = 4
_sparse$ = 20						; size = 4
?test@@YAXIIHH@Z PROC					; test, COMDAT

; 2176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H

; 2177 : 	double b;
; 2178 : 	double f;
; 2179 : 
; 2180 : 	b = 1000;

  00009	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@408f400000000000

; 2181 : 	f = pow(10, 0.1);

  00011	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3fb999999999999a
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	f2 0f 11 45 e8	 movsd	 QWORD PTR _b$[ebp], xmm0
  00020	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4024000000000000
  00028	57		 push	 edi
  00029	e8 00 00 00 00	 call	 ___libm_sse2_pow

; 2182 : 
; 2183 : 	/* log if batch test or requested */
; 2184 : 	the_log = (size == 0 && data == DATA_MAX) || log;

  0002e	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  00031	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
  00034	33 c0		 xor	 eax, eax
  00036	f2 0f 11 45 e0	 movsd	 QWORD PTR _f$[ebp], xmm0
  0003b	3b f8		 cmp	 edi, eax
  0003d	75 05		 jne	 SHORT $LN53@test
  0003f	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00042	74 0f		 je	 SHORT $LN54@test
$LN53@test:
  00044	39 45 10	 cmp	 DWORD PTR _log$[ebp], eax
  00047	75 0a		 jne	 SHORT $LN54@test
  00049	a3 00 00 00 00	 mov	 DWORD PTR ?the_log@@3HA, eax ; the_log
  0004e	e9 cf 00 00 00	 jmp	 $LN47@test
$LN54@test:
  00053	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?the_log@@3HA, 1 ; the_log

; 2185 : 
; 2186 : 	/* write the header */
; 2187 : 	if (the_log)
; 2188 : 	for(the_order=0;the_order<ORDER_MAX;++the_order) {

  0005d	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
$LN49@test:

; 2189 : 		for(the_operation=0;the_operation<OPERATION_MAX;++the_operation) {

  00062	33 c0		 xor	 eax, eax
  00064	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
$LN46@test:

; 2190 : 			FILE* f = open("wt");

  00069	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_order@@3IA ; the_order
  00076	8b 14 8d 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[ecx*4]
  0007d	50		 push	 eax
  0007e	52		 push	 edx
  0007f	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf$236012[ebp]
  00085	68 00 00 00 00	 push	 OFFSET $SG-105
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _sprintf
  00090	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _buf$236012[ebp]
  00096	68 00 00 00 00	 push	 OFFSET $SG-118
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _fopen
  000a1	8b f0		 mov	 esi, eax

; 2191 : 			fprintf(f, "0\t");

  000a3	68 00 00 00 00	 push	 OFFSET $SG-119
  000a8	56		 push	 esi
  000a9	e8 00 00 00 00	 call	 _fprintf
  000ae	83 c4 20	 add	 esp, 32			; 00000020H

; 2192 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  000b1	33 c0		 xor	 eax, eax
  000b3	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000b8	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL43@test:

; 2193 : 				if (is_listed(the_data))
; 2194 : 					fprintf(f, "%s\t", DATA_NAME[the_data]);

  000c0	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?DATA_NAME@@3PAPBDA[eax*4]
  000c7	52		 push	 edx
  000c8	68 00 00 00 00	 push	 OFFSET $SG-120
  000cd	56		 push	 esi
  000ce	e8 00 00 00 00	 call	 _fprintf
  000d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  000d8	40		 inc	 eax
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000dc	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  000e1	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e4	72 da		 jb	 SHORT $LL43@test

; 2195 : 			}
; 2196 : 			fprintf(f, "\n");

  000e6	68 00 00 00 00	 push	 OFFSET $SG-121
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 _fprintf

; 2197 : 			fclose(f);

  000f1	56		 push	 esi
  000f2	e8 00 00 00 00	 call	 _fclose
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  000fc	40		 inc	 eax
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH
  00100	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
  00105	83 f8 06	 cmp	 eax, 6
  00108	0f 82 5b ff ff
	ff		 jb	 $LN46@test

; 2185 : 
; 2186 : 	/* write the header */
; 2187 : 	if (the_log)
; 2188 : 	for(the_order=0;the_order<ORDER_MAX;++the_order) {

  0010e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00113	40		 inc	 eax
  00114	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00119	83 f8 02	 cmp	 eax, 2
  0011c	0f 82 40 ff ff
	ff		 jb	 $LN49@test
$LN47@test:

; 2198 : 		}
; 2199 : 	}
; 2200 : 
; 2201 : 	if (size != 0)

  00122	85 ff		 test	 edi, edi
  00124	74 36		 je	 SHORT $LN39@test

; 2202 : 		the_max = size;

  00126	8b cf		 mov	 ecx, edi
  00128	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max

; 2205 : 
; 2206 : 	while (the_max <= MAX) {

  0012e	81 ff 80 96 98
	00		 cmp	 edi, 10000000		; 00989680H
  00134	0f 87 0f 03 00
	00		 ja	 $LN79@test
  0013a	8d 9b 00 00 00
	00		 npad	 6
$LL37@test:

; 2207 : 		unsigned retry;
; 2208 : 	
; 2209 : 		/* number of retries to avoid spikes */
; 2210 : 		retry = MIN_TRY / the_max;

  00140	33 d2		 xor	 edx, edx
  00142	b8 80 84 1e 00	 mov	 eax, 2000000		; 001e8480H
  00147	f7 f1		 div	 ecx
  00149	8b f8		 mov	 edi, eax
  0014b	89 7d fc	 mov	 DWORD PTR _retry$153105[ebp], edi

; 2211 : 		if (retry < 1)

  0014e	83 ff 01	 cmp	 edi, 1
  00151	73 16		 jae	 SHORT $LN35@test

; 2212 : 			retry = 1;

  00153	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _retry$153105[ebp], 1

; 2213 : 		if (retry > RETRY_MAX)

  0015a	eb 19		 jmp	 SHORT $LN118@test
$LN39@test:

; 2203 : 	else
; 2204 : 		the_max = (unsigned)b;

  0015c	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00161	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max

; 2205 : 
; 2206 : 	while (the_max <= MAX) {

  00167	eb d7		 jmp	 SHORT $LL37@test
$LN35@test:

; 2213 : 		if (retry > RETRY_MAX)

  00169	83 ff 07	 cmp	 edi, 7
  0016c	76 0a		 jbe	 SHORT $LN34@test

; 2214 : 			retry = RETRY_MAX;

  0016e	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR _retry$153105[ebp], 7
$LN118@test:
  00175	8b 7d fc	 mov	 edi, DWORD PTR _retry$153105[ebp]
$LN34@test:

; 2215 : 		if (size != 0)

  00178	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0017c	74 0a		 je	 SHORT $LN33@test

; 2216 : 			retry = 1;

  0017e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _retry$153105[ebp], 1
  00185	8b 7d fc	 mov	 edi, DWORD PTR _retry$153105[ebp]
$LN33@test:

; 2217 : 
; 2218 : 		/* clear the log */
; 2219 : 		memset(LOG, 0, sizeof(LOG));

  00188	68 00 15 00 00	 push	 5376			; 00001500H
  0018d	6a 00		 push	 0
  0018f	68 00 00 00 00	 push	 OFFSET ?LOG@@3PAY2BA@15IA ; LOG
  00194	e8 00 00 00 00	 call	 _memset

; 2220 : 
; 2221 : 		order_init(the_max, sparse);

  00199	8b 45 14	 mov	 eax, DWORD PTR _sparse$[ebp]
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ?order_init@@YAXHH@Z	; order_init
  001a5	83 c4 04	 add	 esp, 4

; 2222 : 
; 2223 : 		/* run the test */
; 2224 : 		for(the_retry=0;the_retry<retry;++the_retry) {

  001a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_retry@@3IA, 0 ; the_retry
  001b2	85 ff		 test	 edi, edi
  001b4	0f 84 f7 00 00
	00		 je	 $LN30@test
$LN32@test:

; 2225 : 			/* data */
; 2226 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  001ba	33 c9		 xor	 ecx, ecx
  001bc	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_data@@3IA, ecx ; the_data
$LN29@test:

; 2227 : 				if (!is_listed(the_data))
; 2228 : 					continue;
; 2229 : 
; 2230 : 				if (data != DATA_MAX && data != the_data)

  001c2	83 fb 10	 cmp	 ebx, 16			; 00000010H
  001c5	74 08		 je	 SHORT $LN25@test
  001c7	3b d9		 cmp	 ebx, ecx
  001c9	0f 85 bf 00 00
	00		 jne	 $LN28@test
$LN25@test:

; 2231 : 					continue;
; 2232 : 
; 2233 : 				for(the_order=0;the_order<ORDER_MAX;++the_order) {

  001cf	33 c0		 xor	 eax, eax
  001d1	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  001d6	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$LL24@test:

; 2234 : 					printf("%d %s %s", the_max, DATA_NAME[the_data], ORDER_NAME[the_order]);

  001e0	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  001e7	8b 04 8d 00 00
	00 00		 mov	 eax, DWORD PTR ?DATA_NAME@@3PAPBDA[ecx*4]
  001ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  001f4	52		 push	 edx
  001f5	50		 push	 eax
  001f6	51		 push	 ecx
  001f7	68 00 00 00 00	 push	 OFFSET $SG-122
  001fc	e8 00 00 00 00	 call	 _printf
  00201	83 c4 10	 add	 esp, 16			; 00000010H

; 2235 : 
; 2236 : 					/* skip degenerated cases */
; 2237 : 					if (data == DATA_MAX && LAST[the_data][the_order] > TIME_MAX_NS) {

  00204	83 fb 10	 cmp	 ebx, 16			; 00000010H
  00207	75 2a		 jne	 SHORT $LN21@test
  00209	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  00214	8d 0c 42	 lea	 ecx, DWORD PTR [edx+eax*2]
  00217	81 3c 8d 00 00
	00 00 dc 05 00
	00		 cmp	 DWORD PTR ?LAST@@3PAY01IA[ecx*4], 1500 ; 000005dcH
  00222	76 0f		 jbe	 SHORT $LN21@test

; 2238 : 						printf(" (skipped, too slow)\n");

  00224	68 00 00 00 00	 push	 OFFSET $SG-123
  00229	e8 00 00 00 00	 call	 _printf
  0022e	83 c4 04	 add	 esp, 4

; 2239 : 						continue;

  00231	eb 41		 jmp	 SHORT $LN23@test
$LN21@test:

; 2240 : 					}
; 2241 : 
; 2242 : 					printf("\n");

  00233	68 00 00 00 00	 push	 OFFSET $SG-124
  00238	e8 00 00 00 00	 call	 _printf
  0023d	83 c4 04	 add	 esp, 4

; 2243 : 					
; 2244 : 					test_alloc();

  00240	e8 00 00 00 00	 call	 ?test_alloc@@YAXXZ	; test_alloc

; 2245 : 					if (the_order == ORDER_FORWARD)

  00245	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_order@@3IA, 0 ; the_order
  0024c	75 0a		 jne	 SHORT $LN20@test

; 2246 : 						test_operation(FORWARD, FORWARD);

  0024e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  00254	8b fe		 mov	 edi, esi

; 2247 : 					else

  00256	eb 0c		 jmp	 SHORT $LN119@test
$LN20@test:

; 2248 : 						test_operation(RAND0, RAND1);

  00258	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?RAND1@@3PAIA ; RAND1
  0025e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?RAND0@@3PAIA ; RAND0
$LN119@test:
  00264	e8 00 00 00 00	 call	 ?test_operation@@YAXPAI0@Z ; test_operation

; 2249 : 					test_free();

  00269	e8 00 00 00 00	 call	 ?test_free@@YAXXZ	; test_free
  0026e	8b 7d fc	 mov	 edi, DWORD PTR _retry$153105[ebp]
  00271	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
$LN23@test:

; 2231 : 					continue;
; 2232 : 
; 2233 : 				for(the_order=0;the_order<ORDER_MAX;++the_order) {

  00274	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_data@@3IA ; the_data
  0027f	40		 inc	 eax
  00280	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00285	83 f8 02	 cmp	 eax, 2
  00288	0f 82 52 ff ff
	ff		 jb	 $LL24@test
$LN28@test:

; 2225 : 			/* data */
; 2226 : 			for(the_data=0;the_data<DATA_MAX;++the_data) {

  0028e	41		 inc	 ecx
  0028f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_data@@3IA, ecx ; the_data
  00295	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00298	0f 82 24 ff ff
	ff		 jb	 $LN29@test

; 2222 : 
; 2223 : 		/* run the test */
; 2224 : 		for(the_retry=0;the_retry<retry;++the_retry) {

  0029e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_retry@@3IA ; the_retry
  002a3	40		 inc	 eax
  002a4	a3 00 00 00 00	 mov	 DWORD PTR ?the_retry@@3IA, eax ; the_retry
  002a9	3b c7		 cmp	 eax, edi
  002ab	0f 82 09 ff ff
	ff		 jb	 $LN32@test
$LN30@test:

; 2250 : 				}
; 2251 : 			}
; 2252 : 		}
; 2253 : 
; 2254 : 		order_done();

  002b1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?FORWARD@@3PAIA ; FORWARD
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _free
  002bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?RAND0@@3PAIA ; RAND0
  002c2	83 c4 04	 add	 esp, 4
  002c5	50		 push	 eax
  002c6	e8 00 00 00 00	 call	 _free
  002cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?RAND1@@3PAIA ; RAND1
  002d1	83 c4 04	 add	 esp, 4
  002d4	51		 push	 ecx
  002d5	e8 00 00 00 00	 call	 _free
  002da	83 c4 04	 add	 esp, 4

; 2255 : 
; 2256 : 		/* write the data */
; 2257 : 		if (the_log)

  002dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?the_log@@3HA, 0 ; the_log
  002e4	0f 84 23 01 00
	00		 je	 $LN15@test

; 2258 : 		for(the_order=0;the_order<ORDER_MAX;++the_order) {

  002ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, 0 ; the_order
$LN17@test:

; 2259 : 			for(the_operation=0;the_operation<OPERATION_MAX;++the_operation) {

  002f4	33 c0		 xor	 eax, eax
  002f6	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
$LN14@test:

; 2260 : 				FILE* f = open("at");

  002fb	8b 14 85 00 00
	00 00		 mov	 edx, DWORD PTR ?OPERATION_NAME@@3PAPBDA[eax*4]
  00302	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  00307	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR ?ORDER_NAME@@3PAPBDA[eax*4]
  0030e	52		 push	 edx
  0030f	51		 push	 ecx
  00310	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _buf$236024[ebp]
  00316	68 00 00 00 00	 push	 OFFSET $SG-105
  0031b	52		 push	 edx
  0031c	e8 00 00 00 00	 call	 _sprintf
  00321	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _buf$236024[ebp]
  00327	68 00 00 00 00	 push	 OFFSET $SG-125
  0032c	50		 push	 eax
  0032d	e8 00 00 00 00	 call	 _fopen

; 2261 : 
; 2262 : 				fprintf(f, "%u\t", the_max);

  00332	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_max@@3IA ; the_max
  00338	51		 push	 ecx
  00339	8b d8		 mov	 ebx, eax
  0033b	68 00 00 00 00	 push	 OFFSET $SG-126
  00340	53		 push	 ebx
  00341	e8 00 00 00 00	 call	 _fprintf
  00346	83 c4 24	 add	 esp, 36			; 00000024H

; 2263 : 				
; 2264 : 				/* data */
; 2265 : 				for(the_data=0;the_data<DATA_MAX;++the_data) {

  00349	33 c0		 xor	 eax, eax
  0034b	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
$LN11@test:

; 2266 : 					unsigned i, v;
; 2267 : 
; 2268 : 					if (!is_listed(the_data))
; 2269 : 						continue;
; 2270 : 
; 2271 : 					/* get the minimum */
; 2272 : 					v = LOG[0][the_data][the_order][the_operation];

  00350	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?the_order@@3IA ; the_order
  00356	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?the_operation@@3IA ; the_operation
  0035c	8d 34 42	 lea	 esi, DWORD PTR [edx+eax*2]
  0035f	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00362	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00365	03 c0		 add	 eax, eax
  00367	8b 8c 00 00 00
	00 00		 mov	 ecx, DWORD PTR ?LOG@@3PAY2BA@15IA[eax+eax]
  0036e	03 c0		 add	 eax, eax

; 2273 : 					for(i=1;i<retry;++i) {

  00370	83 ff 01	 cmp	 edi, 1
  00373	76 1d		 jbe	 SHORT $LN5@test

; 2266 : 					unsigned i, v;
; 2267 : 
; 2268 : 					if (!is_listed(the_data))
; 2269 : 						continue;
; 2270 : 
; 2271 : 					/* get the minimum */
; 2272 : 					v = LOG[0][the_data][the_order][the_operation];

  00375	8d 80 00 03 00
	00		 lea	 eax, DWORD PTR ?LOG@@3PAY2BA@15IA[eax+768]
  0037b	4f		 dec	 edi
  0037c	8d 64 24 00	 npad	 4
$LL7@test:

; 2274 : 						if (LOG[i][the_data][the_order][the_operation] < v)

  00380	8b 10		 mov	 edx, DWORD PTR [eax]
  00382	3b d1		 cmp	 edx, ecx

; 2275 : 							v = LOG[i][the_data][the_order][the_operation];

  00384	0f 42 ca	 cmovb	 ecx, edx
  00387	05 00 03 00 00	 add	 eax, 768		; 00000300H
  0038c	4f		 dec	 edi
  0038d	75 f1		 jne	 SHORT $LL7@test

; 2273 : 					for(i=1;i<retry;++i) {

  0038f	8b 7d fc	 mov	 edi, DWORD PTR _retry$153105[ebp]
$LN5@test:

; 2276 : 					}
; 2277 : 
; 2278 : 					/* save the *longest* measured time */
; 2279 : 					if (the_operation != OPERATION_SIZE) {

  00392	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR ?the_operation@@3IA, 3 ; the_operation
  00399	74 14		 je	 SHORT $LN2@test

; 2280 : 						if (v != 0 && LAST[the_data][the_order] < v)

  0039b	85 c9		 test	 ecx, ecx
  0039d	74 10		 je	 SHORT $LN2@test
  0039f	39 0c b5 00 00
	00 00		 cmp	 DWORD PTR ?LAST@@3PAY01IA[esi*4], ecx
  003a6	73 07		 jae	 SHORT $LN2@test

; 2281 : 							LAST[the_data][the_order] = v;

  003a8	89 0c b5 00 00
	00 00		 mov	 DWORD PTR ?LAST@@3PAY01IA[esi*4], ecx
$LN2@test:

; 2282 : 					}
; 2283 : 
; 2284 : 					fprintf(f, "%u\t", v);

  003af	51		 push	 ecx
  003b0	68 00 00 00 00	 push	 OFFSET $SG-127
  003b5	53		 push	 ebx
  003b6	e8 00 00 00 00	 call	 _fprintf
  003bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_data@@3IA ; the_data
  003c0	40		 inc	 eax
  003c1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c4	a3 00 00 00 00	 mov	 DWORD PTR ?the_data@@3IA, eax ; the_data
  003c9	83 f8 10	 cmp	 eax, 16			; 00000010H
  003cc	72 82		 jb	 SHORT $LN11@test

; 2285 : 				}
; 2286 : 
; 2287 : 				fprintf(f, "\n");

  003ce	68 00 00 00 00	 push	 OFFSET $SG-128
  003d3	53		 push	 ebx
  003d4	e8 00 00 00 00	 call	 _fprintf

; 2288 : 				fclose(f);

  003d9	53		 push	 ebx
  003da	e8 00 00 00 00	 call	 _fclose
  003df	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_operation@@3IA ; the_operation
  003e4	40		 inc	 eax
  003e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e8	a3 00 00 00 00	 mov	 DWORD PTR ?the_operation@@3IA, eax ; the_operation
  003ed	83 f8 06	 cmp	 eax, 6
  003f0	0f 82 05 ff ff
	ff		 jb	 $LN14@test

; 2258 : 		for(the_order=0;the_order<ORDER_MAX;++the_order) {

  003f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?the_order@@3IA ; the_order
  003fb	40		 inc	 eax
  003fc	a3 00 00 00 00	 mov	 DWORD PTR ?the_order@@3IA, eax ; the_order
  00401	83 f8 02	 cmp	 eax, 2
  00404	0f 82 ea fe ff
	ff		 jb	 $LN17@test
  0040a	8b 5d 0c	 mov	 ebx, DWORD PTR _data$[ebp]
$LN15@test:

; 2289 : 			}
; 2290 : 		}
; 2291 : 
; 2292 : 		if (size != 0)

  0040d	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  00411	75 36		 jne	 SHORT $LN79@test

; 2293 : 			break;
; 2294 : 
; 2295 : 		/* new max */
; 2296 : 		b *= f;

  00413	dd 45 e0	 fld	 QWORD PTR _f$[ebp]
  00416	dc 4d e8	 fmul	 QWORD PTR _b$[ebp]

; 2297 : 		the_max = (unsigned)b;

  00419	d9 7d fe	 fnstcw	 WORD PTR tv609[ebp]
  0041c	0f b7 45 fe	 movzx	 eax, WORD PTR tv609[ebp]
  00420	dd 55 e8	 fst	 QWORD PTR _b$[ebp]
  00423	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  00428	89 45 f4	 mov	 DWORD PTR tv606[ebp], eax
  0042b	d9 6d f4	 fldcw	 WORD PTR tv606[ebp]
  0042e	df 7d f0	 fistp	 QWORD PTR tv604[ebp]
  00431	8b 4d f0	 mov	 ecx, DWORD PTR tv604[ebp]
  00434	89 0d 00 00 00
	00		 mov	 DWORD PTR ?the_max@@3IA, ecx ; the_max
  0043a	d9 6d fe	 fldcw	 WORD PTR tv609[ebp]
  0043d	81 f9 80 96 98
	00		 cmp	 ecx, 10000000		; 00989680H
  00443	0f 86 f7 fc ff
	ff		 jbe	 $LL37@test
$LN79@test:

; 2298 : 	}
; 2299 : }

  00449	5f		 pop	 edi
  0044a	5e		 pop	 esi
  0044b	5b		 pop	 ebx
  0044c	8b e5		 mov	 esp, ebp
  0044e	5d		 pop	 ebp
  0044f	c3		 ret	 0
?test@@YAXIIHH@Z ENDP					; test
_TEXT	ENDS
PUBLIC	_main
; Function compile flags: /Ogtp
;	COMDAT _main
_TEXT	SEGMENT
tv308 = -24						; size = 4
_flag_data$ = -20					; size = 4
_flag_size$ = -16					; size = 4
_flag_miss$ = -12					; size = 4
_flag_sparse$ = -8					; size = 4
_flag_log$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 2332 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 2333 : 	int i;
; 2334 : 	int flag_data = DATA_MAX;
; 2335 : 	int flag_size = 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	57		 push	 edi

; 2336 : 	int flag_log = 0;
; 2337 : 	int flag_miss = 0;
; 2338 : 	int flag_sparse = 0;
; 2339 : 
; 2340 : 	nano_init();

  0000e	68 00 00 00 00	 push	 OFFSET _win_frequency
  00013	c7 44 24 18 10
	00 00 00	 mov	 DWORD PTR _flag_data$[esp+44], 16 ; 00000010H
  0001b	89 44 24 1c	 mov	 DWORD PTR _flag_size$[esp+44], eax
  0001f	89 44 24 28	 mov	 DWORD PTR _flag_log$[esp+44], eax
  00023	89 44 24 20	 mov	 DWORD PTR _flag_miss$[esp+44], eax
  00027	89 44 24 24	 mov	 DWORD PTR _flag_sparse$[esp+44], eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryPerformanceFrequency@4
  00031	85 c0		 test	 eax, eax
  00033	75 0c		 jne	 SHORT $LN26@main
  00035	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00039	66 0f 13 05 00
	00 00 00	 movlpd	 QWORD PTR _win_frequency, xmm0
$LN26@main:

; 2341 : 
; 2342 : 	printf("Tommy benchmark program.\n");

  00041	68 00 00 00 00	 push	 OFFSET $SG-130
  00046	e8 00 00 00 00	 call	 _printf

; 2343 : 
; 2344 : 	for(i=1;i<argc;++i) {

  0004b	bb 01 00 00 00	 mov	 ebx, 1
  00050	83 c4 04	 add	 esp, 4
  00053	39 5d 08	 cmp	 DWORD PTR _argc$[ebp], ebx
  00056	0f 8e 81 02 00
	00		 jle	 $LN1@main

; 2341 : 
; 2342 : 	printf("Tommy benchmark program.\n");

  0005c	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR tv308[esp+40], 2
$LL23@main:

; 2345 : 		if (strcmp(argv[i], "-l") == 0) {

  00064	8b 7d 0c	 mov	 edi, DWORD PTR _argv$[ebp]
  00067	8b 34 9f	 mov	 esi, DWORD PTR [edi+ebx*4]
  0006a	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-131
  0006f	8b c6		 mov	 eax, esi
$LL36@main:
  00071	8a 10		 mov	 dl, BYTE PTR [eax]
  00073	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00075	75 1a		 jne	 SHORT $LN37@main
  00077	84 d2		 test	 dl, dl
  00079	74 12		 je	 SHORT $LN38@main
  0007b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0007e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00081	75 0e		 jne	 SHORT $LN37@main
  00083	83 c0 02	 add	 eax, 2
  00086	83 c1 02	 add	 ecx, 2
  00089	84 d2		 test	 dl, dl
  0008b	75 e4		 jne	 SHORT $LL36@main
$LN38@main:
  0008d	33 c0		 xor	 eax, eax
  0008f	eb 05		 jmp	 SHORT $LN39@main
$LN37@main:
  00091	1b c0		 sbb	 eax, eax
  00093	83 d8 ff	 sbb	 eax, -1
$LN39@main:
  00096	85 c0		 test	 eax, eax
  00098	75 0d		 jne	 SHORT $LN20@main

; 2346 : 			flag_log = 1;

  0009a	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR _flag_log$[esp+40], 1
  000a2	e9 b8 01 00 00	 jmp	 $LN22@main
$LN20@main:

; 2347 : 		} else if (strcmp(argv[i], "-s") == 0) {

  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-132
  000ac	8b c6		 mov	 eax, esi
  000ae	8b ff		 npad	 2
$LL40@main:
  000b0	8a 10		 mov	 dl, BYTE PTR [eax]
  000b2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000b4	75 1a		 jne	 SHORT $LN41@main
  000b6	84 d2		 test	 dl, dl
  000b8	74 12		 je	 SHORT $LN42@main
  000ba	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000bd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  000c0	75 0e		 jne	 SHORT $LN41@main
  000c2	83 c0 02	 add	 eax, 2
  000c5	83 c1 02	 add	 ecx, 2
  000c8	84 d2		 test	 dl, dl
  000ca	75 e4		 jne	 SHORT $LL40@main
$LN42@main:
  000cc	33 c0		 xor	 eax, eax
  000ce	eb 05		 jmp	 SHORT $LN43@main
$LN41@main:
  000d0	1b c0		 sbb	 eax, eax
  000d2	83 d8 ff	 sbb	 eax, -1
$LN43@main:
  000d5	85 c0		 test	 eax, eax
  000d7	75 0d		 jne	 SHORT $LN18@main

; 2348 : 			flag_sparse = 1;

  000d9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _flag_sparse$[esp+40], 1
  000e1	e9 79 01 00 00	 jmp	 $LN22@main
$LN18@main:

; 2349 : 		} else if (strcmp(argv[i], "-m") == 0) {

  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-133
  000eb	8b c6		 mov	 eax, esi
  000ed	8d 49 00	 npad	 3
$LL44@main:
  000f0	8a 10		 mov	 dl, BYTE PTR [eax]
  000f2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  000f4	75 1a		 jne	 SHORT $LN45@main
  000f6	84 d2		 test	 dl, dl
  000f8	74 12		 je	 SHORT $LN46@main
  000fa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  000fd	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00100	75 0e		 jne	 SHORT $LN45@main
  00102	83 c0 02	 add	 eax, 2
  00105	83 c1 02	 add	 ecx, 2
  00108	84 d2		 test	 dl, dl
  0010a	75 e4		 jne	 SHORT $LL44@main
$LN46@main:
  0010c	33 c0		 xor	 eax, eax
  0010e	eb 05		 jmp	 SHORT $LN47@main
$LN45@main:
  00110	1b c0		 sbb	 eax, eax
  00112	83 d8 ff	 sbb	 eax, -1
$LN47@main:
  00115	85 c0		 test	 eax, eax
  00117	75 0d		 jne	 SHORT $LN16@main

; 2350 : 			flag_miss = 1;

  00119	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR _flag_miss$[esp+40], 1
  00121	e9 39 01 00 00	 jmp	 $LN22@main
$LN16@main:

; 2351 : 		} else if (strcmp(argv[i], "-n") == 0) {

  00126	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-134
  0012b	8b c6		 mov	 eax, esi
  0012d	8d 49 00	 npad	 3
$LL48@main:
  00130	8a 10		 mov	 dl, BYTE PTR [eax]
  00132	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00134	75 1a		 jne	 SHORT $LN49@main
  00136	84 d2		 test	 dl, dl
  00138	74 12		 je	 SHORT $LN50@main
  0013a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0013d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00140	75 0e		 jne	 SHORT $LN49@main
  00142	83 c0 02	 add	 eax, 2
  00145	83 c1 02	 add	 ecx, 2
  00148	84 d2		 test	 dl, dl
  0014a	75 e4		 jne	 SHORT $LL48@main
$LN50@main:
  0014c	33 c0		 xor	 eax, eax
  0014e	eb 05		 jmp	 SHORT $LN51@main
$LN49@main:
  00150	1b c0		 sbb	 eax, eax
  00152	83 d8 ff	 sbb	 eax, -1
$LN51@main:
  00155	85 c0		 test	 eax, eax
  00157	75 0d		 jne	 SHORT $LN14@main

; 2352 : 			flag_size = MAX;

  00159	c7 44 24 18 80
	96 98 00	 mov	 DWORD PTR _flag_size$[esp+40], 10000000 ; 00989680H
  00161	e9 f9 00 00 00	 jmp	 $LN22@main
$LN14@main:

; 2353 : 		} else if (strcmp(argv[i], "-N") == 0) {

  00166	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-135
  0016b	8b c6		 mov	 eax, esi
  0016d	8d 49 00	 npad	 3
$LL52@main:
  00170	8a 10		 mov	 dl, BYTE PTR [eax]
  00172	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00174	75 1a		 jne	 SHORT $LN53@main
  00176	84 d2		 test	 dl, dl
  00178	74 12		 je	 SHORT $LN54@main
  0017a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0017d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00180	75 0e		 jne	 SHORT $LN53@main
  00182	83 c0 02	 add	 eax, 2
  00185	83 c1 02	 add	 ecx, 2
  00188	84 d2		 test	 dl, dl
  0018a	75 e4		 jne	 SHORT $LL52@main
$LN54@main:
  0018c	33 c0		 xor	 eax, eax
  0018e	eb 05		 jmp	 SHORT $LN55@main
$LN53@main:
  00190	1b c0		 sbb	 eax, eax
  00192	83 d8 ff	 sbb	 eax, -1
$LN55@main:
  00195	85 c0		 test	 eax, eax
  00197	75 23		 jne	 SHORT $LN12@main

; 2354 : 			if (i+1 >= argc) {

  00199	8b 44 24 10	 mov	 eax, DWORD PTR tv308[esp+40]
  0019d	3b 45 08	 cmp	 eax, DWORD PTR _argc$[ebp]
  001a0	0f 8d dc 00 00
	00		 jge	 $LN31@main

; 2357 : 			}
; 2358 : 			flag_size = atoi(argv[i+1]);

  001a6	8b 4c 9f 04	 mov	 ecx, DWORD PTR [edi+ebx*4+4]
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 _atoi
  001b0	83 c4 04	 add	 esp, 4
  001b3	89 44 24 18	 mov	 DWORD PTR _flag_size$[esp+40], eax

; 2359 : 			++i;

  001b7	e9 9e 00 00 00	 jmp	 $LN66@main
$LN12@main:

; 2360 : 		} else if (strcmp(argv[i], "-d") == 0) {

  001bc	b9 00 00 00 00	 mov	 ecx, OFFSET $SG-137
  001c1	8b c6		 mov	 eax, esi
$LL56@main:
  001c3	8a 10		 mov	 dl, BYTE PTR [eax]
  001c5	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001c7	75 1a		 jne	 SHORT $LN57@main
  001c9	84 d2		 test	 dl, dl
  001cb	74 12		 je	 SHORT $LN58@main
  001cd	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001d0	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001d3	75 0e		 jne	 SHORT $LN57@main
  001d5	83 c0 02	 add	 eax, 2
  001d8	83 c1 02	 add	 ecx, 2
  001db	84 d2		 test	 dl, dl
  001dd	75 e4		 jne	 SHORT $LL56@main
$LN58@main:
  001df	33 c0		 xor	 eax, eax
  001e1	eb 05		 jmp	 SHORT $LN59@main
$LN57@main:
  001e3	1b c0		 sbb	 eax, eax
  001e5	83 d8 ff	 sbb	 eax, -1
$LN59@main:
  001e8	85 c0		 test	 eax, eax
  001ea	0f 85 d8 00 00
	00		 jne	 $LN9@main

; 2361 : 			int j;
; 2362 : 			if (i+1 >= argc) {

  001f0	8b 55 08	 mov	 edx, DWORD PTR _argc$[ebp]
  001f3	39 54 24 10	 cmp	 DWORD PTR tv308[esp+40], edx
  001f7	0f 8d 9a 00 00
	00		 jge	 $LN32@main

; 2365 : 			}
; 2366 : 			flag_data = DATA_MAX;

  001fd	8b 7c 9f 04	 mov	 edi, DWORD PTR [edi+ebx*4+4]
  00201	c7 44 24 14 10
	00 00 00	 mov	 DWORD PTR _flag_data$[esp+40], 16 ; 00000010H

; 2367 : 			for(j=0;j<DATA_MAX;++j) {

  00209	33 f6		 xor	 esi, esi
  0020b	eb 03 8d 49 00	 npad	 5
$LL7@main:

; 2368 : 				if (strcmp(argv[i+1], DATA_NAME[j]) == 0) {

  00210	8b 0c b5 00 00
	00 00		 mov	 ecx, DWORD PTR ?DATA_NAME@@3PAPBDA[esi*4]
  00217	8b c7		 mov	 eax, edi
  00219	8d a4 24 00 00
	00 00		 npad	 7
$LL60@main:
  00220	8a 10		 mov	 dl, BYTE PTR [eax]
  00222	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00224	75 1a		 jne	 SHORT $LN61@main
  00226	84 d2		 test	 dl, dl
  00228	74 12		 je	 SHORT $LN62@main
  0022a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0022d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00230	75 0e		 jne	 SHORT $LN61@main
  00232	83 c0 02	 add	 eax, 2
  00235	83 c1 02	 add	 ecx, 2
  00238	84 d2		 test	 dl, dl
  0023a	75 e4		 jne	 SHORT $LL60@main
$LN62@main:
  0023c	33 c0		 xor	 eax, eax
  0023e	eb 05		 jmp	 SHORT $LN63@main
$LN61@main:
  00240	1b c0		 sbb	 eax, eax
  00242	83 d8 ff	 sbb	 eax, -1
$LN63@main:
  00245	85 c0		 test	 eax, eax
  00247	75 04		 jne	 SHORT $LN6@main

; 2369 : 					flag_data = j;

  00249	89 74 24 14	 mov	 DWORD PTR _flag_data$[esp+40], esi
$LN6@main:

; 2367 : 			for(j=0;j<DATA_MAX;++j) {

  0024d	46		 inc	 esi
  0024e	83 fe 10	 cmp	 esi, 16			; 00000010H
  00251	7c bd		 jl	 SHORT $LL7@main

; 2370 : 				}
; 2371 : 			}
; 2372 : 			if (flag_data == DATA_MAX) {

  00253	83 7c 24 14 10	 cmp	 DWORD PTR _flag_data$[esp+40], 16 ; 00000010H
  00258	74 52		 je	 SHORT $LN33@main
$LN66@main:

; 2375 : 			}
; 2376 : 			++i;

  0025a	43		 inc	 ebx
  0025b	ff 44 24 10	 inc	 DWORD PTR tv308[esp+40]
$LN22@main:

; 2343 : 
; 2344 : 	for(i=1;i<argc;++i) {

  0025f	ff 44 24 10	 inc	 DWORD PTR tv308[esp+40]
  00263	43		 inc	 ebx
  00264	3b 5d 08	 cmp	 ebx, DWORD PTR _argc$[ebp]
  00267	0f 8c f7 fd ff
	ff		 jl	 $LL23@main

; 2380 : 		} 
; 2381 : 	}
; 2382 : 
; 2383 : 	if (flag_miss) {

  0026d	83 7c 24 1c 00	 cmp	 DWORD PTR _flag_miss$[esp+40], 0
  00272	74 69		 je	 SHORT $LN1@main

; 2384 : 		test_cache_miss();

  00274	e8 00 00 00 00	 call	 ?test_cache_miss@@YAXXZ	; test_cache_miss

; 2391 : 
; 2392 : 	return EXIT_SUCCESS;

  00279	33 c0		 xor	 eax, eax

; 2393 : }

  0027b	5f		 pop	 edi
  0027c	5e		 pop	 esi
  0027d	5b		 pop	 ebx
  0027e	8b e5		 mov	 esp, ebp
  00280	5d		 pop	 ebp
  00281	c3		 ret	 0
$LN31@main:

; 2355 : 				printf("Missing data in %s\n", argv[i]);

  00282	56		 push	 esi
  00283	68 00 00 00 00	 push	 OFFSET $SG-136
  00288	e8 00 00 00 00	 call	 _printf
  0028d	83 c4 08	 add	 esp, 8

; 2356 : 				exit(EXIT_FAILURE);

  00290	6a 01		 push	 1
  00292	e8 00 00 00 00	 call	 _exit
$LN68@main:
$LN32@main:

; 2363 : 				printf("Missing data in %s\n", argv[i]);

  00297	56		 push	 esi
  00298	68 00 00 00 00	 push	 OFFSET $SG-138
  0029d	e8 00 00 00 00	 call	 _printf
  002a2	83 c4 08	 add	 esp, 8

; 2364 : 				exit(EXIT_FAILURE);

  002a5	6a 01		 push	 1
  002a7	e8 00 00 00 00	 call	 _exit
$LN69@main:
$LN33@main:

; 2373 : 				printf("Unknown data %s\n", argv[i+1]);

  002ac	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  002af	8b 44 9a 04	 mov	 eax, DWORD PTR [edx+ebx*4+4]
  002b3	50		 push	 eax
  002b4	68 00 00 00 00	 push	 OFFSET $SG-139
  002b9	e8 00 00 00 00	 call	 _printf
  002be	83 c4 08	 add	 esp, 8

; 2374 : 				exit(EXIT_FAILURE);

  002c1	6a 01		 push	 1
  002c3	e8 00 00 00 00	 call	 _exit
$LN70@main:
$LN9@main:

; 2377 : 		} else {
; 2378 : 			printf("Unknown option %s\n", argv[i]);

  002c8	56		 push	 esi
  002c9	68 00 00 00 00	 push	 OFFSET $SG-140
  002ce	e8 00 00 00 00	 call	 _printf
  002d3	83 c4 08	 add	 esp, 8

; 2379 : 			exit(EXIT_FAILURE);

  002d6	6a 01		 push	 1
  002d8	e8 00 00 00 00	 call	 _exit
$LN71@main:
$LN1@main:

; 2385 : 		return EXIT_SUCCESS;
; 2386 : 	}
; 2387 : 
; 2388 : 	test(flag_size, flag_data, flag_log, flag_sparse);

  002dd	8b 54 24 20	 mov	 edx, DWORD PTR _flag_sparse$[esp+40]
  002e1	8b 44 24 24	 mov	 eax, DWORD PTR _flag_log$[esp+40]
  002e5	8b 4c 24 14	 mov	 ecx, DWORD PTR _flag_data$[esp+40]
  002e9	52		 push	 edx
  002ea	8b 54 24 1c	 mov	 edx, DWORD PTR _flag_size$[esp+44]
  002ee	50		 push	 eax
  002ef	51		 push	 ecx
  002f0	52		 push	 edx
  002f1	e8 00 00 00 00	 call	 ?test@@YAXIIHH@Z	; test

; 2389 : 
; 2390 : 	printf("OK\n");

  002f6	68 00 00 00 00	 push	 OFFSET $SG-141
  002fb	e8 00 00 00 00	 call	 _printf
  00300	83 c4 14	 add	 esp, 20			; 00000014H

; 2393 : }

  00303	5f		 pop	 edi
  00304	5e		 pop	 esi
  00305	33 c0		 xor	 eax, eax
  00307	5b		 pop	 ebx
  00308	8b e5		 mov	 esp, ebp
  0030a	5d		 pop	 ebp
  0030b	c3		 ret	 0
$LN65@main:
_main	ENDP
_TEXT	ENDS
END
